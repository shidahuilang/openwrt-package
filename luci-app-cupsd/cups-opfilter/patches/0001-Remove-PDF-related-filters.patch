From d86f5c4c42829395327661da6a276fc8eb7c0e8b Mon Sep 17 00:00:00 2001
From: Florian Knodt <adlerweb@adlerweb.info>
Date: Sun, 1 Mar 2020 15:23:24 +0100
Subject: [PATCH] Remove PDF related filters

---
 Makefile.am                                |  331 +--
 Makefile.in                                | 1531 +-------------
 backend/implicitclass.c                    |    9 -
 configure                                  |    6 +-
 cupsfilters/pdftoippprinter.c              |  912 --------
 cupsfilters/pdftoippprinter.h              |    9 -
 filter/bannertopdf.c                       |  574 ------
 filter/gstopdf                             |   25 -
 filter/imagetopdf.c                        | 2000 ------------------
 filter/mupdftoraster.c                     |  435 ----
 filter/pdf.cxx                             |  439 ----
 filter/pdf.h                               |   54 -
 filter/pdftopdf/intervalset.cc             |  121 --
 filter/pdftopdf/intervalset.h              |   34 -
 filter/pdftopdf/nup.cc                     |  265 ---
 filter/pdftopdf/nup.h                      |   91 -
 filter/pdftopdf/pdftopdf.cc                | 1326 ------------
 filter/pdftopdf/pdftopdf_jcl.cc            |  202 --
 filter/pdftopdf/pdftopdf_jcl.h             |   12 -
 filter/pdftopdf/pdftopdf_processor.cc      |  430 ----
 filter/pdftopdf/pdftopdf_processor.h       |  174 --
 filter/pdftopdf/pptypes.cc                 |  177 --
 filter/pdftopdf/pptypes.h                  |   39 -
 filter/pdftopdf/qpdf_cm.cc                 |  151 --
 filter/pdftopdf/qpdf_cm.h                  |   12 -
 filter/pdftopdf/qpdf_pdftopdf.cc           |  225 --
 filter/pdftopdf/qpdf_pdftopdf.h            |   41 -
 filter/pdftopdf/qpdf_pdftopdf_processor.cc |  763 -------
 filter/pdftopdf/qpdf_pdftopdf_processor.h  |   74 -
 filter/pdftopdf/qpdf_tools.cc              |   69 -
 filter/pdftopdf/qpdf_tools.h               |   18 -
 filter/pdftopdf/qpdf_xobject.cc            |  170 --
 filter/pdftopdf/qpdf_xobject.h             |    8 -
 filter/pdftops.c                           | 1645 ---------------
 filter/pdftoraster.cxx                     | 2171 --------------------
 filter/pdfutils.c                          |  431 ----
 filter/pdfutils.h                          |   80 -
 filter/rastertopdf.cpp                     | 1544 --------------
 filter/test_pdf1.c                         |   52 -
 filter/test_pdf2.c                         |  102 -
 filter/texttopdf.c                         | 1212 -----------
 filter/urftopdf.cpp                        |  498 -----
 fontembed/README                           |   48 -
 fontembed/aglfn13.c                        |  214 --
 fontembed/bitset.h                         |   38 -
 fontembed/dynstring.c                      |  105 -
 fontembed/dynstring.h                      |   16 -
 fontembed/embed.c                          |  260 ---
 fontembed/embed.h                          |   92 -
 fontembed/embed_pdf.c                      |  597 ------
 fontembed/embed_pdf.h                      |   53 -
 fontembed/embed_pdf_int.h                  |   10 -
 fontembed/embed_sfnt.c                     |  677 ------
 fontembed/embed_sfnt_int.h                 |   18 -
 fontembed/fontfile.c                       |   50 -
 fontembed/fontfile.h                       |   22 -
 fontembed/frequent.c                       |   83 -
 fontembed/frequent.h                       |   17 -
 fontembed/iofn.h                           |    6 -
 fontembed/macroman.h                       |   32 -
 fontembed/main.c                           |  170 --
 fontembed/sfnt.c                           |  992 ---------
 fontembed/sfnt.h                           |   64 -
 fontembed/sfnt_int.h                       |   97 -
 fontembed/sfnt_subset.c                    |  343 ----
 fontembed/test_analyze.c                   |  234 ---
 fontembed/test_pdf.c                       |  215 --
 fontembed/test_ps.c                        |   89 -
 mime/cupsfilters-mupdf.convs               |   19 -
 69 files changed, 59 insertions(+), 22964 deletions(-)
 delete mode 100644 cupsfilters/pdftoippprinter.c
 delete mode 100644 cupsfilters/pdftoippprinter.h
 delete mode 100644 filter/bannertopdf.c
 delete mode 100644 filter/gstopdf
 delete mode 100644 filter/imagetopdf.c
 delete mode 100644 filter/mupdftoraster.c
 delete mode 100644 filter/pdf.cxx
 delete mode 100644 filter/pdf.h
 delete mode 100644 filter/pdftopdf/intervalset.cc
 delete mode 100644 filter/pdftopdf/intervalset.h
 delete mode 100644 filter/pdftopdf/nup.cc
 delete mode 100644 filter/pdftopdf/nup.h
 delete mode 100644 filter/pdftopdf/pdftopdf.cc
 delete mode 100644 filter/pdftopdf/pdftopdf_jcl.cc
 delete mode 100644 filter/pdftopdf/pdftopdf_jcl.h
 delete mode 100644 filter/pdftopdf/pdftopdf_processor.cc
 delete mode 100644 filter/pdftopdf/pdftopdf_processor.h
 delete mode 100644 filter/pdftopdf/pptypes.cc
 delete mode 100644 filter/pdftopdf/pptypes.h
 delete mode 100644 filter/pdftopdf/qpdf_cm.cc
 delete mode 100644 filter/pdftopdf/qpdf_cm.h
 delete mode 100644 filter/pdftopdf/qpdf_pdftopdf.cc
 delete mode 100644 filter/pdftopdf/qpdf_pdftopdf.h
 delete mode 100644 filter/pdftopdf/qpdf_pdftopdf_processor.cc
 delete mode 100644 filter/pdftopdf/qpdf_pdftopdf_processor.h
 delete mode 100644 filter/pdftopdf/qpdf_tools.cc
 delete mode 100644 filter/pdftopdf/qpdf_tools.h
 delete mode 100644 filter/pdftopdf/qpdf_xobject.cc
 delete mode 100644 filter/pdftopdf/qpdf_xobject.h
 delete mode 100644 filter/pdftops.c
 delete mode 100644 filter/pdftoraster.cxx
 delete mode 100644 filter/pdfutils.c
 delete mode 100644 filter/pdfutils.h
 delete mode 100644 filter/rastertopdf.cpp
 delete mode 100644 filter/test_pdf1.c
 delete mode 100644 filter/test_pdf2.c
 delete mode 100644 filter/texttopdf.c
 delete mode 100644 filter/urftopdf.cpp
 delete mode 100644 fontembed/README
 delete mode 100644 fontembed/aglfn13.c
 delete mode 100644 fontembed/bitset.h
 delete mode 100644 fontembed/dynstring.c
 delete mode 100644 fontembed/dynstring.h
 delete mode 100644 fontembed/embed.c
 delete mode 100644 fontembed/embed.h
 delete mode 100644 fontembed/embed_pdf.c
 delete mode 100644 fontembed/embed_pdf.h
 delete mode 100644 fontembed/embed_pdf_int.h
 delete mode 100644 fontembed/embed_sfnt.c
 delete mode 100644 fontembed/embed_sfnt_int.h
 delete mode 100644 fontembed/fontfile.c
 delete mode 100644 fontembed/fontfile.h
 delete mode 100644 fontembed/frequent.c
 delete mode 100644 fontembed/frequent.h
 delete mode 100644 fontembed/iofn.h
 delete mode 100644 fontembed/macroman.h
 delete mode 100644 fontembed/main.c
 delete mode 100644 fontembed/sfnt.c
 delete mode 100644 fontembed/sfnt.h
 delete mode 100644 fontembed/sfnt_int.h
 delete mode 100644 fontembed/sfnt_subset.c
 delete mode 100644 fontembed/test_analyze.c
 delete mode 100644 fontembed/test_pdf.c
 delete mode 100644 fontembed/test_ps.c
 delete mode 100644 mime/cupsfilters-mupdf.convs

diff --git a/Makefile.am b/Makefile.am
index 3eda2bd..4978462 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -2,8 +2,7 @@ ACLOCAL_AMFLAGS = -I m4
 
 pkgconfdir = $(libdir)/pkgconfig
 pkgconf_DATA = \
-	libcupsfilters.pc \
-	libfontembed.pc
+	libcupsfilters.pc
 
 doc_DATA = \
 	ABOUT-NLS \
@@ -18,8 +17,7 @@ EXTRA_DIST = \
 	autogen.sh \
 	config.rpath \
 	ln-srf \
-	libcupsfilters.pc.in \
-	libfontembed.pc.in \
+	libcupsfilters.pc.in
 	utils/cups-browsed.service \
 	utils/cups-browsed-upstart.conf \
 	filter/braille/drivers/index/ubrlto4dot.c \
@@ -149,8 +147,7 @@ pkgfiltersinclude_DATA = \
 	cupsfilters/image.h \
 	cupsfilters/ipp.h \
 	cupsfilters/raster.h \
-	cupsfilters/ppdgenerator.h \
-	cupsfilters/pdftoippprinter.h
+	cupsfilters/ppdgenerator.h
 
 lib_LTLIBRARIES = libcupsfilters.la
 
@@ -183,7 +180,6 @@ libcupsfilters_la_SOURCES = \
 	cupsfilters/colormanager.c \
 	cupsfilters/dither.c \
 	cupsfilters/image.c \
-	cupsfilters/pdftoippprinter.c \
 	cupsfilters/image-bmp.c \
 	cupsfilters/image-colorspace.c \
 	cupsfilters/image-gif.c \
@@ -410,6 +406,9 @@ EXTRA_DIST += \
 	$(brlmimefiles) \
 	mime/cupsfilters.convs.in
 
+pkgfilter_PROGRAMS =
+pkgfilterdir = $(CUPS_SERVERBIN)/filter
+
 # =================
 # Braille aux files
 # =================
@@ -422,121 +421,14 @@ nodist_pkgbraille_SCRIPTS = \
 	filter/braille/filters/cups-braille.sh
 endif
 
-# =================
-# Fontembed library
-# =================
-pkgfontembedincludedir = $(includedir)/fontembed
-pkgfontembedinclude_DATA = \
-        fontembed/bitset.h \
-        fontembed/embed.h \
-        fontembed/fontfile.h \
-        fontembed/iofn.h \
-        fontembed/sfnt.h
-
-lib_LTLIBRARIES += libfontembed.la
-
-bin_PROGRAMS = ttfread
-
-check_PROGRAMS += \
-	test_analyze \
-	test_pdf \
-	test_ps
-TESTS += \
-	test_analyze \
-	test_pdf \
-	test_ps
-
-libfontembed_la_SOURCES = \
-	fontembed/aglfn13.c \
-	fontembed/bitset.h \
-	fontembed/dynstring.c \
-	fontembed/dynstring.h \
-	fontembed/embed.c \
-	fontembed/embed.h \
-	fontembed/embed_sfnt.c \
-	fontembed/embed_sfnt_int.h \
-	fontembed/embed_pdf.c \
-	fontembed/embed_pdf.h \
-	fontembed/embed_pdf_int.h \
-	fontembed/fontfile.c \
-	fontembed/fontfile.h \
-	fontembed/frequent.c \
-	fontembed/frequent.h \
-	fontembed/iofn.h \
-	fontembed/macroman.h \
-	fontembed/sfnt.c \
-	fontembed/sfnt.h \
-	fontembed/sfnt_int.h \
-	fontembed/sfnt_subset.c
-libfontembed_la_LDFLAGS = \
-	-no-undefined \
-	-version-info 1
-
-ttfread_SOURCES = fontembed/main.c
-ttfread_LDADD = libfontembed.la
-
-test_analyze_SOURCES = fontembed/test_analyze.c
-test_analyze_LDADD = libfontembed.la
-
-test_pdf_SOURCES = fontembed/test_pdf.c
-test_pdf_LDADD = libfontembed.la
-
-test_ps_SOURCES = fontembed/test_ps.c
-test_ps_LDADD = libfontembed.la
-
-EXTRA_DIST += \
-	$(pkgfontembedinclude_DATA) \
-	fontembed/README
-
-pkgfilter_PROGRAMS =
-pkgfilterdir = $(CUPS_SERVERBIN)/filter
-
-# ==========
-# PDF to PDF 
-# ==========
-pkgfilter_PROGRAMS += pdftopdf
-
-pdftopdf_SOURCES = \
-	filter/pdftopdf/pdftopdf.cc \
-	filter/pdftopdf/pdftopdf_jcl.cc \
-	filter/pdftopdf/pdftopdf_jcl.h \
-	filter/pdftopdf/pdftopdf_processor.cc \
-	filter/pdftopdf/pdftopdf_processor.h \
-	filter/pdftopdf/qpdf_pdftopdf_processor.cc \
-	filter/pdftopdf/qpdf_pdftopdf_processor.h \
-	filter/pdftopdf/pptypes.cc \
-	filter/pdftopdf/pptypes.h \
-	filter/pdftopdf/nup.cc \
-	filter/pdftopdf/nup.h \
-	filter/pdftopdf/intervalset.cc \
-	filter/pdftopdf/intervalset.h \
-	filter/pdftopdf/qpdf_tools.cc \
-	filter/pdftopdf/qpdf_tools.h \
-	filter/pdftopdf/qpdf_xobject.cc \
-	filter/pdftopdf/qpdf_xobject.h \
-	filter/pdftopdf/qpdf_pdftopdf.cc \
-	filter/pdftopdf/qpdf_pdftopdf.h \
-	filter/pdftopdf/qpdf_cm.cc \
-	filter/pdftopdf/qpdf_cm.h
-pdftopdf_CFLAGS = \
-	$(LIBQPDF_CFLAGS) \
-	$(CUPS_CFLAGS)
-pdftopdf_CXXFLAGS = -std=c++0x $(pdftopdf_CFLAGS)   # -std=c++11
-pdftopdf_LDADD = \
-	$(LIBQPDF_LIBS) \
-	$(CUPS_LIBS)
-
 # ======================
 # Simple filter binaries
 # ======================
 genfilterscripts = \
-	filter/imagetops \
-	filter/texttops  \
 	filter/rastertopclm
 pkgfilter_SCRIPTS = $(genfilterscripts)
 gsfilterscripts = \
-	filter/gstopxl \
-	filter/gstopdf
+	filter/gstopxl
 if ENABLE_GHOSTSCRIPT
 pkgfilter_SCRIPTS += $(gsfilterscripts)
 endif
@@ -547,7 +439,6 @@ nodist_pkgfilter_SCRIPTS = \
 	filter/braille/drivers/index/imageubrltoindexv4 \
 	filter/braille/drivers/index/textbrftoindexv3 \
 	filter/braille/filters/imagetobrf \
-	filter/braille/filters/vectortopdf \
 	filter/braille/filters/vectortobrf \
 	filter/braille/filters/texttobrf \
 	filter/braille/filters/brftopagedbrf \
@@ -559,47 +450,21 @@ pkgfilter_PROGRAMS += \
 	commandtopclx \
 	sys5ippprinter \
 	texttotext \
-	pdftops \
 	rastertoescpx \
-	rastertopclx \
-	texttopdf \
-	rastertopdf \
-	bannertopdf \
-	rastertops
-if ENABLE_URFTOPDF
-pkgfilter_PROGRAMS += \
-	urftopdf
-endif
-if ENABLE_POPPLER
-pkgfilter_PROGRAMS += \
-	pdftoraster
-endif
+	rastertopclx 
 if ENABLE_GHOSTSCRIPT
 pkgfilter_PROGRAMS += \
 	gstoraster
 endif
-if ENABLE_MUTOOL
-pkgfilter_PROGRAMS += \
-	mupdftoraster
-endif
 if ENABLE_FOOMATIC
 pkgfilter_PROGRAMS += \
 	foomatic-rip
 endif
 if ENABLE_IMAGEFILTERS
 pkgfilter_PROGRAMS += \
-	imagetopdf \
 	imagetoraster
 endif
 
-check_PROGRAMS += \
-	test_pdf1 \
-	test_pdf2
-
-TESTS += \
-	test_pdf1 \
-	test_pdf2
-
 # Not reliable bash script
 #TESTS += filter/test.sh
 
@@ -608,39 +473,6 @@ EXTRA_DIST += \
 	$(gsfilterscripts) \
 	filter/test.sh
 
-bannertopdf_SOURCES = \
-	filter/banner.c \
-	filter/banner.h \
-	filter/bannertopdf.c \
-	filter/pdf.cxx \
-	filter/pdf.h \
-	fontembed/embed.h \
-	fontembed/sfnt.h
-EXTRA_bannertopdf_SOURCES = filter/getline.c
-bannertopdf_CFLAGS = \
-	$(CUPS_CFLAGS) \
-	$(LIBJPEG_CFLAGS) \
-	$(LIBPNG_CFLAGS) \
-	$(LIBQPDF_CFLAGS) \
-	$(TIFF_CFLAGS) \
-	$(FONTCONFIG_CFLAGS) \
-	-I$(srcdir)/fontembed/
-
-bannertopdf_CXXFLAGS = $(bannertopdf_CFLAGS)
-bannertopdf_LDADD = \
-	$(GETLINE) \
-	$(CUPS_LIBS) \
-	$(LIBJPEG_LIBS) \
-	$(LIBPNG_LIBS) \
-	$(LIBQPDF_LIBS) \
-	$(TIFF_LIBS) \
-	$(FONTCONFIG_LIBS) \
-	libfontembed.la
-
-bannertopdf_DEPENDENCIES = \
-	$(GETLINE) \
-	libfontembed.la
-
 commandtoescpx_SOURCES = \
 	cupsfilters/driver.h \
 	filter/commandtoescpx.c \
@@ -701,25 +533,6 @@ gstoraster_LDADD = \
 	$(LIBQPDF_LIBS) \
 	libcupsfilters.la
 
-imagetopdf_SOURCES = \
-	cupsfilters/image.h \
-	filter/common.c \
-	filter/common.h \
-	filter/imagetopdf.c
-imagetopdf_CFLAGS = \
-	$(CUPS_CFLAGS) \
-	$(LIBJPEG_CFLAGS) \
-	$(LIBPNG_CFLAGS) \
-	$(TIFF_CFLAGS) \
-	-I$(srcdir)/cupsfilters/
-imagetopdf_LDADD = \
-	$(CUPS_LIBS) \
-	$(LIBJPEG_LIBS) \
-	$(LIBPNG_LIBS) \
-	$(TIFF_LIBS) \
-	-lm \
-	libcupsfilters.la
-
 imagetoraster_SOURCES = \
 	cupsfilters/image.h \
 	cupsfilters/image-private.h \
@@ -734,46 +547,6 @@ imagetoraster_LDADD = \
 	-lm \
 	libcupsfilters.la
 
-urftopdf_SOURCES = \
-	filter/urftopdf.cpp \
-	filter/unirast.h
-urftopdf_CXXFLAGS = \
-	$(LIBQPDF_CFLAGS)
-urftopdf_LDADD = \
-	$(LIBQPDF_LIBS)
-
-rastertopdf_SOURCES = \
-	filter/rastertopdf.cpp
-rastertopdf_CXXFLAGS = \
-	$(CUPS_CFLAGS) \
-	$(LCMS_CFLAGS) \
-	$(LIBQPDF_CFLAGS) \
-	-I$(srcdir)/cupsfilters/
-rastertopdf_LDADD = \
-	$(CUPS_LIBS) \
-	$(LCMS_LIBS) \
-	$(LIBQPDF_LIBS) \
-	libcupsfilters.la
-
-mupdftoraster_SOURCES = \
-        filter/mupdftoraster.c
-mupdftoraster_CFLAGS = \
-        $(CUPS_CFLAGS) \
-        -I$(srcdir)/cupsfilters/
-mupdftoraster_LDADD = \
-        $(CUPS_LIBS) \
-        libcupsfilters.la
-
-rastertops_SOURCES = \
-	filter/rastertops.c
-rastertops_CFLAGS = \
-	$(CUPS_CFLAGS) \
-	-I$(srcdir)/cupsfilters/
-rastertops_LDADD = \
-	$(CUPS_LIBS) \
-	-lz \
-	libcupsfilters.la
-
 sys5ippprinter_SOURCES = \
 	filter/common.c \
 	filter/common.h \
@@ -790,42 +563,6 @@ texttotext_CFLAGS = $(CUPS_CFLAGS)
 texttotext_LDADD = $(STRCASESTR) $(CUPS_LIBS) $(LIBICONV)
 texttotext_DEPENDENCIES = $(STRCASESTR)
 
-pdftops_SOURCES = \
-	filter/common.c \
-	filter/common.h \
-	filter/pdftops.c \
-	filter/pdf.cxx \
-	filter/pdf.h
-EXTRA_pdftops_SOURCES = filter/strcasestr.c
-pdftops_CFLAGS = \
-	$(CUPS_CFLAGS) \
-	$(LIBQPDF_CFLAGS)
-pdftops_LDADD = \
-	$(STRCASESTR) \
-	$(CUPS_LIBS) \
-	$(LIBQPDF_LIBS)
-pdftops_DEPENDENCIES = $(STRCASESTR)
-
-pdftoraster_SOURCES = \
-	filter/pdftoraster.cxx
-pdftoraster_CFLAGS = \
-	$(CUPS_CFLAGS) \
-	$(LCMS_CFLAGS) \
-	$(LIBJPEG_CFLAGS) \
-	$(LIBPNG_CFLAGS) \
-	$(POPPLER_CFLAGS) \
-	$(TIFF_CFLAGS) \
-	-I$(srcdir)/cupsfilters/
-pdftoraster_CXXFLAGS = $(pdftoraster_CFLAGS)
-pdftoraster_LDADD = \
-	$(CUPS_LIBS) \
-	$(LCMS_LIBS) \
-	$(LIBJPEG_LIBS) \
-	$(LIBPNG_LIBS) \
-	$(POPPLER_LIBS) \
-	$(TIFF_LIBS) \
-	libcupsfilters.la
-
 rastertoescpx_SOURCES = \
 	cupsfilters/driver.h \
 	filter/escp.h \
@@ -852,46 +589,6 @@ rastertopclx_LDADD = \
 	$(LIBPNG_LIBS) \
 	libcupsfilters.la
 
-test_pdf1_SOURCES = \
-	filter/pdfutils.c \
-	filter/pdfutils.h \
-	filter/test_pdf1.c \
-	fontembed/embed.h \
-	fontembed/sfnt.h
-test_pdf1_CFLAGS = -I$(srcdir)/fontembed/
-test_pdf1_LDADD = libfontembed.la
-
-test_pdf2_SOURCES = \
-	filter/pdfutils.c \
-	filter/pdfutils.h \
-	filter/test_pdf2.c \
-	fontembed/embed.h \
-	fontembed/sfnt.h
-test_pdf2_CFLAGS = -I$(srcdir)/fontembed/
-test_pdf2_LDADD = libfontembed.la
-
-texttopdf_SOURCES = \
-	filter/common.c \
-	filter/common.h \
-	filter/pdfutils.c \
-	filter/pdfutils.h \
-	filter/textcommon.c \
-	filter/textcommon.h \
-	filter/texttopdf.c \
-	fontembed/bitset.h \
-	fontembed/embed.h \
-	fontembed/fontfile.h \
-	fontembed/iofn.h \
-	fontembed/sfnt.h
-texttopdf_CFLAGS = \
-	$(CUPS_CFLAGS) \
-	$(FONTCONFIG_CFLAGS) \
-	-I$(srcdir)/fontembed/
-texttopdf_LDADD = \
-	$(CUPS_LIBS) \
-	$(FONTCONFIG_LIBS) \
-	libfontembed.la
-
 # =====
 # UTILS
 # =====
@@ -1012,12 +709,6 @@ if ENABLE_DRIVERLESS
 endif
 if ENABLE_BRAILLE
 	$(LN_S) -f imagetobrf $(DESTDIR)$(pkgfilterdir)/imagetoubrl
-	$(LN_S) -f vectortopdf $(DESTDIR)$(pkgfilterdir)/svgtopdf
-	$(LN_S) -f vectortopdf $(DESTDIR)$(pkgfilterdir)/xfigtopdf
-	$(LN_S) -f vectortopdf $(DESTDIR)$(pkgfilterdir)/wmftopdf
-	$(LN_S) -f vectortopdf $(DESTDIR)$(pkgfilterdir)/emftopdf
-	$(LN_S) -f vectortopdf $(DESTDIR)$(pkgfilterdir)/cgmtopdf
-	$(LN_S) -f vectortopdf $(DESTDIR)$(pkgfilterdir)/cmxtopdf
 	$(LN_S) -f vectortobrf $(DESTDIR)$(pkgfilterdir)/vectortoubrl
 	$(LN_S) -f textbrftoindexv3 $(DESTDIR)$(pkgfilterdir)/textbrftoindexv4
 endif
@@ -1057,12 +748,6 @@ if ENABLE_DRIVERLESS
 endif
 if ENABLE_BRAILLE
 	$(RM) $(DESTDIR)$(pkgfilterdir)/imagetoubrl
-	$(RM) $(DESTDIR)$(pkgfilterdir)/svgtopdf
-	$(RM) $(DESTDIR)$(pkgfilterdir)/xfigtopdf
-	$(RM) $(DESTDIR)$(pkgfilterdir)/wmftopdf
-	$(RM) $(DESTDIR)$(pkgfilterdir)/emftopdf
-	$(RM) $(DESTDIR)$(pkgfilterdir)/cgmtopdf
-	$(RM) $(DESTDIR)$(pkgfilterdir)/cmxtopdf
 	$(RM) $(DESTDIR)$(pkgfilterdir)/vectortoubrl
 	$(RM) $(DESTDIR)$(pkgfilterdir)/textbrftoindexv4
 endif
diff --git a/Makefile.in b/Makefile.in
index 50108d3..1ca50f0 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -94,13 +94,10 @@ host_triplet = @host@
 pkgbackend_PROGRAMS = parallel$(EXEEXT) serial$(EXEEXT) beh$(EXEEXT) \
 	implicitclass$(EXEEXT) $(am__EXEEXT_1)
 check_PROGRAMS = test1284$(EXEEXT) testcmyk$(EXEEXT) \
-	testdither$(EXEEXT) testimage$(EXEEXT) testrgb$(EXEEXT) \
-	test_analyze$(EXEEXT) test_pdf$(EXEEXT) test_ps$(EXEEXT) \
-	test_pdf1$(EXEEXT) test_pdf2$(EXEEXT)
+	testdither$(EXEEXT) testimage$(EXEEXT) testrgb$(EXEEXT)
 @ENABLE_BRAILLE_TRUE@am__append_1 = cups-brf
 @ENABLE_DRIVERLESS_TRUE@pkgppdgen_PROGRAMS = driverless$(EXEEXT)
-TESTS = testdither$(EXEEXT) test_analyze$(EXEEXT) test_pdf$(EXEEXT) \
-	test_ps$(EXEEXT) test_pdf1$(EXEEXT) test_pdf2$(EXEEXT)
+TESTS = testdither$(EXEEXT)
 @BUILD_DBUS_TRUE@am__append_2 = $(DBUS_CFLAGS) -DHAVE_DBUS
 @BUILD_DBUS_TRUE@am__append_3 = $(DBUS_LIBS)
 @ENABLE_BRAILLE_TRUE@am__append_4 = $(brldrvfiles)
@@ -109,38 +106,26 @@ TESTS = testdither$(EXEEXT) test_analyze$(EXEEXT) test_pdf$(EXEEXT) \
 @ENABLE_GHOSTSCRIPT_TRUE@am__append_7 = $(gsmimefiles)
 @ENABLE_MUTOOL_TRUE@am__append_8 = $(mutoolmimefiles)
 @ENABLE_BRAILLE_TRUE@am__append_9 = $(brlmimefiles)
-bin_PROGRAMS = ttfread$(EXEEXT)
-pkgfilter_PROGRAMS = pdftopdf$(EXEEXT) commandtoescpx$(EXEEXT) \
+pkgfilter_PROGRAMS = commandtoescpx$(EXEEXT) \
 	commandtopclx$(EXEEXT) sys5ippprinter$(EXEEXT) \
-	texttotext$(EXEEXT) pdftops$(EXEEXT) rastertoescpx$(EXEEXT) \
-	rastertopclx$(EXEEXT) texttopdf$(EXEEXT) rastertopdf$(EXEEXT) \
-	bannertopdf$(EXEEXT) rastertops$(EXEEXT) $(am__EXEEXT_2) \
+	texttotext$(EXEEXT) rastertoescpx$(EXEEXT) \
+	rastertopclx$(EXEEXT) $(am__EXEEXT_2) \
 	$(am__EXEEXT_3) $(am__EXEEXT_4) $(am__EXEEXT_5) \
 	$(am__EXEEXT_6) $(am__EXEEXT_7)
 @ENABLE_GHOSTSCRIPT_TRUE@am__append_10 = $(gsfilterscripts)
-@ENABLE_URFTOPDF_TRUE@am__append_11 = \
-@ENABLE_URFTOPDF_TRUE@	urftopdf
-
-@ENABLE_POPPLER_TRUE@am__append_12 = \
-@ENABLE_POPPLER_TRUE@	pdftoraster
 
 @ENABLE_GHOSTSCRIPT_TRUE@am__append_13 = \
 @ENABLE_GHOSTSCRIPT_TRUE@	gstoraster
 
-@ENABLE_MUTOOL_TRUE@am__append_14 = \
-@ENABLE_MUTOOL_TRUE@	mupdftoraster
-
 @ENABLE_FOOMATIC_TRUE@am__append_15 = \
 @ENABLE_FOOMATIC_TRUE@	foomatic-rip
 
 @ENABLE_IMAGEFILTERS_TRUE@am__append_16 = \
-@ENABLE_IMAGEFILTERS_TRUE@	imagetopdf \
 @ENABLE_IMAGEFILTERS_TRUE@	imagetoraster
 
 sbin_PROGRAMS = cups-browsed$(EXEEXT)
 @ENABLE_DRIVERLESS_TRUE@am__append_17 = $(driverlessmanpages)
 @ENABLE_FOOMATIC_TRUE@am__append_18 = $(foomaticmanpages)
-@ENABLE_GHOSTSCRIPT_TRUE@am__append_19 = $(gsppdfiles)
 subdir = .
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/m4/ac_ln_srf.m4 \
@@ -164,7 +149,7 @@ am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \
  configure.lineno config.status.lineno
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = config.h
-CONFIG_CLEAN_FILES = libcupsfilters.pc libfontembed.pc \
+CONFIG_CLEAN_FILES = libcupsfilters.pc \
 	utils/cups-browsed utils/cups-browsed.conf \
 	filter/foomatic-rip/foomatic-rip.1 \
 	filter/braille/drivers/index/indexv4.sh \
@@ -178,7 +163,6 @@ CONFIG_CLEAN_FILES = libcupsfilters.pc libfontembed.pc \
 	filter/braille/filters/imagetobrf \
 	filter/braille/filters/texttobrf \
 	filter/braille/filters/brftopagedbrf \
-	filter/braille/filters/vectortopdf \
 	filter/braille/filters/vectortobrf \
 	filter/braille/filters/musicxmltobrf \
 	filter/braille/filters/liblouis1.defs.gen \
@@ -197,17 +181,12 @@ am__installdirs = "$(DESTDIR)$(bindir)" "$(DESTDIR)$(pkgbackenddir)" \
 	"$(DESTDIR)$(pkgcupsserverrootdir)" \
 	"$(DESTDIR)$(pkgdriverdir)" \
 	"$(DESTDIR)$(pkgfiltersincludedir)" \
-	"$(DESTDIR)$(pkgfontembedincludedir)" \
 	"$(DESTDIR)$(pkgmimedir)" "$(DESTDIR)$(pkgppdcdir)" \
 	"$(DESTDIR)$(ppddir)"
 @ENABLE_BRAILLE_TRUE@am__EXEEXT_1 = cups-brf$(EXEEXT)
-@ENABLE_URFTOPDF_TRUE@am__EXEEXT_2 = urftopdf$(EXEEXT)
-@ENABLE_POPPLER_TRUE@am__EXEEXT_3 = pdftoraster$(EXEEXT)
 @ENABLE_GHOSTSCRIPT_TRUE@am__EXEEXT_4 = gstoraster$(EXEEXT)
-@ENABLE_MUTOOL_TRUE@am__EXEEXT_5 = mupdftoraster$(EXEEXT)
 @ENABLE_FOOMATIC_TRUE@am__EXEEXT_6 = foomatic-rip$(EXEEXT)
-@ENABLE_IMAGEFILTERS_TRUE@am__EXEEXT_7 = imagetopdf$(EXEEXT) \
-@ENABLE_IMAGEFILTERS_TRUE@	imagetoraster$(EXEEXT)
+@ENABLE_IMAGEFILTERS_TRUE@am__EXEEXT_7 = imagetoraster$(EXEEXT)
 PROGRAMS = $(bin_PROGRAMS) $(pkgbackend_PROGRAMS) \
 	$(pkgfilter_PROGRAMS) $(pkgppdgen_PROGRAMS) $(sbin_PROGRAMS)
 am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
@@ -252,7 +231,6 @@ am_libcupsfilters_la_OBJECTS = cupsfilters/libcupsfilters_la-attr.lo \
 	cupsfilters/libcupsfilters_la-colormanager.lo \
 	cupsfilters/libcupsfilters_la-dither.lo \
 	cupsfilters/libcupsfilters_la-image.lo \
-	cupsfilters/libcupsfilters_la-pdftoippprinter.lo \
 	cupsfilters/libcupsfilters_la-image-bmp.lo \
 	cupsfilters/libcupsfilters_la-image-colorspace.lo \
 	cupsfilters/libcupsfilters_la-image-gif.lo \
@@ -282,17 +260,6 @@ libcupsfilters_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
 	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
 	$(libcupsfilters_la_CFLAGS) $(CFLAGS) \
 	$(libcupsfilters_la_LDFLAGS) $(LDFLAGS) -o $@
-libfontembed_la_LIBADD =
-am_libfontembed_la_OBJECTS = fontembed/aglfn13.lo \
-	fontembed/dynstring.lo fontembed/embed.lo \
-	fontembed/embed_sfnt.lo fontembed/embed_pdf.lo \
-	fontembed/fontfile.lo fontembed/frequent.lo fontembed/sfnt.lo \
-	fontembed/sfnt_subset.lo
-libfontembed_la_OBJECTS = $(am_libfontembed_la_OBJECTS)
-libfontembed_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC \
-	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=link $(CCLD) \
-	$(AM_CFLAGS) $(CFLAGS) $(libfontembed_la_LDFLAGS) $(LDFLAGS) \
-	-o $@
 libphpcups_la_DEPENDENCIES = $(am__DEPENDENCIES_1)
 am_libphpcups_la_OBJECTS = scripting/php/libphpcups_la-phpcups.lo
 libphpcups_la_OBJECTS = $(am_libphpcups_la_OBJECTS)
@@ -300,13 +267,6 @@ libphpcups_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(libphpcups_la_CFLAGS) \
 	$(CFLAGS) $(libphpcups_la_LDFLAGS) $(LDFLAGS) -o $@
 @WITH_PHP_TRUE@am_libphpcups_la_rpath = -rpath $(phpextensiondir)
-am_bannertopdf_OBJECTS = filter/bannertopdf-banner.$(OBJEXT) \
-	filter/bannertopdf-bannertopdf.$(OBJEXT) \
-	filter/bannertopdf-pdf.$(OBJEXT)
-bannertopdf_OBJECTS = $(am_bannertopdf_OBJECTS)
-bannertopdf_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(bannertopdf_CXXFLAGS) \
-	$(CXXFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 am_beh_OBJECTS = backend/beh-beh.$(OBJEXT)
 beh_OBJECTS = $(am_beh_OBJECTS)
 beh_DEPENDENCIES = $(am__DEPENDENCIES_1)
@@ -352,7 +312,6 @@ driverless_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 am_foomatic_rip_OBJECTS =  \
 	filter/foomatic-rip/foomatic_rip-foomaticrip.$(OBJEXT) \
 	filter/foomatic-rip/foomatic_rip-options.$(OBJEXT) \
-	filter/foomatic-rip/foomatic_rip-pdf.$(OBJEXT) \
 	filter/foomatic-rip/foomatic_rip-postscript.$(OBJEXT) \
 	filter/foomatic-rip/foomatic_rip-process.$(OBJEXT) \
 	filter/foomatic-rip/foomatic_rip-renderer.$(OBJEXT) \
@@ -363,19 +322,9 @@ foomatic_rip_DEPENDENCIES = $(am__DEPENDENCIES_1) libcupsfilters.la
 foomatic_rip_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(foomatic_rip_CFLAGS) \
 	$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-am_gstoraster_OBJECTS = filter/gstoraster-gstoraster.$(OBJEXT) \
-	filter/pdf.$(OBJEXT)
 gstoraster_OBJECTS = $(am_gstoraster_OBJECTS)
 gstoraster_DEPENDENCIES = $(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
 	libcupsfilters.la
-am_imagetopdf_OBJECTS = filter/imagetopdf-common.$(OBJEXT) \
-	filter/imagetopdf-imagetopdf.$(OBJEXT)
-imagetopdf_OBJECTS = $(am_imagetopdf_OBJECTS)
-imagetopdf_DEPENDENCIES = $(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1) libcupsfilters.la
-imagetopdf_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(imagetopdf_CFLAGS) \
-	$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 am_imagetoraster_OBJECTS = filter/imagetoraster-common.$(OBJEXT) \
 	filter/imagetoraster-imagetoraster.$(OBJEXT)
 imagetoraster_OBJECTS = $(am_imagetoraster_OBJECTS)
@@ -390,13 +339,6 @@ implicitclass_DEPENDENCIES = $(am__DEPENDENCIES_1) libcupsfilters.la
 implicitclass_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(implicitclass_CFLAGS) \
 	$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-am_mupdftoraster_OBJECTS =  \
-	filter/mupdftoraster-mupdftoraster.$(OBJEXT)
-mupdftoraster_OBJECTS = $(am_mupdftoraster_OBJECTS)
-mupdftoraster_DEPENDENCIES = $(am__DEPENDENCIES_1) libcupsfilters.la
-mupdftoraster_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(mupdftoraster_CFLAGS) \
-	$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 am_parallel_OBJECTS = backend/parallel-ieee1284.$(OBJEXT) \
 	backend/parallel-parallel.$(OBJEXT)
 parallel_OBJECTS = $(am_parallel_OBJECTS)
@@ -404,33 +346,6 @@ parallel_DEPENDENCIES = $(am__DEPENDENCIES_1)
 parallel_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(parallel_CFLAGS) \
 	$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-am_pdftopdf_OBJECTS = filter/pdftopdf/pdftopdf-pdftopdf.$(OBJEXT) \
-	filter/pdftopdf/pdftopdf-pdftopdf_jcl.$(OBJEXT) \
-	filter/pdftopdf/pdftopdf-pdftopdf_processor.$(OBJEXT) \
-	filter/pdftopdf/pdftopdf-qpdf_pdftopdf_processor.$(OBJEXT) \
-	filter/pdftopdf/pdftopdf-pptypes.$(OBJEXT) \
-	filter/pdftopdf/pdftopdf-nup.$(OBJEXT) \
-	filter/pdftopdf/pdftopdf-intervalset.$(OBJEXT) \
-	filter/pdftopdf/pdftopdf-qpdf_tools.$(OBJEXT) \
-	filter/pdftopdf/pdftopdf-qpdf_xobject.$(OBJEXT) \
-	filter/pdftopdf/pdftopdf-qpdf_pdftopdf.$(OBJEXT) \
-	filter/pdftopdf/pdftopdf-qpdf_cm.$(OBJEXT)
-pdftopdf_OBJECTS = $(am_pdftopdf_OBJECTS)
-pdftopdf_DEPENDENCIES = $(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1)
-pdftopdf_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(pdftopdf_CXXFLAGS) \
-	$(CXXFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-am_pdftops_OBJECTS = filter/pdftops-common.$(OBJEXT) \
-	filter/pdftops-pdftops.$(OBJEXT) filter/pdf.$(OBJEXT)
-pdftops_OBJECTS = $(am_pdftops_OBJECTS)
-am_pdftoraster_OBJECTS = filter/pdftoraster-pdftoraster.$(OBJEXT)
-pdftoraster_OBJECTS = $(am_pdftoraster_OBJECTS)
-pdftoraster_DEPENDENCIES = $(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1) libcupsfilters.la
-pdftoraster_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(pdftoraster_CXXFLAGS) \
-	$(CXXFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 am_rastertoescpx_OBJECTS =  \
 	filter/rastertoescpx-rastertoescpx.$(OBJEXT)
 rastertoescpx_OBJECTS = $(am_rastertoescpx_OBJECTS)
@@ -446,19 +361,6 @@ rastertopclx_DEPENDENCIES = $(am__DEPENDENCIES_1) \
 rastertopclx_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(rastertopclx_CFLAGS) \
 	$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-am_rastertopdf_OBJECTS = filter/rastertopdf-rastertopdf.$(OBJEXT)
-rastertopdf_OBJECTS = $(am_rastertopdf_OBJECTS)
-rastertopdf_DEPENDENCIES = $(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
-	$(am__DEPENDENCIES_1) libcupsfilters.la
-rastertopdf_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(rastertopdf_CXXFLAGS) \
-	$(CXXFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-am_rastertops_OBJECTS = filter/rastertops-rastertops.$(OBJEXT)
-rastertops_OBJECTS = $(am_rastertops_OBJECTS)
-rastertops_DEPENDENCIES = $(am__DEPENDENCIES_1) libcupsfilters.la
-rastertops_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(rastertops_CFLAGS) \
-	$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 am_serial_OBJECTS = backend/serial-serial.$(OBJEXT)
 serial_OBJECTS = $(am_serial_OBJECTS)
 serial_DEPENDENCIES = $(am__DEPENDENCIES_1)
@@ -479,29 +381,6 @@ test1284_DEPENDENCIES = $(am__DEPENDENCIES_1)
 test1284_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(test1284_CFLAGS) \
 	$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-am_test_analyze_OBJECTS = fontembed/test_analyze.$(OBJEXT)
-test_analyze_OBJECTS = $(am_test_analyze_OBJECTS)
-test_analyze_DEPENDENCIES = libfontembed.la
-am_test_pdf_OBJECTS = fontembed/test_pdf.$(OBJEXT)
-test_pdf_OBJECTS = $(am_test_pdf_OBJECTS)
-test_pdf_DEPENDENCIES = libfontembed.la
-am_test_pdf1_OBJECTS = filter/test_pdf1-pdfutils.$(OBJEXT) \
-	filter/test_pdf1-test_pdf1.$(OBJEXT)
-test_pdf1_OBJECTS = $(am_test_pdf1_OBJECTS)
-test_pdf1_DEPENDENCIES = libfontembed.la
-test_pdf1_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(test_pdf1_CFLAGS) \
-	$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-am_test_pdf2_OBJECTS = filter/test_pdf2-pdfutils.$(OBJEXT) \
-	filter/test_pdf2-test_pdf2.$(OBJEXT)
-test_pdf2_OBJECTS = $(am_test_pdf2_OBJECTS)
-test_pdf2_DEPENDENCIES = libfontembed.la
-test_pdf2_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(test_pdf2_CFLAGS) \
-	$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-am_test_ps_OBJECTS = fontembed/test_ps.$(OBJEXT)
-test_ps_OBJECTS = $(am_test_ps_OBJECTS)
-test_ps_DEPENDENCIES = libfontembed.la
 am_testcmyk_OBJECTS = cupsfilters/testcmyk.$(OBJEXT) $(am__objects_1)
 testcmyk_OBJECTS = $(am_testcmyk_OBJECTS)
 testcmyk_DEPENDENCIES = libcupsfilters.la
@@ -520,30 +399,11 @@ testimage_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 am_testrgb_OBJECTS = cupsfilters/testrgb.$(OBJEXT) $(am__objects_1)
 testrgb_OBJECTS = $(am_testrgb_OBJECTS)
 testrgb_DEPENDENCIES = libcupsfilters.la
-am_texttopdf_OBJECTS = filter/texttopdf-common.$(OBJEXT) \
-	filter/texttopdf-pdfutils.$(OBJEXT) \
-	filter/texttopdf-textcommon.$(OBJEXT) \
-	filter/texttopdf-texttopdf.$(OBJEXT)
-texttopdf_OBJECTS = $(am_texttopdf_OBJECTS)
-texttopdf_DEPENDENCIES = $(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \
-	libfontembed.la
-texttopdf_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(texttopdf_CFLAGS) \
-	$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 am_texttotext_OBJECTS = filter/texttotext-texttotext.$(OBJEXT)
 texttotext_OBJECTS = $(am_texttotext_OBJECTS)
 texttotext_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(texttotext_CFLAGS) \
 	$(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-am_ttfread_OBJECTS = fontembed/main.$(OBJEXT)
-ttfread_OBJECTS = $(am_ttfread_OBJECTS)
-ttfread_DEPENDENCIES = libfontembed.la
-am_urftopdf_OBJECTS = filter/urftopdf-urftopdf.$(OBJEXT)
-urftopdf_OBJECTS = $(am_urftopdf_OBJECTS)
-urftopdf_DEPENDENCIES = $(am__DEPENDENCIES_1)
-urftopdf_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CXX $(AM_LIBTOOLFLAGS) \
-	$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(urftopdf_CXXFLAGS) \
-	$(CXXFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 SCRIPTS = $(initrc_SCRIPTS) $(nodist_pkgbraille_SCRIPTS) \
 	$(nodist_pkgfilter_SCRIPTS) $(pkgfilter_SCRIPTS)
 AM_V_P = $(am__v_P_@AM_V@)
@@ -592,7 +452,6 @@ am__depfiles_remade = ./$(DEPDIR)/cups_browsed-cups-notifier.Po \
 	cupsfilters/$(DEPDIR)/libcupsfilters_la-ipp.Plo \
 	cupsfilters/$(DEPDIR)/libcupsfilters_la-lut.Plo \
 	cupsfilters/$(DEPDIR)/libcupsfilters_la-pack.Plo \
-	cupsfilters/$(DEPDIR)/libcupsfilters_la-pdftoippprinter.Plo \
 	cupsfilters/$(DEPDIR)/libcupsfilters_la-ppdgenerator.Plo \
 	cupsfilters/$(DEPDIR)/libcupsfilters_la-raster.Plo \
 	cupsfilters/$(DEPDIR)/libcupsfilters_la-rgb.Plo \
@@ -601,71 +460,26 @@ am__depfiles_remade = ./$(DEPDIR)/cups_browsed-cups-notifier.Po \
 	cupsfilters/$(DEPDIR)/testdither.Po \
 	cupsfilters/$(DEPDIR)/testimage-testimage.Po \
 	cupsfilters/$(DEPDIR)/testrgb.Po \
-	filter/$(DEPDIR)/bannertopdf-banner.Po \
-	filter/$(DEPDIR)/bannertopdf-bannertopdf.Po \
-	filter/$(DEPDIR)/bannertopdf-getline.Po \
-	filter/$(DEPDIR)/bannertopdf-pdf.Po \
 	filter/$(DEPDIR)/commandtoescpx-commandtoescpx.Po \
 	filter/$(DEPDIR)/commandtopclx-commandtopclx.Po \
 	filter/$(DEPDIR)/gstoraster-gstoraster.Po \
-	filter/$(DEPDIR)/imagetopdf-common.Po \
-	filter/$(DEPDIR)/imagetopdf-imagetopdf.Po \
 	filter/$(DEPDIR)/imagetoraster-common.Po \
 	filter/$(DEPDIR)/imagetoraster-imagetoraster.Po \
-	filter/$(DEPDIR)/mupdftoraster-mupdftoraster.Po \
-	filter/$(DEPDIR)/pdf.Po filter/$(DEPDIR)/pdftops-common.Po \
-	filter/$(DEPDIR)/pdftops-pdftops.Po \
-	filter/$(DEPDIR)/pdftops-strcasestr.Po \
-	filter/$(DEPDIR)/pdftoraster-pdftoraster.Po \
 	filter/$(DEPDIR)/rastertoescpx-rastertoescpx.Po \
 	filter/$(DEPDIR)/rastertopclx-pcl-common.Po \
 	filter/$(DEPDIR)/rastertopclx-rastertopclx.Po \
-	filter/$(DEPDIR)/rastertopdf-rastertopdf.Po \
-	filter/$(DEPDIR)/rastertops-rastertops.Po \
 	filter/$(DEPDIR)/sys5ippprinter-common.Po \
 	filter/$(DEPDIR)/sys5ippprinter-strcasestr.Po \
 	filter/$(DEPDIR)/sys5ippprinter-sys5ippprinter.Po \
-	filter/$(DEPDIR)/test_pdf1-pdfutils.Po \
-	filter/$(DEPDIR)/test_pdf1-test_pdf1.Po \
-	filter/$(DEPDIR)/test_pdf2-pdfutils.Po \
-	filter/$(DEPDIR)/test_pdf2-test_pdf2.Po \
-	filter/$(DEPDIR)/texttopdf-common.Po \
-	filter/$(DEPDIR)/texttopdf-pdfutils.Po \
-	filter/$(DEPDIR)/texttopdf-textcommon.Po \
-	filter/$(DEPDIR)/texttopdf-texttopdf.Po \
 	filter/$(DEPDIR)/texttotext-strcasestr.Po \
 	filter/$(DEPDIR)/texttotext-texttotext.Po \
-	filter/$(DEPDIR)/urftopdf-urftopdf.Po \
 	filter/foomatic-rip/$(DEPDIR)/foomatic_rip-foomaticrip.Po \
 	filter/foomatic-rip/$(DEPDIR)/foomatic_rip-options.Po \
-	filter/foomatic-rip/$(DEPDIR)/foomatic_rip-pdf.Po \
 	filter/foomatic-rip/$(DEPDIR)/foomatic_rip-postscript.Po \
 	filter/foomatic-rip/$(DEPDIR)/foomatic_rip-process.Po \
 	filter/foomatic-rip/$(DEPDIR)/foomatic_rip-renderer.Po \
 	filter/foomatic-rip/$(DEPDIR)/foomatic_rip-spooler.Po \
 	filter/foomatic-rip/$(DEPDIR)/foomatic_rip-util.Po \
-	filter/pdftopdf/$(DEPDIR)/pdftopdf-intervalset.Po \
-	filter/pdftopdf/$(DEPDIR)/pdftopdf-nup.Po \
-	filter/pdftopdf/$(DEPDIR)/pdftopdf-pdftopdf.Po \
-	filter/pdftopdf/$(DEPDIR)/pdftopdf-pdftopdf_jcl.Po \
-	filter/pdftopdf/$(DEPDIR)/pdftopdf-pdftopdf_processor.Po \
-	filter/pdftopdf/$(DEPDIR)/pdftopdf-pptypes.Po \
-	filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_cm.Po \
-	filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_pdftopdf.Po \
-	filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_pdftopdf_processor.Po \
-	filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_tools.Po \
-	filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_xobject.Po \
-	fontembed/$(DEPDIR)/aglfn13.Plo \
-	fontembed/$(DEPDIR)/dynstring.Plo \
-	fontembed/$(DEPDIR)/embed.Plo \
-	fontembed/$(DEPDIR)/embed_pdf.Plo \
-	fontembed/$(DEPDIR)/embed_sfnt.Plo \
-	fontembed/$(DEPDIR)/fontfile.Plo \
-	fontembed/$(DEPDIR)/frequent.Plo fontembed/$(DEPDIR)/main.Po \
-	fontembed/$(DEPDIR)/sfnt.Plo \
-	fontembed/$(DEPDIR)/sfnt_subset.Plo \
-	fontembed/$(DEPDIR)/test_analyze.Po \
-	fontembed/$(DEPDIR)/test_pdf.Po fontembed/$(DEPDIR)/test_ps.Po \
 	scripting/php/$(DEPDIR)/libphpcups_la-phpcups.Plo \
 	utils/$(DEPDIR)/cups_browsed-cups-browsed.Po \
 	utils/$(DEPDIR)/driverless-driverless.Po
@@ -706,53 +520,43 @@ AM_V_CXXLD = $(am__v_CXXLD_@AM_V@)
 am__v_CXXLD_ = $(am__v_CXXLD_@AM_DEFAULT_V@)
 am__v_CXXLD_0 = @echo "  CXXLD   " $@;
 am__v_CXXLD_1 = 
-SOURCES = $(libcupsfilters_la_SOURCES) $(libfontembed_la_SOURCES) \
-	$(libphpcups_la_SOURCES) $(bannertopdf_SOURCES) \
-	$(EXTRA_bannertopdf_SOURCES) $(beh_SOURCES) \
+SOURCES = $(libcupsfilters_la_SOURCES) \
+	$(libphpcups_la_SOURCES) $(beh_SOURCES) \
 	$(commandtoescpx_SOURCES) $(commandtopclx_SOURCES) \
 	$(cups_brf_SOURCES) $(cups_browsed_SOURCES) \
 	$(nodist_cups_browsed_SOURCES) $(driverless_SOURCES) \
 	$(foomatic_rip_SOURCES) $(gstoraster_SOURCES) \
-	$(imagetopdf_SOURCES) $(imagetoraster_SOURCES) \
-	$(implicitclass_SOURCES) $(mupdftoraster_SOURCES) \
-	$(parallel_SOURCES) $(pdftopdf_SOURCES) $(pdftops_SOURCES) \
-	$(EXTRA_pdftops_SOURCES) $(pdftoraster_SOURCES) \
+	$(imagetoraster_SOURCES) \
+	$(implicitclass_SOURCES) \
+	$(parallel_SOURCES) \
 	$(rastertoescpx_SOURCES) $(rastertopclx_SOURCES) \
-	$(rastertopdf_SOURCES) $(rastertops_SOURCES) $(serial_SOURCES) \
+	$(serial_SOURCES) \
 	$(sys5ippprinter_SOURCES) $(EXTRA_sys5ippprinter_SOURCES) \
-	$(test1284_SOURCES) $(test_analyze_SOURCES) \
-	$(test_pdf_SOURCES) $(test_pdf1_SOURCES) $(test_pdf2_SOURCES) \
-	$(test_ps_SOURCES) $(testcmyk_SOURCES) $(testdither_SOURCES) \
-	$(testimage_SOURCES) $(testrgb_SOURCES) $(texttopdf_SOURCES) \
-	$(texttotext_SOURCES) $(EXTRA_texttotext_SOURCES) \
-	$(ttfread_SOURCES) $(urftopdf_SOURCES)
-DIST_SOURCES = $(libcupsfilters_la_SOURCES) $(libfontembed_la_SOURCES) \
-	$(libphpcups_la_SOURCES) $(bannertopdf_SOURCES) \
-	$(EXTRA_bannertopdf_SOURCES) $(beh_SOURCES) \
+	$(test1284_SOURCES) \
+	$(testcmyk_SOURCES) $(testdither_SOURCES) \
+	$(testimage_SOURCES) $(testrgb_SOURCES) \
+	$(texttotext_SOURCES) $(EXTRA_texttotext_SOURCES)
+DIST_SOURCES = $(libcupsfilters_la_SOURCES) \
+	$(libphpcups_la_SOURCES) $(beh_SOURCES) \
 	$(commandtoescpx_SOURCES) $(commandtopclx_SOURCES) \
 	$(cups_brf_SOURCES) $(cups_browsed_SOURCES) \
 	$(driverless_SOURCES) $(foomatic_rip_SOURCES) \
-	$(gstoraster_SOURCES) $(imagetopdf_SOURCES) \
+	$(gstoraster_SOURCES) \
 	$(imagetoraster_SOURCES) $(implicitclass_SOURCES) \
-	$(mupdftoraster_SOURCES) $(parallel_SOURCES) \
-	$(pdftopdf_SOURCES) $(pdftops_SOURCES) \
-	$(EXTRA_pdftops_SOURCES) $(pdftoraster_SOURCES) \
+	$(parallel_SOURCES) \
 	$(rastertoescpx_SOURCES) $(rastertopclx_SOURCES) \
-	$(rastertopdf_SOURCES) $(rastertops_SOURCES) $(serial_SOURCES) \
+	$(serial_SOURCES) \
 	$(sys5ippprinter_SOURCES) $(EXTRA_sys5ippprinter_SOURCES) \
-	$(test1284_SOURCES) $(test_analyze_SOURCES) \
-	$(test_pdf_SOURCES) $(test_pdf1_SOURCES) $(test_pdf2_SOURCES) \
-	$(test_ps_SOURCES) $(testcmyk_SOURCES) $(testdither_SOURCES) \
-	$(testimage_SOURCES) $(testrgb_SOURCES) $(texttopdf_SOURCES) \
-	$(texttotext_SOURCES) $(EXTRA_texttotext_SOURCES) \
-	$(ttfread_SOURCES) $(urftopdf_SOURCES)
+	$(test1284_SOURCES) \
+	$(testcmyk_SOURCES) $(testdither_SOURCES) \
+	$(testimage_SOURCES) $(testrgb_SOURCES) \
+	$(texttotext_SOURCES) $(EXTRA_texttotext_SOURCES)
 RECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \
 	ctags-recursive dvi-recursive html-recursive info-recursive \
 	install-data-recursive install-dvi-recursive \
 	install-exec-recursive install-html-recursive \
-	install-info-recursive install-pdf-recursive \
 	install-ps-recursive install-recursive installcheck-recursive \
-	installdirs-recursive pdf-recursive ps-recursive \
+	installdirs-recursive \
 	tags-recursive uninstall-recursive
 am__can_run_installinfo = \
   case $$AM_UPDATE_INFO_DIR in \
@@ -767,7 +571,7 @@ MANS = $(man_MANS)
 DATA = $(doc_DATA) $(nodist_pkgppdc_DATA) $(pkgbanner_DATA) \
 	$(pkgcharset_DATA) $(pkgconf_DATA) $(pkgcupsdata_DATA) \
 	$(pkgcupsserverroot_DATA) $(pkgdriver_DATA) \
-	$(pkgfiltersinclude_DATA) $(pkgfontembedinclude_DATA) \
+	$(pkgfiltersinclude_DATA) \
 	$(pkgmime_DATA) $(pkgppdc_DATA) $(ppd_DATA)
 RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
   distclean-recursive maintainer-clean-recursive
@@ -977,7 +781,7 @@ TEST_LOG_COMPILE = $(TEST_LOG_COMPILER) $(AM_TEST_LOG_FLAGS) \
 	$(TEST_LOG_FLAGS)
 DIST_SUBDIRS = $(SUBDIRS)
 am__DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/config.h.in \
-	$(srcdir)/libcupsfilters.pc.in $(srcdir)/libfontembed.pc.in \
+	$(srcdir)/libcupsfilters.pc.in \
 	$(top_srcdir)/filter/braille/drivers/generic/brftoembosser.in \
 	$(top_srcdir)/filter/braille/drivers/index/imageubrltoindexv3.in \
 	$(top_srcdir)/filter/braille/drivers/index/imageubrltoindexv4.in \
@@ -992,7 +796,6 @@ am__DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/config.h.in \
 	$(top_srcdir)/filter/braille/filters/musicxmltobrf.in \
 	$(top_srcdir)/filter/braille/filters/texttobrf.in \
 	$(top_srcdir)/filter/braille/filters/vectortobrf.in \
-	$(top_srcdir)/filter/braille/filters/vectortopdf.in \
 	$(top_srcdir)/filter/foomatic-rip/foomatic-rip.1.in \
 	$(top_srcdir)/mime/cupsfilters.convs.in \
 	$(top_srcdir)/utils/cups-browsed.conf.in \
@@ -1055,7 +858,6 @@ AVAHI_GLIB_CFLAGS = @AVAHI_GLIB_CFLAGS@
 AVAHI_GLIB_LIBS = @AVAHI_GLIB_LIBS@
 AVAHI_LIBS = @AVAHI_LIBS@
 AWK = @AWK@
-BANNERTOPDF_DATADIR = @BANNERTOPDF_DATADIR@
 BROWSEREMOTEPROTOCOLS = @BROWSEREMOTEPROTOCOLS@
 CC = @CC@
 CCDEPMODE = @CCDEPMODE@
@@ -1070,7 +872,6 @@ CUPS_FONTPATH = @CUPS_FONTPATH@
 CUPS_GHOSTSCRIPT = @CUPS_GHOSTSCRIPT@
 CUPS_LIBS = @CUPS_LIBS@
 CUPS_MUTOOL = @CUPS_MUTOOL@
-CUPS_PDFTOPS = @CUPS_PDFTOPS@
 CUPS_SERVERBIN = @CUPS_SERVERBIN@
 CUPS_SERVERROOT = @CUPS_SERVERROOT@
 CUPS_STATEDIR = @CUPS_STATEDIR@
@@ -1245,8 +1046,7 @@ top_srcdir = @top_srcdir@
 ACLOCAL_AMFLAGS = -I m4
 pkgconfdir = $(libdir)/pkgconfig
 pkgconf_DATA = \
-	libcupsfilters.pc \
-	libfontembed.pc
+	libcupsfilters.pc
 
 doc_DATA = \
 	ABOUT-NLS \
@@ -1260,12 +1060,12 @@ doc_DATA = \
 # Not reliable bash script
 #TESTS += filter/test.sh
 EXTRA_DIST = $(doc_DATA) autogen.sh config.rpath ln-srf \
-	libcupsfilters.pc.in libfontembed.pc.in \
+	libcupsfilters.pc.in \
 	utils/cups-browsed.service utils/cups-browsed-upstart.conf \
 	filter/braille/drivers/index/ubrlto4dot.c \
 	filter/braille/filters/TODO.txt cupsfilters/kmdevices.cpp \
 	cupsfilters/kmdevices.h cupsfilters/testdriver.c \
-	data/makePDFfromPS.sh data/classified.ps data/confidential.ps \
+	data/classified.ps data/confidential.ps \
 	data/secret.ps data/standard.ps data/topsecret.ps \
 	data/unclassified.ps drv/custom-media-lines $(bannerfiles) \
 	$(pkgcharset_DATA) $(pkgfiltersinclude_DATA) \
@@ -1274,11 +1074,11 @@ EXTRA_DIST = $(doc_DATA) autogen.sh config.rpath ln-srf \
 	filter/braille/filters/liblouis1.defs.gen.in $(genppdcfiles) \
 	$(brlppdcfiles) $(genmimefiles) $(popplermimefiles) \
 	$(gsmimefiles) $(mutoolmimefiles) $(brlmimefiles) \
-	mime/cupsfilters.convs.in $(pkgfontembedinclude_DATA) \
-	fontembed/README $(genfilterscripts) $(gsfilterscripts) \
+	mime/cupsfilters.convs.in \
+	$(genfilterscripts) $(gsfilterscripts) \
 	filter/test.sh utils/cups-browsed.in $(cupsbrowsedmanpages) \
 	$(driverlessmanpages) filter/foomatic-rip/foomatic-rip.1.in \
-	utils/org.cups.cupsd.Notifier.xml $(genppdfiles) $(gsppdfiles) \
+	utils/org.cups.cupsd.Notifier.xml \
 	scripting/perl scripting/php/README scripting/php/phpcups.php
 
 # ========
@@ -1360,15 +1160,6 @@ bannerfiles = \
 	banners/unclassified
 
 
-# ========
-# Charsets
-# ========
-pkgcharsetdir = $(CUPS_DATADIR)/charsets
-pkgcharset_DATA = \
-	charset/pdf.utf-8.heavy \
-	charset/pdf.utf-8.simple
-
-
 # ====================
 # CUPS Filters library
 # ====================
@@ -1380,10 +1171,9 @@ pkgfiltersinclude_DATA = \
 	cupsfilters/image.h \
 	cupsfilters/ipp.h \
 	cupsfilters/raster.h \
-	cupsfilters/ppdgenerator.h \
-	cupsfilters/pdftoippprinter.h
+	cupsfilters/ppdgenerator.h
 
-lib_LTLIBRARIES = libcupsfilters.la libfontembed.la
+lib_LTLIBRARIES = libcupsfilters.la
 #	testcmyk # fails as it opens some image.ppm which is nowerhe to be found.
 #	testimage # requires also some ppm file as argument
 #	testrgb # same error
@@ -1404,7 +1194,6 @@ libcupsfilters_la_SOURCES = \
 	cupsfilters/colormanager.c \
 	cupsfilters/dither.c \
 	cupsfilters/image.c \
-	cupsfilters/pdftoippprinter.c \
 	cupsfilters/image-bmp.c \
 	cupsfilters/image-colorspace.c \
 	cupsfilters/image-gif.c \
@@ -1483,19 +1272,9 @@ testrgb_LDADD = \
 # =========
 pkgcupsdatadir = $(CUPS_DATADIR)/data
 pkgcupsdata_DATA = \
-	data/default.pdf \
-	data/form_russian.pdf \
-	data/form_english.pdf \
 	data/form_english_in.odt \
 	data/form_russian_in.odt \
-	data/default-testpage.pdf \
 	data/testprint \
-	data/classified.pdf \
-	data/confidential.pdf \
-	data/secret.pdf \
-	data/standard.pdf \
-	data/topsecret.pdf \
-	data/unclassified.pdf
 
 
 # ===========
@@ -1566,9 +1345,6 @@ popplermimefiles = \
 gsmimefiles = \
 	mime/cupsfilters-ghostscript.convs
 
-mutoolmimefiles = \
-	mime/cupsfilters-mupdf.convs
-
 brlmimefiles = \
 	mime/braille.convs \
 	mime/braille.types
@@ -1584,99 +1360,18 @@ brlmimefiles = \
 @ENABLE_BRAILLE_TRUE@	filter/braille/drivers/index/index.sh \
 @ENABLE_BRAILLE_TRUE@	filter/braille/filters/cups-braille.sh
 
-
-# =================
-# Fontembed library
-# =================
-pkgfontembedincludedir = $(includedir)/fontembed
-pkgfontembedinclude_DATA = \
-        fontembed/bitset.h \
-        fontembed/embed.h \
-        fontembed/fontfile.h \
-        fontembed/iofn.h \
-        fontembed/sfnt.h
-
-libfontembed_la_SOURCES = \
-	fontembed/aglfn13.c \
-	fontembed/bitset.h \
-	fontembed/dynstring.c \
-	fontembed/dynstring.h \
-	fontembed/embed.c \
-	fontembed/embed.h \
-	fontembed/embed_sfnt.c \
-	fontembed/embed_sfnt_int.h \
-	fontembed/embed_pdf.c \
-	fontembed/embed_pdf.h \
-	fontembed/embed_pdf_int.h \
-	fontembed/fontfile.c \
-	fontembed/fontfile.h \
-	fontembed/frequent.c \
-	fontembed/frequent.h \
-	fontembed/iofn.h \
-	fontembed/macroman.h \
-	fontembed/sfnt.c \
-	fontembed/sfnt.h \
-	fontembed/sfnt_int.h \
-	fontembed/sfnt_subset.c
-
-libfontembed_la_LDFLAGS = \
-	-no-undefined \
-	-version-info 1
-
-ttfread_SOURCES = fontembed/main.c
-ttfread_LDADD = libfontembed.la
-test_analyze_SOURCES = fontembed/test_analyze.c
-test_analyze_LDADD = libfontembed.la
-test_pdf_SOURCES = fontembed/test_pdf.c
-test_pdf_LDADD = libfontembed.la
-test_ps_SOURCES = fontembed/test_ps.c
-test_ps_LDADD = libfontembed.la
 pkgfilterdir = $(CUPS_SERVERBIN)/filter
-pdftopdf_SOURCES = \
-	filter/pdftopdf/pdftopdf.cc \
-	filter/pdftopdf/pdftopdf_jcl.cc \
-	filter/pdftopdf/pdftopdf_jcl.h \
-	filter/pdftopdf/pdftopdf_processor.cc \
-	filter/pdftopdf/pdftopdf_processor.h \
-	filter/pdftopdf/qpdf_pdftopdf_processor.cc \
-	filter/pdftopdf/qpdf_pdftopdf_processor.h \
-	filter/pdftopdf/pptypes.cc \
-	filter/pdftopdf/pptypes.h \
-	filter/pdftopdf/nup.cc \
-	filter/pdftopdf/nup.h \
-	filter/pdftopdf/intervalset.cc \
-	filter/pdftopdf/intervalset.h \
-	filter/pdftopdf/qpdf_tools.cc \
-	filter/pdftopdf/qpdf_tools.h \
-	filter/pdftopdf/qpdf_xobject.cc \
-	filter/pdftopdf/qpdf_xobject.h \
-	filter/pdftopdf/qpdf_pdftopdf.cc \
-	filter/pdftopdf/qpdf_pdftopdf.h \
-	filter/pdftopdf/qpdf_cm.cc \
-	filter/pdftopdf/qpdf_cm.h
-
-pdftopdf_CFLAGS = \
-	$(LIBQPDF_CFLAGS) \
-	$(CUPS_CFLAGS)
-
-pdftopdf_CXXFLAGS = -std=c++0x $(pdftopdf_CFLAGS)   # -std=c++11
-pdftopdf_LDADD = \
-	$(LIBQPDF_LIBS) \
-	$(CUPS_LIBS)
 
 
 # ======================
 # Simple filter binaries
 # ======================
 genfilterscripts = \
-	filter/imagetops \
-	filter/texttops  \
 	filter/rastertopclm
 
 pkgfilter_SCRIPTS = $(genfilterscripts) $(am__append_10)
 gsfilterscripts = \
-	filter/gstopxl \
-	filter/gstopdf
+	filter/gstopxl
 
 @ENABLE_BRAILLE_TRUE@nodist_pkgfilter_SCRIPTS = \
 @ENABLE_BRAILLE_TRUE@	filter/braille/drivers/generic/brftoembosser \
@@ -1684,46 +1379,11 @@ gsfilterscripts = \
 @ENABLE_BRAILLE_TRUE@	filter/braille/drivers/index/imageubrltoindexv4 \
 @ENABLE_BRAILLE_TRUE@	filter/braille/drivers/index/textbrftoindexv3 \
 @ENABLE_BRAILLE_TRUE@	filter/braille/filters/imagetobrf \
-@ENABLE_BRAILLE_TRUE@	filter/braille/filters/vectortopdf \
 @ENABLE_BRAILLE_TRUE@	filter/braille/filters/vectortobrf \
 @ENABLE_BRAILLE_TRUE@	filter/braille/filters/texttobrf \
 @ENABLE_BRAILLE_TRUE@	filter/braille/filters/brftopagedbrf \
 @ENABLE_BRAILLE_TRUE@	filter/braille/filters/musicxmltobrf
 
-bannertopdf_SOURCES = \
-	filter/banner.c \
-	filter/banner.h \
-	filter/bannertopdf.c \
-	filter/pdf.cxx \
-	filter/pdf.h \
-	fontembed/embed.h \
-	fontembed/sfnt.h
-
-EXTRA_bannertopdf_SOURCES = filter/getline.c
-bannertopdf_CFLAGS = \
-	$(CUPS_CFLAGS) \
-	$(LIBJPEG_CFLAGS) \
-	$(LIBPNG_CFLAGS) \
-	$(LIBQPDF_CFLAGS) \
-	$(TIFF_CFLAGS) \
-	$(FONTCONFIG_CFLAGS) \
-	-I$(srcdir)/fontembed/
-
-bannertopdf_CXXFLAGS = $(bannertopdf_CFLAGS)
-bannertopdf_LDADD = \
-	$(GETLINE) \
-	$(CUPS_LIBS) \
-	$(LIBJPEG_LIBS) \
-	$(LIBPNG_LIBS) \
-	$(LIBQPDF_LIBS) \
-	$(TIFF_LIBS) \
-	$(FONTCONFIG_LIBS) \
-	libfontembed.la
-
-bannertopdf_DEPENDENCIES = \
-	$(GETLINE) \
-	libfontembed.la
-
 commandtoescpx_SOURCES = \
 	cupsfilters/driver.h \
 	filter/commandtoescpx.c \
@@ -1749,8 +1409,6 @@ foomatic_rip_SOURCES = \
 	filter/foomatic-rip/foomaticrip.h \
 	filter/foomatic-rip/options.c \
 	filter/foomatic-rip/options.h \
-	filter/foomatic-rip/pdf.c \
-	filter/foomatic-rip/pdf.h \
 	filter/foomatic-rip/postscript.c \
 	filter/foomatic-rip/postscript.h \
 	filter/foomatic-rip/process.c \
@@ -1773,44 +1431,6 @@ foomatic_rip_LDADD = \
 	-lm \
 	libcupsfilters.la
 
-gstoraster_SOURCES = \
-	filter/gstoraster.c \
-	cupsfilters/colord.h \
-	cupsfilters/raster.h \
-	filter/pdf.cxx \
-	filter/pdf.h
-
-gstoraster_CFLAGS = \
-	$(CUPS_CFLAGS) \
-	$(LIBQPDF_CFLAGS) \
-	-I$(srcdir)/cupsfilters/
-
-gstoraster_LDADD = \
-	$(CUPS_LIBS) \
-	$(LIBQPDF_LIBS) \
-	libcupsfilters.la
-
-imagetopdf_SOURCES = \
-	cupsfilters/image.h \
-	filter/common.c \
-	filter/common.h \
-	filter/imagetopdf.c
-
-imagetopdf_CFLAGS = \
-	$(CUPS_CFLAGS) \
-	$(LIBJPEG_CFLAGS) \
-	$(LIBPNG_CFLAGS) \
-	$(TIFF_CFLAGS) \
-	-I$(srcdir)/cupsfilters/
-
-imagetopdf_LDADD = \
-	$(CUPS_LIBS) \
-	$(LIBJPEG_LIBS) \
-	$(LIBPNG_LIBS) \
-	$(TIFF_LIBS) \
-	-lm \
-	libcupsfilters.la
-
 imagetoraster_SOURCES = \
 	cupsfilters/image.h \
 	cupsfilters/image-private.h \
@@ -1827,54 +1447,6 @@ imagetoraster_LDADD = \
 	-lm \
 	libcupsfilters.la
 
-urftopdf_SOURCES = \
-	filter/urftopdf.cpp \
-	filter/unirast.h
-
-urftopdf_CXXFLAGS = \
-	$(LIBQPDF_CFLAGS)
-
-urftopdf_LDADD = \
-	$(LIBQPDF_LIBS)
-
-rastertopdf_SOURCES = \
-	filter/rastertopdf.cpp
-
-rastertopdf_CXXFLAGS = \
-	$(CUPS_CFLAGS) \
-	$(LCMS_CFLAGS) \
-	$(LIBQPDF_CFLAGS) \
-	-I$(srcdir)/cupsfilters/
-
-rastertopdf_LDADD = \
-	$(CUPS_LIBS) \
-	$(LCMS_LIBS) \
-	$(LIBQPDF_LIBS) \
-	libcupsfilters.la
-
-mupdftoraster_SOURCES = \
-        filter/mupdftoraster.c
-
-mupdftoraster_CFLAGS = \
-        $(CUPS_CFLAGS) \
-        -I$(srcdir)/cupsfilters/
-
-mupdftoraster_LDADD = \
-        $(CUPS_LIBS) \
-        libcupsfilters.la
-
-rastertops_SOURCES = \
-	filter/rastertops.c
-
-rastertops_CFLAGS = \
-	$(CUPS_CFLAGS) \
-	-I$(srcdir)/cupsfilters/
-
-rastertops_LDADD = \
-	$(CUPS_LIBS) \
-	-lz \
-	libcupsfilters.la
-
 sys5ippprinter_SOURCES = \
 	filter/common.c \
 	filter/common.h \
@@ -1891,45 +1463,6 @@ EXTRA_texttotext_SOURCES = filter/strcasestr.c
 texttotext_CFLAGS = $(CUPS_CFLAGS)
 texttotext_LDADD = $(STRCASESTR) $(CUPS_LIBS) $(LIBICONV)
 texttotext_DEPENDENCIES = $(STRCASESTR)
-pdftops_SOURCES = \
-	filter/common.c \
-	filter/common.h \
-	filter/pdftops.c \
-	filter/pdf.cxx \
-	filter/pdf.h
-
-EXTRA_pdftops_SOURCES = filter/strcasestr.c
-pdftops_CFLAGS = \
-	$(CUPS_CFLAGS) \
-	$(LIBQPDF_CFLAGS)
-
-pdftops_LDADD = \
-	$(STRCASESTR) \
-	$(CUPS_LIBS) \
-	$(LIBQPDF_LIBS)
-
-pdftops_DEPENDENCIES = $(STRCASESTR)
-pdftoraster_SOURCES = \
-	filter/pdftoraster.cxx
-
-pdftoraster_CFLAGS = \
-	$(CUPS_CFLAGS) \
-	$(LCMS_CFLAGS) \
-	$(LIBJPEG_CFLAGS) \
-	$(LIBPNG_CFLAGS) \
-	$(POPPLER_CFLAGS) \
-	$(TIFF_CFLAGS) \
-	-I$(srcdir)/cupsfilters/
-
-pdftoraster_CXXFLAGS = $(pdftoraster_CFLAGS)
-pdftoraster_LDADD = \
-	$(CUPS_LIBS) \
-	$(LCMS_LIBS) \
-	$(LIBJPEG_LIBS) \
-	$(LIBPNG_LIBS) \
-	$(POPPLER_LIBS) \
-	$(TIFF_LIBS) \
-	libcupsfilters.la
 
 rastertoescpx_SOURCES = \
 	cupsfilters/driver.h \
@@ -1961,48 +1494,6 @@ rastertopclx_LDADD = \
 	$(LIBPNG_LIBS) \
 	libcupsfilters.la
 
-test_pdf1_SOURCES = \
-	filter/pdfutils.c \
-	filter/pdfutils.h \
-	filter/test_pdf1.c \
-	fontembed/embed.h \
-	fontembed/sfnt.h
-
-test_pdf1_CFLAGS = -I$(srcdir)/fontembed/
-test_pdf1_LDADD = libfontembed.la
-test_pdf2_SOURCES = \
-	filter/pdfutils.c \
-	filter/pdfutils.h \
-	filter/test_pdf2.c \
-	fontembed/embed.h \
-	fontembed/sfnt.h
-
-test_pdf2_CFLAGS = -I$(srcdir)/fontembed/
-test_pdf2_LDADD = libfontembed.la
-texttopdf_SOURCES = \
-	filter/common.c \
-	filter/common.h \
-	filter/pdfutils.c \
-	filter/pdfutils.h \
-	filter/textcommon.c \
-	filter/textcommon.h \
-	filter/texttopdf.c \
-	fontembed/bitset.h \
-	fontembed/embed.h \
-	fontembed/fontfile.h \
-	fontembed/iofn.h \
-	fontembed/sfnt.h
-
-texttopdf_CFLAGS = \
-	$(CUPS_CFLAGS) \
-	$(FONTCONFIG_CFLAGS) \
-	-I$(srcdir)/fontembed/
-
-texttopdf_LDADD = \
-	$(CUPS_LIBS) \
-	$(FONTCONFIG_LIBS) \
-	libfontembed.la
-
 
 # =====
 # UTILS
@@ -2052,22 +1543,6 @@ foomaticmanpages = \
 BUILT_SOURCES = $(cups_notifier_sources)
 CLEANFILES = $(BUILT_SOURCES) $(GENERATED_DEFS)
 
-# ===
-# PPD
-# ===
-ppddir = $(datadir)/ppd/cupsfilters
-genppdfiles = \
-	ppd/Fuji_Xerox-DocuPrint_CM305_df-PDF.ppd \
-	ppd/Generic-PDF_Printer-PDF.ppd \
-	ppd/HP-Color_LaserJet_CM3530_MFP-PDF.ppd \
-	ppd/Ricoh-PDF_Printer-PDF.ppd
-
-ppd_DATA = $(genppdfiles) $(am__append_19)
-gsppdfiles = \
-	ppd/pxlcolor.ppd \
-	ppd/pxlmono.ppd
-
-
 # =========
 # Scripting
 # =========
@@ -2136,8 +1611,6 @@ distclean-hdr:
 	-rm -f config.h stamp-h1
 libcupsfilters.pc: $(top_builddir)/config.status $(srcdir)/libcupsfilters.pc.in
 	cd $(top_builddir) && $(SHELL) ./config.status $@
-libfontembed.pc: $(top_builddir)/config.status $(srcdir)/libfontembed.pc.in
-	cd $(top_builddir) && $(SHELL) ./config.status $@
 utils/cups-browsed: $(top_builddir)/config.status $(top_srcdir)/utils/cups-browsed.in
 	cd $(top_builddir) && $(SHELL) ./config.status $@
 utils/cups-browsed.conf: $(top_builddir)/config.status $(top_srcdir)/utils/cups-browsed.conf.in
@@ -2166,8 +1639,6 @@ filter/braille/filters/texttobrf: $(top_builddir)/config.status $(top_srcdir)/fi
 	cd $(top_builddir) && $(SHELL) ./config.status $@
 filter/braille/filters/brftopagedbrf: $(top_builddir)/config.status $(top_srcdir)/filter/braille/filters/brftopagedbrf.in
 	cd $(top_builddir) && $(SHELL) ./config.status $@
-filter/braille/filters/vectortopdf: $(top_builddir)/config.status $(top_srcdir)/filter/braille/filters/vectortopdf.in
-	cd $(top_builddir) && $(SHELL) ./config.status $@
 filter/braille/filters/vectortobrf: $(top_builddir)/config.status $(top_srcdir)/filter/braille/filters/vectortobrf.in
 	cd $(top_builddir) && $(SHELL) ./config.status $@
 filter/braille/filters/musicxmltobrf: $(top_builddir)/config.status $(top_srcdir)/filter/braille/filters/musicxmltobrf.in
@@ -2521,9 +1992,6 @@ cupsfilters/libcupsfilters_la-dither.lo: cupsfilters/$(am__dirstamp) \
 	cupsfilters/$(DEPDIR)/$(am__dirstamp)
 cupsfilters/libcupsfilters_la-image.lo: cupsfilters/$(am__dirstamp) \
 	cupsfilters/$(DEPDIR)/$(am__dirstamp)
-cupsfilters/libcupsfilters_la-pdftoippprinter.lo:  \
-	cupsfilters/$(am__dirstamp) \
-	cupsfilters/$(DEPDIR)/$(am__dirstamp)
 cupsfilters/libcupsfilters_la-image-bmp.lo:  \
 	cupsfilters/$(am__dirstamp) \
 	cupsfilters/$(DEPDIR)/$(am__dirstamp)
@@ -2581,33 +2049,7 @@ cupsfilters/libcupsfilters_la-srgb.lo: cupsfilters/$(am__dirstamp) \
 
 libcupsfilters.la: $(libcupsfilters_la_OBJECTS) $(libcupsfilters_la_DEPENDENCIES) $(EXTRA_libcupsfilters_la_DEPENDENCIES) 
 	$(AM_V_CCLD)$(libcupsfilters_la_LINK) -rpath $(libdir) $(libcupsfilters_la_OBJECTS) $(libcupsfilters_la_LIBADD) $(LIBS)
-fontembed/$(am__dirstamp):
-	@$(MKDIR_P) fontembed
-	@: > fontembed/$(am__dirstamp)
-fontembed/$(DEPDIR)/$(am__dirstamp):
-	@$(MKDIR_P) fontembed/$(DEPDIR)
-	@: > fontembed/$(DEPDIR)/$(am__dirstamp)
-fontembed/aglfn13.lo: fontembed/$(am__dirstamp) \
-	fontembed/$(DEPDIR)/$(am__dirstamp)
-fontembed/dynstring.lo: fontembed/$(am__dirstamp) \
-	fontembed/$(DEPDIR)/$(am__dirstamp)
-fontembed/embed.lo: fontembed/$(am__dirstamp) \
-	fontembed/$(DEPDIR)/$(am__dirstamp)
-fontembed/embed_sfnt.lo: fontembed/$(am__dirstamp) \
-	fontembed/$(DEPDIR)/$(am__dirstamp)
-fontembed/embed_pdf.lo: fontembed/$(am__dirstamp) \
-	fontembed/$(DEPDIR)/$(am__dirstamp)
-fontembed/fontfile.lo: fontembed/$(am__dirstamp) \
-	fontembed/$(DEPDIR)/$(am__dirstamp)
-fontembed/frequent.lo: fontembed/$(am__dirstamp) \
-	fontembed/$(DEPDIR)/$(am__dirstamp)
-fontembed/sfnt.lo: fontembed/$(am__dirstamp) \
-	fontembed/$(DEPDIR)/$(am__dirstamp)
-fontembed/sfnt_subset.lo: fontembed/$(am__dirstamp) \
-	fontembed/$(DEPDIR)/$(am__dirstamp)
-
-libfontembed.la: $(libfontembed_la_OBJECTS) $(libfontembed_la_DEPENDENCIES) $(EXTRA_libfontembed_la_DEPENDENCIES) 
-	$(AM_V_CCLD)$(libfontembed_la_LINK) -rpath $(libdir) $(libfontembed_la_OBJECTS) $(libfontembed_la_LIBADD) $(LIBS)
+
 scripting/php/$(am__dirstamp):
 	@$(MKDIR_P) scripting/php
 	@: > scripting/php/$(am__dirstamp)
@@ -2625,18 +2067,7 @@ filter/$(am__dirstamp):
 filter/$(DEPDIR)/$(am__dirstamp):
 	@$(MKDIR_P) filter/$(DEPDIR)
 	@: > filter/$(DEPDIR)/$(am__dirstamp)
-filter/bannertopdf-banner.$(OBJEXT): filter/$(am__dirstamp) \
-	filter/$(DEPDIR)/$(am__dirstamp)
-filter/bannertopdf-bannertopdf.$(OBJEXT): filter/$(am__dirstamp) \
-	filter/$(DEPDIR)/$(am__dirstamp)
-filter/bannertopdf-pdf.$(OBJEXT): filter/$(am__dirstamp) \
-	filter/$(DEPDIR)/$(am__dirstamp)
-filter/bannertopdf-getline.$(OBJEXT): filter/$(am__dirstamp) \
-	filter/$(DEPDIR)/$(am__dirstamp)
 
-bannertopdf$(EXEEXT): $(bannertopdf_OBJECTS) $(bannertopdf_DEPENDENCIES) $(EXTRA_bannertopdf_DEPENDENCIES) 
-	@rm -f bannertopdf$(EXEEXT)
-	$(AM_V_CXXLD)$(bannertopdf_LINK) $(bannertopdf_OBJECTS) $(bannertopdf_LDADD) $(LIBS)
 backend/$(am__dirstamp):
 	@$(MKDIR_P) backend
 	@: > backend/$(am__dirstamp)
@@ -2697,9 +2128,6 @@ filter/foomatic-rip/foomatic_rip-foomaticrip.$(OBJEXT):  \
 filter/foomatic-rip/foomatic_rip-options.$(OBJEXT):  \
 	filter/foomatic-rip/$(am__dirstamp) \
 	filter/foomatic-rip/$(DEPDIR)/$(am__dirstamp)
-filter/foomatic-rip/foomatic_rip-pdf.$(OBJEXT):  \
-	filter/foomatic-rip/$(am__dirstamp) \
-	filter/foomatic-rip/$(DEPDIR)/$(am__dirstamp)
 filter/foomatic-rip/foomatic_rip-postscript.$(OBJEXT):  \
 	filter/foomatic-rip/$(am__dirstamp) \
 	filter/foomatic-rip/$(DEPDIR)/$(am__dirstamp)
@@ -2721,20 +2149,11 @@ foomatic-rip$(EXEEXT): $(foomatic_rip_OBJECTS) $(foomatic_rip_DEPENDENCIES) $(EX
 	$(AM_V_CCLD)$(foomatic_rip_LINK) $(foomatic_rip_OBJECTS) $(foomatic_rip_LDADD) $(LIBS)
 filter/gstoraster-gstoraster.$(OBJEXT): filter/$(am__dirstamp) \
 	filter/$(DEPDIR)/$(am__dirstamp)
-filter/pdf.$(OBJEXT): filter/$(am__dirstamp) \
-	filter/$(DEPDIR)/$(am__dirstamp)
 
 gstoraster$(EXEEXT): $(gstoraster_OBJECTS) $(gstoraster_DEPENDENCIES) $(EXTRA_gstoraster_DEPENDENCIES) 
 	@rm -f gstoraster$(EXEEXT)
 	$(AM_V_CXXLD)$(CXXLINK) $(gstoraster_OBJECTS) $(gstoraster_LDADD) $(LIBS)
-filter/imagetopdf-common.$(OBJEXT): filter/$(am__dirstamp) \
-	filter/$(DEPDIR)/$(am__dirstamp)
-filter/imagetopdf-imagetopdf.$(OBJEXT): filter/$(am__dirstamp) \
-	filter/$(DEPDIR)/$(am__dirstamp)
-
-imagetopdf$(EXEEXT): $(imagetopdf_OBJECTS) $(imagetopdf_DEPENDENCIES) $(EXTRA_imagetopdf_DEPENDENCIES) 
-	@rm -f imagetopdf$(EXEEXT)
-	$(AM_V_CCLD)$(imagetopdf_LINK) $(imagetopdf_OBJECTS) $(imagetopdf_LDADD) $(LIBS)
+	
 filter/imagetoraster-common.$(OBJEXT): filter/$(am__dirstamp) \
 	filter/$(DEPDIR)/$(am__dirstamp)
 filter/imagetoraster-imagetoraster.$(OBJEXT): filter/$(am__dirstamp) \
@@ -2749,12 +2168,7 @@ backend/implicitclass-implicitclass.$(OBJEXT):  \
 implicitclass$(EXEEXT): $(implicitclass_OBJECTS) $(implicitclass_DEPENDENCIES) $(EXTRA_implicitclass_DEPENDENCIES) 
 	@rm -f implicitclass$(EXEEXT)
 	$(AM_V_CCLD)$(implicitclass_LINK) $(implicitclass_OBJECTS) $(implicitclass_LDADD) $(LIBS)
-filter/mupdftoraster-mupdftoraster.$(OBJEXT): filter/$(am__dirstamp) \
-	filter/$(DEPDIR)/$(am__dirstamp)
 
-mupdftoraster$(EXEEXT): $(mupdftoraster_OBJECTS) $(mupdftoraster_DEPENDENCIES) $(EXTRA_mupdftoraster_DEPENDENCIES) 
-	@rm -f mupdftoraster$(EXEEXT)
-	$(AM_V_CCLD)$(mupdftoraster_LINK) $(mupdftoraster_OBJECTS) $(mupdftoraster_LDADD) $(LIBS)
 backend/parallel-ieee1284.$(OBJEXT): backend/$(am__dirstamp) \
 	backend/$(DEPDIR)/$(am__dirstamp)
 backend/parallel-parallel.$(OBJEXT): backend/$(am__dirstamp) \
@@ -2763,65 +2177,6 @@ backend/parallel-parallel.$(OBJEXT): backend/$(am__dirstamp) \
 parallel$(EXEEXT): $(parallel_OBJECTS) $(parallel_DEPENDENCIES) $(EXTRA_parallel_DEPENDENCIES) 
 	@rm -f parallel$(EXEEXT)
 	$(AM_V_CCLD)$(parallel_LINK) $(parallel_OBJECTS) $(parallel_LDADD) $(LIBS)
-filter/pdftopdf/$(am__dirstamp):
-	@$(MKDIR_P) filter/pdftopdf
-	@: > filter/pdftopdf/$(am__dirstamp)
-filter/pdftopdf/$(DEPDIR)/$(am__dirstamp):
-	@$(MKDIR_P) filter/pdftopdf/$(DEPDIR)
-	@: > filter/pdftopdf/$(DEPDIR)/$(am__dirstamp)
-filter/pdftopdf/pdftopdf-pdftopdf.$(OBJEXT):  \
-	filter/pdftopdf/$(am__dirstamp) \
-	filter/pdftopdf/$(DEPDIR)/$(am__dirstamp)
-filter/pdftopdf/pdftopdf-pdftopdf_jcl.$(OBJEXT):  \
-	filter/pdftopdf/$(am__dirstamp) \
-	filter/pdftopdf/$(DEPDIR)/$(am__dirstamp)
-filter/pdftopdf/pdftopdf-pdftopdf_processor.$(OBJEXT):  \
-	filter/pdftopdf/$(am__dirstamp) \
-	filter/pdftopdf/$(DEPDIR)/$(am__dirstamp)
-filter/pdftopdf/pdftopdf-qpdf_pdftopdf_processor.$(OBJEXT):  \
-	filter/pdftopdf/$(am__dirstamp) \
-	filter/pdftopdf/$(DEPDIR)/$(am__dirstamp)
-filter/pdftopdf/pdftopdf-pptypes.$(OBJEXT):  \
-	filter/pdftopdf/$(am__dirstamp) \
-	filter/pdftopdf/$(DEPDIR)/$(am__dirstamp)
-filter/pdftopdf/pdftopdf-nup.$(OBJEXT):  \
-	filter/pdftopdf/$(am__dirstamp) \
-	filter/pdftopdf/$(DEPDIR)/$(am__dirstamp)
-filter/pdftopdf/pdftopdf-intervalset.$(OBJEXT):  \
-	filter/pdftopdf/$(am__dirstamp) \
-	filter/pdftopdf/$(DEPDIR)/$(am__dirstamp)
-filter/pdftopdf/pdftopdf-qpdf_tools.$(OBJEXT):  \
-	filter/pdftopdf/$(am__dirstamp) \
-	filter/pdftopdf/$(DEPDIR)/$(am__dirstamp)
-filter/pdftopdf/pdftopdf-qpdf_xobject.$(OBJEXT):  \
-	filter/pdftopdf/$(am__dirstamp) \
-	filter/pdftopdf/$(DEPDIR)/$(am__dirstamp)
-filter/pdftopdf/pdftopdf-qpdf_pdftopdf.$(OBJEXT):  \
-	filter/pdftopdf/$(am__dirstamp) \
-	filter/pdftopdf/$(DEPDIR)/$(am__dirstamp)
-filter/pdftopdf/pdftopdf-qpdf_cm.$(OBJEXT):  \
-	filter/pdftopdf/$(am__dirstamp) \
-	filter/pdftopdf/$(DEPDIR)/$(am__dirstamp)
-
-pdftopdf$(EXEEXT): $(pdftopdf_OBJECTS) $(pdftopdf_DEPENDENCIES) $(EXTRA_pdftopdf_DEPENDENCIES) 
-	@rm -f pdftopdf$(EXEEXT)
-	$(AM_V_CXXLD)$(pdftopdf_LINK) $(pdftopdf_OBJECTS) $(pdftopdf_LDADD) $(LIBS)
-filter/pdftops-common.$(OBJEXT): filter/$(am__dirstamp) \
-	filter/$(DEPDIR)/$(am__dirstamp)
-filter/pdftops-pdftops.$(OBJEXT): filter/$(am__dirstamp) \
-	filter/$(DEPDIR)/$(am__dirstamp)
-filter/pdftops-strcasestr.$(OBJEXT): filter/$(am__dirstamp) \
-	filter/$(DEPDIR)/$(am__dirstamp)
-
-pdftops$(EXEEXT): $(pdftops_OBJECTS) $(pdftops_DEPENDENCIES) $(EXTRA_pdftops_DEPENDENCIES) 
-	@rm -f pdftops$(EXEEXT)
-	$(AM_V_CXXLD)$(CXXLINK) $(pdftops_OBJECTS) $(pdftops_LDADD) $(LIBS)
-filter/pdftoraster-pdftoraster.$(OBJEXT): filter/$(am__dirstamp) \
-	filter/$(DEPDIR)/$(am__dirstamp)
-
-pdftoraster$(EXEEXT): $(pdftoraster_OBJECTS) $(pdftoraster_DEPENDENCIES) $(EXTRA_pdftoraster_DEPENDENCIES) 
-	@rm -f pdftoraster$(EXEEXT)
-	$(AM_V_CXXLD)$(pdftoraster_LINK) $(pdftoraster_OBJECTS) $(pdftoraster_LDADD) $(LIBS)
 filter/rastertoescpx-rastertoescpx.$(OBJEXT): filter/$(am__dirstamp) \
 	filter/$(DEPDIR)/$(am__dirstamp)
 
@@ -2836,18 +2191,7 @@ filter/rastertopclx-rastertopclx.$(OBJEXT): filter/$(am__dirstamp) \
 rastertopclx$(EXEEXT): $(rastertopclx_OBJECTS) $(rastertopclx_DEPENDENCIES) $(EXTRA_rastertopclx_DEPENDENCIES) 
 	@rm -f rastertopclx$(EXEEXT)
 	$(AM_V_CCLD)$(rastertopclx_LINK) $(rastertopclx_OBJECTS) $(rastertopclx_LDADD) $(LIBS)
-filter/rastertopdf-rastertopdf.$(OBJEXT): filter/$(am__dirstamp) \
-	filter/$(DEPDIR)/$(am__dirstamp)
 
-rastertopdf$(EXEEXT): $(rastertopdf_OBJECTS) $(rastertopdf_DEPENDENCIES) $(EXTRA_rastertopdf_DEPENDENCIES) 
-	@rm -f rastertopdf$(EXEEXT)
-	$(AM_V_CXXLD)$(rastertopdf_LINK) $(rastertopdf_OBJECTS) $(rastertopdf_LDADD) $(LIBS)
-filter/rastertops-rastertops.$(OBJEXT): filter/$(am__dirstamp) \
-	filter/$(DEPDIR)/$(am__dirstamp)
-
-rastertops$(EXEEXT): $(rastertops_OBJECTS) $(rastertops_DEPENDENCIES) $(EXTRA_rastertops_DEPENDENCIES) 
-	@rm -f rastertops$(EXEEXT)
-	$(AM_V_CCLD)$(rastertops_LINK) $(rastertops_OBJECTS) $(rastertops_LDADD) $(LIBS)
 backend/serial-serial.$(OBJEXT): backend/$(am__dirstamp) \
 	backend/$(DEPDIR)/$(am__dirstamp)
 
@@ -2872,42 +2216,6 @@ backend/test1284-test1284.$(OBJEXT): backend/$(am__dirstamp) \
 test1284$(EXEEXT): $(test1284_OBJECTS) $(test1284_DEPENDENCIES) $(EXTRA_test1284_DEPENDENCIES) 
 	@rm -f test1284$(EXEEXT)
 	$(AM_V_CCLD)$(test1284_LINK) $(test1284_OBJECTS) $(test1284_LDADD) $(LIBS)
-fontembed/test_analyze.$(OBJEXT): fontembed/$(am__dirstamp) \
-	fontembed/$(DEPDIR)/$(am__dirstamp)
-
-test_analyze$(EXEEXT): $(test_analyze_OBJECTS) $(test_analyze_DEPENDENCIES) $(EXTRA_test_analyze_DEPENDENCIES) 
-	@rm -f test_analyze$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(test_analyze_OBJECTS) $(test_analyze_LDADD) $(LIBS)
-fontembed/test_pdf.$(OBJEXT): fontembed/$(am__dirstamp) \
-	fontembed/$(DEPDIR)/$(am__dirstamp)
-
-test_pdf$(EXEEXT): $(test_pdf_OBJECTS) $(test_pdf_DEPENDENCIES) $(EXTRA_test_pdf_DEPENDENCIES) 
-	@rm -f test_pdf$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(test_pdf_OBJECTS) $(test_pdf_LDADD) $(LIBS)
-filter/test_pdf1-pdfutils.$(OBJEXT): filter/$(am__dirstamp) \
-	filter/$(DEPDIR)/$(am__dirstamp)
-filter/test_pdf1-test_pdf1.$(OBJEXT): filter/$(am__dirstamp) \
-	filter/$(DEPDIR)/$(am__dirstamp)
-
-test_pdf1$(EXEEXT): $(test_pdf1_OBJECTS) $(test_pdf1_DEPENDENCIES) $(EXTRA_test_pdf1_DEPENDENCIES) 
-	@rm -f test_pdf1$(EXEEXT)
-	$(AM_V_CCLD)$(test_pdf1_LINK) $(test_pdf1_OBJECTS) $(test_pdf1_LDADD) $(LIBS)
-filter/test_pdf2-pdfutils.$(OBJEXT): filter/$(am__dirstamp) \
-	filter/$(DEPDIR)/$(am__dirstamp)
-filter/test_pdf2-test_pdf2.$(OBJEXT): filter/$(am__dirstamp) \
-	filter/$(DEPDIR)/$(am__dirstamp)
-
-test_pdf2$(EXEEXT): $(test_pdf2_OBJECTS) $(test_pdf2_DEPENDENCIES) $(EXTRA_test_pdf2_DEPENDENCIES) 
-	@rm -f test_pdf2$(EXEEXT)
-	$(AM_V_CCLD)$(test_pdf2_LINK) $(test_pdf2_OBJECTS) $(test_pdf2_LDADD) $(LIBS)
-fontembed/test_ps.$(OBJEXT): fontembed/$(am__dirstamp) \
-	fontembed/$(DEPDIR)/$(am__dirstamp)
-
-test_ps$(EXEEXT): $(test_ps_OBJECTS) $(test_ps_DEPENDENCIES) $(EXTRA_test_ps_DEPENDENCIES) 
-	@rm -f test_ps$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(test_ps_OBJECTS) $(test_ps_LDADD) $(LIBS)
-cupsfilters/testcmyk.$(OBJEXT): cupsfilters/$(am__dirstamp) \
-	cupsfilters/$(DEPDIR)/$(am__dirstamp)
 
 testcmyk$(EXEEXT): $(testcmyk_OBJECTS) $(testcmyk_DEPENDENCIES) $(EXTRA_testcmyk_DEPENDENCIES) 
 	@rm -f testcmyk$(EXEEXT)
@@ -2931,18 +2239,7 @@ cupsfilters/testrgb.$(OBJEXT): cupsfilters/$(am__dirstamp) \
 testrgb$(EXEEXT): $(testrgb_OBJECTS) $(testrgb_DEPENDENCIES) $(EXTRA_testrgb_DEPENDENCIES) 
 	@rm -f testrgb$(EXEEXT)
 	$(AM_V_CCLD)$(LINK) $(testrgb_OBJECTS) $(testrgb_LDADD) $(LIBS)
-filter/texttopdf-common.$(OBJEXT): filter/$(am__dirstamp) \
-	filter/$(DEPDIR)/$(am__dirstamp)
-filter/texttopdf-pdfutils.$(OBJEXT): filter/$(am__dirstamp) \
-	filter/$(DEPDIR)/$(am__dirstamp)
-filter/texttopdf-textcommon.$(OBJEXT): filter/$(am__dirstamp) \
-	filter/$(DEPDIR)/$(am__dirstamp)
-filter/texttopdf-texttopdf.$(OBJEXT): filter/$(am__dirstamp) \
-	filter/$(DEPDIR)/$(am__dirstamp)
 
-texttopdf$(EXEEXT): $(texttopdf_OBJECTS) $(texttopdf_DEPENDENCIES) $(EXTRA_texttopdf_DEPENDENCIES) 
-	@rm -f texttopdf$(EXEEXT)
-	$(AM_V_CCLD)$(texttopdf_LINK) $(texttopdf_OBJECTS) $(texttopdf_LDADD) $(LIBS)
 filter/texttotext-texttotext.$(OBJEXT): filter/$(am__dirstamp) \
 	filter/$(DEPDIR)/$(am__dirstamp)
 filter/texttotext-strcasestr.$(OBJEXT): filter/$(am__dirstamp) \
@@ -2951,18 +2248,7 @@ filter/texttotext-strcasestr.$(OBJEXT): filter/$(am__dirstamp) \
 texttotext$(EXEEXT): $(texttotext_OBJECTS) $(texttotext_DEPENDENCIES) $(EXTRA_texttotext_DEPENDENCIES) 
 	@rm -f texttotext$(EXEEXT)
 	$(AM_V_CCLD)$(texttotext_LINK) $(texttotext_OBJECTS) $(texttotext_LDADD) $(LIBS)
-fontembed/main.$(OBJEXT): fontembed/$(am__dirstamp) \
-	fontembed/$(DEPDIR)/$(am__dirstamp)
-
-ttfread$(EXEEXT): $(ttfread_OBJECTS) $(ttfread_DEPENDENCIES) $(EXTRA_ttfread_DEPENDENCIES) 
-	@rm -f ttfread$(EXEEXT)
-	$(AM_V_CCLD)$(LINK) $(ttfread_OBJECTS) $(ttfread_LDADD) $(LIBS)
-filter/urftopdf-urftopdf.$(OBJEXT): filter/$(am__dirstamp) \
-	filter/$(DEPDIR)/$(am__dirstamp)
-
-urftopdf$(EXEEXT): $(urftopdf_OBJECTS) $(urftopdf_DEPENDENCIES) $(EXTRA_urftopdf_DEPENDENCIES) 
-	@rm -f urftopdf$(EXEEXT)
-	$(AM_V_CXXLD)$(urftopdf_LINK) $(urftopdf_OBJECTS) $(urftopdf_LDADD) $(LIBS)
+	
 install-initrcSCRIPTS: $(initrc_SCRIPTS)
 	@$(NORMAL_INSTALL)
 	@list='$(initrc_SCRIPTS)'; test -n "$(initrcdir)" || list=; \
@@ -3111,9 +2397,6 @@ mostlyclean-compile:
 	-rm -f cupsfilters/*.lo
 	-rm -f filter/*.$(OBJEXT)
 	-rm -f filter/foomatic-rip/*.$(OBJEXT)
-	-rm -f filter/pdftopdf/*.$(OBJEXT)
-	-rm -f fontembed/*.$(OBJEXT)
-	-rm -f fontembed/*.lo
 	-rm -f scripting/php/*.$(OBJEXT)
 	-rm -f scripting/php/*.lo
 	-rm -f utils/*.$(OBJEXT)
@@ -3153,7 +2436,6 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@cupsfilters/$(DEPDIR)/libcupsfilters_la-ipp.Plo@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@cupsfilters/$(DEPDIR)/libcupsfilters_la-lut.Plo@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@cupsfilters/$(DEPDIR)/libcupsfilters_la-pack.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@cupsfilters/$(DEPDIR)/libcupsfilters_la-pdftoippprinter.Plo@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@cupsfilters/$(DEPDIR)/libcupsfilters_la-ppdgenerator.Plo@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@cupsfilters/$(DEPDIR)/libcupsfilters_la-raster.Plo@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@cupsfilters/$(DEPDIR)/libcupsfilters_la-rgb.Plo@am__quote@ # am--include-marker
@@ -3162,74 +2444,26 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@cupsfilters/$(DEPDIR)/testdither.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@cupsfilters/$(DEPDIR)/testimage-testimage.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@cupsfilters/$(DEPDIR)/testrgb.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/bannertopdf-banner.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/bannertopdf-bannertopdf.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/bannertopdf-getline.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/bannertopdf-pdf.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/commandtoescpx-commandtoescpx.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/commandtopclx-commandtopclx.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/gstoraster-gstoraster.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/imagetopdf-common.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/imagetopdf-imagetopdf.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/imagetoraster-common.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/imagetoraster-imagetoraster.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/mupdftoraster-mupdftoraster.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/pdf.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/pdftops-common.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/pdftops-pdftops.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/pdftops-strcasestr.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/pdftoraster-pdftoraster.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/rastertoescpx-rastertoescpx.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/rastertopclx-pcl-common.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/rastertopclx-rastertopclx.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/rastertopdf-rastertopdf.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/rastertops-rastertops.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/sys5ippprinter-common.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/sys5ippprinter-strcasestr.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/sys5ippprinter-sys5ippprinter.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/test_pdf1-pdfutils.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/test_pdf1-test_pdf1.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/test_pdf2-pdfutils.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/test_pdf2-test_pdf2.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/texttopdf-common.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/texttopdf-pdfutils.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/texttopdf-textcommon.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/texttopdf-texttopdf.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/texttotext-strcasestr.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/texttotext-texttotext.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/$(DEPDIR)/urftopdf-urftopdf.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@filter/foomatic-rip/$(DEPDIR)/foomatic_rip-foomaticrip.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@filter/foomatic-rip/$(DEPDIR)/foomatic_rip-options.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/foomatic-rip/$(DEPDIR)/foomatic_rip-pdf.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@filter/foomatic-rip/$(DEPDIR)/foomatic_rip-postscript.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@filter/foomatic-rip/$(DEPDIR)/foomatic_rip-process.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@filter/foomatic-rip/$(DEPDIR)/foomatic_rip-renderer.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@filter/foomatic-rip/$(DEPDIR)/foomatic_rip-spooler.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@filter/foomatic-rip/$(DEPDIR)/foomatic_rip-util.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/pdftopdf/$(DEPDIR)/pdftopdf-intervalset.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/pdftopdf/$(DEPDIR)/pdftopdf-nup.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/pdftopdf/$(DEPDIR)/pdftopdf-pdftopdf.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/pdftopdf/$(DEPDIR)/pdftopdf-pdftopdf_jcl.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/pdftopdf/$(DEPDIR)/pdftopdf-pdftopdf_processor.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/pdftopdf/$(DEPDIR)/pdftopdf-pptypes.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_cm.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_pdftopdf.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_pdftopdf_processor.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_tools.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_xobject.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@fontembed/$(DEPDIR)/aglfn13.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@fontembed/$(DEPDIR)/dynstring.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@fontembed/$(DEPDIR)/embed.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@fontembed/$(DEPDIR)/embed_pdf.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@fontembed/$(DEPDIR)/embed_sfnt.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@fontembed/$(DEPDIR)/fontfile.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@fontembed/$(DEPDIR)/frequent.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@fontembed/$(DEPDIR)/main.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@fontembed/$(DEPDIR)/sfnt.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@fontembed/$(DEPDIR)/sfnt_subset.Plo@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@fontembed/$(DEPDIR)/test_analyze.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@fontembed/$(DEPDIR)/test_pdf.Po@am__quote@ # am--include-marker
-@AMDEP_TRUE@@am__include@ @am__quote@fontembed/$(DEPDIR)/test_ps.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@scripting/php/$(DEPDIR)/libphpcups_la-phpcups.Plo@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@utils/$(DEPDIR)/cups_browsed-cups-browsed.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@utils/$(DEPDIR)/driverless-driverless.Po@am__quote@ # am--include-marker
@@ -3313,13 +2547,6 @@ cupsfilters/libcupsfilters_la-image.lo: cupsfilters/image.c
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libcupsfilters_la_CFLAGS) $(CFLAGS) -c -o cupsfilters/libcupsfilters_la-image.lo `test -f 'cupsfilters/image.c' || echo '$(srcdir)/'`cupsfilters/image.c
 
-cupsfilters/libcupsfilters_la-pdftoippprinter.lo: cupsfilters/pdftoippprinter.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libcupsfilters_la_CFLAGS) $(CFLAGS) -MT cupsfilters/libcupsfilters_la-pdftoippprinter.lo -MD -MP -MF cupsfilters/$(DEPDIR)/libcupsfilters_la-pdftoippprinter.Tpo -c -o cupsfilters/libcupsfilters_la-pdftoippprinter.lo `test -f 'cupsfilters/pdftoippprinter.c' || echo '$(srcdir)/'`cupsfilters/pdftoippprinter.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) cupsfilters/$(DEPDIR)/libcupsfilters_la-pdftoippprinter.Tpo cupsfilters/$(DEPDIR)/libcupsfilters_la-pdftoippprinter.Plo
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='cupsfilters/pdftoippprinter.c' object='cupsfilters/libcupsfilters_la-pdftoippprinter.lo' libtool=yes @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libcupsfilters_la_CFLAGS) $(CFLAGS) -c -o cupsfilters/libcupsfilters_la-pdftoippprinter.lo `test -f 'cupsfilters/pdftoippprinter.c' || echo '$(srcdir)/'`cupsfilters/pdftoippprinter.c
-
 cupsfilters/libcupsfilters_la-image-bmp.lo: cupsfilters/image-bmp.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libcupsfilters_la_CFLAGS) $(CFLAGS) -MT cupsfilters/libcupsfilters_la-image-bmp.lo -MD -MP -MF cupsfilters/$(DEPDIR)/libcupsfilters_la-image-bmp.Tpo -c -o cupsfilters/libcupsfilters_la-image-bmp.lo `test -f 'cupsfilters/image-bmp.c' || echo '$(srcdir)/'`cupsfilters/image-bmp.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) cupsfilters/$(DEPDIR)/libcupsfilters_la-image-bmp.Tpo cupsfilters/$(DEPDIR)/libcupsfilters_la-image-bmp.Plo
@@ -3467,48 +2694,6 @@ scripting/php/libphpcups_la-phpcups.lo: scripting/php/phpcups.c
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libphpcups_la_CFLAGS) $(CFLAGS) -c -o scripting/php/libphpcups_la-phpcups.lo `test -f 'scripting/php/phpcups.c' || echo '$(srcdir)/'`scripting/php/phpcups.c
 
-filter/bannertopdf-banner.o: filter/banner.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(bannertopdf_CFLAGS) $(CFLAGS) -MT filter/bannertopdf-banner.o -MD -MP -MF filter/$(DEPDIR)/bannertopdf-banner.Tpo -c -o filter/bannertopdf-banner.o `test -f 'filter/banner.c' || echo '$(srcdir)/'`filter/banner.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/bannertopdf-banner.Tpo filter/$(DEPDIR)/bannertopdf-banner.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/banner.c' object='filter/bannertopdf-banner.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(bannertopdf_CFLAGS) $(CFLAGS) -c -o filter/bannertopdf-banner.o `test -f 'filter/banner.c' || echo '$(srcdir)/'`filter/banner.c
-
-filter/bannertopdf-banner.obj: filter/banner.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(bannertopdf_CFLAGS) $(CFLAGS) -MT filter/bannertopdf-banner.obj -MD -MP -MF filter/$(DEPDIR)/bannertopdf-banner.Tpo -c -o filter/bannertopdf-banner.obj `if test -f 'filter/banner.c'; then $(CYGPATH_W) 'filter/banner.c'; else $(CYGPATH_W) '$(srcdir)/filter/banner.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/bannertopdf-banner.Tpo filter/$(DEPDIR)/bannertopdf-banner.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/banner.c' object='filter/bannertopdf-banner.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(bannertopdf_CFLAGS) $(CFLAGS) -c -o filter/bannertopdf-banner.obj `if test -f 'filter/banner.c'; then $(CYGPATH_W) 'filter/banner.c'; else $(CYGPATH_W) '$(srcdir)/filter/banner.c'; fi`
-
-filter/bannertopdf-bannertopdf.o: filter/bannertopdf.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(bannertopdf_CFLAGS) $(CFLAGS) -MT filter/bannertopdf-bannertopdf.o -MD -MP -MF filter/$(DEPDIR)/bannertopdf-bannertopdf.Tpo -c -o filter/bannertopdf-bannertopdf.o `test -f 'filter/bannertopdf.c' || echo '$(srcdir)/'`filter/bannertopdf.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/bannertopdf-bannertopdf.Tpo filter/$(DEPDIR)/bannertopdf-bannertopdf.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/bannertopdf.c' object='filter/bannertopdf-bannertopdf.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(bannertopdf_CFLAGS) $(CFLAGS) -c -o filter/bannertopdf-bannertopdf.o `test -f 'filter/bannertopdf.c' || echo '$(srcdir)/'`filter/bannertopdf.c
-
-filter/bannertopdf-bannertopdf.obj: filter/bannertopdf.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(bannertopdf_CFLAGS) $(CFLAGS) -MT filter/bannertopdf-bannertopdf.obj -MD -MP -MF filter/$(DEPDIR)/bannertopdf-bannertopdf.Tpo -c -o filter/bannertopdf-bannertopdf.obj `if test -f 'filter/bannertopdf.c'; then $(CYGPATH_W) 'filter/bannertopdf.c'; else $(CYGPATH_W) '$(srcdir)/filter/bannertopdf.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/bannertopdf-bannertopdf.Tpo filter/$(DEPDIR)/bannertopdf-bannertopdf.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/bannertopdf.c' object='filter/bannertopdf-bannertopdf.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(bannertopdf_CFLAGS) $(CFLAGS) -c -o filter/bannertopdf-bannertopdf.obj `if test -f 'filter/bannertopdf.c'; then $(CYGPATH_W) 'filter/bannertopdf.c'; else $(CYGPATH_W) '$(srcdir)/filter/bannertopdf.c'; fi`
-
-filter/bannertopdf-getline.o: filter/getline.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(bannertopdf_CFLAGS) $(CFLAGS) -MT filter/bannertopdf-getline.o -MD -MP -MF filter/$(DEPDIR)/bannertopdf-getline.Tpo -c -o filter/bannertopdf-getline.o `test -f 'filter/getline.c' || echo '$(srcdir)/'`filter/getline.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/bannertopdf-getline.Tpo filter/$(DEPDIR)/bannertopdf-getline.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/getline.c' object='filter/bannertopdf-getline.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(bannertopdf_CFLAGS) $(CFLAGS) -c -o filter/bannertopdf-getline.o `test -f 'filter/getline.c' || echo '$(srcdir)/'`filter/getline.c
-
-filter/bannertopdf-getline.obj: filter/getline.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(bannertopdf_CFLAGS) $(CFLAGS) -MT filter/bannertopdf-getline.obj -MD -MP -MF filter/$(DEPDIR)/bannertopdf-getline.Tpo -c -o filter/bannertopdf-getline.obj `if test -f 'filter/getline.c'; then $(CYGPATH_W) 'filter/getline.c'; else $(CYGPATH_W) '$(srcdir)/filter/getline.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/bannertopdf-getline.Tpo filter/$(DEPDIR)/bannertopdf-getline.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/getline.c' object='filter/bannertopdf-getline.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(bannertopdf_CFLAGS) $(CFLAGS) -c -o filter/bannertopdf-getline.obj `if test -f 'filter/getline.c'; then $(CYGPATH_W) 'filter/getline.c'; else $(CYGPATH_W) '$(srcdir)/filter/getline.c'; fi`
-
 backend/beh-beh.o: backend/beh.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(beh_CFLAGS) $(CFLAGS) -MT backend/beh-beh.o -MD -MP -MF backend/$(DEPDIR)/beh-beh.Tpo -c -o backend/beh-beh.o `test -f 'backend/beh.c' || echo '$(srcdir)/'`backend/beh.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) backend/$(DEPDIR)/beh-beh.Tpo backend/$(DEPDIR)/beh-beh.Po
@@ -3621,20 +2806,6 @@ filter/foomatic-rip/foomatic_rip-options.obj: filter/foomatic-rip/options.c
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(foomatic_rip_CFLAGS) $(CFLAGS) -c -o filter/foomatic-rip/foomatic_rip-options.obj `if test -f 'filter/foomatic-rip/options.c'; then $(CYGPATH_W) 'filter/foomatic-rip/options.c'; else $(CYGPATH_W) '$(srcdir)/filter/foomatic-rip/options.c'; fi`
 
-filter/foomatic-rip/foomatic_rip-pdf.o: filter/foomatic-rip/pdf.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(foomatic_rip_CFLAGS) $(CFLAGS) -MT filter/foomatic-rip/foomatic_rip-pdf.o -MD -MP -MF filter/foomatic-rip/$(DEPDIR)/foomatic_rip-pdf.Tpo -c -o filter/foomatic-rip/foomatic_rip-pdf.o `test -f 'filter/foomatic-rip/pdf.c' || echo '$(srcdir)/'`filter/foomatic-rip/pdf.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/foomatic-rip/$(DEPDIR)/foomatic_rip-pdf.Tpo filter/foomatic-rip/$(DEPDIR)/foomatic_rip-pdf.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/foomatic-rip/pdf.c' object='filter/foomatic-rip/foomatic_rip-pdf.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(foomatic_rip_CFLAGS) $(CFLAGS) -c -o filter/foomatic-rip/foomatic_rip-pdf.o `test -f 'filter/foomatic-rip/pdf.c' || echo '$(srcdir)/'`filter/foomatic-rip/pdf.c
-
-filter/foomatic-rip/foomatic_rip-pdf.obj: filter/foomatic-rip/pdf.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(foomatic_rip_CFLAGS) $(CFLAGS) -MT filter/foomatic-rip/foomatic_rip-pdf.obj -MD -MP -MF filter/foomatic-rip/$(DEPDIR)/foomatic_rip-pdf.Tpo -c -o filter/foomatic-rip/foomatic_rip-pdf.obj `if test -f 'filter/foomatic-rip/pdf.c'; then $(CYGPATH_W) 'filter/foomatic-rip/pdf.c'; else $(CYGPATH_W) '$(srcdir)/filter/foomatic-rip/pdf.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/foomatic-rip/$(DEPDIR)/foomatic_rip-pdf.Tpo filter/foomatic-rip/$(DEPDIR)/foomatic_rip-pdf.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/foomatic-rip/pdf.c' object='filter/foomatic-rip/foomatic_rip-pdf.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(foomatic_rip_CFLAGS) $(CFLAGS) -c -o filter/foomatic-rip/foomatic_rip-pdf.obj `if test -f 'filter/foomatic-rip/pdf.c'; then $(CYGPATH_W) 'filter/foomatic-rip/pdf.c'; else $(CYGPATH_W) '$(srcdir)/filter/foomatic-rip/pdf.c'; fi`
-
 filter/foomatic-rip/foomatic_rip-postscript.o: filter/foomatic-rip/postscript.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(foomatic_rip_CFLAGS) $(CFLAGS) -MT filter/foomatic-rip/foomatic_rip-postscript.o -MD -MP -MF filter/foomatic-rip/$(DEPDIR)/foomatic_rip-postscript.Tpo -c -o filter/foomatic-rip/foomatic_rip-postscript.o `test -f 'filter/foomatic-rip/postscript.c' || echo '$(srcdir)/'`filter/foomatic-rip/postscript.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/foomatic-rip/$(DEPDIR)/foomatic_rip-postscript.Tpo filter/foomatic-rip/$(DEPDIR)/foomatic_rip-postscript.Po
@@ -3719,34 +2890,6 @@ filter/gstoraster-gstoraster.obj: filter/gstoraster.c
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(gstoraster_CFLAGS) $(CFLAGS) -c -o filter/gstoraster-gstoraster.obj `if test -f 'filter/gstoraster.c'; then $(CYGPATH_W) 'filter/gstoraster.c'; else $(CYGPATH_W) '$(srcdir)/filter/gstoraster.c'; fi`
 
-filter/imagetopdf-common.o: filter/common.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(imagetopdf_CFLAGS) $(CFLAGS) -MT filter/imagetopdf-common.o -MD -MP -MF filter/$(DEPDIR)/imagetopdf-common.Tpo -c -o filter/imagetopdf-common.o `test -f 'filter/common.c' || echo '$(srcdir)/'`filter/common.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/imagetopdf-common.Tpo filter/$(DEPDIR)/imagetopdf-common.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/common.c' object='filter/imagetopdf-common.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(imagetopdf_CFLAGS) $(CFLAGS) -c -o filter/imagetopdf-common.o `test -f 'filter/common.c' || echo '$(srcdir)/'`filter/common.c
-
-filter/imagetopdf-common.obj: filter/common.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(imagetopdf_CFLAGS) $(CFLAGS) -MT filter/imagetopdf-common.obj -MD -MP -MF filter/$(DEPDIR)/imagetopdf-common.Tpo -c -o filter/imagetopdf-common.obj `if test -f 'filter/common.c'; then $(CYGPATH_W) 'filter/common.c'; else $(CYGPATH_W) '$(srcdir)/filter/common.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/imagetopdf-common.Tpo filter/$(DEPDIR)/imagetopdf-common.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/common.c' object='filter/imagetopdf-common.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(imagetopdf_CFLAGS) $(CFLAGS) -c -o filter/imagetopdf-common.obj `if test -f 'filter/common.c'; then $(CYGPATH_W) 'filter/common.c'; else $(CYGPATH_W) '$(srcdir)/filter/common.c'; fi`
-
-filter/imagetopdf-imagetopdf.o: filter/imagetopdf.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(imagetopdf_CFLAGS) $(CFLAGS) -MT filter/imagetopdf-imagetopdf.o -MD -MP -MF filter/$(DEPDIR)/imagetopdf-imagetopdf.Tpo -c -o filter/imagetopdf-imagetopdf.o `test -f 'filter/imagetopdf.c' || echo '$(srcdir)/'`filter/imagetopdf.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/imagetopdf-imagetopdf.Tpo filter/$(DEPDIR)/imagetopdf-imagetopdf.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/imagetopdf.c' object='filter/imagetopdf-imagetopdf.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(imagetopdf_CFLAGS) $(CFLAGS) -c -o filter/imagetopdf-imagetopdf.o `test -f 'filter/imagetopdf.c' || echo '$(srcdir)/'`filter/imagetopdf.c
-
-filter/imagetopdf-imagetopdf.obj: filter/imagetopdf.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(imagetopdf_CFLAGS) $(CFLAGS) -MT filter/imagetopdf-imagetopdf.obj -MD -MP -MF filter/$(DEPDIR)/imagetopdf-imagetopdf.Tpo -c -o filter/imagetopdf-imagetopdf.obj `if test -f 'filter/imagetopdf.c'; then $(CYGPATH_W) 'filter/imagetopdf.c'; else $(CYGPATH_W) '$(srcdir)/filter/imagetopdf.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/imagetopdf-imagetopdf.Tpo filter/$(DEPDIR)/imagetopdf-imagetopdf.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/imagetopdf.c' object='filter/imagetopdf-imagetopdf.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(imagetopdf_CFLAGS) $(CFLAGS) -c -o filter/imagetopdf-imagetopdf.obj `if test -f 'filter/imagetopdf.c'; then $(CYGPATH_W) 'filter/imagetopdf.c'; else $(CYGPATH_W) '$(srcdir)/filter/imagetopdf.c'; fi`
-
 filter/imagetoraster-common.o: filter/common.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(imagetoraster_CFLAGS) $(CFLAGS) -MT filter/imagetoraster-common.o -MD -MP -MF filter/$(DEPDIR)/imagetoraster-common.Tpo -c -o filter/imagetoraster-common.o `test -f 'filter/common.c' || echo '$(srcdir)/'`filter/common.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/imagetoraster-common.Tpo filter/$(DEPDIR)/imagetoraster-common.Po
@@ -3789,20 +2932,6 @@ backend/implicitclass-implicitclass.obj: backend/implicitclass.c
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(implicitclass_CFLAGS) $(CFLAGS) -c -o backend/implicitclass-implicitclass.obj `if test -f 'backend/implicitclass.c'; then $(CYGPATH_W) 'backend/implicitclass.c'; else $(CYGPATH_W) '$(srcdir)/backend/implicitclass.c'; fi`
 
-filter/mupdftoraster-mupdftoraster.o: filter/mupdftoraster.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(mupdftoraster_CFLAGS) $(CFLAGS) -MT filter/mupdftoraster-mupdftoraster.o -MD -MP -MF filter/$(DEPDIR)/mupdftoraster-mupdftoraster.Tpo -c -o filter/mupdftoraster-mupdftoraster.o `test -f 'filter/mupdftoraster.c' || echo '$(srcdir)/'`filter/mupdftoraster.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/mupdftoraster-mupdftoraster.Tpo filter/$(DEPDIR)/mupdftoraster-mupdftoraster.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/mupdftoraster.c' object='filter/mupdftoraster-mupdftoraster.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(mupdftoraster_CFLAGS) $(CFLAGS) -c -o filter/mupdftoraster-mupdftoraster.o `test -f 'filter/mupdftoraster.c' || echo '$(srcdir)/'`filter/mupdftoraster.c
-
-filter/mupdftoraster-mupdftoraster.obj: filter/mupdftoraster.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(mupdftoraster_CFLAGS) $(CFLAGS) -MT filter/mupdftoraster-mupdftoraster.obj -MD -MP -MF filter/$(DEPDIR)/mupdftoraster-mupdftoraster.Tpo -c -o filter/mupdftoraster-mupdftoraster.obj `if test -f 'filter/mupdftoraster.c'; then $(CYGPATH_W) 'filter/mupdftoraster.c'; else $(CYGPATH_W) '$(srcdir)/filter/mupdftoraster.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/mupdftoraster-mupdftoraster.Tpo filter/$(DEPDIR)/mupdftoraster-mupdftoraster.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/mupdftoraster.c' object='filter/mupdftoraster-mupdftoraster.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(mupdftoraster_CFLAGS) $(CFLAGS) -c -o filter/mupdftoraster-mupdftoraster.obj `if test -f 'filter/mupdftoraster.c'; then $(CYGPATH_W) 'filter/mupdftoraster.c'; else $(CYGPATH_W) '$(srcdir)/filter/mupdftoraster.c'; fi`
-
 backend/parallel-ieee1284.o: backend/ieee1284.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(parallel_CFLAGS) $(CFLAGS) -MT backend/parallel-ieee1284.o -MD -MP -MF backend/$(DEPDIR)/parallel-ieee1284.Tpo -c -o backend/parallel-ieee1284.o `test -f 'backend/ieee1284.c' || echo '$(srcdir)/'`backend/ieee1284.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) backend/$(DEPDIR)/parallel-ieee1284.Tpo backend/$(DEPDIR)/parallel-ieee1284.Po
@@ -3831,48 +2960,6 @@ backend/parallel-parallel.obj: backend/parallel.c
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(parallel_CFLAGS) $(CFLAGS) -c -o backend/parallel-parallel.obj `if test -f 'backend/parallel.c'; then $(CYGPATH_W) 'backend/parallel.c'; else $(CYGPATH_W) '$(srcdir)/backend/parallel.c'; fi`
 
-filter/pdftops-common.o: filter/common.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftops_CFLAGS) $(CFLAGS) -MT filter/pdftops-common.o -MD -MP -MF filter/$(DEPDIR)/pdftops-common.Tpo -c -o filter/pdftops-common.o `test -f 'filter/common.c' || echo '$(srcdir)/'`filter/common.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/pdftops-common.Tpo filter/$(DEPDIR)/pdftops-common.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/common.c' object='filter/pdftops-common.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftops_CFLAGS) $(CFLAGS) -c -o filter/pdftops-common.o `test -f 'filter/common.c' || echo '$(srcdir)/'`filter/common.c
-
-filter/pdftops-common.obj: filter/common.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftops_CFLAGS) $(CFLAGS) -MT filter/pdftops-common.obj -MD -MP -MF filter/$(DEPDIR)/pdftops-common.Tpo -c -o filter/pdftops-common.obj `if test -f 'filter/common.c'; then $(CYGPATH_W) 'filter/common.c'; else $(CYGPATH_W) '$(srcdir)/filter/common.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/pdftops-common.Tpo filter/$(DEPDIR)/pdftops-common.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/common.c' object='filter/pdftops-common.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftops_CFLAGS) $(CFLAGS) -c -o filter/pdftops-common.obj `if test -f 'filter/common.c'; then $(CYGPATH_W) 'filter/common.c'; else $(CYGPATH_W) '$(srcdir)/filter/common.c'; fi`
-
-filter/pdftops-pdftops.o: filter/pdftops.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftops_CFLAGS) $(CFLAGS) -MT filter/pdftops-pdftops.o -MD -MP -MF filter/$(DEPDIR)/pdftops-pdftops.Tpo -c -o filter/pdftops-pdftops.o `test -f 'filter/pdftops.c' || echo '$(srcdir)/'`filter/pdftops.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/pdftops-pdftops.Tpo filter/$(DEPDIR)/pdftops-pdftops.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/pdftops.c' object='filter/pdftops-pdftops.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftops_CFLAGS) $(CFLAGS) -c -o filter/pdftops-pdftops.o `test -f 'filter/pdftops.c' || echo '$(srcdir)/'`filter/pdftops.c
-
-filter/pdftops-pdftops.obj: filter/pdftops.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftops_CFLAGS) $(CFLAGS) -MT filter/pdftops-pdftops.obj -MD -MP -MF filter/$(DEPDIR)/pdftops-pdftops.Tpo -c -o filter/pdftops-pdftops.obj `if test -f 'filter/pdftops.c'; then $(CYGPATH_W) 'filter/pdftops.c'; else $(CYGPATH_W) '$(srcdir)/filter/pdftops.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/pdftops-pdftops.Tpo filter/$(DEPDIR)/pdftops-pdftops.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/pdftops.c' object='filter/pdftops-pdftops.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftops_CFLAGS) $(CFLAGS) -c -o filter/pdftops-pdftops.obj `if test -f 'filter/pdftops.c'; then $(CYGPATH_W) 'filter/pdftops.c'; else $(CYGPATH_W) '$(srcdir)/filter/pdftops.c'; fi`
-
-filter/pdftops-strcasestr.o: filter/strcasestr.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftops_CFLAGS) $(CFLAGS) -MT filter/pdftops-strcasestr.o -MD -MP -MF filter/$(DEPDIR)/pdftops-strcasestr.Tpo -c -o filter/pdftops-strcasestr.o `test -f 'filter/strcasestr.c' || echo '$(srcdir)/'`filter/strcasestr.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/pdftops-strcasestr.Tpo filter/$(DEPDIR)/pdftops-strcasestr.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/strcasestr.c' object='filter/pdftops-strcasestr.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftops_CFLAGS) $(CFLAGS) -c -o filter/pdftops-strcasestr.o `test -f 'filter/strcasestr.c' || echo '$(srcdir)/'`filter/strcasestr.c
-
-filter/pdftops-strcasestr.obj: filter/strcasestr.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftops_CFLAGS) $(CFLAGS) -MT filter/pdftops-strcasestr.obj -MD -MP -MF filter/$(DEPDIR)/pdftops-strcasestr.Tpo -c -o filter/pdftops-strcasestr.obj `if test -f 'filter/strcasestr.c'; then $(CYGPATH_W) 'filter/strcasestr.c'; else $(CYGPATH_W) '$(srcdir)/filter/strcasestr.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/pdftops-strcasestr.Tpo filter/$(DEPDIR)/pdftops-strcasestr.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/strcasestr.c' object='filter/pdftops-strcasestr.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftops_CFLAGS) $(CFLAGS) -c -o filter/pdftops-strcasestr.obj `if test -f 'filter/strcasestr.c'; then $(CYGPATH_W) 'filter/strcasestr.c'; else $(CYGPATH_W) '$(srcdir)/filter/strcasestr.c'; fi`
-
 filter/rastertoescpx-rastertoescpx.o: filter/rastertoescpx.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(rastertoescpx_CFLAGS) $(CFLAGS) -MT filter/rastertoescpx-rastertoescpx.o -MD -MP -MF filter/$(DEPDIR)/rastertoescpx-rastertoescpx.Tpo -c -o filter/rastertoescpx-rastertoescpx.o `test -f 'filter/rastertoescpx.c' || echo '$(srcdir)/'`filter/rastertoescpx.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/rastertoescpx-rastertoescpx.Tpo filter/$(DEPDIR)/rastertoescpx-rastertoescpx.Po
@@ -3915,20 +3002,6 @@ filter/rastertopclx-rastertopclx.obj: filter/rastertopclx.c
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(rastertopclx_CFLAGS) $(CFLAGS) -c -o filter/rastertopclx-rastertopclx.obj `if test -f 'filter/rastertopclx.c'; then $(CYGPATH_W) 'filter/rastertopclx.c'; else $(CYGPATH_W) '$(srcdir)/filter/rastertopclx.c'; fi`
 
-filter/rastertops-rastertops.o: filter/rastertops.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(rastertops_CFLAGS) $(CFLAGS) -MT filter/rastertops-rastertops.o -MD -MP -MF filter/$(DEPDIR)/rastertops-rastertops.Tpo -c -o filter/rastertops-rastertops.o `test -f 'filter/rastertops.c' || echo '$(srcdir)/'`filter/rastertops.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/rastertops-rastertops.Tpo filter/$(DEPDIR)/rastertops-rastertops.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/rastertops.c' object='filter/rastertops-rastertops.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(rastertops_CFLAGS) $(CFLAGS) -c -o filter/rastertops-rastertops.o `test -f 'filter/rastertops.c' || echo '$(srcdir)/'`filter/rastertops.c
-
-filter/rastertops-rastertops.obj: filter/rastertops.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(rastertops_CFLAGS) $(CFLAGS) -MT filter/rastertops-rastertops.obj -MD -MP -MF filter/$(DEPDIR)/rastertops-rastertops.Tpo -c -o filter/rastertops-rastertops.obj `if test -f 'filter/rastertops.c'; then $(CYGPATH_W) 'filter/rastertops.c'; else $(CYGPATH_W) '$(srcdir)/filter/rastertops.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/rastertops-rastertops.Tpo filter/$(DEPDIR)/rastertops-rastertops.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/rastertops.c' object='filter/rastertops-rastertops.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(rastertops_CFLAGS) $(CFLAGS) -c -o filter/rastertops-rastertops.obj `if test -f 'filter/rastertops.c'; then $(CYGPATH_W) 'filter/rastertops.c'; else $(CYGPATH_W) '$(srcdir)/filter/rastertops.c'; fi`
-
 backend/serial-serial.o: backend/serial.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(serial_CFLAGS) $(CFLAGS) -MT backend/serial-serial.o -MD -MP -MF backend/$(DEPDIR)/serial-serial.Tpo -c -o backend/serial-serial.o `test -f 'backend/serial.c' || echo '$(srcdir)/'`backend/serial.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) backend/$(DEPDIR)/serial-serial.Tpo backend/$(DEPDIR)/serial-serial.Po
@@ -4013,62 +3086,6 @@ backend/test1284-test1284.obj: backend/test1284.c
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test1284_CFLAGS) $(CFLAGS) -c -o backend/test1284-test1284.obj `if test -f 'backend/test1284.c'; then $(CYGPATH_W) 'backend/test1284.c'; else $(CYGPATH_W) '$(srcdir)/backend/test1284.c'; fi`
 
-filter/test_pdf1-pdfutils.o: filter/pdfutils.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_pdf1_CFLAGS) $(CFLAGS) -MT filter/test_pdf1-pdfutils.o -MD -MP -MF filter/$(DEPDIR)/test_pdf1-pdfutils.Tpo -c -o filter/test_pdf1-pdfutils.o `test -f 'filter/pdfutils.c' || echo '$(srcdir)/'`filter/pdfutils.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/test_pdf1-pdfutils.Tpo filter/$(DEPDIR)/test_pdf1-pdfutils.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/pdfutils.c' object='filter/test_pdf1-pdfutils.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_pdf1_CFLAGS) $(CFLAGS) -c -o filter/test_pdf1-pdfutils.o `test -f 'filter/pdfutils.c' || echo '$(srcdir)/'`filter/pdfutils.c
-
-filter/test_pdf1-pdfutils.obj: filter/pdfutils.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_pdf1_CFLAGS) $(CFLAGS) -MT filter/test_pdf1-pdfutils.obj -MD -MP -MF filter/$(DEPDIR)/test_pdf1-pdfutils.Tpo -c -o filter/test_pdf1-pdfutils.obj `if test -f 'filter/pdfutils.c'; then $(CYGPATH_W) 'filter/pdfutils.c'; else $(CYGPATH_W) '$(srcdir)/filter/pdfutils.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/test_pdf1-pdfutils.Tpo filter/$(DEPDIR)/test_pdf1-pdfutils.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/pdfutils.c' object='filter/test_pdf1-pdfutils.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_pdf1_CFLAGS) $(CFLAGS) -c -o filter/test_pdf1-pdfutils.obj `if test -f 'filter/pdfutils.c'; then $(CYGPATH_W) 'filter/pdfutils.c'; else $(CYGPATH_W) '$(srcdir)/filter/pdfutils.c'; fi`
-
-filter/test_pdf1-test_pdf1.o: filter/test_pdf1.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_pdf1_CFLAGS) $(CFLAGS) -MT filter/test_pdf1-test_pdf1.o -MD -MP -MF filter/$(DEPDIR)/test_pdf1-test_pdf1.Tpo -c -o filter/test_pdf1-test_pdf1.o `test -f 'filter/test_pdf1.c' || echo '$(srcdir)/'`filter/test_pdf1.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/test_pdf1-test_pdf1.Tpo filter/$(DEPDIR)/test_pdf1-test_pdf1.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/test_pdf1.c' object='filter/test_pdf1-test_pdf1.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_pdf1_CFLAGS) $(CFLAGS) -c -o filter/test_pdf1-test_pdf1.o `test -f 'filter/test_pdf1.c' || echo '$(srcdir)/'`filter/test_pdf1.c
-
-filter/test_pdf1-test_pdf1.obj: filter/test_pdf1.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_pdf1_CFLAGS) $(CFLAGS) -MT filter/test_pdf1-test_pdf1.obj -MD -MP -MF filter/$(DEPDIR)/test_pdf1-test_pdf1.Tpo -c -o filter/test_pdf1-test_pdf1.obj `if test -f 'filter/test_pdf1.c'; then $(CYGPATH_W) 'filter/test_pdf1.c'; else $(CYGPATH_W) '$(srcdir)/filter/test_pdf1.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/test_pdf1-test_pdf1.Tpo filter/$(DEPDIR)/test_pdf1-test_pdf1.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/test_pdf1.c' object='filter/test_pdf1-test_pdf1.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_pdf1_CFLAGS) $(CFLAGS) -c -o filter/test_pdf1-test_pdf1.obj `if test -f 'filter/test_pdf1.c'; then $(CYGPATH_W) 'filter/test_pdf1.c'; else $(CYGPATH_W) '$(srcdir)/filter/test_pdf1.c'; fi`
-
-filter/test_pdf2-pdfutils.o: filter/pdfutils.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_pdf2_CFLAGS) $(CFLAGS) -MT filter/test_pdf2-pdfutils.o -MD -MP -MF filter/$(DEPDIR)/test_pdf2-pdfutils.Tpo -c -o filter/test_pdf2-pdfutils.o `test -f 'filter/pdfutils.c' || echo '$(srcdir)/'`filter/pdfutils.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/test_pdf2-pdfutils.Tpo filter/$(DEPDIR)/test_pdf2-pdfutils.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/pdfutils.c' object='filter/test_pdf2-pdfutils.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_pdf2_CFLAGS) $(CFLAGS) -c -o filter/test_pdf2-pdfutils.o `test -f 'filter/pdfutils.c' || echo '$(srcdir)/'`filter/pdfutils.c
-
-filter/test_pdf2-pdfutils.obj: filter/pdfutils.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_pdf2_CFLAGS) $(CFLAGS) -MT filter/test_pdf2-pdfutils.obj -MD -MP -MF filter/$(DEPDIR)/test_pdf2-pdfutils.Tpo -c -o filter/test_pdf2-pdfutils.obj `if test -f 'filter/pdfutils.c'; then $(CYGPATH_W) 'filter/pdfutils.c'; else $(CYGPATH_W) '$(srcdir)/filter/pdfutils.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/test_pdf2-pdfutils.Tpo filter/$(DEPDIR)/test_pdf2-pdfutils.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/pdfutils.c' object='filter/test_pdf2-pdfutils.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_pdf2_CFLAGS) $(CFLAGS) -c -o filter/test_pdf2-pdfutils.obj `if test -f 'filter/pdfutils.c'; then $(CYGPATH_W) 'filter/pdfutils.c'; else $(CYGPATH_W) '$(srcdir)/filter/pdfutils.c'; fi`
-
-filter/test_pdf2-test_pdf2.o: filter/test_pdf2.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_pdf2_CFLAGS) $(CFLAGS) -MT filter/test_pdf2-test_pdf2.o -MD -MP -MF filter/$(DEPDIR)/test_pdf2-test_pdf2.Tpo -c -o filter/test_pdf2-test_pdf2.o `test -f 'filter/test_pdf2.c' || echo '$(srcdir)/'`filter/test_pdf2.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/test_pdf2-test_pdf2.Tpo filter/$(DEPDIR)/test_pdf2-test_pdf2.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/test_pdf2.c' object='filter/test_pdf2-test_pdf2.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_pdf2_CFLAGS) $(CFLAGS) -c -o filter/test_pdf2-test_pdf2.o `test -f 'filter/test_pdf2.c' || echo '$(srcdir)/'`filter/test_pdf2.c
-
-filter/test_pdf2-test_pdf2.obj: filter/test_pdf2.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_pdf2_CFLAGS) $(CFLAGS) -MT filter/test_pdf2-test_pdf2.obj -MD -MP -MF filter/$(DEPDIR)/test_pdf2-test_pdf2.Tpo -c -o filter/test_pdf2-test_pdf2.obj `if test -f 'filter/test_pdf2.c'; then $(CYGPATH_W) 'filter/test_pdf2.c'; else $(CYGPATH_W) '$(srcdir)/filter/test_pdf2.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/test_pdf2-test_pdf2.Tpo filter/$(DEPDIR)/test_pdf2-test_pdf2.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/test_pdf2.c' object='filter/test_pdf2-test_pdf2.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(test_pdf2_CFLAGS) $(CFLAGS) -c -o filter/test_pdf2-test_pdf2.obj `if test -f 'filter/test_pdf2.c'; then $(CYGPATH_W) 'filter/test_pdf2.c'; else $(CYGPATH_W) '$(srcdir)/filter/test_pdf2.c'; fi`
-
 cupsfilters/testimage-testimage.o: cupsfilters/testimage.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(testimage_CFLAGS) $(CFLAGS) -MT cupsfilters/testimage-testimage.o -MD -MP -MF cupsfilters/$(DEPDIR)/testimage-testimage.Tpo -c -o cupsfilters/testimage-testimage.o `test -f 'cupsfilters/testimage.c' || echo '$(srcdir)/'`cupsfilters/testimage.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) cupsfilters/$(DEPDIR)/testimage-testimage.Tpo cupsfilters/$(DEPDIR)/testimage-testimage.Po
@@ -4083,62 +3100,6 @@ cupsfilters/testimage-testimage.obj: cupsfilters/testimage.c
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(testimage_CFLAGS) $(CFLAGS) -c -o cupsfilters/testimage-testimage.obj `if test -f 'cupsfilters/testimage.c'; then $(CYGPATH_W) 'cupsfilters/testimage.c'; else $(CYGPATH_W) '$(srcdir)/cupsfilters/testimage.c'; fi`
 
-filter/texttopdf-common.o: filter/common.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(texttopdf_CFLAGS) $(CFLAGS) -MT filter/texttopdf-common.o -MD -MP -MF filter/$(DEPDIR)/texttopdf-common.Tpo -c -o filter/texttopdf-common.o `test -f 'filter/common.c' || echo '$(srcdir)/'`filter/common.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/texttopdf-common.Tpo filter/$(DEPDIR)/texttopdf-common.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/common.c' object='filter/texttopdf-common.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(texttopdf_CFLAGS) $(CFLAGS) -c -o filter/texttopdf-common.o `test -f 'filter/common.c' || echo '$(srcdir)/'`filter/common.c
-
-filter/texttopdf-common.obj: filter/common.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(texttopdf_CFLAGS) $(CFLAGS) -MT filter/texttopdf-common.obj -MD -MP -MF filter/$(DEPDIR)/texttopdf-common.Tpo -c -o filter/texttopdf-common.obj `if test -f 'filter/common.c'; then $(CYGPATH_W) 'filter/common.c'; else $(CYGPATH_W) '$(srcdir)/filter/common.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/texttopdf-common.Tpo filter/$(DEPDIR)/texttopdf-common.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/common.c' object='filter/texttopdf-common.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(texttopdf_CFLAGS) $(CFLAGS) -c -o filter/texttopdf-common.obj `if test -f 'filter/common.c'; then $(CYGPATH_W) 'filter/common.c'; else $(CYGPATH_W) '$(srcdir)/filter/common.c'; fi`
-
-filter/texttopdf-pdfutils.o: filter/pdfutils.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(texttopdf_CFLAGS) $(CFLAGS) -MT filter/texttopdf-pdfutils.o -MD -MP -MF filter/$(DEPDIR)/texttopdf-pdfutils.Tpo -c -o filter/texttopdf-pdfutils.o `test -f 'filter/pdfutils.c' || echo '$(srcdir)/'`filter/pdfutils.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/texttopdf-pdfutils.Tpo filter/$(DEPDIR)/texttopdf-pdfutils.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/pdfutils.c' object='filter/texttopdf-pdfutils.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(texttopdf_CFLAGS) $(CFLAGS) -c -o filter/texttopdf-pdfutils.o `test -f 'filter/pdfutils.c' || echo '$(srcdir)/'`filter/pdfutils.c
-
-filter/texttopdf-pdfutils.obj: filter/pdfutils.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(texttopdf_CFLAGS) $(CFLAGS) -MT filter/texttopdf-pdfutils.obj -MD -MP -MF filter/$(DEPDIR)/texttopdf-pdfutils.Tpo -c -o filter/texttopdf-pdfutils.obj `if test -f 'filter/pdfutils.c'; then $(CYGPATH_W) 'filter/pdfutils.c'; else $(CYGPATH_W) '$(srcdir)/filter/pdfutils.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/texttopdf-pdfutils.Tpo filter/$(DEPDIR)/texttopdf-pdfutils.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/pdfutils.c' object='filter/texttopdf-pdfutils.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(texttopdf_CFLAGS) $(CFLAGS) -c -o filter/texttopdf-pdfutils.obj `if test -f 'filter/pdfutils.c'; then $(CYGPATH_W) 'filter/pdfutils.c'; else $(CYGPATH_W) '$(srcdir)/filter/pdfutils.c'; fi`
-
-filter/texttopdf-textcommon.o: filter/textcommon.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(texttopdf_CFLAGS) $(CFLAGS) -MT filter/texttopdf-textcommon.o -MD -MP -MF filter/$(DEPDIR)/texttopdf-textcommon.Tpo -c -o filter/texttopdf-textcommon.o `test -f 'filter/textcommon.c' || echo '$(srcdir)/'`filter/textcommon.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/texttopdf-textcommon.Tpo filter/$(DEPDIR)/texttopdf-textcommon.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/textcommon.c' object='filter/texttopdf-textcommon.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(texttopdf_CFLAGS) $(CFLAGS) -c -o filter/texttopdf-textcommon.o `test -f 'filter/textcommon.c' || echo '$(srcdir)/'`filter/textcommon.c
-
-filter/texttopdf-textcommon.obj: filter/textcommon.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(texttopdf_CFLAGS) $(CFLAGS) -MT filter/texttopdf-textcommon.obj -MD -MP -MF filter/$(DEPDIR)/texttopdf-textcommon.Tpo -c -o filter/texttopdf-textcommon.obj `if test -f 'filter/textcommon.c'; then $(CYGPATH_W) 'filter/textcommon.c'; else $(CYGPATH_W) '$(srcdir)/filter/textcommon.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/texttopdf-textcommon.Tpo filter/$(DEPDIR)/texttopdf-textcommon.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/textcommon.c' object='filter/texttopdf-textcommon.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(texttopdf_CFLAGS) $(CFLAGS) -c -o filter/texttopdf-textcommon.obj `if test -f 'filter/textcommon.c'; then $(CYGPATH_W) 'filter/textcommon.c'; else $(CYGPATH_W) '$(srcdir)/filter/textcommon.c'; fi`
-
-filter/texttopdf-texttopdf.o: filter/texttopdf.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(texttopdf_CFLAGS) $(CFLAGS) -MT filter/texttopdf-texttopdf.o -MD -MP -MF filter/$(DEPDIR)/texttopdf-texttopdf.Tpo -c -o filter/texttopdf-texttopdf.o `test -f 'filter/texttopdf.c' || echo '$(srcdir)/'`filter/texttopdf.c
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/texttopdf-texttopdf.Tpo filter/$(DEPDIR)/texttopdf-texttopdf.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/texttopdf.c' object='filter/texttopdf-texttopdf.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(texttopdf_CFLAGS) $(CFLAGS) -c -o filter/texttopdf-texttopdf.o `test -f 'filter/texttopdf.c' || echo '$(srcdir)/'`filter/texttopdf.c
-
-filter/texttopdf-texttopdf.obj: filter/texttopdf.c
-@am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(texttopdf_CFLAGS) $(CFLAGS) -MT filter/texttopdf-texttopdf.obj -MD -MP -MF filter/$(DEPDIR)/texttopdf-texttopdf.Tpo -c -o filter/texttopdf-texttopdf.obj `if test -f 'filter/texttopdf.c'; then $(CYGPATH_W) 'filter/texttopdf.c'; else $(CYGPATH_W) '$(srcdir)/filter/texttopdf.c'; fi`
-@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/texttopdf-texttopdf.Tpo filter/$(DEPDIR)/texttopdf-texttopdf.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='filter/texttopdf.c' object='filter/texttopdf-texttopdf.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(texttopdf_CFLAGS) $(CFLAGS) -c -o filter/texttopdf-texttopdf.obj `if test -f 'filter/texttopdf.c'; then $(CYGPATH_W) 'filter/texttopdf.c'; else $(CYGPATH_W) '$(srcdir)/filter/texttopdf.c'; fi`
-
 filter/texttotext-texttotext.o: filter/texttotext.c
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(texttotext_CFLAGS) $(CFLAGS) -MT filter/texttotext-texttotext.o -MD -MP -MF filter/$(DEPDIR)/texttotext-texttotext.Tpo -c -o filter/texttotext-texttotext.o `test -f 'filter/texttotext.c' || echo '$(srcdir)/'`filter/texttotext.c
 @am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/texttotext-texttotext.Tpo filter/$(DEPDIR)/texttotext-texttotext.Po
@@ -4191,216 +3152,6 @@ filter/texttotext-strcasestr.obj: filter/strcasestr.c
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(LTCXXCOMPILE) -c -o $@ $<
 
-filter/bannertopdf-pdf.o: filter/pdf.cxx
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(bannertopdf_CXXFLAGS) $(CXXFLAGS) -MT filter/bannertopdf-pdf.o -MD -MP -MF filter/$(DEPDIR)/bannertopdf-pdf.Tpo -c -o filter/bannertopdf-pdf.o `test -f 'filter/pdf.cxx' || echo '$(srcdir)/'`filter/pdf.cxx
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/bannertopdf-pdf.Tpo filter/$(DEPDIR)/bannertopdf-pdf.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='filter/pdf.cxx' object='filter/bannertopdf-pdf.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(bannertopdf_CXXFLAGS) $(CXXFLAGS) -c -o filter/bannertopdf-pdf.o `test -f 'filter/pdf.cxx' || echo '$(srcdir)/'`filter/pdf.cxx
-
-filter/bannertopdf-pdf.obj: filter/pdf.cxx
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(bannertopdf_CXXFLAGS) $(CXXFLAGS) -MT filter/bannertopdf-pdf.obj -MD -MP -MF filter/$(DEPDIR)/bannertopdf-pdf.Tpo -c -o filter/bannertopdf-pdf.obj `if test -f 'filter/pdf.cxx'; then $(CYGPATH_W) 'filter/pdf.cxx'; else $(CYGPATH_W) '$(srcdir)/filter/pdf.cxx'; fi`
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/bannertopdf-pdf.Tpo filter/$(DEPDIR)/bannertopdf-pdf.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='filter/pdf.cxx' object='filter/bannertopdf-pdf.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(bannertopdf_CXXFLAGS) $(CXXFLAGS) -c -o filter/bannertopdf-pdf.obj `if test -f 'filter/pdf.cxx'; then $(CYGPATH_W) 'filter/pdf.cxx'; else $(CYGPATH_W) '$(srcdir)/filter/pdf.cxx'; fi`
-
-filter/pdftopdf/pdftopdf-pdftopdf.o: filter/pdftopdf/pdftopdf.cc
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -MT filter/pdftopdf/pdftopdf-pdftopdf.o -MD -MP -MF filter/pdftopdf/$(DEPDIR)/pdftopdf-pdftopdf.Tpo -c -o filter/pdftopdf/pdftopdf-pdftopdf.o `test -f 'filter/pdftopdf/pdftopdf.cc' || echo '$(srcdir)/'`filter/pdftopdf/pdftopdf.cc
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) filter/pdftopdf/$(DEPDIR)/pdftopdf-pdftopdf.Tpo filter/pdftopdf/$(DEPDIR)/pdftopdf-pdftopdf.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='filter/pdftopdf/pdftopdf.cc' object='filter/pdftopdf/pdftopdf-pdftopdf.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -c -o filter/pdftopdf/pdftopdf-pdftopdf.o `test -f 'filter/pdftopdf/pdftopdf.cc' || echo '$(srcdir)/'`filter/pdftopdf/pdftopdf.cc
-
-filter/pdftopdf/pdftopdf-pdftopdf.obj: filter/pdftopdf/pdftopdf.cc
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -MT filter/pdftopdf/pdftopdf-pdftopdf.obj -MD -MP -MF filter/pdftopdf/$(DEPDIR)/pdftopdf-pdftopdf.Tpo -c -o filter/pdftopdf/pdftopdf-pdftopdf.obj `if test -f 'filter/pdftopdf/pdftopdf.cc'; then $(CYGPATH_W) 'filter/pdftopdf/pdftopdf.cc'; else $(CYGPATH_W) '$(srcdir)/filter/pdftopdf/pdftopdf.cc'; fi`
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) filter/pdftopdf/$(DEPDIR)/pdftopdf-pdftopdf.Tpo filter/pdftopdf/$(DEPDIR)/pdftopdf-pdftopdf.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='filter/pdftopdf/pdftopdf.cc' object='filter/pdftopdf/pdftopdf-pdftopdf.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -c -o filter/pdftopdf/pdftopdf-pdftopdf.obj `if test -f 'filter/pdftopdf/pdftopdf.cc'; then $(CYGPATH_W) 'filter/pdftopdf/pdftopdf.cc'; else $(CYGPATH_W) '$(srcdir)/filter/pdftopdf/pdftopdf.cc'; fi`
-
-filter/pdftopdf/pdftopdf-pdftopdf_jcl.o: filter/pdftopdf/pdftopdf_jcl.cc
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -MT filter/pdftopdf/pdftopdf-pdftopdf_jcl.o -MD -MP -MF filter/pdftopdf/$(DEPDIR)/pdftopdf-pdftopdf_jcl.Tpo -c -o filter/pdftopdf/pdftopdf-pdftopdf_jcl.o `test -f 'filter/pdftopdf/pdftopdf_jcl.cc' || echo '$(srcdir)/'`filter/pdftopdf/pdftopdf_jcl.cc
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) filter/pdftopdf/$(DEPDIR)/pdftopdf-pdftopdf_jcl.Tpo filter/pdftopdf/$(DEPDIR)/pdftopdf-pdftopdf_jcl.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='filter/pdftopdf/pdftopdf_jcl.cc' object='filter/pdftopdf/pdftopdf-pdftopdf_jcl.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -c -o filter/pdftopdf/pdftopdf-pdftopdf_jcl.o `test -f 'filter/pdftopdf/pdftopdf_jcl.cc' || echo '$(srcdir)/'`filter/pdftopdf/pdftopdf_jcl.cc
-
-filter/pdftopdf/pdftopdf-pdftopdf_jcl.obj: filter/pdftopdf/pdftopdf_jcl.cc
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -MT filter/pdftopdf/pdftopdf-pdftopdf_jcl.obj -MD -MP -MF filter/pdftopdf/$(DEPDIR)/pdftopdf-pdftopdf_jcl.Tpo -c -o filter/pdftopdf/pdftopdf-pdftopdf_jcl.obj `if test -f 'filter/pdftopdf/pdftopdf_jcl.cc'; then $(CYGPATH_W) 'filter/pdftopdf/pdftopdf_jcl.cc'; else $(CYGPATH_W) '$(srcdir)/filter/pdftopdf/pdftopdf_jcl.cc'; fi`
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) filter/pdftopdf/$(DEPDIR)/pdftopdf-pdftopdf_jcl.Tpo filter/pdftopdf/$(DEPDIR)/pdftopdf-pdftopdf_jcl.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='filter/pdftopdf/pdftopdf_jcl.cc' object='filter/pdftopdf/pdftopdf-pdftopdf_jcl.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -c -o filter/pdftopdf/pdftopdf-pdftopdf_jcl.obj `if test -f 'filter/pdftopdf/pdftopdf_jcl.cc'; then $(CYGPATH_W) 'filter/pdftopdf/pdftopdf_jcl.cc'; else $(CYGPATH_W) '$(srcdir)/filter/pdftopdf/pdftopdf_jcl.cc'; fi`
-
-filter/pdftopdf/pdftopdf-pdftopdf_processor.o: filter/pdftopdf/pdftopdf_processor.cc
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -MT filter/pdftopdf/pdftopdf-pdftopdf_processor.o -MD -MP -MF filter/pdftopdf/$(DEPDIR)/pdftopdf-pdftopdf_processor.Tpo -c -o filter/pdftopdf/pdftopdf-pdftopdf_processor.o `test -f 'filter/pdftopdf/pdftopdf_processor.cc' || echo '$(srcdir)/'`filter/pdftopdf/pdftopdf_processor.cc
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) filter/pdftopdf/$(DEPDIR)/pdftopdf-pdftopdf_processor.Tpo filter/pdftopdf/$(DEPDIR)/pdftopdf-pdftopdf_processor.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='filter/pdftopdf/pdftopdf_processor.cc' object='filter/pdftopdf/pdftopdf-pdftopdf_processor.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -c -o filter/pdftopdf/pdftopdf-pdftopdf_processor.o `test -f 'filter/pdftopdf/pdftopdf_processor.cc' || echo '$(srcdir)/'`filter/pdftopdf/pdftopdf_processor.cc
-
-filter/pdftopdf/pdftopdf-pdftopdf_processor.obj: filter/pdftopdf/pdftopdf_processor.cc
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -MT filter/pdftopdf/pdftopdf-pdftopdf_processor.obj -MD -MP -MF filter/pdftopdf/$(DEPDIR)/pdftopdf-pdftopdf_processor.Tpo -c -o filter/pdftopdf/pdftopdf-pdftopdf_processor.obj `if test -f 'filter/pdftopdf/pdftopdf_processor.cc'; then $(CYGPATH_W) 'filter/pdftopdf/pdftopdf_processor.cc'; else $(CYGPATH_W) '$(srcdir)/filter/pdftopdf/pdftopdf_processor.cc'; fi`
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) filter/pdftopdf/$(DEPDIR)/pdftopdf-pdftopdf_processor.Tpo filter/pdftopdf/$(DEPDIR)/pdftopdf-pdftopdf_processor.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='filter/pdftopdf/pdftopdf_processor.cc' object='filter/pdftopdf/pdftopdf-pdftopdf_processor.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -c -o filter/pdftopdf/pdftopdf-pdftopdf_processor.obj `if test -f 'filter/pdftopdf/pdftopdf_processor.cc'; then $(CYGPATH_W) 'filter/pdftopdf/pdftopdf_processor.cc'; else $(CYGPATH_W) '$(srcdir)/filter/pdftopdf/pdftopdf_processor.cc'; fi`
-
-filter/pdftopdf/pdftopdf-qpdf_pdftopdf_processor.o: filter/pdftopdf/qpdf_pdftopdf_processor.cc
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -MT filter/pdftopdf/pdftopdf-qpdf_pdftopdf_processor.o -MD -MP -MF filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_pdftopdf_processor.Tpo -c -o filter/pdftopdf/pdftopdf-qpdf_pdftopdf_processor.o `test -f 'filter/pdftopdf/qpdf_pdftopdf_processor.cc' || echo '$(srcdir)/'`filter/pdftopdf/qpdf_pdftopdf_processor.cc
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_pdftopdf_processor.Tpo filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_pdftopdf_processor.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='filter/pdftopdf/qpdf_pdftopdf_processor.cc' object='filter/pdftopdf/pdftopdf-qpdf_pdftopdf_processor.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -c -o filter/pdftopdf/pdftopdf-qpdf_pdftopdf_processor.o `test -f 'filter/pdftopdf/qpdf_pdftopdf_processor.cc' || echo '$(srcdir)/'`filter/pdftopdf/qpdf_pdftopdf_processor.cc
-
-filter/pdftopdf/pdftopdf-qpdf_pdftopdf_processor.obj: filter/pdftopdf/qpdf_pdftopdf_processor.cc
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -MT filter/pdftopdf/pdftopdf-qpdf_pdftopdf_processor.obj -MD -MP -MF filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_pdftopdf_processor.Tpo -c -o filter/pdftopdf/pdftopdf-qpdf_pdftopdf_processor.obj `if test -f 'filter/pdftopdf/qpdf_pdftopdf_processor.cc'; then $(CYGPATH_W) 'filter/pdftopdf/qpdf_pdftopdf_processor.cc'; else $(CYGPATH_W) '$(srcdir)/filter/pdftopdf/qpdf_pdftopdf_processor.cc'; fi`
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_pdftopdf_processor.Tpo filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_pdftopdf_processor.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='filter/pdftopdf/qpdf_pdftopdf_processor.cc' object='filter/pdftopdf/pdftopdf-qpdf_pdftopdf_processor.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -c -o filter/pdftopdf/pdftopdf-qpdf_pdftopdf_processor.obj `if test -f 'filter/pdftopdf/qpdf_pdftopdf_processor.cc'; then $(CYGPATH_W) 'filter/pdftopdf/qpdf_pdftopdf_processor.cc'; else $(CYGPATH_W) '$(srcdir)/filter/pdftopdf/qpdf_pdftopdf_processor.cc'; fi`
-
-filter/pdftopdf/pdftopdf-pptypes.o: filter/pdftopdf/pptypes.cc
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -MT filter/pdftopdf/pdftopdf-pptypes.o -MD -MP -MF filter/pdftopdf/$(DEPDIR)/pdftopdf-pptypes.Tpo -c -o filter/pdftopdf/pdftopdf-pptypes.o `test -f 'filter/pdftopdf/pptypes.cc' || echo '$(srcdir)/'`filter/pdftopdf/pptypes.cc
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) filter/pdftopdf/$(DEPDIR)/pdftopdf-pptypes.Tpo filter/pdftopdf/$(DEPDIR)/pdftopdf-pptypes.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='filter/pdftopdf/pptypes.cc' object='filter/pdftopdf/pdftopdf-pptypes.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -c -o filter/pdftopdf/pdftopdf-pptypes.o `test -f 'filter/pdftopdf/pptypes.cc' || echo '$(srcdir)/'`filter/pdftopdf/pptypes.cc
-
-filter/pdftopdf/pdftopdf-pptypes.obj: filter/pdftopdf/pptypes.cc
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -MT filter/pdftopdf/pdftopdf-pptypes.obj -MD -MP -MF filter/pdftopdf/$(DEPDIR)/pdftopdf-pptypes.Tpo -c -o filter/pdftopdf/pdftopdf-pptypes.obj `if test -f 'filter/pdftopdf/pptypes.cc'; then $(CYGPATH_W) 'filter/pdftopdf/pptypes.cc'; else $(CYGPATH_W) '$(srcdir)/filter/pdftopdf/pptypes.cc'; fi`
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) filter/pdftopdf/$(DEPDIR)/pdftopdf-pptypes.Tpo filter/pdftopdf/$(DEPDIR)/pdftopdf-pptypes.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='filter/pdftopdf/pptypes.cc' object='filter/pdftopdf/pdftopdf-pptypes.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -c -o filter/pdftopdf/pdftopdf-pptypes.obj `if test -f 'filter/pdftopdf/pptypes.cc'; then $(CYGPATH_W) 'filter/pdftopdf/pptypes.cc'; else $(CYGPATH_W) '$(srcdir)/filter/pdftopdf/pptypes.cc'; fi`
-
-filter/pdftopdf/pdftopdf-nup.o: filter/pdftopdf/nup.cc
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -MT filter/pdftopdf/pdftopdf-nup.o -MD -MP -MF filter/pdftopdf/$(DEPDIR)/pdftopdf-nup.Tpo -c -o filter/pdftopdf/pdftopdf-nup.o `test -f 'filter/pdftopdf/nup.cc' || echo '$(srcdir)/'`filter/pdftopdf/nup.cc
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) filter/pdftopdf/$(DEPDIR)/pdftopdf-nup.Tpo filter/pdftopdf/$(DEPDIR)/pdftopdf-nup.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='filter/pdftopdf/nup.cc' object='filter/pdftopdf/pdftopdf-nup.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -c -o filter/pdftopdf/pdftopdf-nup.o `test -f 'filter/pdftopdf/nup.cc' || echo '$(srcdir)/'`filter/pdftopdf/nup.cc
-
-filter/pdftopdf/pdftopdf-nup.obj: filter/pdftopdf/nup.cc
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -MT filter/pdftopdf/pdftopdf-nup.obj -MD -MP -MF filter/pdftopdf/$(DEPDIR)/pdftopdf-nup.Tpo -c -o filter/pdftopdf/pdftopdf-nup.obj `if test -f 'filter/pdftopdf/nup.cc'; then $(CYGPATH_W) 'filter/pdftopdf/nup.cc'; else $(CYGPATH_W) '$(srcdir)/filter/pdftopdf/nup.cc'; fi`
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) filter/pdftopdf/$(DEPDIR)/pdftopdf-nup.Tpo filter/pdftopdf/$(DEPDIR)/pdftopdf-nup.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='filter/pdftopdf/nup.cc' object='filter/pdftopdf/pdftopdf-nup.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -c -o filter/pdftopdf/pdftopdf-nup.obj `if test -f 'filter/pdftopdf/nup.cc'; then $(CYGPATH_W) 'filter/pdftopdf/nup.cc'; else $(CYGPATH_W) '$(srcdir)/filter/pdftopdf/nup.cc'; fi`
-
-filter/pdftopdf/pdftopdf-intervalset.o: filter/pdftopdf/intervalset.cc
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -MT filter/pdftopdf/pdftopdf-intervalset.o -MD -MP -MF filter/pdftopdf/$(DEPDIR)/pdftopdf-intervalset.Tpo -c -o filter/pdftopdf/pdftopdf-intervalset.o `test -f 'filter/pdftopdf/intervalset.cc' || echo '$(srcdir)/'`filter/pdftopdf/intervalset.cc
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) filter/pdftopdf/$(DEPDIR)/pdftopdf-intervalset.Tpo filter/pdftopdf/$(DEPDIR)/pdftopdf-intervalset.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='filter/pdftopdf/intervalset.cc' object='filter/pdftopdf/pdftopdf-intervalset.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -c -o filter/pdftopdf/pdftopdf-intervalset.o `test -f 'filter/pdftopdf/intervalset.cc' || echo '$(srcdir)/'`filter/pdftopdf/intervalset.cc
-
-filter/pdftopdf/pdftopdf-intervalset.obj: filter/pdftopdf/intervalset.cc
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -MT filter/pdftopdf/pdftopdf-intervalset.obj -MD -MP -MF filter/pdftopdf/$(DEPDIR)/pdftopdf-intervalset.Tpo -c -o filter/pdftopdf/pdftopdf-intervalset.obj `if test -f 'filter/pdftopdf/intervalset.cc'; then $(CYGPATH_W) 'filter/pdftopdf/intervalset.cc'; else $(CYGPATH_W) '$(srcdir)/filter/pdftopdf/intervalset.cc'; fi`
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) filter/pdftopdf/$(DEPDIR)/pdftopdf-intervalset.Tpo filter/pdftopdf/$(DEPDIR)/pdftopdf-intervalset.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='filter/pdftopdf/intervalset.cc' object='filter/pdftopdf/pdftopdf-intervalset.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -c -o filter/pdftopdf/pdftopdf-intervalset.obj `if test -f 'filter/pdftopdf/intervalset.cc'; then $(CYGPATH_W) 'filter/pdftopdf/intervalset.cc'; else $(CYGPATH_W) '$(srcdir)/filter/pdftopdf/intervalset.cc'; fi`
-
-filter/pdftopdf/pdftopdf-qpdf_tools.o: filter/pdftopdf/qpdf_tools.cc
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -MT filter/pdftopdf/pdftopdf-qpdf_tools.o -MD -MP -MF filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_tools.Tpo -c -o filter/pdftopdf/pdftopdf-qpdf_tools.o `test -f 'filter/pdftopdf/qpdf_tools.cc' || echo '$(srcdir)/'`filter/pdftopdf/qpdf_tools.cc
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_tools.Tpo filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_tools.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='filter/pdftopdf/qpdf_tools.cc' object='filter/pdftopdf/pdftopdf-qpdf_tools.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -c -o filter/pdftopdf/pdftopdf-qpdf_tools.o `test -f 'filter/pdftopdf/qpdf_tools.cc' || echo '$(srcdir)/'`filter/pdftopdf/qpdf_tools.cc
-
-filter/pdftopdf/pdftopdf-qpdf_tools.obj: filter/pdftopdf/qpdf_tools.cc
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -MT filter/pdftopdf/pdftopdf-qpdf_tools.obj -MD -MP -MF filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_tools.Tpo -c -o filter/pdftopdf/pdftopdf-qpdf_tools.obj `if test -f 'filter/pdftopdf/qpdf_tools.cc'; then $(CYGPATH_W) 'filter/pdftopdf/qpdf_tools.cc'; else $(CYGPATH_W) '$(srcdir)/filter/pdftopdf/qpdf_tools.cc'; fi`
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_tools.Tpo filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_tools.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='filter/pdftopdf/qpdf_tools.cc' object='filter/pdftopdf/pdftopdf-qpdf_tools.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -c -o filter/pdftopdf/pdftopdf-qpdf_tools.obj `if test -f 'filter/pdftopdf/qpdf_tools.cc'; then $(CYGPATH_W) 'filter/pdftopdf/qpdf_tools.cc'; else $(CYGPATH_W) '$(srcdir)/filter/pdftopdf/qpdf_tools.cc'; fi`
-
-filter/pdftopdf/pdftopdf-qpdf_xobject.o: filter/pdftopdf/qpdf_xobject.cc
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -MT filter/pdftopdf/pdftopdf-qpdf_xobject.o -MD -MP -MF filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_xobject.Tpo -c -o filter/pdftopdf/pdftopdf-qpdf_xobject.o `test -f 'filter/pdftopdf/qpdf_xobject.cc' || echo '$(srcdir)/'`filter/pdftopdf/qpdf_xobject.cc
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_xobject.Tpo filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_xobject.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='filter/pdftopdf/qpdf_xobject.cc' object='filter/pdftopdf/pdftopdf-qpdf_xobject.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -c -o filter/pdftopdf/pdftopdf-qpdf_xobject.o `test -f 'filter/pdftopdf/qpdf_xobject.cc' || echo '$(srcdir)/'`filter/pdftopdf/qpdf_xobject.cc
-
-filter/pdftopdf/pdftopdf-qpdf_xobject.obj: filter/pdftopdf/qpdf_xobject.cc
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -MT filter/pdftopdf/pdftopdf-qpdf_xobject.obj -MD -MP -MF filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_xobject.Tpo -c -o filter/pdftopdf/pdftopdf-qpdf_xobject.obj `if test -f 'filter/pdftopdf/qpdf_xobject.cc'; then $(CYGPATH_W) 'filter/pdftopdf/qpdf_xobject.cc'; else $(CYGPATH_W) '$(srcdir)/filter/pdftopdf/qpdf_xobject.cc'; fi`
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_xobject.Tpo filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_xobject.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='filter/pdftopdf/qpdf_xobject.cc' object='filter/pdftopdf/pdftopdf-qpdf_xobject.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -c -o filter/pdftopdf/pdftopdf-qpdf_xobject.obj `if test -f 'filter/pdftopdf/qpdf_xobject.cc'; then $(CYGPATH_W) 'filter/pdftopdf/qpdf_xobject.cc'; else $(CYGPATH_W) '$(srcdir)/filter/pdftopdf/qpdf_xobject.cc'; fi`
-
-filter/pdftopdf/pdftopdf-qpdf_pdftopdf.o: filter/pdftopdf/qpdf_pdftopdf.cc
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -MT filter/pdftopdf/pdftopdf-qpdf_pdftopdf.o -MD -MP -MF filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_pdftopdf.Tpo -c -o filter/pdftopdf/pdftopdf-qpdf_pdftopdf.o `test -f 'filter/pdftopdf/qpdf_pdftopdf.cc' || echo '$(srcdir)/'`filter/pdftopdf/qpdf_pdftopdf.cc
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_pdftopdf.Tpo filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_pdftopdf.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='filter/pdftopdf/qpdf_pdftopdf.cc' object='filter/pdftopdf/pdftopdf-qpdf_pdftopdf.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -c -o filter/pdftopdf/pdftopdf-qpdf_pdftopdf.o `test -f 'filter/pdftopdf/qpdf_pdftopdf.cc' || echo '$(srcdir)/'`filter/pdftopdf/qpdf_pdftopdf.cc
-
-filter/pdftopdf/pdftopdf-qpdf_pdftopdf.obj: filter/pdftopdf/qpdf_pdftopdf.cc
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -MT filter/pdftopdf/pdftopdf-qpdf_pdftopdf.obj -MD -MP -MF filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_pdftopdf.Tpo -c -o filter/pdftopdf/pdftopdf-qpdf_pdftopdf.obj `if test -f 'filter/pdftopdf/qpdf_pdftopdf.cc'; then $(CYGPATH_W) 'filter/pdftopdf/qpdf_pdftopdf.cc'; else $(CYGPATH_W) '$(srcdir)/filter/pdftopdf/qpdf_pdftopdf.cc'; fi`
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_pdftopdf.Tpo filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_pdftopdf.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='filter/pdftopdf/qpdf_pdftopdf.cc' object='filter/pdftopdf/pdftopdf-qpdf_pdftopdf.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -c -o filter/pdftopdf/pdftopdf-qpdf_pdftopdf.obj `if test -f 'filter/pdftopdf/qpdf_pdftopdf.cc'; then $(CYGPATH_W) 'filter/pdftopdf/qpdf_pdftopdf.cc'; else $(CYGPATH_W) '$(srcdir)/filter/pdftopdf/qpdf_pdftopdf.cc'; fi`
-
-filter/pdftopdf/pdftopdf-qpdf_cm.o: filter/pdftopdf/qpdf_cm.cc
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -MT filter/pdftopdf/pdftopdf-qpdf_cm.o -MD -MP -MF filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_cm.Tpo -c -o filter/pdftopdf/pdftopdf-qpdf_cm.o `test -f 'filter/pdftopdf/qpdf_cm.cc' || echo '$(srcdir)/'`filter/pdftopdf/qpdf_cm.cc
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_cm.Tpo filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_cm.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='filter/pdftopdf/qpdf_cm.cc' object='filter/pdftopdf/pdftopdf-qpdf_cm.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -c -o filter/pdftopdf/pdftopdf-qpdf_cm.o `test -f 'filter/pdftopdf/qpdf_cm.cc' || echo '$(srcdir)/'`filter/pdftopdf/qpdf_cm.cc
-
-filter/pdftopdf/pdftopdf-qpdf_cm.obj: filter/pdftopdf/qpdf_cm.cc
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -MT filter/pdftopdf/pdftopdf-qpdf_cm.obj -MD -MP -MF filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_cm.Tpo -c -o filter/pdftopdf/pdftopdf-qpdf_cm.obj `if test -f 'filter/pdftopdf/qpdf_cm.cc'; then $(CYGPATH_W) 'filter/pdftopdf/qpdf_cm.cc'; else $(CYGPATH_W) '$(srcdir)/filter/pdftopdf/qpdf_cm.cc'; fi`
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_cm.Tpo filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_cm.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='filter/pdftopdf/qpdf_cm.cc' object='filter/pdftopdf/pdftopdf-qpdf_cm.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftopdf_CXXFLAGS) $(CXXFLAGS) -c -o filter/pdftopdf/pdftopdf-qpdf_cm.obj `if test -f 'filter/pdftopdf/qpdf_cm.cc'; then $(CYGPATH_W) 'filter/pdftopdf/qpdf_cm.cc'; else $(CYGPATH_W) '$(srcdir)/filter/pdftopdf/qpdf_cm.cc'; fi`
-
-filter/pdftoraster-pdftoraster.o: filter/pdftoraster.cxx
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftoraster_CXXFLAGS) $(CXXFLAGS) -MT filter/pdftoraster-pdftoraster.o -MD -MP -MF filter/$(DEPDIR)/pdftoraster-pdftoraster.Tpo -c -o filter/pdftoraster-pdftoraster.o `test -f 'filter/pdftoraster.cxx' || echo '$(srcdir)/'`filter/pdftoraster.cxx
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/pdftoraster-pdftoraster.Tpo filter/$(DEPDIR)/pdftoraster-pdftoraster.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='filter/pdftoraster.cxx' object='filter/pdftoraster-pdftoraster.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftoraster_CXXFLAGS) $(CXXFLAGS) -c -o filter/pdftoraster-pdftoraster.o `test -f 'filter/pdftoraster.cxx' || echo '$(srcdir)/'`filter/pdftoraster.cxx
-
-filter/pdftoraster-pdftoraster.obj: filter/pdftoraster.cxx
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftoraster_CXXFLAGS) $(CXXFLAGS) -MT filter/pdftoraster-pdftoraster.obj -MD -MP -MF filter/$(DEPDIR)/pdftoraster-pdftoraster.Tpo -c -o filter/pdftoraster-pdftoraster.obj `if test -f 'filter/pdftoraster.cxx'; then $(CYGPATH_W) 'filter/pdftoraster.cxx'; else $(CYGPATH_W) '$(srcdir)/filter/pdftoraster.cxx'; fi`
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/pdftoraster-pdftoraster.Tpo filter/$(DEPDIR)/pdftoraster-pdftoraster.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='filter/pdftoraster.cxx' object='filter/pdftoraster-pdftoraster.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(pdftoraster_CXXFLAGS) $(CXXFLAGS) -c -o filter/pdftoraster-pdftoraster.obj `if test -f 'filter/pdftoraster.cxx'; then $(CYGPATH_W) 'filter/pdftoraster.cxx'; else $(CYGPATH_W) '$(srcdir)/filter/pdftoraster.cxx'; fi`
-
-filter/rastertopdf-rastertopdf.o: filter/rastertopdf.cpp
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(rastertopdf_CXXFLAGS) $(CXXFLAGS) -MT filter/rastertopdf-rastertopdf.o -MD -MP -MF filter/$(DEPDIR)/rastertopdf-rastertopdf.Tpo -c -o filter/rastertopdf-rastertopdf.o `test -f 'filter/rastertopdf.cpp' || echo '$(srcdir)/'`filter/rastertopdf.cpp
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/rastertopdf-rastertopdf.Tpo filter/$(DEPDIR)/rastertopdf-rastertopdf.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='filter/rastertopdf.cpp' object='filter/rastertopdf-rastertopdf.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(rastertopdf_CXXFLAGS) $(CXXFLAGS) -c -o filter/rastertopdf-rastertopdf.o `test -f 'filter/rastertopdf.cpp' || echo '$(srcdir)/'`filter/rastertopdf.cpp
-
-filter/rastertopdf-rastertopdf.obj: filter/rastertopdf.cpp
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(rastertopdf_CXXFLAGS) $(CXXFLAGS) -MT filter/rastertopdf-rastertopdf.obj -MD -MP -MF filter/$(DEPDIR)/rastertopdf-rastertopdf.Tpo -c -o filter/rastertopdf-rastertopdf.obj `if test -f 'filter/rastertopdf.cpp'; then $(CYGPATH_W) 'filter/rastertopdf.cpp'; else $(CYGPATH_W) '$(srcdir)/filter/rastertopdf.cpp'; fi`
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/rastertopdf-rastertopdf.Tpo filter/$(DEPDIR)/rastertopdf-rastertopdf.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='filter/rastertopdf.cpp' object='filter/rastertopdf-rastertopdf.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(rastertopdf_CXXFLAGS) $(CXXFLAGS) -c -o filter/rastertopdf-rastertopdf.obj `if test -f 'filter/rastertopdf.cpp'; then $(CYGPATH_W) 'filter/rastertopdf.cpp'; else $(CYGPATH_W) '$(srcdir)/filter/rastertopdf.cpp'; fi`
-
-filter/urftopdf-urftopdf.o: filter/urftopdf.cpp
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(urftopdf_CXXFLAGS) $(CXXFLAGS) -MT filter/urftopdf-urftopdf.o -MD -MP -MF filter/$(DEPDIR)/urftopdf-urftopdf.Tpo -c -o filter/urftopdf-urftopdf.o `test -f 'filter/urftopdf.cpp' || echo '$(srcdir)/'`filter/urftopdf.cpp
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/urftopdf-urftopdf.Tpo filter/$(DEPDIR)/urftopdf-urftopdf.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='filter/urftopdf.cpp' object='filter/urftopdf-urftopdf.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(urftopdf_CXXFLAGS) $(CXXFLAGS) -c -o filter/urftopdf-urftopdf.o `test -f 'filter/urftopdf.cpp' || echo '$(srcdir)/'`filter/urftopdf.cpp
-
-filter/urftopdf-urftopdf.obj: filter/urftopdf.cpp
-@am__fastdepCXX_TRUE@	$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(urftopdf_CXXFLAGS) $(CXXFLAGS) -MT filter/urftopdf-urftopdf.obj -MD -MP -MF filter/$(DEPDIR)/urftopdf-urftopdf.Tpo -c -o filter/urftopdf-urftopdf.obj `if test -f 'filter/urftopdf.cpp'; then $(CYGPATH_W) 'filter/urftopdf.cpp'; else $(CYGPATH_W) '$(srcdir)/filter/urftopdf.cpp'; fi`
-@am__fastdepCXX_TRUE@	$(AM_V_at)$(am__mv) filter/$(DEPDIR)/urftopdf-urftopdf.Tpo filter/$(DEPDIR)/urftopdf-urftopdf.Po
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	$(AM_V_CXX)source='filter/urftopdf.cpp' object='filter/urftopdf-urftopdf.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCXX_FALSE@	$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(urftopdf_CXXFLAGS) $(CXXFLAGS) -c -o filter/urftopdf-urftopdf.obj `if test -f 'filter/urftopdf.cpp'; then $(CYGPATH_W) 'filter/urftopdf.cpp'; else $(CYGPATH_W) '$(srcdir)/filter/urftopdf.cpp'; fi`
-
 .cpp.o:
 @am__fastdepCXX_TRUE@	$(AM_V_CXX)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.o$$||'`;\
 @am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ $< &&\
@@ -4455,7 +3206,6 @@ mostlyclean-libtool:
 clean-libtool:
 	-rm -rf .libs _libs
 	-rm -rf cupsfilters/.libs cupsfilters/_libs
-	-rm -rf fontembed/.libs fontembed/_libs
 	-rm -rf scripting/php/.libs scripting/php/_libs
 
 distclean-libtool:
@@ -4778,27 +3528,7 @@ uninstall-pkgfiltersincludeDATA:
 	@list='$(pkgfiltersinclude_DATA)'; test -n "$(pkgfiltersincludedir)" || list=; \
 	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
 	dir='$(DESTDIR)$(pkgfiltersincludedir)'; $(am__uninstall_files_from_dir)
-install-pkgfontembedincludeDATA: $(pkgfontembedinclude_DATA)
-	@$(NORMAL_INSTALL)
-	@list='$(pkgfontembedinclude_DATA)'; test -n "$(pkgfontembedincludedir)" || list=; \
-	if test -n "$$list"; then \
-	  echo " $(MKDIR_P) '$(DESTDIR)$(pkgfontembedincludedir)'"; \
-	  $(MKDIR_P) "$(DESTDIR)$(pkgfontembedincludedir)" || exit 1; \
-	fi; \
-	for p in $$list; do \
-	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
-	  echo "$$d$$p"; \
-	done | $(am__base_list) | \
-	while read files; do \
-	  echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(pkgfontembedincludedir)'"; \
-	  $(INSTALL_DATA) $$files "$(DESTDIR)$(pkgfontembedincludedir)" || exit $$?; \
-	done
 
-uninstall-pkgfontembedincludeDATA:
-	@$(NORMAL_UNINSTALL)
-	@list='$(pkgfontembedinclude_DATA)'; test -n "$(pkgfontembedincludedir)" || list=; \
-	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
-	dir='$(DESTDIR)$(pkgfontembedincludedir)'; $(am__uninstall_files_from_dir)
 install-pkgmimeDATA: $(pkgmime_DATA)
 	@$(NORMAL_INSTALL)
 	@list='$(pkgmime_DATA)'; test -n "$(pkgmimedir)" || list=; \
@@ -5117,41 +3847,6 @@ testdither.log: testdither$(EXEEXT)
 	--log-file $$b.log --trs-file $$b.trs \
 	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
 	"$$tst" $(AM_TESTS_FD_REDIRECT)
-test_analyze.log: test_analyze$(EXEEXT)
-	@p='test_analyze$(EXEEXT)'; \
-	b='test_analyze'; \
-	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
-	--log-file $$b.log --trs-file $$b.trs \
-	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
-	"$$tst" $(AM_TESTS_FD_REDIRECT)
-test_pdf.log: test_pdf$(EXEEXT)
-	@p='test_pdf$(EXEEXT)'; \
-	b='test_pdf'; \
-	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
-	--log-file $$b.log --trs-file $$b.trs \
-	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
-	"$$tst" $(AM_TESTS_FD_REDIRECT)
-test_ps.log: test_ps$(EXEEXT)
-	@p='test_ps$(EXEEXT)'; \
-	b='test_ps'; \
-	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
-	--log-file $$b.log --trs-file $$b.trs \
-	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
-	"$$tst" $(AM_TESTS_FD_REDIRECT)
-test_pdf1.log: test_pdf1$(EXEEXT)
-	@p='test_pdf1$(EXEEXT)'; \
-	b='test_pdf1'; \
-	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
-	--log-file $$b.log --trs-file $$b.trs \
-	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
-	"$$tst" $(AM_TESTS_FD_REDIRECT)
-test_pdf2.log: test_pdf2$(EXEEXT)
-	@p='test_pdf2$(EXEEXT)'; \
-	b='test_pdf2'; \
-	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
-	--log-file $$b.log --trs-file $$b.trs \
-	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
-	"$$tst" $(AM_TESTS_FD_REDIRECT)
 .test.log:
 	@p='$<'; \
 	$(am__set_b); \
@@ -5367,7 +4062,7 @@ install-binPROGRAMS: install-libLTLIBRARIES
 
 installdirs: installdirs-recursive
 installdirs-am:
-	for dir in "$(DESTDIR)$(bindir)" "$(DESTDIR)$(pkgbackenddir)" "$(DESTDIR)$(pkgfilterdir)" "$(DESTDIR)$(pkgppdgendir)" "$(DESTDIR)$(sbindir)" "$(DESTDIR)$(libdir)" "$(DESTDIR)$(phpextensiondir)" "$(DESTDIR)$(initrcdir)" "$(DESTDIR)$(pkgbrailledir)" "$(DESTDIR)$(pkgfilterdir)" "$(DESTDIR)$(pkgfilterdir)" "$(DESTDIR)$(man1dir)" "$(DESTDIR)$(man5dir)" "$(DESTDIR)$(man8dir)" "$(DESTDIR)$(docdir)" "$(DESTDIR)$(pkgppdcdir)" "$(DESTDIR)$(pkgbannerdir)" "$(DESTDIR)$(pkgcharsetdir)" "$(DESTDIR)$(pkgconfdir)" "$(DESTDIR)$(pkgcupsdatadir)" "$(DESTDIR)$(pkgcupsserverrootdir)" "$(DESTDIR)$(pkgdriverdir)" "$(DESTDIR)$(pkgfiltersincludedir)" "$(DESTDIR)$(pkgfontembedincludedir)" "$(DESTDIR)$(pkgmimedir)" "$(DESTDIR)$(pkgppdcdir)" "$(DESTDIR)$(ppddir)"; do \
+	for dir in "$(DESTDIR)$(bindir)" "$(DESTDIR)$(pkgbackenddir)" "$(DESTDIR)$(pkgfilterdir)" "$(DESTDIR)$(pkgppdgendir)" "$(DESTDIR)$(sbindir)" "$(DESTDIR)$(libdir)" "$(DESTDIR)$(phpextensiondir)" "$(DESTDIR)$(initrcdir)" "$(DESTDIR)$(pkgbrailledir)" "$(DESTDIR)$(pkgfilterdir)" "$(DESTDIR)$(pkgfilterdir)" "$(DESTDIR)$(man1dir)" "$(DESTDIR)$(man5dir)" "$(DESTDIR)$(man8dir)" "$(DESTDIR)$(docdir)" "$(DESTDIR)$(pkgppdcdir)" "$(DESTDIR)$(pkgbannerdir)" "$(DESTDIR)$(pkgcharsetdir)" "$(DESTDIR)$(pkgconfdir)" "$(DESTDIR)$(pkgcupsdatadir)" "$(DESTDIR)$(pkgcupsserverrootdir)" "$(DESTDIR)$(pkgdriverdir)" "$(DESTDIR)$(pkgfiltersincludedir)" "$(DESTDIR)$(pkgmimedir)" "$(DESTDIR)$(pkgppdcdir)" "$(DESTDIR)$(ppddir)"; do \
 	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
 	done
 install: $(BUILT_SOURCES)
@@ -5409,10 +4104,6 @@ distclean-generic:
 	-rm -f filter/$(am__dirstamp)
 	-rm -f filter/foomatic-rip/$(DEPDIR)/$(am__dirstamp)
 	-rm -f filter/foomatic-rip/$(am__dirstamp)
-	-rm -f filter/pdftopdf/$(DEPDIR)/$(am__dirstamp)
-	-rm -f filter/pdftopdf/$(am__dirstamp)
-	-rm -f fontembed/$(DEPDIR)/$(am__dirstamp)
-	-rm -f fontembed/$(am__dirstamp)
 	-rm -f scripting/php/$(DEPDIR)/$(am__dirstamp)
 	-rm -f scripting/php/$(am__dirstamp)
 	-rm -f utils/$(DEPDIR)/$(am__dirstamp)
@@ -5464,7 +4155,6 @@ distclean: distclean-recursive
 	-rm -f cupsfilters/$(DEPDIR)/libcupsfilters_la-ipp.Plo
 	-rm -f cupsfilters/$(DEPDIR)/libcupsfilters_la-lut.Plo
 	-rm -f cupsfilters/$(DEPDIR)/libcupsfilters_la-pack.Plo
-	-rm -f cupsfilters/$(DEPDIR)/libcupsfilters_la-pdftoippprinter.Plo
 	-rm -f cupsfilters/$(DEPDIR)/libcupsfilters_la-ppdgenerator.Plo
 	-rm -f cupsfilters/$(DEPDIR)/libcupsfilters_la-raster.Plo
 	-rm -f cupsfilters/$(DEPDIR)/libcupsfilters_la-rgb.Plo
@@ -5473,74 +4163,26 @@ distclean: distclean-recursive
 	-rm -f cupsfilters/$(DEPDIR)/testdither.Po
 	-rm -f cupsfilters/$(DEPDIR)/testimage-testimage.Po
 	-rm -f cupsfilters/$(DEPDIR)/testrgb.Po
-	-rm -f filter/$(DEPDIR)/bannertopdf-banner.Po
-	-rm -f filter/$(DEPDIR)/bannertopdf-bannertopdf.Po
-	-rm -f filter/$(DEPDIR)/bannertopdf-getline.Po
-	-rm -f filter/$(DEPDIR)/bannertopdf-pdf.Po
 	-rm -f filter/$(DEPDIR)/commandtoescpx-commandtoescpx.Po
 	-rm -f filter/$(DEPDIR)/commandtopclx-commandtopclx.Po
 	-rm -f filter/$(DEPDIR)/gstoraster-gstoraster.Po
-	-rm -f filter/$(DEPDIR)/imagetopdf-common.Po
-	-rm -f filter/$(DEPDIR)/imagetopdf-imagetopdf.Po
 	-rm -f filter/$(DEPDIR)/imagetoraster-common.Po
 	-rm -f filter/$(DEPDIR)/imagetoraster-imagetoraster.Po
-	-rm -f filter/$(DEPDIR)/mupdftoraster-mupdftoraster.Po
-	-rm -f filter/$(DEPDIR)/pdf.Po
-	-rm -f filter/$(DEPDIR)/pdftops-common.Po
-	-rm -f filter/$(DEPDIR)/pdftops-pdftops.Po
-	-rm -f filter/$(DEPDIR)/pdftops-strcasestr.Po
-	-rm -f filter/$(DEPDIR)/pdftoraster-pdftoraster.Po
 	-rm -f filter/$(DEPDIR)/rastertoescpx-rastertoescpx.Po
 	-rm -f filter/$(DEPDIR)/rastertopclx-pcl-common.Po
 	-rm -f filter/$(DEPDIR)/rastertopclx-rastertopclx.Po
-	-rm -f filter/$(DEPDIR)/rastertopdf-rastertopdf.Po
-	-rm -f filter/$(DEPDIR)/rastertops-rastertops.Po
 	-rm -f filter/$(DEPDIR)/sys5ippprinter-common.Po
 	-rm -f filter/$(DEPDIR)/sys5ippprinter-strcasestr.Po
 	-rm -f filter/$(DEPDIR)/sys5ippprinter-sys5ippprinter.Po
-	-rm -f filter/$(DEPDIR)/test_pdf1-pdfutils.Po
-	-rm -f filter/$(DEPDIR)/test_pdf1-test_pdf1.Po
-	-rm -f filter/$(DEPDIR)/test_pdf2-pdfutils.Po
-	-rm -f filter/$(DEPDIR)/test_pdf2-test_pdf2.Po
-	-rm -f filter/$(DEPDIR)/texttopdf-common.Po
-	-rm -f filter/$(DEPDIR)/texttopdf-pdfutils.Po
-	-rm -f filter/$(DEPDIR)/texttopdf-textcommon.Po
-	-rm -f filter/$(DEPDIR)/texttopdf-texttopdf.Po
 	-rm -f filter/$(DEPDIR)/texttotext-strcasestr.Po
 	-rm -f filter/$(DEPDIR)/texttotext-texttotext.Po
-	-rm -f filter/$(DEPDIR)/urftopdf-urftopdf.Po
 	-rm -f filter/foomatic-rip/$(DEPDIR)/foomatic_rip-foomaticrip.Po
 	-rm -f filter/foomatic-rip/$(DEPDIR)/foomatic_rip-options.Po
-	-rm -f filter/foomatic-rip/$(DEPDIR)/foomatic_rip-pdf.Po
 	-rm -f filter/foomatic-rip/$(DEPDIR)/foomatic_rip-postscript.Po
 	-rm -f filter/foomatic-rip/$(DEPDIR)/foomatic_rip-process.Po
 	-rm -f filter/foomatic-rip/$(DEPDIR)/foomatic_rip-renderer.Po
 	-rm -f filter/foomatic-rip/$(DEPDIR)/foomatic_rip-spooler.Po
 	-rm -f filter/foomatic-rip/$(DEPDIR)/foomatic_rip-util.Po
-	-rm -f filter/pdftopdf/$(DEPDIR)/pdftopdf-intervalset.Po
-	-rm -f filter/pdftopdf/$(DEPDIR)/pdftopdf-nup.Po
-	-rm -f filter/pdftopdf/$(DEPDIR)/pdftopdf-pdftopdf.Po
-	-rm -f filter/pdftopdf/$(DEPDIR)/pdftopdf-pdftopdf_jcl.Po
-	-rm -f filter/pdftopdf/$(DEPDIR)/pdftopdf-pdftopdf_processor.Po
-	-rm -f filter/pdftopdf/$(DEPDIR)/pdftopdf-pptypes.Po
-	-rm -f filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_cm.Po
-	-rm -f filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_pdftopdf.Po
-	-rm -f filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_pdftopdf_processor.Po
-	-rm -f filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_tools.Po
-	-rm -f filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_xobject.Po
-	-rm -f fontembed/$(DEPDIR)/aglfn13.Plo
-	-rm -f fontembed/$(DEPDIR)/dynstring.Plo
-	-rm -f fontembed/$(DEPDIR)/embed.Plo
-	-rm -f fontembed/$(DEPDIR)/embed_pdf.Plo
-	-rm -f fontembed/$(DEPDIR)/embed_sfnt.Plo
-	-rm -f fontembed/$(DEPDIR)/fontfile.Plo
-	-rm -f fontembed/$(DEPDIR)/frequent.Plo
-	-rm -f fontembed/$(DEPDIR)/main.Po
-	-rm -f fontembed/$(DEPDIR)/sfnt.Plo
-	-rm -f fontembed/$(DEPDIR)/sfnt_subset.Plo
-	-rm -f fontembed/$(DEPDIR)/test_analyze.Po
-	-rm -f fontembed/$(DEPDIR)/test_pdf.Po
-	-rm -f fontembed/$(DEPDIR)/test_ps.Po
 	-rm -f scripting/php/$(DEPDIR)/libphpcups_la-phpcups.Plo
 	-rm -f utils/$(DEPDIR)/cups_browsed-cups-browsed.Po
 	-rm -f utils/$(DEPDIR)/driverless-driverless.Po
@@ -5568,7 +4210,7 @@ install-data-am: install-docDATA install-initrcSCRIPTS install-man \
 	install-pkgconfDATA install-pkgcupsdataDATA \
 	install-pkgcupsserverrootDATA install-pkgdriverDATA \
 	install-pkgfilterPROGRAMS install-pkgfilterSCRIPTS \
-	install-pkgfiltersincludeDATA install-pkgfontembedincludeDATA \
+	install-pkgfiltersincludeDATA \
 	install-pkgmimeDATA install-pkgppdcDATA \
 	install-pkgppdgenPROGRAMS install-ppdDATA
 	@$(NORMAL_INSTALL)
@@ -5591,14 +4233,6 @@ install-info-am:
 
 install-man: install-man1 install-man5 install-man8
 
-install-pdf: install-pdf-recursive
-
-install-pdf-am:
-
-install-ps: install-ps-recursive
-
-install-ps-am:
-
 installcheck-am:
 
 maintainer-clean: maintainer-clean-recursive
@@ -5636,7 +4270,6 @@ maintainer-clean: maintainer-clean-recursive
 	-rm -f cupsfilters/$(DEPDIR)/libcupsfilters_la-ipp.Plo
 	-rm -f cupsfilters/$(DEPDIR)/libcupsfilters_la-lut.Plo
 	-rm -f cupsfilters/$(DEPDIR)/libcupsfilters_la-pack.Plo
-	-rm -f cupsfilters/$(DEPDIR)/libcupsfilters_la-pdftoippprinter.Plo
 	-rm -f cupsfilters/$(DEPDIR)/libcupsfilters_la-ppdgenerator.Plo
 	-rm -f cupsfilters/$(DEPDIR)/libcupsfilters_la-raster.Plo
 	-rm -f cupsfilters/$(DEPDIR)/libcupsfilters_la-rgb.Plo
@@ -5645,74 +4278,26 @@ maintainer-clean: maintainer-clean-recursive
 	-rm -f cupsfilters/$(DEPDIR)/testdither.Po
 	-rm -f cupsfilters/$(DEPDIR)/testimage-testimage.Po
 	-rm -f cupsfilters/$(DEPDIR)/testrgb.Po
-	-rm -f filter/$(DEPDIR)/bannertopdf-banner.Po
-	-rm -f filter/$(DEPDIR)/bannertopdf-bannertopdf.Po
-	-rm -f filter/$(DEPDIR)/bannertopdf-getline.Po
-	-rm -f filter/$(DEPDIR)/bannertopdf-pdf.Po
 	-rm -f filter/$(DEPDIR)/commandtoescpx-commandtoescpx.Po
 	-rm -f filter/$(DEPDIR)/commandtopclx-commandtopclx.Po
 	-rm -f filter/$(DEPDIR)/gstoraster-gstoraster.Po
-	-rm -f filter/$(DEPDIR)/imagetopdf-common.Po
-	-rm -f filter/$(DEPDIR)/imagetopdf-imagetopdf.Po
 	-rm -f filter/$(DEPDIR)/imagetoraster-common.Po
 	-rm -f filter/$(DEPDIR)/imagetoraster-imagetoraster.Po
-	-rm -f filter/$(DEPDIR)/mupdftoraster-mupdftoraster.Po
-	-rm -f filter/$(DEPDIR)/pdf.Po
-	-rm -f filter/$(DEPDIR)/pdftops-common.Po
-	-rm -f filter/$(DEPDIR)/pdftops-pdftops.Po
-	-rm -f filter/$(DEPDIR)/pdftops-strcasestr.Po
-	-rm -f filter/$(DEPDIR)/pdftoraster-pdftoraster.Po
 	-rm -f filter/$(DEPDIR)/rastertoescpx-rastertoescpx.Po
 	-rm -f filter/$(DEPDIR)/rastertopclx-pcl-common.Po
 	-rm -f filter/$(DEPDIR)/rastertopclx-rastertopclx.Po
-	-rm -f filter/$(DEPDIR)/rastertopdf-rastertopdf.Po
-	-rm -f filter/$(DEPDIR)/rastertops-rastertops.Po
 	-rm -f filter/$(DEPDIR)/sys5ippprinter-common.Po
 	-rm -f filter/$(DEPDIR)/sys5ippprinter-strcasestr.Po
 	-rm -f filter/$(DEPDIR)/sys5ippprinter-sys5ippprinter.Po
-	-rm -f filter/$(DEPDIR)/test_pdf1-pdfutils.Po
-	-rm -f filter/$(DEPDIR)/test_pdf1-test_pdf1.Po
-	-rm -f filter/$(DEPDIR)/test_pdf2-pdfutils.Po
-	-rm -f filter/$(DEPDIR)/test_pdf2-test_pdf2.Po
-	-rm -f filter/$(DEPDIR)/texttopdf-common.Po
-	-rm -f filter/$(DEPDIR)/texttopdf-pdfutils.Po
-	-rm -f filter/$(DEPDIR)/texttopdf-textcommon.Po
-	-rm -f filter/$(DEPDIR)/texttopdf-texttopdf.Po
 	-rm -f filter/$(DEPDIR)/texttotext-strcasestr.Po
 	-rm -f filter/$(DEPDIR)/texttotext-texttotext.Po
-	-rm -f filter/$(DEPDIR)/urftopdf-urftopdf.Po
 	-rm -f filter/foomatic-rip/$(DEPDIR)/foomatic_rip-foomaticrip.Po
 	-rm -f filter/foomatic-rip/$(DEPDIR)/foomatic_rip-options.Po
-	-rm -f filter/foomatic-rip/$(DEPDIR)/foomatic_rip-pdf.Po
 	-rm -f filter/foomatic-rip/$(DEPDIR)/foomatic_rip-postscript.Po
 	-rm -f filter/foomatic-rip/$(DEPDIR)/foomatic_rip-process.Po
 	-rm -f filter/foomatic-rip/$(DEPDIR)/foomatic_rip-renderer.Po
 	-rm -f filter/foomatic-rip/$(DEPDIR)/foomatic_rip-spooler.Po
 	-rm -f filter/foomatic-rip/$(DEPDIR)/foomatic_rip-util.Po
-	-rm -f filter/pdftopdf/$(DEPDIR)/pdftopdf-intervalset.Po
-	-rm -f filter/pdftopdf/$(DEPDIR)/pdftopdf-nup.Po
-	-rm -f filter/pdftopdf/$(DEPDIR)/pdftopdf-pdftopdf.Po
-	-rm -f filter/pdftopdf/$(DEPDIR)/pdftopdf-pdftopdf_jcl.Po
-	-rm -f filter/pdftopdf/$(DEPDIR)/pdftopdf-pdftopdf_processor.Po
-	-rm -f filter/pdftopdf/$(DEPDIR)/pdftopdf-pptypes.Po
-	-rm -f filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_cm.Po
-	-rm -f filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_pdftopdf.Po
-	-rm -f filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_pdftopdf_processor.Po
-	-rm -f filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_tools.Po
-	-rm -f filter/pdftopdf/$(DEPDIR)/pdftopdf-qpdf_xobject.Po
-	-rm -f fontembed/$(DEPDIR)/aglfn13.Plo
-	-rm -f fontembed/$(DEPDIR)/dynstring.Plo
-	-rm -f fontembed/$(DEPDIR)/embed.Plo
-	-rm -f fontembed/$(DEPDIR)/embed_pdf.Plo
-	-rm -f fontembed/$(DEPDIR)/embed_sfnt.Plo
-	-rm -f fontembed/$(DEPDIR)/fontfile.Plo
-	-rm -f fontembed/$(DEPDIR)/frequent.Plo
-	-rm -f fontembed/$(DEPDIR)/main.Po
-	-rm -f fontembed/$(DEPDIR)/sfnt.Plo
-	-rm -f fontembed/$(DEPDIR)/sfnt_subset.Plo
-	-rm -f fontembed/$(DEPDIR)/test_analyze.Po
-	-rm -f fontembed/$(DEPDIR)/test_pdf.Po
-	-rm -f fontembed/$(DEPDIR)/test_ps.Po
 	-rm -f scripting/php/$(DEPDIR)/libphpcups_la-phpcups.Plo
 	-rm -f utils/$(DEPDIR)/cups_browsed-cups-browsed.Po
 	-rm -f utils/$(DEPDIR)/driverless-driverless.Po
@@ -5724,14 +4309,6 @@ mostlyclean: mostlyclean-recursive
 mostlyclean-am: mostlyclean-compile mostlyclean-generic \
 	mostlyclean-libtool
 
-pdf: pdf-recursive
-
-pdf-am:
-
-ps: ps-recursive
-
-ps-am:
-
 uninstall-am: uninstall-binPROGRAMS uninstall-docDATA \
 	uninstall-initrcSCRIPTS uninstall-libLTLIBRARIES uninstall-man \
 	uninstall-nodist_pkgbrailleSCRIPTS \
@@ -5742,7 +4319,7 @@ uninstall-am: uninstall-binPROGRAMS uninstall-docDATA \
 	uninstall-pkgcupsserverrootDATA uninstall-pkgdriverDATA \
 	uninstall-pkgfilterPROGRAMS uninstall-pkgfilterSCRIPTS \
 	uninstall-pkgfiltersincludeDATA \
-	uninstall-pkgfontembedincludeDATA uninstall-pkgmimeDATA \
+	uninstall-pkgmimeDATA \
 	uninstall-pkgppdcDATA uninstall-pkgppdgenPROGRAMS \
 	uninstall-ppdDATA uninstall-sbinPROGRAMS
 	@$(NORMAL_INSTALL)
@@ -5772,19 +4349,19 @@ uninstall-man: uninstall-man1 uninstall-man5 uninstall-man8
 	install-man1 install-man5 install-man8 \
 	install-nodist_pkgbrailleSCRIPTS \
 	install-nodist_pkgfilterSCRIPTS install-nodist_pkgppdcDATA \
-	install-pdf install-pdf-am install-phpextensionLTLIBRARIES \
+	install-phpextensionLTLIBRARIES \
 	install-pkgbackendPROGRAMS install-pkgbannerDATA \
 	install-pkgcharsetDATA install-pkgconfDATA \
 	install-pkgcupsdataDATA install-pkgcupsserverrootDATA \
 	install-pkgdriverDATA install-pkgfilterPROGRAMS \
 	install-pkgfilterSCRIPTS install-pkgfiltersincludeDATA \
-	install-pkgfontembedincludeDATA install-pkgmimeDATA \
+	install-pkgmimeDATA \
 	install-pkgppdcDATA install-pkgppdgenPROGRAMS install-ppdDATA \
 	install-ps install-ps-am install-sbinPROGRAMS install-strip \
 	installcheck installcheck-am installdirs installdirs-am \
 	maintainer-clean maintainer-clean-generic mostlyclean \
 	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
-	pdf pdf-am ps ps-am recheck tags tags-am uninstall \
+	recheck tags tags-am uninstall \
 	uninstall-am uninstall-binPROGRAMS uninstall-docDATA \
 	uninstall-hook uninstall-initrcSCRIPTS \
 	uninstall-libLTLIBRARIES uninstall-man uninstall-man1 \
@@ -5797,7 +4374,7 @@ uninstall-man: uninstall-man1 uninstall-man5 uninstall-man8
 	uninstall-pkgcupsserverrootDATA uninstall-pkgdriverDATA \
 	uninstall-pkgfilterPROGRAMS uninstall-pkgfilterSCRIPTS \
 	uninstall-pkgfiltersincludeDATA \
-	uninstall-pkgfontembedincludeDATA uninstall-pkgmimeDATA \
+	uninstall-pkgmimeDATA \
 	uninstall-pkgppdcDATA uninstall-pkgppdgenPROGRAMS \
 	uninstall-ppdDATA uninstall-sbinPROGRAMS
 
@@ -5839,12 +4416,6 @@ install-exec-hook:
 @ENABLE_DRIVERLESS_TRUE@	$(LN_SRF) $(DESTDIR)$(pkgppdgendir)/driverless $(DESTDIR)$(bindir)
 @ENABLE_DRIVERLESS_TRUE@	$(LN_SRF) $(DESTDIR)$(pkgppdgendir)/driverless $(DESTDIR)$(pkgbackenddir)
 @ENABLE_BRAILLE_TRUE@	$(LN_S) -f imagetobrf $(DESTDIR)$(pkgfilterdir)/imagetoubrl
-@ENABLE_BRAILLE_TRUE@	$(LN_S) -f vectortopdf $(DESTDIR)$(pkgfilterdir)/svgtopdf
-@ENABLE_BRAILLE_TRUE@	$(LN_S) -f vectortopdf $(DESTDIR)$(pkgfilterdir)/xfigtopdf
-@ENABLE_BRAILLE_TRUE@	$(LN_S) -f vectortopdf $(DESTDIR)$(pkgfilterdir)/wmftopdf
-@ENABLE_BRAILLE_TRUE@	$(LN_S) -f vectortopdf $(DESTDIR)$(pkgfilterdir)/emftopdf
-@ENABLE_BRAILLE_TRUE@	$(LN_S) -f vectortopdf $(DESTDIR)$(pkgfilterdir)/cgmtopdf
-@ENABLE_BRAILLE_TRUE@	$(LN_S) -f vectortopdf $(DESTDIR)$(pkgfilterdir)/cmxtopdf
 @ENABLE_BRAILLE_TRUE@	$(LN_S) -f vectortobrf $(DESTDIR)$(pkgfilterdir)/vectortoubrl
 @ENABLE_BRAILLE_TRUE@	$(LN_S) -f textbrftoindexv3 $(DESTDIR)$(pkgfilterdir)/textbrftoindexv4
 
@@ -5871,12 +4442,6 @@ uninstall-hook:
 @ENABLE_DRIVERLESS_TRUE@	$(RM) $(DESTDIR)$(bindir)/driverless
 @ENABLE_DRIVERLESS_TRUE@	$(RM) $(DESTDIR)$(pkgbackenddir)/driverless
 @ENABLE_BRAILLE_TRUE@	$(RM) $(DESTDIR)$(pkgfilterdir)/imagetoubrl
-@ENABLE_BRAILLE_TRUE@	$(RM) $(DESTDIR)$(pkgfilterdir)/svgtopdf
-@ENABLE_BRAILLE_TRUE@	$(RM) $(DESTDIR)$(pkgfilterdir)/xfigtopdf
-@ENABLE_BRAILLE_TRUE@	$(RM) $(DESTDIR)$(pkgfilterdir)/wmftopdf
-@ENABLE_BRAILLE_TRUE@	$(RM) $(DESTDIR)$(pkgfilterdir)/emftopdf
-@ENABLE_BRAILLE_TRUE@	$(RM) $(DESTDIR)$(pkgfilterdir)/cgmtopdf
-@ENABLE_BRAILLE_TRUE@	$(RM) $(DESTDIR)$(pkgfilterdir)/cmxtopdf
 @ENABLE_BRAILLE_TRUE@	$(RM) $(DESTDIR)$(pkgfilterdir)/vectortoubrl
 @ENABLE_BRAILLE_TRUE@	$(RM) $(DESTDIR)$(pkgfilterdir)/textbrftoindexv4
 
diff --git a/backend/implicitclass.c b/backend/implicitclass.c
index 3ec5d81..f949a6c 100644
--- a/backend/implicitclass.c
+++ b/backend/implicitclass.c
@@ -28,7 +28,6 @@
 #include <cups/cups.h>
 #include <sys/types.h>
 #include <sys/wait.h>
-#include <cupsfilters/pdftoippprinter.h>
 
 /*
  * Local globals...
@@ -321,11 +320,6 @@ main(int  argc,				/* I - Number of command-line args */
       /* Filter pdftoippprinter.c will read the input from this file*/
       argv_nt[6] = filename;
       argv_nt[7] = NULL;
-      set_option_in_str(argv_nt[5], outbuflen, "output-format",
-			document_format);
-      set_option_in_str(argv_nt[5], outbuflen, "Resolution",resolution);
-      set_option_in_str(argv_nt[5], outbuflen, "cups-browsed-dest-printer",NULL);
-      set_option_in_str(argv_nt[5], outbuflen, "cups-browsed",NULL);
       setenv("DEVICE_URI",printer_uri, 1);
       fprintf(stderr, "Setting the device uri to  %s\n",printer_uri);
       fprintf(stderr, "Changed the argv[5] to %s\n",argv_nt[5]);
@@ -345,9 +339,6 @@ main(int  argc,				/* I - Number of command-line args */
       }
       close(filefd);
 
-      /* Calling pdftoippprinter.c filter*/
-      apply_filters(7,argv_nt);
-
       /* Reset stdout to standard */
       dup2(savestdout, 1);
       close(savestdout);
diff --git a/configure b/configure
index a54ede6..af95f24 100755
--- a/configure
+++ b/configure
@@ -21641,7 +21641,7 @@ fi
 	# Put the nasty error message in config.log where it belongs
 	echo "$GIO_PKG_ERRORS" >&5
 
-	as_fn_error $? "Package requirements (gio-2.0) were not met:
+	$as_echo $? "Package requirements (gio-2.0) were not met:
 
 $GIO_PKG_ERRORS
 
@@ -22017,7 +22017,7 @@ fi
 	# Put the nasty error message in config.log where it belongs
 	echo "$LCMS_PKG_ERRORS" >&5
 
-	as_fn_error $? "Package requirements (lcms) were not met:
+	$as_echo $? "Package requirements (lcms) were not met:
 
 $LCMS_PKG_ERRORS
 
@@ -22391,7 +22391,7 @@ fi
 	# Put the nasty error message in config.log where it belongs
 	echo "$LIBQPDF_PKG_ERRORS" >&5
 
-	as_fn_error $? "Package requirements (libqpdf >= 8.3.0) were not met:
+	$as_echo $? "Package requirements (libqpdf >= 8.3.0) were not met:
 
 $LIBQPDF_PKG_ERRORS
 
diff --git a/cupsfilters/pdftoippprinter.c b/cupsfilters/pdftoippprinter.c
deleted file mode 100644
index ea5427b..0000000
--- a/cupsfilters/pdftoippprinter.c
+++ /dev/null
@@ -1,912 +0,0 @@
-/*
- *   pdftoippprinter.c
- *
- *   Function to convert PDF into PWG/Apple Raster and PCLm for printing
- *   on driverless IPP printers.
- *
- *   Copyright 2007-2011 by Apple Inc.
- *   Copyright 1997-2006 by Easy Software Products.
- *   Copyright 2011-2013 by Till Kamppeter
- *
- * Contents:
- *
- *   apply_filters()     - Main function...
- *   cancel_job()        - Flag the job as canceled.
- *   filter_present()    - Is the requested filter actually installed?
- *   compare_pids()      - Compare process IDs for sorting PID list
- *   exec_filter()       - Execute a filter process
- *   exec_filters()      - Execute a filter chain
- *   open_pipe()         - Create a pipe to transfer data from filter to filter
- *   get_option_in_str() - Get an option value from a string like argv[5]
- *   set_option_in_str() - Set an option value in a string like argv[5]
- */
-
-/*
- * Include necessary headers...
- */
-
-#include <config.h>
-#include <cups/cups.h>
-#include <cups/ppd.h>
-#include <cups/file.h>
-#include <signal.h>
-#include <sys/wait.h>
-#include <limits.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <errno.h>
-#include <string.h>
-#include <ctype.h>
-#include <cupsfilters/image-private.h>
-
-#define MAX_CHECK_COMMENT_LINES	20
-
-/*
- * Type definitions
- */
-
-typedef unsigned output_format_t;
-enum output_format_e {PDF = 0, POSTSCRIPT = 1, PWGRASTER = 2, PCLXL = 3, PCL = 4, APPLERASTER = 5, PCLM = 6};
-typedef struct filter_pid_s             /* Filter in filter chain */
-{
-  char          *name;                  /* Filter executable name */
-  int           pid;                    /* PID of filter process */
-} filter_pid_t;
-
-/*
- * Local functions...
- */
-
-static void		cancel_job(int sig);
-static int              filter_present(const char *filter);
-static int		compare_pids(filter_pid_t *a, filter_pid_t *b);
-static int		exec_filter(const char *filter, char **argv,
-			            int infd, int outfd);
-static int		exec_filters(cups_array_t *filters, char **argv);
-static int		open_pipe(int *fds);
-static char*		get_option_in_str(char *buf, const char *option,
-					  int return_value);
-
-
-/*
- * Local globals...
- */
-
-static int		job_canceled = 0;
-
-/*
- * Set an option in a string of options
- */
-
-void          /* O - 0 on success, 1 on error */
-set_option_in_str(char *buf,          /* I - Buffer with option list string */
-      int buflen,         /* I - Length of buffer */
-      const char *option, /* I - Option to change/add */
-      const char *value)  /* I - New value for option, NULL
-               removes option */
-{
-  char *p1, *p2, *p3;
-
-  if (!buf || buflen == 0 || !option)
-    return;
-  /* Remove any occurrence of option in the string */
-  p1 = buf;
-  while (*p1 != '\0' && (p2 = strcasestr(p1, option)) != NULL) {
-    if (p2 > buf && *(p2 - 1) != ' ' && *(p2 - 1) != '\t') {
-      p1 = p2 + 1;
-      continue;
-    }
-    p1 = p2 + strlen(option);
-    if(!strcmp(option,"cups-browsed")){
-      fprintf(stderr, "DEBUG: Removing option cups-browsed if it is present\n");
-    }else if (*p1 != '=' && *p1 != ' ' && *p1 != '\t' && *p1 != '\0')
-      continue;
-    if(!strcmp(option,"cups-browsed-dest-printer")){
-      fprintf(stderr, "DEBUG: Removing cups-browsed-dest-printer option from arguments\n");
-      p3 = strchr(p1, '"');
-      p3++;
-      p1 = strchr(p3, '"');
-    }
-    while (*p1 != ' ' && *p1 != '\t' && *p1 != '\0') p1 ++;
-    while ((*p1 == ' ' || *p1 == '\t') && *p1 != '\0') p1 ++;
-    memmove(p2, p1, strlen(buf) - (p1 - buf) + 1);
-    p1 = p2;
-  }
-  /* Add option=value to the end of the string */
-  if (!value)
-    return;
-  p1 = buf + strlen(buf);
-  *p1 = ' ';
-  p1 ++;
-  snprintf(p1, buflen - (p1 - buf), "%s=%s", option, value);
-  buf[buflen - 1] = '\0';
-}
-
-
-/*
- * 'apply_filters()' - Main function...
- */
-
-int 
-apply_filters(int argc, char *argv[])
-{
-  int		i;			/* Looping var */
-  output_format_t    output_format;     /* Output format */
-  int		fd = 0;			/* Copy file descriptor */
-  char		*filename,		/* PDF file to convert */
-		tempfile[1024];		/* Temporary file */
-  char		buffer[8192];		/* Copy buffer */
-  int		bytes;			/* Bytes copied */
-  int		num_options;		/* Number of options */
-  cups_option_t	*options;		/* Options */
-  const char	*val;			/* Option value */
-  char	        *argv_nt[8];		/* NULL-terminated array of the command
-					   line arguments */
-  int           optbuflen;
-  cups_array_t  *filter_chain;          /* Filter chain to execute */
-  int		exit_status = 0;	/* Exit status */
-  int		color_printing;		/* Do we print in color? */
-  char		*filter, *p;
-#if defined(HAVE_SIGACTION) && !defined(HAVE_SIGSET)
-  struct sigaction action;		/* Actions for POSIX signals */
-#endif /* HAVE_SIGACTION && !HAVE_SIGSET */
-  static const char * const color_mode_option_names[] =
-    {	/* Possible names for a color mode option */
-      "pwg-raster-document-type",
-      "PwgRasterDocumentType",
-      "print-color-mode",
-      "PrintColorMode",
-      "color-space",
-      "ColorSpace",
-      "color-model",
-      "ColorModel",
-      NULL
-    };
-
-
- /*
-  * Make sure status messages are not buffered...
-  */
-
-  setbuf(stderr, NULL);
-
- /*
-  * Ignore broken pipe signals...
-  */
-
-  signal(SIGPIPE, SIG_IGN);
-
- /*
-  * Make sure we have the right number of arguments for CUPS!
-  */
-
-  if (argc < 6 || argc > 7)
-  {
-    fprintf(stderr, "Usage: %s job user title copies options [file]\n",
-	    argv[0]);
-    return (1);
-  }
-
- /*
-  * Register a signal handler to cleanly cancel a job.
-  */
-
-#ifdef HAVE_SIGSET /* Use System V signals over POSIX to avoid bugs */
-  sigset(SIGTERM, cancel_job);
-#elif defined(HAVE_SIGACTION)
-  memset(&action, 0, sizeof(action));
-
-  sigemptyset(&action.sa_mask);
-  action.sa_handler = cancel_job;
-  sigaction(SIGTERM, &action, NULL);
-#else
-  signal(SIGTERM, cancel_job);
-#endif /* HAVE_SIGSET */
-
- /*
-  * Copy stdin if needed...
-  */
-
-  if (argc == 6) {
-   /*
-    * Copy stdin to a temp file...
-    */
-
-    if ((fd = cupsTempFd(tempfile, sizeof(tempfile))) < 0) {
-      perror("DEBUG: Unable to copy PDF file");
-      return (1);
-    }
-
-    fprintf(stderr,
-	    "DEBUG: sys5ippprinter - copying to temp print file \"%s\"\n",
-            tempfile);
-
-    while ((bytes = fread(buffer, 1, sizeof(buffer), stdin)) > 0)
-      bytes = write(fd, buffer, bytes);
-
-    close(fd);
-
-    filename = tempfile;
-  } else {
-   /*
-    * Use the filename on the command-line...
-    */
-
-    filename    = argv[6];
-    tempfile[0] = '\0';
-  }
-
- /*
-  * Get the options from the fifth command line argument
-  */
-
-  num_options = cupsParseOptions(argv[5], 0, &options);
-
- /*
-  * Copy the command line arguments into a NULL-terminated array
-  */
-
-  for (i = 0; i < 5; i++)
-    argv_nt[i] = argv[i];
-  /* We copy the contents of argv[5] into a somewhat larger buffer so that
-     we can manipulate it */
-  optbuflen = strlen(argv[5]) + 256;
-  argv_nt[5] = calloc(optbuflen, sizeof(char));
-  strcpy(argv_nt[5], (const char*)argv[5]);
-  argv_nt[6] = filename;
-  argv_nt[7] = NULL;
-
- /*
-  * Create filter chain
-  */
-
-  filter_chain = cupsArrayNew(NULL, NULL);
-
- /*
-  * Add the gziptoany filter if installed
-  */
-
-  if (filter_present("gziptoany"))
-    cupsArrayAdd(filter_chain, "gziptoany");
-
- /*
-  * Select the output format: PDF, PostScript, PWG Raster, PCL-XL, and
-  * PCL 5c/e
-  * Add the needed filters to the filter chain
-  */
-
-  if ((val = cupsGetOption("output-format", num_options, options)) != NULL) {
-    if (!strcmp(val, "raster")) {
-      output_format = PWGRASTER;
-      /* PWG Raster output */
-      set_option_in_str(argv_nt[5], optbuflen, "MediaClass", NULL);
-      set_option_in_str(argv_nt[5], optbuflen, "media-class", "pwg");
-      /* Page logging into page_log is not done by gstoraster/pdftoraster,
-	 so let it be done by pdftopdf */
-      set_option_in_str(argv_nt[5], optbuflen, "page-logging", "on");
-      if (filter_present("gstoraster") && access(CUPS_GHOSTSCRIPT, X_OK) == 0)
-	cupsArrayAdd(filter_chain, "gstoraster");
-      else {
-	fprintf(stderr,
-		"DEBUG: Filter gstoraster or Ghostscript (%s) missing for \"output-format=%s\", using pdftoraster.\n",
-		CUPS_GHOSTSCRIPT, val);
-	if (filter_present("pdftoraster"))
-	  cupsArrayAdd(filter_chain, "pdftoraster");
-	else {
-	  fprintf(stderr,
-		  "ERROR: Filter pdftoraster missing for \"output-format=%s\"\n",
-		  val);
-	  exit_status = 1;
-	  goto error;
-	}
-	setenv("FINAL_CONTENT_TYPE", "pwg", 1);
-      }
-    } else if (!strcmp(val, "apple-raster")) {
-      output_format = APPLERASTER;
-      /* PWG Raster output */
-      set_option_in_str(argv_nt[5], optbuflen, "MediaClass", NULL);
-      set_option_in_str(argv_nt[5], optbuflen, "media-class", "");
-      /* Page logging into page_log is not done by gstoraster/pdftoraster,
-	 so let it be done by pdftopdf */
-      set_option_in_str(argv_nt[5], optbuflen, "page-logging", "on");
-      if (filter_present("gstoraster") && access(CUPS_GHOSTSCRIPT, X_OK) == 0)
-	cupsArrayAdd(filter_chain, "gstoraster");
-      else {
-	fprintf(stderr,
-		"DEBUG: Filter gstoraster or Ghostscript (%s) missing for \"output-format=%s\", using pdftoraster.\n",
-		CUPS_GHOSTSCRIPT, val);
-	if (filter_present("pdftoraster"))
-	  cupsArrayAdd(filter_chain, "pdftoraster");
-	else {
-	  fprintf(stderr,
-		  "ERROR: Filter pdftoraster missing for \"output-format=%s\"\n",
-		  val);
-	  exit_status = 1;
-	  goto error;
-	}
-      }
-      if (filter_present("rastertopwg"))
-	cupsArrayAdd(filter_chain, "rastertopwg");
-      else {
-	fprintf(stderr,
-		"ERROR: Filter rastertopwg missing for \"output-format=%s\"\n",
-		val);
-	exit_status = 1;
-	goto error;
-      }
-      setenv("FINAL_CONTENT_TYPE", "image/urf", 1);
-    } else if (!strcmp(val, "pdf")) {
-      output_format = PDF;
-      /* Page logging into page_log has to be done by pdftopdf */
-      set_option_in_str(argv_nt[5], optbuflen, "page-logging", "on");
-    } else if (!strcmp(val, "postscript")) {
-      output_format = POSTSCRIPT;
-      /* Page logging into page_log is done by pstops, so no need by
-	 pdftopdf */
-      set_option_in_str(argv_nt[5], optbuflen, "page-logging", "off");
-      if (filter_present("pdftops")) {
-	cupsArrayAdd(filter_chain, "pdftops");
-	if (access(CUPS_GHOSTSCRIPT, X_OK) != 0) {
-	  fprintf(stderr,
-		  "DEBUG: Ghostscript (%s) missing for \"output-format=%s\", using Poppler's pdftops instead.\n",
-		  CUPS_GHOSTSCRIPT, val);
-	  set_option_in_str(argv_nt[5], optbuflen, "pdftops-renderer",
-			    "pdftops");
-	} else if (access(CUPS_POPPLER_PDFTOPS, X_OK) != 0) {
-	  fprintf(stderr,
-		  "DEBUG: Poppler's pdftops (%s) missing for \"output-format=%s\", using Ghostscript instead.\n",
-		  CUPS_POPPLER_PDFTOPS, val);
-	  set_option_in_str(argv_nt[5], optbuflen, "pdftops-renderer",
-			    "gs");
-	} else
-	  set_option_in_str(argv_nt[5], optbuflen, "pdftops-renderer",
-			    "hybrid");
-      } else {
-	fprintf(stderr,
-		"ERROR: Filter pdftops missing for \"output-format=%s\"\n",
-		val);
-	exit_status = 1;
-	goto error;
-      }
-    } else if ((p = strcasestr(val, "pcl")) != NULL) {
-      if (!strcasecmp(p, "pclxl")) {
-	output_format = PCLXL;
-	if (filter_present("gstopxl") && access(CUPS_GHOSTSCRIPT, X_OK) == 0) {
-	  cupsArrayAdd(filter_chain, "gstopxl");
-	  /* Page logging into page_log is not done by gstopxl,
-	     so let it be done by pdftopdf */
-	  set_option_in_str(argv_nt[5], optbuflen, "page-logging", "on");
-	} else {
-	  fprintf(stderr,
-		  "DEBUG: Filter gstopxl or Ghostscript (%s) missing for \"output-format=%s\", falling back to PCL 5c/e.\n",
-		  CUPS_GHOSTSCRIPT, val);
-	  output_format = PCL;
-	}
-      } else if (!strcasecmp(p, "pclm")) {
-	output_format = PCLM;
-	/* PWG Raster output */
-	set_option_in_str(argv_nt[5], optbuflen, "MediaClass", NULL);
-	set_option_in_str(argv_nt[5], optbuflen, "media-class", "");
-	/* Page logging into page_log is not done by gstoraster/pdftoraster,
-	   so let it be done by pdftopdf */
-	set_option_in_str(argv_nt[5], optbuflen, "page-logging", "on");
-	if (filter_present("gstoraster") && access(CUPS_GHOSTSCRIPT, X_OK) == 0)
-	  cupsArrayAdd(filter_chain, "gstoraster");
-	else {
-	  fprintf(stderr,
-		  "DEBUG: Filter gstoraster or Ghostscript (%s) missing for \"output-format=%s\", using pdftoraster.\n",
-		  CUPS_GHOSTSCRIPT, val);
-	  if (filter_present("pdftoraster"))
-	    cupsArrayAdd(filter_chain, "pdftoraster");
-	  else {
-	    fprintf(stderr,
-		    "ERROR: Filter pdftoraster missing for \"output-format=%s\"\n",
-		    val);
-	    exit_status = 1;
-	    goto error;
-	  }
-	}
-	if (filter_present("rastertopclm"))
-	  cupsArrayAdd(filter_chain, "rastertopclm");
-	else {
-	  fprintf(stderr,
-		  "ERROR: Filter rastertopclm missing for \"output-format=%s\"\n",
-		  val);
-	  exit_status = 1;
-	  goto error;
-	}
-      }
-      if (!strcasecmp(p, "pclxl")) {
-	output_format = PCLXL;
-	if (filter_present("gstopxl") && access(CUPS_GHOSTSCRIPT, X_OK) == 0) {
-	  cupsArrayAdd(filter_chain, "gstopxl");
-	  /* Page logging into page_log is not done by gstopxl,
-	     so let it be done by pdftopdf */
-	  set_option_in_str(argv_nt[5], optbuflen, "page-logging", "on");
-	} else {
-	  fprintf(stderr,
-		  "DEBUG: Filter gstopxl or Ghostscript (%s) missing for \"output-format=%s\", falling back to PCL 5c/e.\n",
-		  CUPS_GHOSTSCRIPT, val);
-	  output_format = PCL;
-	}
-      } else {
-	output_format = PCL;
-      }
-    } else {
-      fprintf(stderr,
-	      "ERROR: Invalid value for \"output-format\": \"%s\"\n", val);
-      exit_status = 1;
-      goto error;
-    }
-  } else {
-    fprintf(stderr,
-	    "ERROR: Missing option \"output-format\".\n");
-    exit_status = 1;
-    goto error;
-  }
-  if (output_format == PCL) {
-    /* We need CUPS Raster as we want to use rastertopclx with unprintable
-       margins */
-    set_option_in_str(argv_nt[5], optbuflen, "MediaClass", NULL);
-    set_option_in_str(argv_nt[5], optbuflen, "media-class", "");
-    /* Page logging into page_log is done by rastertopclx, so no need by
-       pdftopdf */
-    set_option_in_str(argv_nt[5], optbuflen, "page-logging", "off");
-    /* Does the client send info about margins? */
-    if (!get_option_in_str(argv_nt[5], "media-left-margin", 0) &&
-	!get_option_in_str(argv_nt[5], "media-right-margin", 0) &&
-	!get_option_in_str(argv_nt[5], "media-top-margin", 0) &&
-	!get_option_in_str(argv_nt[5], "media-bottom-margin", 0)) {
-      /* Set default 12pt margins if there is no info about printer's
-	 unprintable margins (100th of mm units, 12.0 * 2540.0 / 72.0 = 423.33)
-      */
-      set_option_in_str(argv_nt[5], optbuflen, "media-left-margin", "423.33");
-      set_option_in_str(argv_nt[5], optbuflen, "media-right-margin", "423.33");
-      set_option_in_str(argv_nt[5], optbuflen, "media-top-margin", "423.33");
-      set_option_in_str(argv_nt[5], optbuflen, "media-bottom-margin", "423.33");
-    }
-    /* Check whether the job is requested to be printed in color and if so,
-       set the color space to RGB as this is the best color printing support
-       in PCL 5c */
-    color_printing = 0;
-    for (i = 0; color_mode_option_names[i]; i ++) {
-      p = get_option_in_str(argv_nt[5], color_mode_option_names[i], 1);
-      if (p && (strcasestr(p, "RGB") || strcasestr(p, "CMY") ||
-		strcasestr(p, "color"))) {
-	color_printing = 1;
-	break;
-      }
-    }
-    if (color_printing == 1) {
-      /* Remove unneeded color mode options */
-      for (i = 0; color_mode_option_names[i]; i ++)
-	set_option_in_str(argv_nt[5], optbuflen, color_mode_option_names[i],
-			  NULL);
-      /* Set RGB as color mode */
-      set_option_in_str(argv_nt[5], optbuflen, "print-color-mode", "RGB");
-    }
-    if (filter_present("gstoraster") && access(CUPS_GHOSTSCRIPT, X_OK) == 0)
-      cupsArrayAdd(filter_chain, "gstoraster");
-    else {
-      fprintf(stderr,
-	      "DEBUG: Filter gstoraster or Ghostscript (%s) missing for \"output-format=%s\", using pdftoraster.\n",
-	      CUPS_GHOSTSCRIPT, val);
-      if (filter_present("pdftoraster"))
-	cupsArrayAdd(filter_chain, "pdftoraster");
-      else {
-	fprintf(stderr,
-		"ERROR: Filter pdftoraster missing for \"output-format=%s\"\n",
-		val);
-	exit_status = 1;
-	goto error;
-      }
-    }
-    if (filter_present("rastertopclx"))
-      cupsArrayAdd(filter_chain, "rastertopclx");
-    else {
-      fprintf(stderr,
-	      "ERROR: Filter rastertopclx missing for \"output-format=%s\"\n",
-	      val);
-      exit_status = 1;
-      goto error;
-    }
-  }
-
-  fprintf(stderr,
-	  "DEBUG: Printer supports output formats: %s\nDEBUG: Using following CUPS filter chain to convert input data to the %s format:",
-	  val,
-	  output_format == PDF ? "PDF" :
-	  (output_format == POSTSCRIPT ? "Postscript" :
-	   (output_format == PWGRASTER ? "PWG Raster" :
-	    (output_format == PCLXL ? "PCL XL" :
-	     (output_format == PCL ? "PCL 5c/e" : 
-	      (output_format == APPLERASTER ? "APPLE Raster" :
-	       (output_format == PCLM ? "PCLm" : "unknown")))))));
-  for (filter = (char *)cupsArrayFirst(filter_chain);
-       filter;
-       filter = (char *)cupsArrayNext(filter_chain))
-    fprintf(stderr, " %s", filter);
-  fprintf(stderr, "\n");
-
- /*
-  * Execute the filter chain
-  */
-
-  exit_status = exec_filters(filter_chain, (char **)argv_nt);
-
- /*
-  * Cleanup and exit...
-  */
-
- error:
-
-  if (tempfile[0])
-    unlink(tempfile);
-
-  return (exit_status);
-}
-
-
-/*
- * 'cancel_job()' - Flag the job as canceled.
- */
-
-static void
-cancel_job(int sig)			/* I - Signal number (unused) */
-{
-  (void)sig;
-
-  job_canceled = 1;
-}
-
-
-static int
-filter_present(const char *filter) /* I - Filter name */
-{
-  char		filter_path[1024]; /* Path to filter executable */
-  const char	*cups_serverbin;   /* CUPS_SERVERBIN environment variable */
-
-  if ((cups_serverbin = getenv("CUPS_SERVERBIN")) == NULL)
-    cups_serverbin = CUPS_SERVERBIN;
-
-  snprintf(filter_path, sizeof(filter_path), "%s/filter/%s",
-           cups_serverbin, filter);
-
-  if (access(filter_path, X_OK) == 0)
-    return 1;
-
-  return 0;
-}
-
-
-/*
- * 'compare_pids()' - Compare two filter PIDs...
- */
-
-static int				/* O - Result of comparison */
-compare_pids(filter_pid_t *a,		/* I - First filter */
-             filter_pid_t *b)		/* I - Second filter */
-{
-  return (a->pid - b->pid);
-}
-
-
-/*
- * 'exec_filter()' - Execute a single filter.
- */
-
-static int				/* O - Process ID or -1 on error */
-exec_filter(const char *filter,		/* I - Filter to execute */
-	    char       **argv,		/* I - Original command line args */
-	    int        infd,		/* I - Stdin file descriptor */
-	    int        outfd)		/* I - Stdout file descriptor */
-{
-  int		pid,			/* Process ID */
-		fd;			/* Temporary file descriptor */
-
-  if ((pid = fork()) == 0) {
-   /*
-    * Child process goes here...
-    *
-    * Update stdin/stdout/stderr as needed...
-    */
-
-    if (infd != 0) {
-      if (infd < 0)
-        infd = open("/dev/null", O_RDONLY);
-
-      if (infd > 0) {
-        dup2(infd, 0);
-	close(infd);
-      }
-    }
-
-    if (outfd != 1) {
-      if (outfd < 0)
-        outfd = open("/dev/null", O_WRONLY);
-
-      if (outfd > 1) {
-	dup2(outfd, 1);
-	close(outfd);
-      }
-    }
-
-    /* Send stderr to the Nirwana if we are running gziptoany, as
-       gziptoany emits a false "PAGE: 1 1" */
-    if (strcasestr(filter, "gziptoany")) {
-      if ((fd = open("/dev/null", O_RDWR)) > 2) {
-	dup2(fd, 2);
-	close(fd);
-      } else
-        close(fd);
-      fcntl(2, F_SETFL, O_NDELAY);
-    }
-
-    if ((fd = open("/dev/null", O_RDWR)) > 3) {
-      dup2(fd, 3);
-      close(fd);
-    }
-    else
-      close(fd);
-    fcntl(3, F_SETFL, O_NDELAY);
-
-    if ((fd = open("/dev/null", O_RDWR)) > 4) {
-      dup2(fd, 4);
-      close(fd);
-    } else
-      close(fd);
-    fcntl(4, F_SETFL, O_NDELAY);
-
-   /*
-    * Execute command...
-    */
-
-    execvp(filter, argv);
-
-    perror(filter);
-
-    exit(errno);
-  }
-
-  return (pid);
-}
-
-
-/*
- * 'exec_filters()' - Execute filters for the given file and options.
- */
-
-static int			     /* O - 0 on success, 1 on error */
-exec_filters(cups_array_t  *filters, /* I - Array of filters to run */
-	     char	   **argv)   /* I - Filter options */
-{
-  int		i;		     /* Looping var */
-  char		program[1024];	     /* Program to run */
-  char		*filter,	     /* Current filter */
-		*next;		     /* Next filter */
-  int		current,	     /* Current filter */
-		filterfds[2][2],     /* Pipes for filters */
-		pid,		     /* Process ID of filter */
-		status,		     /* Exit status */
-		retval;		     /* Return value */
-  cups_array_t	*pids;		     /* Executed filters array */
-  filter_pid_t	*pid_entry,	     /* Entry in executed filters array */
-		key;		     /* Search key for filters */
-  const char	*cups_serverbin;     /* CUPS_SERVERBIN environment variable */
-
- /*
-  * Remove NULL ("-") filters...
-  */
-
-  for (filter = (char *)cupsArrayFirst(filters);
-       filter;
-       filter = (char *)cupsArrayNext(filters))
-    if (!strcmp(filter, "-"))
-      cupsArrayRemove(filters, filter);
-
-  for (i = 0; argv[i]; i ++)
-    fprintf(stderr, "DEBUG: argv[%d]=\"%s\"\n", i, argv[i]);
-
- /*
-  * Execute all of the filters...
-  */
-
-  pids            = cupsArrayNew((cups_array_func_t)compare_pids, NULL);
-  current         = 0;
-  filterfds[0][0] = 0;
-  filterfds[0][1] = -1;
-  filterfds[1][0] = -1;
-  filterfds[1][1] = -1;
-
-  for (filter = (char *)cupsArrayFirst(filters);
-       filter;
-       filter = next, current = 1 - current) {
-    next = (char *)cupsArrayNext(filters);
-
-    if (filter[0] == '/') {
-      strncpy(program, filter, sizeof(program) - 1);
-      if (strlen(filter) > 1023)
-        program[1023] = '\0';
-    } else {
-      if ((cups_serverbin = getenv("CUPS_SERVERBIN")) == NULL)
-	cups_serverbin = CUPS_SERVERBIN;
-      snprintf(program, sizeof(program), "%s/filter/%s", cups_serverbin,
-	       filter);
-    }
-
-    if (filterfds[!current][1] > 1) {
-      close(filterfds[1 - current][0]);
-      close(filterfds[1 - current][1]);
-
-      filterfds[1 - current][0] = -1;
-      filterfds[1 - current][0] = -1;
-    }
-
-    if (next)
-      open_pipe(filterfds[1 - current]);
-    else
-      filterfds[1 - current][1] = 1;
-
-    pid = exec_filter(program, argv,
-                      filterfds[current][0], filterfds[1 - current][1]);
-
-    if (pid > 0) {
-      fprintf(stderr, "INFO: %s (PID %d) started.\n", filter, pid);
-
-      pid_entry = malloc(sizeof(filter_pid_t));
-      pid_entry->pid = pid;
-      pid_entry->name = filter;
-      cupsArrayAdd(pids, pid_entry);
-    } else
-      break;
-
-    argv[6] = NULL;
-  }
-
- /*
-  * Close remaining pipes...
-  */
-
-  if (filterfds[0][1] > 1) {
-    close(filterfds[0][0]);
-    close(filterfds[0][1]);
-  }
-
-  if (filterfds[1][1] > 1) {
-    close(filterfds[1][0]);
-    close(filterfds[1][1]);
-  }
-
- /*
-  * Wait for the children to exit...
-  */
-
-  retval = 0;
-
-  while (cupsArrayCount(pids) > 0) {
-    if ((pid = wait(&status)) < 0) {
-      if (errno == EINTR && job_canceled) {
-	fprintf(stderr, "DEBUG: Job canceled, killing filters ...\n");
-	for (pid_entry = (filter_pid_t *)cupsArrayFirst(pids);
-	     pid_entry;
-	     pid_entry = (filter_pid_t *)cupsArrayNext(pids))
-	  kill(pid_entry->pid, SIGTERM);
-	job_canceled = 0;
-      } else
-	continue;
-    }
-
-    key.pid = pid;
-    if ((pid_entry = (filter_pid_t *)cupsArrayFind(pids, &key)) != NULL) {
-      cupsArrayRemove(pids, pid_entry);
-
-      if (status) {
-	if (WIFEXITED(status))
-	  fprintf(stderr, "ERROR: %s (PID %d) stopped with status %d\n",
-		  pid_entry->name, pid, WEXITSTATUS(status));
-	else
-	  fprintf(stderr, "ERROR: %s (PID %d) crashed on signal %d\n",
-		  pid_entry->name, pid, WTERMSIG(status));
-
-        retval = 1;
-      } else
-        fprintf(stderr, "INFO: %s (PID %d) exited with no errors.\n",
-	        pid_entry->name, pid);
-
-      free(pid_entry);
-    }
-  }
-
-  cupsArrayDelete(pids);
-
-  return (retval);
-}
-
-
-/*
- * 'open_pipe()' - Create a pipe which is closed on exec.
- */
-
-static int				/* O - 0 on success, -1 on error */
-open_pipe(int *fds)			/* O - Pipe file descriptors (2) */
-{
- /*
-  * Create the pipe...
-  */
-
-  if (pipe(fds)) {
-    fds[0] = -1;
-    fds[1] = -1;
-
-    return (-1);
-  }
-
- /*
-  * Set the "close on exec" flag on each end of the pipe...
-  */
-
-  if (fcntl(fds[0], F_SETFD, fcntl(fds[0], F_GETFD) | FD_CLOEXEC)) {
-    close(fds[0]);
-    close(fds[1]);
-
-    fds[0] = -1;
-    fds[1] = -1;
-
-    return (-1);
-  }
-
-  if (fcntl(fds[1], F_SETFD, fcntl(fds[1], F_GETFD) | FD_CLOEXEC)) {
-    close(fds[0]);
-    close(fds[1]);
-
-    fds[0] = -1;
-    fds[1] = -1;
-
-    return (-1);
-  }
-
- /*
-  * Return 0 indicating success...
-  */
-
-  return (0);
-}
-
-
-/*
- * Get option value in a string of options
- */
-
-static char*				/* O - Value, NULL if option not set */
-get_option_in_str(char *buf,		/* I - Buffer with option list string */
-		  const char *option,	/* I - Option of which to get value */
-		  int return_value)	/* I - Return value or only check
-					       presence of option? */
-{
-  char *p1, *p2;
-  char *result;
-
-  if (!buf || !option)
-    return NULL;
-  if ((p1 = strcasestr(buf, option)) == NULL)
-    return NULL;
-  if (p1 > buf && *(p1 - 1) != ' ' && *(p1 - 1) != '\t')
-    return NULL;
-  p2 = p1 + strlen(option);
-  if (*p2 == ' ' || *p2 == '\t' || *p2 == '\0')
-    return "";
-  if (*p2 != '=')
-    return NULL;
-  if (!return_value)
-    return "";
-  p1 = p2 + 1;
-  for (p2 = p1; *p2 != ' ' && *p2 != '\t' && *p2 != '\0'; p2 ++);
-  if (p2 == p1)
-    return "";
-  result = calloc(p2 - p1 + 1, sizeof(char));
-  memcpy(result, p1, p2 - p1);
-  result[p2 - p1] = '\0';
-  return result;
-}
-
-
diff --git a/cupsfilters/pdftoippprinter.h b/cupsfilters/pdftoippprinter.h
deleted file mode 100644
index 2e593fc..0000000
--- a/cupsfilters/pdftoippprinter.h
+++ /dev/null
@@ -1,9 +0,0 @@
-#ifndef _CUPS_FILTERS_PDFTOIPPPRINTER_H
-#  define _CUPS_FILTERS_PDFTOIPPPRINTER_H
-
-int         apply_filters(int argc, char *argv[]);
-void		set_option_in_str(char *buf, int buflen,
-					  const char *option,
-					  const char *value);
-
-#endif
diff --git a/filter/bannertopdf.c b/filter/bannertopdf.c
deleted file mode 100644
index 028bf60..0000000
--- a/filter/bannertopdf.c
+++ /dev/null
@@ -1,574 +0,0 @@
-/*
- * Copyright 2012 Canonical Ltd.
- * Copyright 2013 ALT Linux, Andrew V. Stepanov <stanv@altlinux.com>
- * Copyright 2018 Sahil Arora <sahilarora.535@gmail.com>
- *
- * This program is free software: you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 3, as published
- * by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranties of
- * MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
- * PURPOSE.  See the GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <config.h>
-#include <stdio.h>
-#include <stdarg.h>
-#include <math.h>
-
-#ifndef HAVE_OPEN_MEMSTREAM
-#include <fcntl.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <errno.h>
-#endif
-
-#include <cups/cups.h>
-#include <cups/ppd.h>
-#if (CUPS_VERSION_MAJOR > 1) || (CUPS_VERSION_MINOR > 6)
-#define HAVE_CUPS_1_7 1
-#endif
-#ifdef HAVE_CUPS_1_7
-#include <cups/pwg.h>
-#endif /* HAVE_CUPS_1_7 */
-
-#include "banner.h"
-#include "pdf.h"
-
-
-static float get_float_option(const char *name,
-                              int noptions,
-                              cups_option_t *options,
-                              float def)
-{
-    const char *value = cupsGetOption(name, noptions, options);
-    return value ? atof(value) : def;
-}
-
-
-static int get_int_option(const char *name,
-                          int noptions,
-                          cups_option_t *options,
-                          int def)
-{
-    const char *value = cupsGetOption(name, noptions, options);
-    return value ? atoi(value) : def;
-}
-
-
-static void get_pagesize(ppd_file_t *ppd,
-                         int noptions,
-                         cups_option_t *options,
-                         float *width,
-                         float *length,
-                         float media_limits[4])
-{
-    static const ppd_size_t defaultsize = {
-        0,          /* marked */
-        "",         /* name */
-        612.0,      /* width */
-        792.0,      /* length */
-        18.0,       /* left */
-        36.0,       /* bottom */
-        594.0,      /* right */
-        756.0,      /* top */
-    };
-    const ppd_size_t *pagesize;
-#ifdef HAVE_CUPS_1_7
-    pwg_media_t      *size_found;          /* page size found for given name */
-    const char       *val;                 /* Pointer into value */
-    char             *ptr1, *ptr2,         /* Pointer into string */
-                     s[255];               /* Temporary string */
-#endif /* HAVE_CUPS_1_7 */
-
-    if (!ppd || !(pagesize = ppdPageSize(ppd, NULL)))
-        pagesize = &defaultsize;
-
-    *width = pagesize->width;
-    *length = pagesize->length;
-
-    media_limits[0] = get_float_option("page-left",
-                                       noptions, options,
-                                       pagesize->left);
-    media_limits[1] = get_float_option("page-bottom",
-                                       noptions, options,
-                                       pagesize->bottom);
-    media_limits[2] = get_float_option("page-right",
-                                       noptions, options,
-                                       fabs(pagesize->right));
-    media_limits[3] = get_float_option("page-top",
-                                       noptions, options,
-                                       fabs(pagesize->top));
-
-#ifdef HAVE_CUPS_1_7
-    if (!ppd) {
-      if ((val = cupsGetOption("media-size", noptions, options)) != NULL ||
-	  (val = cupsGetOption("MediaSize", noptions, options)) != NULL ||
-	  (val = cupsGetOption("page-size", noptions, options)) != NULL ||
-	  (val = cupsGetOption("PageSize", noptions, options)) != NULL ||
-	  (val = cupsGetOption("media", noptions, options)) != NULL) {
-	for (ptr1 = (char *)val; *ptr1;) {
-	  for (ptr2 = s; *ptr1 && *ptr1 != ',' && (ptr2 - s) < (sizeof(s) - 1);)
-	    *ptr2++ = *ptr1++;
-	  *ptr2++ = '\0';
-	  if (*ptr1 == ',')
-	    ptr1 ++;
-	  size_found = NULL;
-	  if ((size_found = pwgMediaForPWG(s)) == NULL)
-	    if ((size_found = pwgMediaForPPD(s)) == NULL)
-	      size_found = pwgMediaForLegacy(s);
-	  if (size_found != NULL) {
-	    *width = size_found->width * 72.0 / 2540.0;
-	    *length = size_found->length * 72.0 / 2540.0;
-	    media_limits[2] += (*width - 612.0);
-	    media_limits[3] += (*length - 792.0);
-	  }
-	}
-      }
-      if ((val = cupsGetOption("media-left-margin", noptions, options))
-	  != NULL)
-	media_limits[0] = atol(val) * 72.0 / 2540.0; 
-      if ((val = cupsGetOption("media-bottom-margin", noptions, options))
-	  != NULL)
-	media_limits[1] = atol(val) * 72.0 / 2540.0; 
-      if ((val = cupsGetOption("media-right-margin", noptions, options))
-	  != NULL)
-	media_limits[2] = *width - atol(val) * 72.0 / 2540.0; 
-      if ((val = cupsGetOption("media-top-margin", noptions, options))
-	  != NULL)
-	media_limits[3] = *length - atol(val) * 72.0 / 2540.0; 
-    }
-#endif /* HAVE_CUPS_1_7 */
-}
-
-
-static int duplex_marked(ppd_file_t *ppd,
-                         int noptions,
-                         cups_option_t *options)
-{
-    const char       *val;                 /* Pointer into value */
-    return
-      (ppd &&
-       (ppdIsMarked(ppd, "Duplex", "DuplexNoTumble") ||
-        ppdIsMarked(ppd, "Duplex", "DuplexTumble") ||
-        ppdIsMarked(ppd, "JCLDuplex", "DuplexNoTumble") ||
-        ppdIsMarked(ppd, "JCLDuplex", "DuplexTumble") ||
-        ppdIsMarked(ppd, "EFDuplex", "DuplexNoTumble") ||
-        ppdIsMarked(ppd, "EFDuplex", "DuplexTumble") ||
-        ppdIsMarked(ppd, "KD03Duplex", "DuplexNoTumble") ||
-        ppdIsMarked(ppd, "KD03Duplex", "DuplexTumble"))) ||
-      ((val = cupsGetOption("Duplex", noptions, options))
-       != NULL &&
-       (!strcasecmp(val, "DuplexNoTumble") ||
-	!strcasecmp(val, "DuplexTumble"))) ||
-      ((val = cupsGetOption("sides", noptions, options))
-       != NULL &&
-       (!strcasecmp(val, "two-sided-long-edge") ||
-	!strcasecmp(val, "two-sided-short-edge")));
-}
-
-
-static void info_linef(FILE *s,
-                       const char *key,
-                       const char *valuefmt, ...)
-{
-    va_list ap;
-
-    va_start(ap, valuefmt);
-    fprintf(s, "(%s: ", key);
-    vfprintf(s, valuefmt, ap);
-    fprintf(s, ") Tj T*\n");
-    va_end(ap);
-}
-
-
-static void info_line(FILE *s,
-                      const char *key,
-                      const char *value)
-{
-    info_linef(s, key, "%s", value);
-}
-
-
-static void info_line_time(FILE *s,
-                      const char *key,
-                      const char *timestamp)
-{
-    char buf[40];
-    time_t time;
-
-    if (timestamp) {
-        time = (time_t)atoll(timestamp);
-        strftime(buf, sizeof buf, "%c", localtime(&time));
-        info_line(s, key, buf);
-    }
-    else
-        info_line(s, key, "unknown");
-}
-
-static const char *human_time(const char *timestamp)
-{
-    time_t time;
-    int size = sizeof(char) * 40;
-    char *buf = malloc(size);
-    strcpy(buf, "unknown");
-
-    if (timestamp) {
-        time = (time_t)atoll(timestamp);
-        strftime(buf, size, "%c", localtime(&time));
-    }
-
-    return buf;
-}
-
-/*
- * Add new key & value.
- */
-static opt_t* add_opt(opt_t *in_opt, const char *key, const char *val) {
-    if ( ! key || ! val ) {
-        return in_opt;
-    }
-
-    if ( !strlen(key) || !strlen(val) ) {
-        return in_opt;
-    }
-
-    opt_t *entry = malloc(sizeof(opt_t));
-    if ( ! entry ) {
-        return in_opt;
-    }
-
-    entry->key = key;
-    entry->val = val;
-    entry->next = in_opt;
-
-    return entry;
-}
-
-/*
- * Collect all known info about current task.
- * Bond PDF form field name with collected info.
- *
- * Create PDF form's field names according above.
- */
-opt_t *get_known_opts(
-        ppd_file_t *ppd,
-        const char *jobid,
-        const char *user,
-        const char *jobtitle,
-        int noptions,
-        cups_option_t *options) {
-
-    ppd_attr_t *attr;
-    opt_t *opt = NULL;
-
-    /* Job ID */
-    opt = add_opt(opt, "job-id", jobid);
-
-    /* Job title */
-    opt = add_opt(opt, "job-title", jobtitle);
-
-    /* Printer by */
-    opt = add_opt(opt, "user", user);
-
-    /* Printer name */
-    opt = add_opt(opt, "printer-name", getenv("PRINTER"));
-
-    /* Printer info */
-    opt = add_opt(opt, "printer-info", getenv("PRINTER_INFO"));
-
-    /* Time at creation */
-    opt = add_opt(opt, "time-at-creation",
-            human_time(cupsGetOption("time-at-creation", noptions, options)));
-
-    /* Processing time */
-    opt = add_opt(opt, "time-at-processing",
-            human_time(cupsGetOption("time-at-processing", noptions, options)));
-
-    /* Billing information */
-    opt = add_opt(opt, "job-billing",
-            cupsGetOption("job-billing", noptions, options));
-
-    /* Source hostname */
-    opt = add_opt(opt, "job-originating-host-name",
-            cupsGetOption("job-originating-host-name", noptions, options));
-
-    /* Banner font */
-    opt = add_opt(opt, "banner-font",
-            cupsGetOption("banner-font", noptions, options));
-
-    /* Banner font size */
-    opt = add_opt(opt, "banner-font-size",
-            cupsGetOption("banner-font-size", noptions, options));
-
-    /* Job UUID */
-    opt = add_opt(opt, "job-uuid",
-            cupsGetOption("job-uuid", noptions, options));
-
-    /* Security context */
-    opt = add_opt(opt, "security-context",
-            cupsGetOption("security-context", noptions, options));
-
-    /* Security context range part */
-    opt = add_opt(opt, "security-context-range",
-            cupsGetOption("security-context-range", noptions, options));
-
-    /* Security context current range part */
-    const char * full_range = cupsGetOption("security-context-range", noptions, options);
-    if ( full_range ) {
-        size_t cur_size = strcspn(full_range, "-");
-        char * cur_range = strndup(full_range, cur_size);
-        opt = add_opt(opt, "security-context-range-cur", cur_range);
-    }
-
-    /* Security context type part */
-    opt = add_opt(opt, "security-context-type",
-            cupsGetOption("security-context-type", noptions, options));
-
-    /* Security context role part */
-    opt = add_opt(opt, "security-context-role",
-            cupsGetOption("security-context-role", noptions, options));
-
-    /* Security context user part */
-    opt = add_opt(opt, "security-context-user",
-            cupsGetOption("security-context-user", noptions, options));
-
-    if (ppd) {
-      /* Driver */
-      opt = add_opt(opt, "driver", ppd->pcfilename);
-
-      /* Driver version */
-      opt = add_opt(opt, "driver-version", 
-		    (attr = ppdFindAttr(ppd, "FileVersion", NULL)) ? 
-		    attr->value : "");
-
-      /* Make and model */
-      opt = add_opt(opt, "make-and-model", ppd->nickname);
-    }
-
-    return opt;
-}
-
-static int generate_banner_pdf(banner_t *banner,
-                               ppd_file_t *ppd,
-                               const char *jobid,
-                               const char *user,
-                               const char *jobtitle,
-                               int noptions,
-                               cups_option_t *options)
-{
-    char *buf;
-    size_t len;
-    FILE *s;
-    pdf_t *doc;
-    float page_width, page_length;
-    float media_limits[4];
-    float page_scale;
-    ppd_attr_t *attr;
-    unsigned copies;
-#ifndef HAVE_OPEN_MEMSTREAM
-    struct stat st;
-#endif
-
-    if (!(doc = pdf_load_template(banner->template_file)))
-        return 1;
-
-    get_pagesize(ppd, noptions, options,
-                 &page_width, &page_length, media_limits);
-
-    pdf_resize_page (doc, 1, page_width, page_length, &page_scale);
-
-    pdf_add_type1_font(doc, 1, "Courier");
-
-#ifdef HAVE_OPEN_MEMSTREAM
-    s = open_memstream(&buf, &len);
-#else
-    if ((s = tmpfile()) == NULL) {
-        fprintf (stderr, "ERROR: bannertopdf: cannot create temp file: %s\n",
-                 strerror (errno));
-        return 1;
-    }
-#endif
-
-    if (banner->infos & INFO_IMAGEABLE_AREA) {
-        fprintf(s, "q\n");
-        fprintf(s, "0 0 0 RG\n");
-        fprintf(s, "%f %f %f %f re S\n", media_limits[0] + 1.0,
-                                         media_limits[1] + 1.0,
-                                         media_limits[2] - media_limits[0] - 2.0,
-                                         media_limits[3] - media_limits[1] - 2.0);
-        fprintf(s, "Q\n");
-    }
-
-    fprintf(s, "%f 0 0 %f 0 0 cm\n", page_scale, page_scale);
-
-    fprintf(s, "0 0 0 rg\n");
-    fprintf(s, "BT\n");
-    fprintf(s, "/bannertopdf-font 14 Tf\n");
-    fprintf(s, "83.662 335.0 Td\n");
-    fprintf(s, "17 TL\n");
-
-    if (banner->infos & INFO_IMAGEABLE_AREA)
-        info_linef(s, "Media Limits", "%.2f x %.2f to %.2f x %.2f inches",
-                   media_limits[0] / 72.0,
-                   media_limits[1] / 72.0,
-                   media_limits[2] / 72.0,
-                   media_limits[3] / 72.0);
-
-    if (banner->infos & INFO_JOB_BILLING)
-        info_line(s, "Billing Information\n",
-                  cupsGetOption("job-billing", noptions, options));
-
-    if (banner->infos & INFO_JOB_ID)
-        info_linef(s, "Job ID", "%s-%s", getenv("PRINTER"), jobid);
-
-    if (banner->infos & INFO_JOB_NAME)
-        info_line(s, "Job Title", jobtitle);
-
-    if (banner->infos & INFO_JOB_ORIGINATING_HOST_NAME)
-        info_line(s, "Printed from",
-                  cupsGetOption("job-originating-host-name",
-                                noptions, options));
-
-    if (banner->infos & INFO_JOB_ORIGINATING_USER_NAME)
-        info_line(s, "Printed by", user);
-
-    if (banner->infos & INFO_JOB_UUID)
-        info_line(s, "Job UUID",
-                  cupsGetOption("job-uuid", noptions, options));
-
-    if (ppd && banner->infos & INFO_PRINTER_DRIVER_NAME)
-        info_line(s, "Driver", ppd->pcfilename);
-
-    if (ppd && banner->infos & INFO_PRINTER_DRIVER_VERSION)
-        info_line(s, "Driver Version",
-                  (attr = ppdFindAttr(ppd, "FileVersion", NULL)) ? attr->value : "");
-
-    if (banner->infos & INFO_PRINTER_INFO)
-        info_line(s, "Description", getenv("PRINTER_INFO"));
-
-    if (banner->infos & INFO_PRINTER_LOCATION)
-        info_line(s, "Printer Location", getenv("PRINTER_LOCATION"));
-
-    if (ppd && banner->infos & INFO_PRINTER_MAKE_AND_MODEL)
-        info_line(s, "Make and Model", ppd->nickname);
-
-    if (banner->infos & INFO_PRINTER_NAME)
-        info_line(s, "Printer", getenv("PRINTER"));
-
-    if (banner->infos & INFO_TIME_AT_CREATION)
-        info_line_time(s, "Created at",
-                       cupsGetOption("time-at-creation", noptions, options));
-
-    if (banner->infos & INFO_TIME_AT_PROCESSING)
-        info_line_time(s, "Printed at",
-                       cupsGetOption("time-at-processing", noptions, options));
-
-    fprintf(s, "ET\n");
-#ifndef HAVE_OPEN_MEMSTREAM
-    fflush (s);
-    if (fstat (fileno (s), &st) < 0) {
-        fprintf (stderr, "ERROR: bannertopdf: cannot fstat(): %s\n", strerror(errno));
-        return 1 ;
-    }
-    fseek (s, 0L, SEEK_SET);
-    if ((buf = malloc(st.st_size + 1)) == NULL) {
-        fprintf (stderr, "ERROR: bannertopdf: cannot malloc(): %s\n", strerror(errno));
-        return 1 ;
-    }
-    size_t nbytes = fread (buf, 1, st.st_size, s);
-    buf[st.st_size] = '\0';
-    len = strlen (buf);
-#endif /* !HAVE_OPEN_MEMSTREAM */
-    fclose(s);
-
-    opt_t * known_opts = get_known_opts(ppd,
-            jobid,
-            user,
-            jobtitle,
-            noptions,
-            options);
-
-    /*
-     * Try to find a PDF form in PDF template and fill it.
-     */
-    int ret = pdf_fill_form(doc, known_opts);
-
-    /*
-     * Could we fill a PDF form? If no, just add PDF stream.
-     */
-    if ( ! ret ) {
-        pdf_prepend_stream(doc, 1, buf, len);
-    }
-
-    copies = get_int_option("number-up", noptions, options, 1);
-    if (duplex_marked(ppd, noptions, options))
-        copies *= 2;
-
-    if (copies > 1)
-        pdf_duplicate_page(doc, 1, copies - 1);
-
-    pdf_write(doc, stdout);
-
-    opt_t * opt_current = known_opts;
-    opt_t * opt_next = NULL;
-    while (opt_current != NULL)
-    {
-      opt_next = opt_current->next;
-      free(opt_current);
-      opt_current = opt_next;
-    }
-    free(buf);
-    pdf_free(doc);
-    return 0;
-}
-
-
-int main(int argc, char *argv[])
-{
-    banner_t *banner;
-    int noptions;
-    cups_option_t *options;
-    ppd_file_t *ppd;
-    int ret;
-
-    if (argc < 6) {
-        fprintf(stderr,
-                "Usage: %s job-id user job-title nr-copies options [file]\n",
-                argv[0]);
-        return 1;
-    }
-
-    ppd = ppdOpenFile(getenv("PPD"));
-    if (!ppd)
-      fprintf(stderr, "DEBUG: Could not open PPD file '%s'\n", getenv("PPD"));
-
-    noptions = cupsParseOptions(argv[5], 0, &options);
-    if (ppd) {
-      ppdMarkDefaults(ppd);
-      cupsMarkOptions(ppd, noptions, options);
-    }
-
-    banner = banner_new_from_file(argc == 7 ? argv[6] : "-", &noptions, &options);
-    if (!banner) {
-        fprintf(stderr, "Error: could not read banner file\n");
-        return 1;
-    }
-
-    ret = generate_banner_pdf(banner,
-                              ppd,
-                              argv[1],
-                              argv[2],
-                              argv[3],
-                              noptions,
-                              options);
-
-    banner_free(banner);
-    cupsFreeOptions(noptions, options);
-    return ret;
-}
diff --git a/filter/gstopdf b/filter/gstopdf
deleted file mode 100644
index d261cf8..0000000
--- a/filter/gstopdf
+++ /dev/null
@@ -1,25 +0,0 @@
-#!/bin/sh
-
-# gstopdf - Ghostscript-based PDF filter for CUPS
-#
-# Note: This is only a wrapper filter, the real work is done by gstoraster
-#
-# (C) 2012 Till Kamppeter <till.kamppeter@gmail.com>
-#
-# Released under GPL 2 or later
-#
-
-echo "DEBUG: gstopdf argv[$#] = $@" >&2
-echo "DEBUG: PPD: $PPD" >&2
-
-if [ $# -lt 5 -o $# -gt 6 ]; then
-    echo "ERROR: gstopdf job-id user title copies options [file]" >&2
-    exit 1
-fi
-
-# Read from given file.
-if [ -n "$6" ]; then
-    exec <"$6"
-fi
-
-OUTFORMAT=PDF $CUPS_SERVERBIN/filter/gstoraster "$1" "$2" "$3" "$4" "$5"
diff --git a/filter/imagetopdf.c b/filter/imagetopdf.c
deleted file mode 100644
index cc72cea..0000000
--- a/filter/imagetopdf.c
+++ /dev/null
@@ -1,2000 +0,0 @@
-/*
- * Image file to PDF filter for the Common UNIX Printing System (CUPS).
- * developped by BBR Inc. 2006-2007
- *
- * This is based on imagetops.c of CUPS
- *
- * imagetops.c copyright notice is follows
- *
- *   Copyright 1993-2006 by Easy Software Products.
- *
- *   These coded instructions, statements, and computer programs are the
- *   property of Easy Software Products and are protected by Federal
- *   copyright law.  Distribution and use rights are outlined in the file
- *   "COPYING" which should have been included with this file.
- */
-
-/*
- * Include necessary headers...
- */
-
-#include "config.h"
-#include "common.h"
-#include <cupsfilters/image.h>
-#include <cupsfilters/raster.h>
-#include <math.h>
-#include <ctype.h>
-
-#if CUPS_VERSION_MAJOR < 1 \
-  || (CUPS_VERSION_MAJOR == 1 && CUPS_VERSION_MINOR < 2)
-#ifndef CUPS_1_1
-#error Installed libs and specified source Version mismatch \
-	Libs >= 1.2 && Source < 1.2
-#define CUPS_1_1
-#endif
-#else
-#ifdef CUPS_1_1
-#error Installed libs and specified source Version mismatch \
-	Libs < 1.2 && Source >= 1.2
-#undef CUPS_1_1
-#endif
-#endif
-
-#define USE_CONVERT_CMD
-//#define OUT_AS_HEX
-//#define OUT_AS_ASCII85
-
-/*
- * Globals...
- */
-
-int	Flip = 0,		/* Flip/mirror pages */
-	XPosition = 0,		/* Horizontal position on page */
-	YPosition = 0,		/* Vertical position on page */
-	Collate = 0,		/* Collate copies? */
-	Copies = 1,		/* Number of copies */
-	Reverse = 0,		/* Output order */
-	EvenDuplex = 0;		/* cupsEvenDuplex */
-
-#ifdef CUPS_1_1
-#define cups_ib_t ib_t
-#define cups_image_t image_t
-#define CUPS_IMAGE_CMYK IMAGE_CMYK
-#define CUPS_IMAGE_WHITE IMAGE_WHITE
-#define CUPS_IMAGE_RGB IMAGE_RGB
-#define CUPS_IMAGE_RGB_CMYK IMAGE_RGB_CMYK
-#define cupsImageOpen ImageOpen
-#define cupsImageClose ImageClose
-#define cupsImageGetColorSpace(img) (img->colorspace)
-#define cupsImageGetXPPI(img) (img->xppi)
-#define cupsImageGetYPPI(img) (img->yppi)
-#define cupsImageGetWidth(img) (img->xsize)
-#define cupsImageGetHeight(img) (img->ysize)
-#define cupsImageGetRow ImageGetRow
-#endif
-
-/*
- * Local functions...
- */
-
-#ifdef OUT_AS_HEX
-static void	out_hex(cups_ib_t *, int, int);
-#else
-#ifdef OUT_AS_ASCII85
-static void	out_ascii85(cups_ib_t *, int, int);
-#else
-static void	out_bin(cups_ib_t *, int, int);
-#endif
-#endif
-static void	outPdf(const char *str);
-static void	putcPdf(char c);
-static int	newObj(void);
-static void	freeAllObj(void);
-static void	outXref(void);
-static void	outTrailer(void);
-static void	outString(const char *s);
-static void	outPrologue(int nPages);
-static void	allocPageObjects(int noPages);
-static void	setOffset(int obj);
-static void	outPageObject(int pageObj, int contentsObj, int imgObj);
-static void	outPageContents(int contentsObj);
-static void	outImage(int imgObj);
-
-struct pdfObject {
-    int offset;
-};
-
-static struct pdfObject *objects = NULL;
-static int currentObjectNo = 0;
-static int allocatedObjectNum = 0;
-static int currentOffset = 0;
-static int xrefOffset;
-static int *pageObjects = NULL;
-static int catalogObj;
-static int pagesObj;
-static const char *title;
-static int	xpages,			/* # x pages */
-		ypages,			/* # y pages */
-		xpage,			/* Current x page */
-		ypage,			/* Current y page */
-		page;			/* Current page number */
-static int	xc0, yc0,			/* Corners of the page in image coords */
-		xc1, yc1;
-static float	left, top;		/* Left and top of image */
-static float	xprint,			/* Printable area */
-		yprint,
-		xinches,		/* Total size in inches */
-		yinches;
-static float	xsize,			/* Total size in points */
-		ysize,
-		xsize2,
-		ysize2;
-static float	aspect;			/* Aspect ratio */
-static cups_image_t	*img;			/* Image to print */
-static int	colorspace;		/* Output colorspace */
-static cups_ib_t	*row;		/* Current row */
-static float	gammaval = 1.0;		/* Gamma correction value */
-static float	brightness = 1.0;	/* Gamma correction value */
-static ppd_file_t	*ppd;			/* PPD file */
-
-#define N_OBJECT_ALLOC 100
-#define LINEBUFSIZE 1024
-
-static char linebuf[LINEBUFSIZE];
-
-void emitJCLOptions(FILE *fp, int copies)
-{
-  int section;
-  ppd_choice_t **choices;
-  int i;
-  char buf[1024];
-  ppd_attr_t *attr;
-  int pdftopdfjcl = 0;
-  int datawritten = 0;
-
-  if (ppd == 0) return;
-  if ((attr = ppdFindAttr(ppd,"pdftopdfJCLBegin",NULL)) != NULL) {
-    int n = strlen(attr->value);
-    pdftopdfjcl = 1;
-    for (i = 0;i < n;i++) {
-	if (attr->value[i] == '\r' || attr->value[i] == '\n') {
-	    /* skip new line */
-	    continue;
-	}
-	fputc(attr->value[i],fp);
-	datawritten = 1;
-    }
-  }
-
-  snprintf(buf,sizeof(buf),"%d",copies);
-  if (ppdFindOption(ppd,"Copies") != NULL) {
-    ppdMarkOption(ppd,"Copies",buf);
-  } else {
-    if ((attr = ppdFindAttr(ppd,"pdftopdfJCLCopies",buf)) != NULL) {
-      fputs(attr->value,fp);
-      datawritten = 1;
-    } else if (pdftopdfjcl) {
-      fprintf(fp,"Copies=%d;",copies);
-      datawritten = 1;
-    }
-  }
-  for (section = (int)PPD_ORDER_ANY;
-      section <= (int)PPD_ORDER_PROLOG;section++) {
-    int n;
-
-    n = ppdCollect(ppd,(ppd_section_t)section,&choices);
-    for (i = 0;i < n;i++) {
-      snprintf(buf,sizeof(buf),"pdftopdfJCL%s",
-        ((ppd_option_t *)(choices[i]->option))->keyword);
-      if ((attr = ppdFindAttr(ppd,buf,choices[i]->choice)) != NULL) {
-        fputs(attr->value,fp);
-	datawritten = 1;
-      } else if (pdftopdfjcl) {
-        fprintf(fp,"%s=%s;",
-          ((ppd_option_t *)(choices[i]->option))->keyword,
-          choices[i]->choice);
-	datawritten = 1;
-      }
-    }
-  }
-  if (datawritten) fputc('\n',fp);
-}
-
-
-static void setOffset(int obj)
-{
-  objects[obj].offset = currentOffset;
-}
-
-static void allocPageObjects(int nPages)
-{
-  int i;
-
-  if ((pageObjects = malloc(sizeof(int)*nPages)) == NULL)
-  {
-    fprintf(stderr,"ERROR: Can't allocate pageObjects\n");
-    exit(2);
-  }
-  for (i = 0;i < nPages;i++)
-  {
-    pageObjects[i] = newObj();
-  }
-}
-
-static int newObj(void)
-{
-  if (objects == NULL)
-  {
-    if ((objects = malloc(sizeof(struct pdfObject)*N_OBJECT_ALLOC))
-	  == NULL)
-    {
-      fprintf(stderr,"ERROR: Can't allocate objects\n");
-      exit(2);
-    }
-    allocatedObjectNum = N_OBJECT_ALLOC;
-  }
-  if (currentObjectNo >= allocatedObjectNum)
-  {
-    if ((objects = realloc(objects,
-	  sizeof(struct pdfObject)*(allocatedObjectNum+N_OBJECT_ALLOC)))
-	  == NULL)
-    {
-      fprintf(stderr,"ERROR: Can't allocate objects\n");
-      exit(2);
-    }
-    allocatedObjectNum += N_OBJECT_ALLOC;
-  }
-  objects[currentObjectNo].offset = currentOffset;
-  return currentObjectNo++;
-}
-
-static void freeAllObj(void)
-{
-  if (objects != NULL)
-  {
-    free(objects);
-    objects = NULL;
-  }
-}
-
-static void putcPdf(char c)
-{
-  fputc(c,stdout);
-  currentOffset++;
-}
-
-static void outPdf(const char *str)
-{
-  unsigned long len = strlen(str);
-
-  fputs(str,stdout);
-  currentOffset += len;
-}
-
-static void outXref(void)
-{
-  char buf[21];
-  int i;
-
-  xrefOffset = currentOffset;
-  outPdf("xref\n");
-  snprintf(buf,21,"0 %d\n",currentObjectNo);
-  outPdf(buf);
-  outPdf("0000000000 65535 f \n");
-  for (i = 1;i < currentObjectNo;i++)
-  {
-    snprintf(buf,21,"%010d 00000 n \n",objects[i].offset);
-    outPdf(buf);
-  }
-}
-
-static void outString(const char *s)
-{
-  char c;
-
-  putcPdf('(');
-  for (;(c = *s) != '\0';s++) {
-    if (c == '\\' || c == '(' || c == ')') {
-      putcPdf('\\');
-    }
-    putcPdf(c);
-  }
-  putcPdf(')');
-}
-
-static void outTrailer(void)
-{
-  time_t	curtime;
-  struct tm	*curtm;
-  char		curdate[255];
-
-  curtime = time(NULL);
-  curtm = localtime(&curtime);
-  strftime(curdate, sizeof(curdate),"D:%Y%m%d%H%M%S%z", curtm);
-
-  outPdf("trailer\n");
-  snprintf(linebuf, LINEBUFSIZE,"<</Size %d ",currentObjectNo);
-  outPdf(linebuf);
-  outPdf("/Root 1 0 R\n");
-  outPdf("/Info << /Title ");
-  outString(title);
-  putcPdf(' ');
-  snprintf(linebuf,LINEBUFSIZE,"/CreationDate (%s) ",curdate);
-  outPdf(linebuf);
-  snprintf(linebuf,LINEBUFSIZE,"/ModDate (%s) ",curdate);
-  outPdf(linebuf);
-  outPdf("/Producer (imagetopdf) ");
-  outPdf("/Trapped /False >>\n");
-  outPdf(">>\n");
-  outPdf("startxref\n");
-  snprintf(linebuf,LINEBUFSIZE,"%d\n",xrefOffset);
-  outPdf(linebuf);
-  outPdf("%%EOF\n");
-}
-
-static void outPrologue(int nPages)
-{
-  int i;
-
-  /* out header */
-  newObj(); /* dummy for no 0 object */
-  outPdf("%PDF-1.3\n");
-  /* out binary for transfer program */
-  linebuf[0] = '%';
-  linebuf[1] = (char)129;
-  linebuf[2] = (char)130;
-  linebuf[3] = (char)131;
-  linebuf[4] = (char)132;
-  linebuf[5] = '\n';
-  linebuf[6] = (char)0;
-  outPdf(linebuf);
-  outPdf("% This file was generated by imagetopdf\n");
-
-  catalogObj = newObj();
-  pagesObj = newObj();
-  allocPageObjects(nPages);
-
-  /* out catalog */
-  snprintf(linebuf,LINEBUFSIZE,
-    "%d 0 obj <</Type/Catalog /Pages %d 0 R ",catalogObj,pagesObj);
-  outPdf(linebuf);
-  outPdf(">> endobj\n");
-
-  /* out Pages */
-  setOffset(pagesObj);
-  snprintf(linebuf,LINEBUFSIZE,
-    "%d 0 obj <</Type/Pages /Kids [ ",pagesObj);
-  outPdf(linebuf);
-  if (Reverse) {
-    for (i = nPages-1;i >= 0;i--)
-    {
-      snprintf(linebuf,LINEBUFSIZE,"%d 0 R ",pageObjects[i]);
-      outPdf(linebuf);
-    }
-  } else {
-    for (i = 0;i < nPages;i++)
-    {
-      snprintf(linebuf,LINEBUFSIZE,"%d 0 R ",pageObjects[i]);
-      outPdf(linebuf);
-    }
-  }
-  outPdf("] ");
-  snprintf(linebuf,LINEBUFSIZE,"/Count %d >> endobj\n",nPages);
-  outPdf(linebuf);
-}
-
-static void outPageObject(int pageObj, int contentsObj, int imgObj)
-{
-  int trfuncObj;
-  int lengthObj;
-  int startOffset;
-  int length;
-  int outTrfunc = (gammaval != 1.0 || brightness != 1.0);
-
-  /* out Page Object */
-  setOffset(pageObj);
-  snprintf(linebuf,LINEBUFSIZE,
-    "%d 0 obj <</Type/Page /Parent %d 0 R ",
-    pageObj,pagesObj);
-  outPdf(linebuf);
-  snprintf(linebuf,LINEBUFSIZE,
-    "/MediaBox [ 0 0 %f %f ] ",PageWidth,PageLength);
-  outPdf(linebuf);
-  snprintf(linebuf,LINEBUFSIZE,
-    "/TrimBox [ 0 0 %f %f ] ",PageWidth,PageLength);
-  outPdf(linebuf);
-  snprintf(linebuf,LINEBUFSIZE,
-    "/CropBox [ 0 0 %f %f ] ",PageWidth,PageLength);
-  outPdf(linebuf);
-  if (contentsObj >= 0) {
-    snprintf(linebuf,LINEBUFSIZE,
-      "/Contents %d 0 R ",contentsObj);
-    outPdf(linebuf);
-    snprintf(linebuf,LINEBUFSIZE,
-      "/Resources <</ProcSet [/PDF] "
-      "/XObject << /Im %d 0 R >>\n",imgObj);
-    outPdf(linebuf);
-  } else {
-    /* empty page */
-    snprintf(linebuf,LINEBUFSIZE,
-      "/Resources <</ProcSet [/PDF] \n");
-    outPdf(linebuf);
-  }
-  if (outTrfunc) {
-    trfuncObj = newObj();
-    lengthObj = newObj();
-    snprintf(linebuf,LINEBUFSIZE,
-      "/ExtGState << /GS1 << /TR %d 0 R >> >>\n",trfuncObj);
-    outPdf(linebuf);
-  }
-  outPdf("     >>\n>>\nendobj\n");
-
-  if (outTrfunc) {
-    /* out translate function */
-    setOffset(trfuncObj);
-    snprintf(linebuf,LINEBUFSIZE,
-      "%d 0 obj <</FunctionType 4 /Domain [0 1.0]"
-      " /Range [0 1.0] /Length %d 0 R >>\n",
-      trfuncObj,lengthObj);
-    outPdf(linebuf);
-    outPdf("stream\n");
-    startOffset = currentOffset;
-    snprintf(linebuf,LINEBUFSIZE,
-     "{ neg 1 add dup 0 lt { pop 1 } { %.3f exp neg 1 add } "
-     "ifelse %.3f mul }\n", gammaval, brightness);
-    outPdf(linebuf);
-    length = currentOffset - startOffset;
-    snprintf(linebuf,LINEBUFSIZE,
-     "endstream\nendobj\n");
-    outPdf(linebuf);
-
-    /* out length object */
-    setOffset(lengthObj);
-    snprintf(linebuf,LINEBUFSIZE,
-      "%d 0 obj %d endobj\n",lengthObj,length);
-    outPdf(linebuf);
-  }
-}
-
-static void outPageContents(int contentsObj)
-{
-  int startOffset;
-  int lengthObj;
-  int length;
-
-  setOffset(contentsObj);
-  lengthObj = newObj();
-  snprintf(linebuf,LINEBUFSIZE,
-    "%d 0 obj <</Length %d 0 R >> stream\n",contentsObj,lengthObj);
-  outPdf(linebuf);
-  startOffset = currentOffset;
-
-  if (gammaval != 1.0 || brightness != 1.0)
-      outPdf("/GS1 gs\n");
-  if (Flip)
-  {
-    snprintf(linebuf,LINEBUFSIZE,
-      "-1 0 0 1 %.0f 0 cm\n",PageWidth);
-    outPdf(linebuf);
-  }
-
-  switch (Orientation)
-  {
-    case 1:
-	snprintf(linebuf,LINEBUFSIZE,
-	  "0 1 -1 0 %.0f 0 cm\n",PageWidth);
-	outPdf(linebuf);
-	break;
-    case 2:
-	snprintf(linebuf,LINEBUFSIZE,
-	  "-1 0 0 -1 %.0f %.0f cm\n",PageWidth, PageLength);
-	outPdf(linebuf);
-	break;
-    case 3:
-	snprintf(linebuf,LINEBUFSIZE,
-	  "0 -1 1 0 0 %.0f cm\n",PageLength);
-	outPdf(linebuf);
-	break;
-  }
-
-  xc0 = cupsImageGetWidth(img) * xpage / xpages;
-  xc1 = cupsImageGetWidth(img) * (xpage + 1) / xpages - 1;
-  yc0 = cupsImageGetHeight(img) * ypage / ypages;
-  yc1 = cupsImageGetHeight(img) * (ypage + 1) / ypages - 1;
-
-  snprintf(linebuf,LINEBUFSIZE,
-    "1 0 0 1 %.1f %.1f cm\n",left,top);
-  outPdf(linebuf);
-
-  snprintf(linebuf,LINEBUFSIZE,
-    "%.3f 0 0 %.3f 0 0 cm\n",
-     xprint * 72.0, yprint * 72.0);
-  outPdf(linebuf);
-  outPdf("/Im Do\n");
-  length = currentOffset - startOffset - 1;
-  outPdf("endstream\nendobj\n");
-
-  /* out length object */
-  setOffset(lengthObj);
-  snprintf(linebuf,LINEBUFSIZE,
-    "%d 0 obj %d endobj\n",lengthObj,length);
-  outPdf(linebuf);
-}
-
-static void outImage(int imgObj)
-{
-  int		y;			/* Current Y coordinate in image */
-#ifdef OUT_AS_ASCII85
-  int		out_offset;		/* Offset into output buffer */
-#endif
-  int		out_length;		/* Length of output buffer */
-  int startOffset;
-  int lengthObj;
-  int length;
-
-  setOffset(imgObj);
-  lengthObj = newObj();
-  snprintf(linebuf,LINEBUFSIZE,
-    "%d 0 obj << /Length %d 0 R /Type /XObject "
-    "/Subtype /Image /Name /Im"
-#ifdef OUT_AS_HEX
-    "/Filter /ASCIIHexDecode "
-#else
-#ifdef OUT_AS_ASCII85
-    "/Filter /ASCII85Decode "
-#endif
-#endif
-    ,imgObj,lengthObj);
-  outPdf(linebuf);
-  snprintf(linebuf,LINEBUFSIZE,
-    "/Width %d /Height %d /BitsPerComponent 8 ",
-    xc1 - xc0 + 1, yc1 - yc0 + 1);
-  outPdf(linebuf);
-
-  switch (colorspace)
-  {
-    case CUPS_IMAGE_WHITE :
-	outPdf("/ColorSpace /DeviceGray ");
-	outPdf("/Decode[0 1] ");
-	break;
-    case CUPS_IMAGE_RGB :
-	outPdf("/ColorSpace /DeviceRGB ");
-	outPdf("/Decode[0 1 0 1 0 1] ");
-	break;
-    case CUPS_IMAGE_CMYK :
-	outPdf("/ColorSpace /DeviceCMYK ");
-	outPdf("/Decode[0 1 0 1 0 1 0 1] ");
-	break;
-  }
-  if (((xc1 - xc0 + 1) / xprint) < 100.0)
-      outPdf("/Interpolate true ");
-
-  outPdf(">>\n");
-  outPdf("stream\n");
-  startOffset = currentOffset;
-
-#ifdef OUT_AS_ASCII85
-  /* out ascii85 needs multiple of 4bytes */
-  for (y = yc0, out_offset = 0; y <= yc1; y ++)
-  {
-    cupsImageGetRow(img, xc0, y, xc1 - xc0 + 1, row + out_offset);
-
-    out_length = (xc1 - xc0 + 1) * abs(colorspace) + out_offset;
-    out_offset = out_length & 3;
-
-    out_ascii85(row, out_length, y == yc1);
-
-    if (out_offset > 0)
-      memcpy(row, row + out_length - out_offset, out_offset);
-  }
-#else
-  for (y = yc0; y <= yc1; y ++)
-  {
-    cupsImageGetRow(img, xc0, y, xc1 - xc0 + 1, row);
-
-    out_length = (xc1 - xc0 + 1) * abs(colorspace);
-
-#ifdef OUT_AS_HEX
-    out_hex(row, out_length, y == yc1);
-#else
-    out_bin(row, out_length, y == yc1);
-#endif
-  }
-#endif
-  length = currentOffset - startOffset;
-  outPdf("\nendstream\nendobj\n");
-
-  /* out length object */
-  setOffset(lengthObj);
-  snprintf(linebuf,LINEBUFSIZE,
-    "%d 0 obj %d endobj\n",lengthObj,length);
-  outPdf(linebuf);
-}
-
-/*
- * Copied ppd_decode() from CUPS which is not exported to the API
- */
-
-static int				/* O - Length of decoded string */
-ppd_decode(char *string)		/* I - String to decode */
-{
-  char	*inptr,				/* Input pointer */
-	*outptr;			/* Output pointer */
-
-
-  inptr  = string;
-  outptr = string;
-
-  while (*inptr != '\0')
-    if (*inptr == '<' && isxdigit(inptr[1] & 255))
-    {
-     /*
-      * Convert hex to 8-bit values...
-      */
-
-      inptr ++;
-      while (isxdigit(*inptr & 255))
-      {
-	if (isalpha(*inptr))
-	  *outptr = (tolower(*inptr) - 'a' + 10) << 4;
-	else
-	  *outptr = (*inptr - '0') << 4;
-
-	inptr ++;
-
-        if (!isxdigit(*inptr & 255))
-	  break;
-
-	if (isalpha(*inptr))
-	  *outptr |= tolower(*inptr) - 'a' + 10;
-	else
-	  *outptr |= *inptr - '0';
-
-	inptr ++;
-	outptr ++;
-      }
-
-      while (*inptr != '>' && *inptr != '\0')
-	inptr ++;
-      while (*inptr == '>')
-	inptr ++;
-    }
-    else
-      *outptr++ = *inptr++;
-
-  *outptr = '\0';
-
-  return ((int)(outptr - string));
-}
-
-/*
- * 'main()' - Main entry...
- */
-
-int					/* O - Exit status */
-main(int  argc,				/* I - Number of command-line arguments */
-     char *argv[])			/* I - Command-line arguments */
-{
-  cups_page_header2_t h;                /* CUPS Raster page header, to */
-                                        /* accommodate results of command */
-                                        /* line parsing for PPD-less queue */
-  ppd_choice_t	*choice;		/* PPD option choice */
-  int		num_options;		/* Number of print options */
-  cups_option_t	*options;		/* Print options */
-  const char	*val;			/* Option value */
-  float		zoom;			/* Zoom facter */
-  int		xppi, yppi;		/* Pixels-per-inch */
-  int		hue, sat;		/* Hue and saturation adjustment */
-  int		emit_jcl;
-  int           pdf_printer = 0;
-  char		filename[1024];		/* Name of file to print */
-  int deviceCopies = 1;
-  int deviceCollate = 0;
-  int deviceReverse = 0;
-  ppd_attr_t *attr;
-  int pl,pr;
-  int fillprint = 0;  /* print-scaling = fill */
-  int cropfit = 0;  /* -o crop-to-fit = true */
- /*
-  * Make sure status messages are not buffered...
-  */
-
-  setbuf(stderr, NULL);
-
- /*
-  * Check command-line...
-  */
-
-  if (argc < 6 || argc > 7)
-  {
-    fputs("ERROR: imagetopdf job-id user title copies options [file]\n", stderr);
-    return (1);
-  }
-
-  title = argv[3];
-  fprintf(stderr, "INFO: %s %s %s %s %s %s %s\n", argv[0], argv[1], argv[2],
-          argv[3], argv[4], argv[5], argv[6] ? argv[6] : "(null)");
-
- /*
-  * Copy stdin as needed...
-  */
-
-  if (argc == 6)
-  {
-    int		fd;		/* File to write to */
-    char	buffer[8192];	/* Buffer to read into */
-    int		bytes;		/* # of bytes to read */
-
-
-    if ((fd = cupsTempFd(filename, sizeof(filename))) < 0)
-    {
-      perror("ERROR: Unable to copy image file");
-      return (1);
-    }
-
-    fprintf(stderr, "DEBUG: imagetopdf - copying to temp print file \"%s\"\n",
-            filename);
-
-    while ((bytes = fread(buffer, 1, sizeof(buffer), stdin)) > 0)
-      if (write(fd, buffer, bytes) == -1)
-	fprintf(stderr,
-		"DEBUG: imagetopdf - write error on temp print file \"%s\"\n",
-		filename);
-
-    close(fd);
-  }
-  else
-  {
-    strncpy(filename, argv[6], sizeof(filename) - 1);
-  }
-
- /*
-  * Process command-line options and write the prolog...
-  */
-
-  zoom = 1.0;
-  xppi = 0;
-  yppi = 0;
-  hue  = 0;
-  sat  = 100;
-
-  Copies = atoi(argv[4]);
-
-  options     = NULL;
-  num_options = cupsParseOptions(argv[5], 0, &options);
-
-  ppd = SetCommonOptions(num_options, options, 0);
-  if (!ppd) {
-    cupsRasterParseIPPOptions(&h, num_options, options, 0, 1);
-    Orientation = h.Orientation;
-    Duplex = h.Duplex;
-    ColorDevice = h.cupsNumColors <= 1 ? 0 : 1;
-    PageWidth = h.cupsPageSize[0] != 0.0 ? h.cupsPageSize[0] :
-      (float)h.PageSize[0];
-    PageLength = h.cupsPageSize[1] != 0.0 ? h.cupsPageSize[1] :
-      (float)h.PageSize[1];
-    PageLeft = h.cupsImagingBBox[0] != 0.0 ? h.cupsImagingBBox[0] :
-      (float)h.ImagingBoundingBox[0];
-    PageBottom = h.cupsImagingBBox[1] != 0.0 ? h.cupsImagingBBox[1] :
-      (float)h.ImagingBoundingBox[1];
-    PageRight = h.cupsImagingBBox[2] != 0.0 ? h.cupsImagingBBox[2] :
-      (float)h.ImagingBoundingBox[2];
-    PageTop = h.cupsImagingBBox[3] != 0.0 ? h.cupsImagingBBox[3] :
-      (float)h.ImagingBoundingBox[3];
-    Flip = h.MirrorPrint ? 1 : 0;
-    Collate = h.Collate ? 1 : 0;
-    Copies = h.NumCopies;
-  }
-
-  if (Copies == 1
-      && (choice = ppdFindMarkedChoice(ppd,"Copies")) != NULL) {
-    Copies = atoi(choice->choice);
-  }
-  if (Copies == 0) Copies = 1;
-  if ((val = cupsGetOption("Duplex",num_options,options)) != 0 &&
-      (!strcasecmp(val, "true") || !strcasecmp(val, "on") ||
-       !strcasecmp(val, "yes"))) {
-      /* for compatiblity */
-      if (ppdFindOption(ppd,"Duplex") != NULL) {
-        ppdMarkOption(ppd,"Duplex","True");
-        ppdMarkOption(ppd,"Duplex","On");
-        Duplex = 1;
-      }
-  } else if ((val = cupsGetOption("sides",num_options,options)) != 0 &&
-      (!strcasecmp(val, "two-sided-long-edge") ||
-       !strcasecmp(val, "two-sided-short-edge"))) {
-      /* for compatiblity */
-      if (ppdFindOption(ppd,"Duplex") != NULL) {
-        ppdMarkOption(ppd,"Duplex","True");
-        ppdMarkOption(ppd,"Duplex","On");
-        Duplex = 1;
-      }
-  }
-
-  if ((val = cupsGetOption("OutputOrder",num_options,options)) != 0) {
-    if (!strcasecmp(val, "Reverse")) {
-      Reverse = 1;
-    }
-  } else if (ppd) {
-   /*
-    * Figure out the right default output order from the PPD file...
-    */
-
-    if ((choice = ppdFindMarkedChoice(ppd,"OutputOrder")) != 0) {
-      Reverse = !strcasecmp(choice->choice,"Reverse");
-    } else if ((choice = ppdFindMarkedChoice(ppd,"OutputBin")) != 0 &&
-        (attr = ppdFindAttr(ppd,"PageStackOrder",choice->choice)) != 0 &&
-        attr->value) {
-      Reverse = !strcasecmp(attr->value,"Reverse");
-    } else if ((attr = ppdFindAttr(ppd,"DefaultOutputOrder",0)) != 0 &&
-             attr->value) {
-      Reverse = !strcasecmp(attr->value,"Reverse");
-    }
-  }
-
-  /* adjust to even page when duplex */
-  if (((val = cupsGetOption("cupsEvenDuplex",num_options,options)) != 0 &&
-             (!strcasecmp(val, "true") || !strcasecmp(val, "on") ||
-               !strcasecmp(val, "yes"))) ||
-         ((attr = ppdFindAttr(ppd,"cupsEvenDuplex",0)) != 0 &&
-             (!strcasecmp(attr->value, "true")
-               || !strcasecmp(attr->value, "on") ||
-               !strcasecmp(attr->value, "yes")))) {
-    EvenDuplex = 1;
-  }
-
-  if ((val = cupsGetOption("multiple-document-handling", num_options, options)) != NULL)
-  {
-   /*
-    * This IPP attribute is unnecessarily complicated...
-    *
-    *   single-document, separate-documents-collated-copies, and
-    *   single-document-new-sheet all require collated copies.
-    *
-    *   separate-documents-uncollated-copies allows for uncollated copies.
-    */
-
-    Collate = strcasecmp(val, "separate-documents-uncollated-copies") != 0;
-  }
-
-  if ((val = cupsGetOption("Collate", num_options, options)) != NULL) {
-    if (strcasecmp(val, "True") == 0) {
-      Collate = 1;
-    }
-  } else {
-    if ((choice = ppdFindMarkedChoice(ppd,"Collate")) != NULL
-      && (!strcasecmp(choice->choice,"true")
-        || !strcasecmp(choice->choice, "on")
-	|| !strcasecmp(choice->choice, "yes"))) {
-      Collate = 1;
-    }
-  }
-
-  if ((val = cupsGetOption("gamma", num_options, options)) != NULL)
-      gammaval = atoi(val) * 0.001f;
-
-  if ((val = cupsGetOption("brightness", num_options, options)) != NULL)
-      brightness = atoi(val) * 0.01f;
-
-  if ((val = cupsGetOption("ppi", num_options, options)) != NULL)
-  {
-    if (sscanf(val, "%dx%d", &xppi, &yppi) < 2)
-      yppi = xppi;
-    zoom = 0.0;
-  }
-
-  if ((val = cupsGetOption("position", num_options, options)) != NULL)
-  {
-    if (strcasecmp(val, "center") == 0)
-    {
-      XPosition = 0;
-      YPosition = 0;
-    }
-    else if (strcasecmp(val, "top") == 0)
-    {
-      XPosition = 0;
-      YPosition = 1;
-    }
-    else if (strcasecmp(val, "left") == 0)
-    {
-      XPosition = -1;
-      YPosition = 0;
-    }
-    else if (strcasecmp(val, "right") == 0)
-    {
-      XPosition = 1;
-      YPosition = 0;
-    }
-    else if (strcasecmp(val, "top-left") == 0)
-    {
-      XPosition = -1;
-      YPosition = 1;
-    }
-    else if (strcasecmp(val, "top-right") == 0)
-    {
-      XPosition = 1;
-      YPosition = 1;
-    }
-    else if (strcasecmp(val, "bottom") == 0)
-    {
-      XPosition = 0;
-      YPosition = -1;
-    }
-    else if (strcasecmp(val, "bottom-left") == 0)
-    {
-      XPosition = -1;
-      YPosition = -1;
-    }
-    else if (strcasecmp(val, "bottom-right") == 0)
-    {
-      XPosition = 1;
-      YPosition = -1;
-    }
-  }
-
-  if ((val = cupsGetOption("saturation", num_options, options)) != NULL)
-    sat = atoi(val);
-
-  if ((val = cupsGetOption("hue", num_options, options)) != NULL)
-    hue = atoi(val);
-
-  if ((val = cupsGetOption("mirror", num_options, options)) != NULL &&
-      strcasecmp(val, "True") == 0)
-    Flip = 1;
-
-  if ((val = cupsGetOption("emit-jcl", num_options, options)) != NULL &&
-      (!strcasecmp(val, "false") || !strcasecmp(val, "off") ||
-       !strcasecmp(val, "no") || !strcmp(val, "0")))
-    emit_jcl = 0;
-  else
-    emit_jcl = 1;
-
-
-
- /*
-  * Open the input image to print...
-  */
-
-  colorspace = ColorDevice ? CUPS_IMAGE_RGB_CMYK : CUPS_IMAGE_WHITE;
-
-  img = cupsImageOpen(filename, colorspace, CUPS_IMAGE_WHITE, sat, hue, NULL);
-  if(img!=NULL){
-
-  int margin_defined = 0;
-  int fidelity = 0;
-  int document_large = 0;
-
-  if(ppd && (ppd->custom_margins[0]||ppd->custom_margins[1]||
-      ppd->custom_margins[2]||ppd->custom_margins[3]))   // In case of custom margins
-    margin_defined = 1;
-  if(PageLength!=PageTop-PageBottom||PageWidth!=PageRight-PageLeft)
-    margin_defined = 1;
-
-  if((val = cupsGetOption("ipp-attribute-fidelity",num_options,options)) != NULL) {
-    if(!strcasecmp(val,"true")||!strcasecmp(val,"yes")||
-        !strcasecmp(val,"on")) {
-      fidelity = 1;
-    }
-  }
-
-  float w = (float)cupsImageGetWidth(img);
-  float h = (float)cupsImageGetHeight(img);
-  float pw = PageRight-PageLeft;
-  float ph = PageTop-PageBottom;
-  int tempOrientation = Orientation;
-  if((val = cupsGetOption("orientation-requested",num_options,options))!=NULL) {
-    tempOrientation = atoi(val);
-  }
-  else if((val = cupsGetOption("landscape",num_options,options))!=NULL) {
-    if(!strcasecmp(val,"true")||!strcasecmp(val,"yes")) {
-      tempOrientation = 4;
-    }
-  }
-  if(tempOrientation==0) {
-    if(((pw > ph) && (w < h)) || ((pw < ph) && (w > h)))
-      tempOrientation = 4;
-  }
-  if(tempOrientation==4||tempOrientation==5) {
-    int tmp = pw;
-    pw = ph;
-    ph = tmp;
-  }
-  if(w>pw||h>ph) {
-    document_large = 1;
-  }
-
-  if((val = cupsGetOption("print-scaling",num_options,options)) != NULL) {
-    if(!strcasecmp(val,"auto")) {
-      if(fidelity||document_large) {
-        if(margin_defined)
-          zoom = 1.0;       // fit method
-        else
-          fillprint = 1;    // fill method
-      }
-      else
-        cropfit = 1;        // none method
-    }
-    else if(!strcasecmp(val,"auto-fit")) {
-      if(fidelity||document_large)
-        zoom = 1.0;         // fit method
-      else
-        cropfit = 1;        // none method
-    }
-    else if(!strcasecmp(val,"fill"))
-      fillprint = 1;        // fill method
-    else if(!strcasecmp(val,"fit"))
-      zoom = 1.0;           // fitplot = 1 or fit method
-    else
-      cropfit=1;            // none or crop-to-fit
-  }
-  else{       // print-scaling is not defined, look for alternate options.
-
-  if ((val = cupsGetOption("scaling", num_options, options)) != NULL)
-    zoom = atoi(val) * 0.01;
-  else if (((val =
-	     cupsGetOption("fit-to-page", num_options, options)) != NULL) ||
-	   ((val = cupsGetOption("fitplot", num_options, options)) != NULL))
-  {
-    if (!strcasecmp(val, "yes") || !strcasecmp(val, "on") ||
-	      !strcasecmp(val, "true"))
-      zoom = 1.0;
-    else
-      zoom = 0.0;
-  }
-  else if ((val = cupsGetOption("natural-scaling", num_options, options)) != NULL)
-    zoom = 0.0;
-
-  if((val = cupsGetOption("fill",num_options,options))!=0) {
-    if(!strcasecmp(val,"true")||!strcasecmp(val,"yes")) {
-      fillprint = 1;
-    }
-  }
-
-  if((val = cupsGetOption("crop-to-fit",num_options,options))!= NULL){
-    if(!strcasecmp(val,"true")||!strcasecmp(val,"yes")) {
-      cropfit=1;
-    }
-  } }
-  }
-  if(fillprint||cropfit)
-  {
-    float w = (float)cupsImageGetWidth(img);
-    float h = (float)cupsImageGetHeight(img);
-    float pw = PageRight-PageLeft;
-    float ph = PageTop-PageBottom;
-    int tempOrientation = Orientation;
-    const char *val;
-    int flag = 3;
-    if((val = cupsGetOption("orientation-requested",num_options,options))!=NULL)
-    {
-      tempOrientation = atoi(val);
-    }
-    else if((val = cupsGetOption("landscape",num_options,options))!=NULL)
-    {
-      if(!strcasecmp(val,"true")||!strcasecmp(val,"yes"))
-      {
-        tempOrientation = 4;
-      }
-    }
-    if(tempOrientation>0)
-    {
-      if(tempOrientation==4||tempOrientation==5)
-      {
-        float temp = pw;
-        pw = ph;
-        ph = temp;
-        flag = 4;
-      }
-    }
-    if(tempOrientation==0)
-    {
-      if(((pw > ph) && (w < h)) || ((pw < ph) && (w > h)))
-      {
-        int temp = pw;
-        pw = ph;
-        ph = temp;
-        flag = 4;
-      }
-    }
-    if(fillprint){
-      float final_w,final_h;
-      if(w*ph/pw <=h){
-        final_w =w;
-        final_h =w*ph/pw;
-      }
-      else{
-        final_w = h*pw/ph;
-        final_h = h;
-      }
-      float posw=(w-final_w)/2,posh=(h-final_h)/2;
-      posw = (1+XPosition)*posw;
-      posh = (1-YPosition)*posh;
-      cups_image_t *img2 = cupsImageCrop(img,posw,posh,final_w,final_h);
-      cupsImageClose(img);
-      img = img2;
-    }
-    else {
-      float final_w=w,final_h=h;
-      if(final_w>pw)
-      {
-        final_w = pw;
-      }
-      if(final_h>ph)
-      {
-        final_h = ph;
-      }
-      if((fabs(final_w-w)>0.5*w)||(fabs(final_h-h)>0.5*h))
-      {
-        fprintf(stderr,"[DEBUG]: Ignoring crop-to-fit option!\n");
-        cropfit=0;
-      }
-      else{
-        float posw=(w-final_w)/2,posh=(h-final_h)/2;
-        posw = (1+XPosition)*posw;
-        posh = (1-YPosition)*posh;
-        cups_image_t *img2 = cupsImageCrop(img,posw,posh,final_w,final_h);
-        cupsImageClose(img);
-        img = img2;
-        if(flag==4)
-        {
-          PageBottom+=(PageTop-PageBottom-final_w)/2;
-          PageTop = PageBottom+final_w;
-          PageLeft +=(PageRight-PageLeft-final_h)/2;
-          PageRight = PageLeft+final_h;
-        }
-        else{
-          PageBottom+=(PageTop-PageBottom-final_h)/2;
-          PageTop = PageBottom+final_h;
-          PageLeft +=(PageRight-PageLeft-final_w)/2;
-          PageRight = PageLeft+final_w;
-        }
-        if(PageBottom<0) PageBottom = 0;
-        if(PageLeft<0) PageLeft = 0;
-     }
-    }
-  }
-
-#if defined(USE_CONVERT_CMD) && defined(CONVERT_CMD)
-  if (img == NULL) {
-    char filename2[1024];
-    int fd2;
-
-    if ((fd2 = cupsTempFd(filename2, sizeof(filename2))) < 0)
-    {
-      perror("ERROR: Unable to copy image file");
-      return (1);
-    }
-    close(fd2);
-    snprintf(linebuf,LINEBUFSIZE,
-      CONVERT_CMD
-      " %s png:%s",filename, filename2);
-    if (system(linebuf) != 0) {
-      unlink(filename2);
-      perror("ERROR: Unable to copy image file");
-      return (1);
-    }
-    img = cupsImageOpen(filename2, colorspace,
-            CUPS_IMAGE_WHITE, sat, hue, NULL);
-    unlink(filename2);
-  }
-#endif
-  if (argc == 6)
-    unlink(filename);
-
-  if (img == NULL)
-  {
-    fputs("ERROR: Unable to open image file for printing!\n", stderr);
-    ppdClose(ppd);
-    return (1);
-  }
-
-  colorspace = cupsImageGetColorSpace(img);
-
- /*
-  * Scale as necessary...
-  */
-
-  if (zoom == 0.0 && xppi == 0)
-  {
-    xppi = cupsImageGetXPPI(img);
-    yppi = cupsImageGetYPPI(img);
-  }
-
-  if (yppi == 0)
-    yppi = xppi;
-
-  fprintf(stderr, "DEBUG: Before scaling: xppi=%d, yppi=%d, zoom=%.2f\n",
-          xppi, yppi, zoom);
-
-  if (xppi > 0)
-  {
-   /*
-    * Scale the image as neccesary to match the desired pixels-per-inch.
-    */
-
-    if (Orientation & 1)
-    {
-      xprint = (PageTop - PageBottom) / 72.0;
-      yprint = (PageRight - PageLeft) / 72.0;
-    }
-    else
-    {
-      xprint = (PageRight - PageLeft) / 72.0;
-      yprint = (PageTop - PageBottom) / 72.0;
-    }
-
-    fprintf(stderr, "DEBUG: Before scaling: xprint=%.1f, yprint=%.1f\n",
-            xprint, yprint);
-
-    xinches = (float)cupsImageGetWidth(img) / (float)xppi;
-    yinches = (float)cupsImageGetHeight(img) / (float)yppi;
-
-    fprintf(stderr, "DEBUG: Image size is %.1f x %.1f inches...\n",
-            xinches, yinches);
-
-    if ((val = cupsGetOption("natural-scaling", num_options, options)) != NULL)
-    {
-      xinches = xinches * atoi(val) / 100;
-      yinches = yinches * atoi(val) / 100;
-    }
-
-    if (cupsGetOption("orientation-requested", num_options, options) == NULL &&
-        cupsGetOption("landscape", num_options, options) == NULL)
-    {
-     /*
-      * Rotate the image if it will fit landscape but not portrait...
-      */
-
-      fputs("DEBUG: Auto orientation...\n", stderr);
-
-      if ((xinches > xprint || yinches > yprint) &&
-          xinches <= yprint && yinches <= xprint)
-      {
-       /*
-	* Rotate the image as needed...
-	*/
-
-        fputs("DEBUG: Using landscape orientation...\n", stderr);
-
-	Orientation = (Orientation + 1) & 3;
-	xsize       = yprint;
-	yprint      = xprint;
-	xprint      = xsize;
-      }
-    }
-  }
-  else
-  {
-   /*
-    * Scale percentage of page size...
-    */
-
-    xprint = (PageRight - PageLeft) / 72.0;
-    yprint = (PageTop - PageBottom) / 72.0;
-    aspect = (float)cupsImageGetYPPI(img) / (float)cupsImageGetXPPI(img);
-
-    fprintf(stderr, "DEBUG: Before scaling: xprint=%.1f, yprint=%.1f\n",
-            xprint, yprint);
-
-    fprintf(stderr, "DEBUG: cupsImageGetXPPI(img) = %d, cupsImageGetYPPI(img) = %d, aspect = %f\n",
-            cupsImageGetXPPI(img), cupsImageGetYPPI(img), aspect);
-
-    xsize = xprint * zoom;
-    ysize = xsize * cupsImageGetHeight(img) / cupsImageGetWidth(img) / aspect;
-
-    if (ysize > (yprint * zoom))
-    {
-      ysize = yprint * zoom;
-      xsize = ysize * cupsImageGetWidth(img) * aspect / cupsImageGetHeight(img);
-    }
-
-    xsize2 = yprint * zoom;
-    ysize2 = xsize2 * cupsImageGetHeight(img) / cupsImageGetWidth(img) / aspect;
-
-    if (ysize2 > (xprint * zoom))
-    {
-      ysize2 = xprint * zoom;
-      xsize2 = ysize2 * cupsImageGetWidth(img) * aspect / cupsImageGetHeight(img);
-    }
-
-    fprintf(stderr, "DEBUG: Portrait size is %.2f x %.2f inches\n", xsize, ysize);
-    fprintf(stderr, "DEBUG: Landscape size is %.2f x %.2f inches\n", xsize2, ysize2);
-
-    if (cupsGetOption("orientation-requested", num_options, options) == NULL &&
-        cupsGetOption("landscape", num_options, options) == NULL)
-    {
-     /*
-      * Choose the rotation with the largest area, but prefer
-      * portrait if they are equal...
-      */
-
-      fputs("DEBUG: Auto orientation...\n", stderr);
-
-      if ((xsize * ysize) < (xsize2 * xsize2))
-      {
-       /*
-	* Do landscape orientation...
-	*/
-
-        fputs("DEBUG: Using landscape orientation...\n", stderr);
-
-	Orientation = 1;
-	xinches     = xsize2;
-	yinches     = ysize2;
-	xprint      = (PageTop - PageBottom) / 72.0;
-	yprint      = (PageRight - PageLeft) / 72.0;
-      }
-      else
-      {
-       /*
-	* Do portrait orientation...
-	*/
-
-        fputs("DEBUG: Using portrait orientation...\n", stderr);
-
-	Orientation = 0;
-	xinches     = xsize;
-	yinches     = ysize;
-      }
-    }
-    else if (Orientation & 1)
-    {
-      fputs("DEBUG: Using landscape orientation...\n", stderr);
-
-      xinches     = xsize2;
-      yinches     = ysize2;
-      xprint      = (PageTop - PageBottom) / 72.0;
-      yprint      = (PageRight - PageLeft) / 72.0;
-    }
-    else
-    {
-      fputs("DEBUG: Using portrait orientation...\n", stderr);
-
-      xinches     = xsize;
-      yinches     = ysize;
-      xprint      = (PageRight - PageLeft) / 72.0;
-      yprint      = (PageTop - PageBottom) / 72.0;
-    }
-  }
-
- /*
-  * Compute the number of pages to print and the size of the image on each
-  * page...
-  */
-
-  if (zoom == 1.0) {
-    /* If fitplot is specified, make xpages, ypages 1 forcedly.
-       Because calculation error may be caused and
-          result of ceil function may be larger than 1.
-    */
-    xpages = ypages = 1;
-  } else {
-    xpages = ceil(xinches / xprint);
-    ypages = ceil(yinches / yprint);
-  }
-
-  xprint = xinches / xpages;
-  yprint = yinches / ypages;
-
-  fprintf(stderr, "DEBUG: xpages = %dx%.2fin, ypages = %dx%.2fin\n",
-          xpages, xprint, ypages, yprint);
-
- /*
-  * Update the page size for custom sizes...
-  */
-
-  if ((choice = ppdFindMarkedChoice(ppd, "PageSize")) != NULL &&
-      strcasecmp(choice->choice, "Custom") == 0)
-  {
-    float	width,		/* New width in points */
-		length;		/* New length in points */
-    char	s[255];		/* New custom page size... */
-
-
-   /*
-    * Use the correct width and length for the current orientation...
-    */
-
-    if (Orientation & 1)
-    {
-      width  = yprint * 72.0;
-      length = xprint * 72.0;
-    }
-    else
-    {
-      width  = xprint * 72.0;
-      length = yprint * 72.0;
-    }
-
-   /*
-    * Add margins to page size...
-    */
-
-    width  += ppd->custom_margins[0] + ppd->custom_margins[2];
-    length += ppd->custom_margins[1] + ppd->custom_margins[3];
-
-   /*
-    * Enforce minimums...
-    */
-
-    if (width < ppd->custom_min[0])
-      width = ppd->custom_min[0];
-
-    if (length < ppd->custom_min[1])
-      length = ppd->custom_min[1];
-
-    fprintf(stderr, "DEBUG: Updated custom page size to %.2f x %.2f inches...\n",
-            width / 72.0, length / 72.0);
-
-   /*
-    * Set the new custom size...
-    */
-
-    sprintf(s, "Custom.%.0fx%.0f", width, length);
-    ppdMarkOption(ppd, "PageSize", s);
-
-   /*
-    * Update page variables...
-    */
-
-    PageWidth  = width;
-    PageLength = length;
-    PageLeft   = ppd->custom_margins[0];
-    PageRight  = width - ppd->custom_margins[2];
-    PageBottom = ppd->custom_margins[1];
-    PageTop    = length - ppd->custom_margins[3];
-  }
-
-  if (Copies == 1) {
-    /* collate is not needed */
-    Collate = 0;
-    ppdMarkOption(ppd,"Collate","False");
-  }
-  if (!Duplex) {
-    /* evenDuplex is not needed */
-    EvenDuplex = 0;
-  }
-
-  /* check collate device */
-  if (Collate) {
-    if ((choice = ppdFindMarkedChoice(ppd,"Collate")) != NULL &&
-       !strcasecmp(choice->choice,"true")) {
-      ppd_option_t *opt;
-
-      if ((opt = ppdFindOption(ppd,"Collate")) != NULL &&
-        !opt->conflicted) {
-        deviceCollate = 1;
-      } else {
-        ppdMarkOption(ppd,"Collate","False");
-      }
-    }
-  }
-  /* check OutputOrder device */
-  if (Reverse) {
-    if (ppdFindOption(ppd,"OutputOrder") != NULL) {
-      deviceReverse = 1;
-    }
-  }
-  if (ppd != NULL &&
-       !ppd->manual_copies && Collate && !deviceCollate) {
-    /* Copying by device , software collate is impossible */
-    /* Enable software copying */
-    ppd->manual_copies = 1;
-  }
-  if (Copies > 1 && (ppd == NULL || ppd->manual_copies)
-      && Duplex) {
-    /* Enable software collate , or same pages are printed in both sides */
-      Collate = 1;
-      if (deviceCollate) {
-        deviceCollate = 0;
-        ppdMarkOption(ppd,"Collate","False");
-      }
-  }
-  if (Duplex && Collate && !deviceCollate) {
-    /* Enable evenDuplex or the first page may be printed other side of the
-      end of precedings */
-    EvenDuplex = 1;
-  }
-  if (Duplex && Reverse && !deviceReverse) {
-    /* Enable evenDuplex or the first page may be empty. */
-    EvenDuplex = 1;
-  }
-  /* change feature for software */
-  if (deviceCollate) {
-    Collate = 0;
-  }
-  if (deviceReverse) {
-    Reverse = 0;
-  }
-  if (ppd != NULL) {
-    if (ppd->manual_copies) {
-      /* sure disable hardware copying */
-      ppdMarkOption(ppd,"Copies","1");
-      ppdMarkOption(ppd,"JCLCopies","1");
-    } else {
-      /* change for hardware copying */
-      deviceCopies = Copies;
-      Copies = 1;
-    }
-  }
-
- /*
-  * See if we need to collate, and if so how we need to do it...
-  */
-
-  if (xpages == 1 && ypages == 1
-      && (Collate || deviceCollate) && !EvenDuplex) {
-    /* collate is not needed, disable it */
-    deviceCollate = 0;
-    Collate = 0;
-    ppdMarkOption(ppd,"Collate","False");
-  }
-
-  if (((xpages*ypages) % 2) == 0) {
-    /* even pages, disable EvenDuplex */
-    EvenDuplex = 0;
-  }
-
- /*
-  * Write any "exit server" options that have been selected...
-  */
-
-  ppdEmit(ppd, stdout, PPD_ORDER_EXIT);
-
- /*
-  * Write any JCL commands that are needed to print PostScript code...
-  */
-
-  if (ppd && emit_jcl) {
-    /* pdftopdf only adds JCL to the job if the printer is a native PDF
-       printer and the PPD is for this mode, having the "*JCLToPDFInterpreter:"
-       keyword. We need to read this keyword manually from the PPD and replace
-       the content of ppd->jcl_ps by the value of this keyword, so that
-       ppdEmitJCL() actalually adds JCL based on the presence on
-       "*JCLToPDFInterpreter:". */
-    ppd_attr_t *attr;
-    char buf[1024];
-    int devicecopies_done = 0;
-    char *old_jcl_ps = ppd->jcl_ps;
-    /* If there is a "Copies" option in the PPD file, assure that hardware
-       copies are implemented as described by this option */
-    if (ppdFindOption(ppd,"Copies") != NULL && deviceCopies > 1)
-    {
-      snprintf(buf,sizeof(buf),"%d",deviceCopies);
-      ppdMarkOption(ppd,"Copies",buf);
-      devicecopies_done = 1;
-    }
-    if ((attr = ppdFindAttr(ppd,"JCLToPDFInterpreter",NULL)) != NULL)
-    {
-      if (deviceCopies > 1 && devicecopies_done == 0 && /* HW copies */
-	  strncmp(ppd->jcl_begin, "\033%-12345X@", 10) == 0) /* PJL */
-      {
-	/* Add a PJL command to implement the hardware copies */
-        const size_t size = strlen(attr->value) + 1 + 30;
-        ppd->jcl_ps = (char *)malloc(size * sizeof(char));
-        if (deviceCollate)
-	{
-          snprintf(ppd->jcl_ps, size, "@PJL SET QTY=%d\n%s",
-                   deviceCopies, attr->value);
-        }
-	else
-	{
-          snprintf(ppd->jcl_ps, size, "@PJL SET COPIES=%d\n%s",
-                   deviceCopies, attr->value);
-        }
-      }
-      else
-	ppd->jcl_ps = strdup(attr->value);
-      ppd_decode(ppd->jcl_ps);
-      pdf_printer = 1;
-    }
-    else
-    {
-      ppd->jcl_ps = NULL;
-      pdf_printer = 0;
-    }
-    ppdEmitJCL(ppd, stdout, atoi(argv[1]), argv[2], argv[3]);
-    emitJCLOptions(stdout,deviceCopies);
-    free(ppd->jcl_ps);
-    ppd->jcl_ps = old_jcl_ps; /* cups uses pool allocator, not free() */
-  }
-
- /*
-  * Start sending the document with any commands needed...
-  */
-
-  outPrologue(Copies*xpages*ypages+(EvenDuplex ? 1 : 0));
-
- /*
-  * Output the pages...
-  */
-
-  row = malloc(cupsImageGetWidth(img) * abs(colorspace) + 3);
-
-  fprintf(stderr, "DEBUG: XPosition=%d, YPosition=%d, Orientation=%d\n",
-          XPosition, YPosition, Orientation);
-  fprintf(stderr, "DEBUG: xprint=%.0f, yprint=%.0f\n", xprint, yprint);
-  fprintf(stderr, "DEBUG: PageLeft=%.0f, PageRight=%.0f, PageWidth=%.0f\n",
-          PageLeft, PageRight, PageWidth);
-  fprintf(stderr, "DEBUG: PageBottom=%.0f, PageTop=%.0f, PageLength=%.0f\n",
-          PageBottom, PageTop, PageLength);
-
-  if (Flip) {
-    pr = PageWidth - PageLeft;
-    pl = PageWidth - PageRight;
-  } else {
-    pr = PageRight;
-    pl = PageLeft;
-  }
-
-  switch (Orientation)
-  {
-    default :
-	switch (XPosition)
-	{
-	  case -1 :
-	      left = pl;
-	      break;
-	  default :
-              left = (pr + pl - xprint * 72) / 2;
-	      break;
-	  case 1 :
-	      left = pr - xprint * 72;
-	      break;
-	}
-
-	switch (YPosition)
-	{
-	  case -1 :
-	      top = PageBottom;
-	      break;
-	  default :
-	      top = (PageTop + PageBottom - yprint * 72) / 2;
-	      break;
-	  case 1 :
-	      top = PageTop - yprint * 72;;
-	      break;
-	}
-	break;
-
-    case 1 :
-	switch (XPosition)
-	{
-	  case -1 :
-              left = PageBottom;
-	      break;
-	  default :
-              left = (PageTop + PageBottom - xprint * 72) / 2;
-	      break;
-	  case 1 :
-              left = PageTop - xprint * 72;
-	      break;
-	}
-
-	switch (YPosition)
-	{
-	  case -1 :
-	      top = pl;
-	      break;
-	  default :
-	      top = (pr + pl - yprint * 72) / 2;
-	      break;
-	  case 1 :
-	      top = pr - yprint * 72;;
-	      break;
-	}
-	break;
-
-    case 2 :
-	switch (XPosition)
-	{
-	  case -1 :
-              left = pr - xprint * 72;
-	      break;
-	  default :
-              left = (pr + pl - xprint * 72) / 2;
-	      break;
-	  case 1 :
-              left = pl;
-	      break;
-	}
-
-	switch (YPosition)
-	{
-	  case -1 :
-	      top = PageTop - yprint * 72;
-	      break;
-	  default :
-	      top = (PageTop + PageBottom - yprint * 72) / 2;
-	      break;
-	  case 1 :
-	      top = PageBottom;
-	      break;
-	}
-	break;
-
-    case 3 :
-	switch (XPosition)
-	{
-	  case -1 :
-              left = PageTop - xprint * 72;
-	      break;
-	  default :
-              left = (PageTop + PageBottom - xprint * 72) / 2;
-	      break;
-	  case 1 :
-              left = PageBottom;
-	      break;
-	}
-
-	switch (YPosition)
-	{
-	  case -1 :
-	      top = pr - yprint * 72;;
-	      break;
-	  default :
-	      top = (pr + pl - yprint * 72) / 2;
-	      break;
-	  case 1 :
-	      top = pl;
-	      break;
-	}
-	break;
-  }
-
-  fprintf(stderr, "DEBUG: left=%.2f, top=%.2f\n", left, top);
-
-  if (Collate)
-  {
-    int *contentsObjs;
-    int *imgObjs;
-
-    if ((contentsObjs = malloc(sizeof(int)*xpages*ypages)) == NULL)
-    {
-      fprintf(stderr,"ERROR: Can't allocate contentsObjs\n");
-      exit(2);
-    }
-    if ((imgObjs = malloc(sizeof(int)*xpages*ypages)) == NULL)
-    {
-      fprintf(stderr,"ERROR: Can't allocate imgObjs\n");
-      exit(2);
-    }
-    for (xpage = 0; xpage < xpages; xpage ++)
-      for (ypage = 0; ypage < ypages; ypage ++)
-      {
-	int imgObj;
-	int contentsObj;
-
-	contentsObj = contentsObjs[ypages*xpage+ypage] = newObj();
-	imgObj = imgObjs[ypages*xpage+ypage] = newObj();
-
-	/* out contents object */
-	outPageContents(contentsObj);
-
-	/* out image object */
-	outImage(imgObj);
-      }
-    for (page = 0; Copies > 0 ; Copies --) {
-      for (xpage = 0; xpage < xpages; xpage ++)
-	for (ypage = 0; ypage < ypages; ypage ++, page ++)
-	{
-	  /* out Page Object */
-	  outPageObject(pageObjects[page],
-	    contentsObjs[ypages*xpage+ypage],
-	    imgObjs[ypages*xpage+ypage]);
-	  if (pdf_printer)
-	    fprintf(stderr, "PAGE: %d %d\n", page+1, 1);
-	}
-      if (EvenDuplex) {
-	/* out empty page */
-	outPageObject(pageObjects[page],-1,-1);
-	if (pdf_printer)
-	  fprintf(stderr, "PAGE: %d %d\n", page+1, 1);
-      }
-    }
-    free(contentsObjs);
-    free(imgObjs);
-  }
-  else {
-    for (page = 0, xpage = 0; xpage < xpages; xpage ++)
-      for (ypage = 0; ypage < ypages; ypage ++)
-      {
-	int imgObj;
-	int contentsObj;
-	int p;
-
-	imgObj = newObj();
-	contentsObj = newObj();
-
-	/* out contents object */
-	outPageContents(contentsObj);
-
-	/* out image object */
-	outImage(imgObj);
-
-	for (p = 0;p < Copies;p++, page++)
-	{
-	  /* out Page Object */
-	  outPageObject(pageObjects[page],contentsObj,imgObj);
-	  if (pdf_printer)
-	    fprintf(stderr, "PAGE: %d %d\n", page+1, 1);
-	}
-      }
-    if (EvenDuplex) {
-      /* out empty pages */
-      int p;
-
-      for (p = 0;p < Copies;p++, page++)
-      {
-	outPageObject(pageObjects[page],-1,-1);
-	if (pdf_printer)
-	  fprintf(stderr, "PAGE: %d %d\n", page+1, 1);
-      }
-    }
-  }
-
-  outXref();
-  outTrailer();
-  freeAllObj();
- /*
-  * Close files...
-  */
-
-#ifndef CUPS_1_1
-  if (emit_jcl)
-  {
-    if (ppd && ppd->jcl_end)
-      ppdEmitJCLEnd(ppd, stdout);
-  }
-#endif
-
-  cupsImageClose(img);
-  ppdClose(ppd);
-
-  return (0);
-}
-
-#ifdef OUT_AS_HEX
-/*
- * 'out_hex()' - Print binary data as a series of hexadecimal numbers.
- */
-
-static void
-out_hex(cups_ib_t *data,			/* I - Data to print */
-       int       length,		/* I - Number of bytes to print */
-       int       last_line)		/* I - Last line of raster data? */
-{
-  static int	col = 0;		/* Current column */
-  static char	*hex = "0123456789ABCDEF";
-					/* Hex digits */
-
-
-  while (length > 0)
-  {
-   /*
-    * Put the hex chars out to the file; note that we don't use printf()
-    * for speed reasons...
-    */
-
-    putcPdf(hex[*data >> 4]);
-    putcPdf(hex[*data & 15]);
-
-    data ++;
-    length --;
-
-    col += 2;
-    if (col > 78)
-    {
-      putcPdf('\n');
-      col = 0;
-    }
-  }
-
-  if (last_line && col)
-  {
-    putcPdf('\n');
-    col = 0;
-  }
-}
-#else
-
-#ifdef OUT_AS_ASCII85
-/*
- * 'out_ascii85()' - Print binary data as a series of base-85 numbers.
- */
-
-static void
-out_ascii85(cups_ib_t *data,		/* I - Data to print */
-	   int       length,		/* I - Number of bytes to print */
-	   int       last_line)		/* I - Last line of raster data? */
-{
-  unsigned	b;			/* Binary data word */
-  unsigned char	c[6];			/* ASCII85 encoded chars */
-  static int	col = 0;		/* Current column */
-
-
-  c[5] = '\0'; /* end mark */
-  while (length > 3)
-  {
-    b = (((((data[0] << 8) | data[1]) << 8) | data[2]) << 8) | data[3];
-
-    if (b == 0)
-    {
-      putcPdf('z');
-      col ++;
-    }
-    else
-    {
-      c[4] = (b % 85) + '!';
-      b /= 85;
-      c[3] = (b % 85) + '!';
-      b /= 85;
-      c[2] = (b % 85) + '!';
-      b /= 85;
-      c[1] = (b % 85) + '!';
-      b /= 85;
-      c[0] = b + '!';
-
-      outPdf(c);
-      col += 5;
-    }
-
-    data += 4;
-    length -= 4;
-
-    if (col >= 75)
-    {
-      putcPdf('\n');
-      col = 0;
-    }
-  }
-
-  if (last_line)
-  {
-    if (length > 0)
-    {
-      memset(data + length, 0, 4 - length);
-      b = (((((data[0] << 8) | data[1]) << 8) | data[2]) << 8) | data[3];
-
-      c[4] = (b % 85) + '!';
-      b /= 85;
-      c[3] = (b % 85) + '!';
-      b /= 85;
-      c[2] = (b % 85) + '!';
-      b /= 85;
-      c[1] = (b % 85) + '!';
-      b /= 85;
-      c[0] = b + '!';
-
-      c[length+1] = '\0';
-      outPdf(c);
-    }
-
-    outPdf("~>");
-    col = 0;
-  }
-}
-#else
-/*
- * 'out_bin()' - Print binary data as binary.
- */
-
-static void
-out_bin(cups_ib_t *data,		/* I - Data to print */
-	   int       length,		/* I - Number of bytes to print */
-	   int       last_line)		/* I - Last line of raster data? */
-{
-  while (length > 0)
-  {
-    putcPdf(*data);
-    data ++;
-    length --;
-  }
-
-  if (last_line)
-  {
-    putcPdf('\n');
-  }
-}
-#endif
-#endif
diff --git a/filter/mupdftoraster.c b/filter/mupdftoraster.c
deleted file mode 100644
index 09c66c0..0000000
--- a/filter/mupdftoraster.c
+++ /dev/null
@@ -1,435 +0,0 @@
-/*
-
-Copyright (c) 2016, Pranjal Bhor
-Copyright (c) 2008-2016, Till Kamppeter
-Copyright (c) 2011, Tim Waugh
-Copyright (c) 2011-2013, Richard Hughes
-
-Permission is hereby granted, free of charge, to any person obtaining
-a copy of this software and associated documentation files (the
-"Software"), to deal in the Software without restriction, including
-without limitation the rights to use, copy, modify, merge, publish,
-distribute, sublicense, and/or sell copies of the Software, and to
-permit persons to whom the Software is furnished to do so, subject to
-the following conditions:
-
-The above copyright notice and this permission notice shall be included
-in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-MIT Open Source License  -  http://www.opensource.org/
-
-*/
-
-
-/* PS/PDF to CUPS Raster filter based on mutool */
-
-#include <config.h>
-#include <cups/cups.h>
-#if (CUPS_VERSION_MAJOR > 1) || (CUPS_VERSION_MINOR > 6)
-#define HAVE_CUPS_1_7 1
-#endif
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdarg.h>
-#include <fcntl.h>
-#include <cups/raster.h>
-#include <cupsfilters/colormanager.h>
-#include <cupsfilters/raster.h>
-#include <sys/types.h>
-#include <sys/wait.h>
-#include <signal.h>
-#include <unistd.h>
-#include <errno.h>
-
-#define PDF_MAX_CHECK_COMMENT_LINES	20
-
-#define CUPS_IPTEMPFILE "/tmp/ip-XXXXXX"
-#define CUPS_OPTEMPFILE "/tmp/op-XXXXXX"
-
-#ifdef CUPS_RASTER_SYNCv1
-typedef cups_page_header2_t mupdf_page_header;
-#else
-typedef cups_page_header_t mupdf_page_header;
-#endif /* CUPS_RASTER_SYNCv1 */
-
-
-int
-parse_doc_type(FILE *fp)
-{
-  char buf[5];
-  char *rc;
-
-  /* get the first few bytes of the file */
-  rewind(fp);
-  rc = fgets(buf,sizeof(buf),fp);
-  /* empty input */
-  if (rc == NULL)
-    return 1;
-
-  /* is PDF */
-  if (strncmp(buf,"%PDF",4) == 0)
-    return 0;
-
-  fprintf(stderr,"DEBUG: input file cannot be identified\n");
-  exit(EXIT_FAILURE);
-}
-
-static void
-parse_pdf_header_options(FILE *fp, mupdf_page_header *h)
-{
-  char buf[4096];
-  int i;
-
-  rewind(fp);
-  /* skip until PDF start header */
-  while (fgets(buf,sizeof(buf),fp) != 0) {
-    if (strncmp(buf,"%PDF",4) == 0) {
-      break;
-    }
-  }
-  for (i = 0;i < PDF_MAX_CHECK_COMMENT_LINES;i++) {
-    if (fgets(buf,sizeof(buf),fp) == 0) break;
-    if (strncmp(buf,"%%PDFTOPDFNumCopies",19) == 0) {
-      char *p;
-
-      p = strchr(buf+19,':');
-      h->NumCopies = atoi(p+1);
-    } else if (strncmp(buf,"%%PDFTOPDFCollate",17) == 0) {
-      char *p;
-
-      p = strchr(buf+17,':');
-      while (*p == ' ' || *p == '\t') p++;
-      if (strncasecmp(p,"true",4) == 0) {
-        h->Collate = CUPS_TRUE;
-      } else {
-        h->Collate = CUPS_FALSE;
-      }
-    }
-  }
-}
-
-static void
-add_pdf_header_options(mupdf_page_header *h,
-		       cups_array_t 	 *mupdf_args)
-{
-  char tmpstr[1024];
-
-  if ((h->HWResolution[0] != 100) || (h->HWResolution[1] != 100)) {
-    snprintf(tmpstr, sizeof(tmpstr), "-r%dx%d", h->HWResolution[0], 
-	     h->HWResolution[1]); 
-    cupsArrayAdd(mupdf_args, strdup(tmpstr));
-  } else {
-    snprintf(tmpstr, sizeof(tmpstr), "-r100x100");
-    cupsArrayAdd(mupdf_args, strdup(tmpstr));
-  }
-
-  snprintf(tmpstr, sizeof(tmpstr), "-w%d", h->cupsWidth);
-  cupsArrayAdd(mupdf_args, strdup(tmpstr));
-
-  snprintf(tmpstr, sizeof(tmpstr), "-h%d", h->cupsHeight);
-  cupsArrayAdd(mupdf_args, strdup(tmpstr));
-
-  switch (h->cupsColorSpace) {
-  case CUPS_CSPACE_RGB:
-  case CUPS_CSPACE_CMY:
-  case CUPS_CSPACE_SRGB:
-  case CUPS_CSPACE_ADOBERGB:
-    snprintf(tmpstr, sizeof(tmpstr), "-crgb");
-    break;
-
-  case CUPS_CSPACE_CMYK:
-    snprintf(tmpstr, sizeof(tmpstr), "-ccmyk");
-    break;
-
-  case CUPS_CSPACE_SW:
-    snprintf(tmpstr, sizeof(tmpstr), "-cgray");
-    break;
-
-  default:
-  case CUPS_CSPACE_K:
-  case CUPS_CSPACE_W:
-    snprintf(tmpstr, sizeof(tmpstr), "-cmono");
-    break;
-  }
-  cupsArrayAdd(mupdf_args, strdup(tmpstr));
-}
-
-static int
-mutool_spawn (const char *filename,
-	      cups_array_t *mupdf_args,
-	      char **envp)
-{
-  char *argument;
-  char **mutoolargv;
-  const char* apos;
-  int i;
-  int numargs;
-  int pid;
-  int status = 65536;
-  int wstatus;
-
-  /* Put mutool command line argument into an array for the "exec()"
-     call */
-  numargs = cupsArrayCount(mupdf_args);
-  mutoolargv = calloc(numargs + 1, sizeof(char *));
-  for (argument = (char *)cupsArrayFirst(mupdf_args), i = 0; argument;
-       argument = (char *)cupsArrayNext(mupdf_args), i++) {
-    mutoolargv[i] = argument;
-  }
-  mutoolargv[i] = NULL;
-
-  /* Debug output: Full mutool command line and environment variables */
-  fprintf(stderr, "DEBUG: mutool command line:");
-  for (i = 0; mutoolargv[i]; i ++) {
-    if ((strchr(mutoolargv[i],' ')) || (strchr(mutoolargv[i],'\t')))
-      apos = "'";
-    else
-      apos = "";
-    fprintf(stderr, " %s%s%s", apos, mutoolargv[i], apos);
-  }
-  fprintf(stderr, "\n");
-
-  for (i = 0; envp[i]; i ++)
-    fprintf(stderr, "DEBUG: envp[%d]=\"%s\"\n", i, envp[i]);
-
-  if ((pid = fork()) == 0) {
-    /* Execute mutool command line ... */
-    execvpe(filename, mutoolargv, envp);
-    perror(filename);
-    goto out;
-  }
-
- retry_wait:
-  if (waitpid (pid, &wstatus, 0) == -1) {
-    if (errno == EINTR)
-      goto retry_wait;
-    perror ("mutool");
-    goto out;
-  }
-
-  /* How did mutool process terminate */
-  if (WIFEXITED(wstatus))
-    /* Via exit() anywhere or return() in the main() function */
-    status = WEXITSTATUS(wstatus);
-  else if (WIFSIGNALED(wstatus))
-    /* Via signal */
-    status = 256 * WTERMSIG(wstatus);
-  fprintf(stderr, "DEBUG: mutool completed, status: %d\n", status);
-
- out:
-  free(mutoolargv);
-  return status;
-}
-
-int
-main (int argc, char **argv, char *envp[])
-{
-  char buf[BUFSIZ];
-  char *icc_profile = NULL;
-  char tmpstr[1024];
-  const char *t = NULL;
-  cups_array_t *mupdf_args = NULL;
-  cups_option_t *options = NULL;
-  FILE *fp = NULL;
-  char infilename[1024];
-  mupdf_page_header h;
-  int fd = -1;
-  int cm_disabled;
-  int n;
-  int num_options;
-  int empty = 0;
-  int status = 1;
-  ppd_file_t *ppd = NULL;
-  struct sigaction sa;
-  cm_calibration_t cm_calibrate;
-#ifdef HAVE_CUPS_1_7
-  ppd_attr_t *attr;
-#endif /* HAVE_CUPS_1_7 */
-
-  if (argc < 6 || argc > 7) {
-    fprintf(stderr, "ERROR: %s job-id user title copies options [file]\n",
-	    argv[0]);
-    goto out;
-  }
-
-  memset(&sa, 0, sizeof(sa));
-  /* Ignore SIGPIPE and have write return an error instead */
-  sa.sa_handler = SIG_IGN;
-  sigaction(SIGPIPE, &sa, NULL);
-
-  num_options = cupsParseOptions(argv[5], 0, &options);
-
-  t = getenv("PPD");
-  if (t && t[0] != '\0')
-    if ((ppd = ppdOpenFile(t)) == NULL) {
-      fprintf(stderr, "ERROR: Failed to open PPD: %s\n", t);
-    }
-
-  if (ppd) {
-    ppdMarkDefaults (ppd);
-    cupsMarkOptions (ppd, num_options, options);
-  }
-
-  if (argc == 6) {
-    /* stdin */
-
-    fd = cupsTempFd(infilename, 1024);
-    if (fd < 0) {
-      fprintf(stderr, "ERROR: Can't create temporary file\n");
-      goto out;
-    }
-
-    /* copy stdin to the tmp file */
-    while ((n = read(0,buf,BUFSIZ)) > 0) {
-      if (write(fd,buf,n) != n) {
-        fprintf(stderr, "ERROR: Can't copy stdin to temporary file\n");
-        close(fd);
-        goto out;
-      }
-    }
-    if (lseek(fd,0,SEEK_SET) < 0) {
-      fprintf(stderr, "ERROR: Can't rewind temporary file\n");
-      close(fd);
-      goto out;
-    }
-
-    if ((fp = fdopen(fd,"rb")) == 0) {
-      fprintf(stderr, "ERROR: Can't fdopen temporary file\n");
-      close(fd);
-      goto out;
-    }
-  } else {
-    /* argc == 7 filename is specified */
-
-    if ((fp = fopen(argv[6],"rb")) == 0) {
-      fprintf(stderr, "ERROR: Can't open input file %s\n",argv[6]);
-      goto out;
-    }
-    strncpy(infilename, argv[6], sizeof(infilename) - 1);
-  }
-
-  /* If doc type is not PDF exit */
-  if(parse_doc_type(fp))
-     empty = 1;
-
-  /*  Check status of color management in CUPS */
-  cm_calibrate = cmGetCupsColorCalibrateMode(options, num_options);
-
-  if (cm_calibrate == CM_CALIBRATION_ENABLED)
-    cm_disabled = 1;
-  else 
-    cm_disabled = cmIsPrinterCmDisabled(getenv("PRINTER"));
-
-  if (!cm_disabled)
-    cmGetPrinterIccProfile(getenv("PRINTER"), &icc_profile, ppd);
-
-  /* mutool parameters */
-  mupdf_args = cupsArrayNew(NULL, NULL);
-  if (!mupdf_args) {
-    fprintf(stderr, "ERROR: Unable to allocate memory for mutool arguments array\n");
-    goto out;
-  }
-
-  fprintf(stderr,"command: %s\n",CUPS_MUTOOL);
-  snprintf(tmpstr, sizeof(tmpstr), "%s", CUPS_MUTOOL);
-  cupsArrayAdd(mupdf_args, strdup(tmpstr));
-  cupsArrayAdd(mupdf_args, strdup("draw"));
-  cupsArrayAdd(mupdf_args, strdup("-L"));
-  cupsArrayAdd(mupdf_args, strdup("-o-"));
-  cupsArrayAdd(mupdf_args, strdup("-smtf"));
-
-  /* mutool output parameters */
-  cupsArrayAdd(mupdf_args, strdup("-Fpwg"));
-
-  /* Note that MuPDF only creates PWG Raster and never CUPS Raster,
-     so we always set the PWG Raster flag in the cupsRasterParseIPPOptions()
-     calls.
-     Make also sure that the width and height of the page in pixels is
-     the size of the full page (as PWG Raster and MuPDF require it) and not
-     only the printable area (as cupsRasterInterpretPPD() sets, to fulfill
-     CUPS Raster standard) */
-  if (ppd) {
-    cupsRasterInterpretPPD(&h, ppd, num_options, options, 0);
-    h.cupsWidth = h.HWResolution[0] * h.PageSize[0] / 72;
-    h.cupsHeight = h.HWResolution[1] * h.PageSize[1] / 72;
-#ifdef HAVE_CUPS_1_7
-    cupsRasterParseIPPOptions(&h, num_options, options, 1, 0);
-#endif /* HAVE_CUPS_1_7 */
-  } else {
-#ifdef HAVE_CUPS_1_7
-    cupsRasterParseIPPOptions(&h, num_options, options, 1, 1);
-#else
-    fprintf(stderr, "ERROR: No PPD file specified.\n");
-    goto out;
-#endif /* HAVE_CUPS_1_7 */
-  }
-
-  if ((h.HWResolution[0] == 100) && (h.HWResolution[1] == 100)) {
-    /* No "Resolution" option */
-    if (ppd && (attr = ppdFindAttr(ppd, "DefaultResolution", 0)) != NULL) {
-      /* "*DefaultResolution" keyword in the PPD */
-      const char *p = attr->value;
-      h.HWResolution[0] = atoi(p);
-      if ((p = strchr(p, 'x')) != NULL)
-	h.HWResolution[1] = atoi(p);
-      else
-	h.HWResolution[1] = h.HWResolution[0];
-      if (h.HWResolution[0] <= 0)
-	h.HWResolution[0] = 300;
-      if (h.HWResolution[1] <= 0)
-	h.HWResolution[1] = h.HWResolution[0];
-    } else {
-      h.HWResolution[0] = 300;
-      h.HWResolution[1] = 300;
-    }
-    h.cupsWidth = h.HWResolution[0] * h.PageSize[0] / 72;
-    h.cupsHeight = h.HWResolution[1] * h.PageSize[1] / 72;
-  }
-
-  /* set PDF-specific options */
-  parse_pdf_header_options(fp, &h);
-
-  /* fixed other values that pdftopdf handles */
-  h.MirrorPrint = CUPS_FALSE;
-  h.Orientation = CUPS_ORIENT_0;
-
-  /* get all the data from the header and pass it to mutool */
-  add_pdf_header_options (&h, mupdf_args);
-
-  snprintf(tmpstr, sizeof(tmpstr), "%s", infilename);
-  cupsArrayAdd(mupdf_args, strdup(tmpstr));
-
-  /* Execute mutool command line ... */
-  snprintf(tmpstr, sizeof(tmpstr), "%s", CUPS_MUTOOL);
-		
-  /* call mutool */
-  status = mutool_spawn (tmpstr, mupdf_args, envp);
-  if (status != 0) status = 1;
-
-  if(empty)
-  {
-     fprintf(stderr, "DEBUG: Input is empty, outputting empty file.\n");
-     status = 0;
-  }
-out:
-  if (fp)
-    fclose(fp);
-  if (mupdf_args) 
-    cupsArrayDelete(mupdf_args);
-
-  free(icc_profile);
-  if (ppd)
-    ppdClose(ppd);
-  if (fd >= 0)
-    unlink(infilename);
-  return status;
-}
diff --git a/filter/pdf.cxx b/filter/pdf.cxx
deleted file mode 100644
index 51b5fcb..0000000
--- a/filter/pdf.cxx
+++ /dev/null
@@ -1,439 +0,0 @@
-/*
- * Copyright 2012 Canonical Ltd.
- * Copyright 2013 ALT Linux, Andrew V. Stepanov <stanv@altlinux.com>
- * Copyright 2018 Sahil Arora <sahilarora.535@gmail.com>
- *
- * This program is free software: you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 3, as published
- * by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranties of
- * MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
- * PURPOSE.  See the GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <config.h>
-#include "pdf.h"
-#include <vector>
-#include <string>
-#include <cstring>
-#include <qpdf/QPDF.hh>
-#include <qpdf/QPDFObjectHandle.hh>
-#include <qpdf/QPDFWriter.hh>
-#include <qpdf/QPDFAcroFormDocumentHelper.hh>
-#include <qpdf/QPDFPageDocumentHelper.hh>
-
-/*
- * Useful reference:
- *
- * http://www.gnupdf.org/Indirect_Object
- * http://www.gnupdf.org/Introduction_to_PDF
- * http://blog.idrsolutions.com/2011/05/understanding-the-pdf-file-format-%E2%80%93-pdf-xref-tables-explained
- * http://labs.appligent.com/pdfblog/pdf-hello-world/
- * https://github.com/OpenPrinting/cups-filters/pull/25
-*/
-
-
-/**
- * 'makeRealBox()' - Return a QPDF array object of real values for a box.
- * O - QPDFObjectHandle for an array
- * I - Dimensions of the box in a float array
- */
-static QPDFObjectHandle makeRealBox(float values[4])
-{
-  QPDFObjectHandle ret = QPDFObjectHandle::newArray();
-  for (int i = 0; i < 4; ++i) {
-    ret.appendItem(QPDFObjectHandle::newReal(values[i]));
-  }
-  return ret;
-}
-
-
-/**
- * 'pdf_load_template()' - Load an existing PDF file and do initial parsing
- *                         using QPDF.
- * I - Filename to open
- */
-extern "C" pdf_t * pdf_load_template(const char *filename)
-{
-  QPDF *pdf = new QPDF();
-  pdf->processFile(filename);
-  unsigned pages = (pdf->getAllPages()).size();
-
-  if (pages != 1) {
-    fprintf(stderr, "ERROR: PDF template must contain exactly 1 page: %s\n",
-            filename);
-    delete pdf;
-    return NULL;
-  }
-
-  return pdf;
-}
-
-
-/**
- * 'pdf_free()' - Free pointer used by PDF object
- * I - Pointer to PDF object
- */
-extern "C" void pdf_free(pdf_t *pdf)
-{
-  delete pdf;
-}
-
-/*
- * 'pdf_pages()' - Count number of pages in file
- *                         using QPDF.
- * I - Filename to open
- * O - Number of pages or -1 on error
- */
-int pdf_pages(const char *filename)
-{
-  QPDF *pdf = new QPDF();
-  if (pdf) {
-    try{
-      pdf->processFile(filename);
-    } catch(...) {
-      pdf_free(pdf);
-      return -1;
-    }
-    int pages = (pdf->getAllPages()).size();
-    pdf_free(pdf);
-    return pages;
-  } else
-    return -1;
-}
-
-
-/**
- * 'pdf_prepend_stream' - Prepend a stream to the contents of a specified
- *                        page in PDF file.
- * I - Pointer to QPDF object
- * I - page number of page to prepend stream to
- * I - buffer containing data to be prepended
- * I - length of buffer
- */
-extern "C" void pdf_prepend_stream(pdf_t *pdf,
-                                   unsigned page_num,
-                                   char const *buf,
-                                   size_t len)
-{
-  std::vector<QPDFObjectHandle> pages = pdf->getAllPages();
-  if (pages.empty() || page_num > pages.size()) {
-    fprintf(stderr, "ERROR: Unable to prepend stream to requested PDF page\n");
-    return;
-  }
-
-  QPDFObjectHandle page = pages[page_num - 1];
-
-  // get page contents stream / array  
-  QPDFObjectHandle contents = page.getKey("/Contents");
-  if (!contents.isStream() && !contents.isArray())
-  {
-    fprintf(stderr, "ERROR: Malformed PDF.\n");
-    return;
-  }
-
-  // prepare the new stream which is to be prepended
-  PointerHolder<Buffer> stream_data = PointerHolder<Buffer>(new Buffer(len));
-  memcpy(stream_data->getBuffer(), buf, len);
-  QPDFObjectHandle stream = QPDFObjectHandle::newStream(pdf, stream_data);
-  stream = pdf->makeIndirectObject(stream);
-
-  // if the contents is an array, prepend the new stream to the array,
-  // else convert the contents to an array and the do the same.
-  if (contents.isStream())
-  {
-    QPDFObjectHandle old_streamdata = contents;
-    contents = QPDFObjectHandle::newArray();
-    contents.appendItem(old_streamdata);
-  }
-
-  contents.insertItem(0, stream);
-  page.replaceKey("/Contents", contents);
-}
-
-
-/**
- * 'pdf_add_type1_font()' - Add the specified type1 fontface to the specified
- *                          page in a PDF document.
- * I - QPDF object
- * I - page number of the page to which the font is to be added
- * I - name of the font to be added
- */
-extern "C" void pdf_add_type1_font(pdf_t *pdf,
-                                   unsigned page_num,
-                                   const char *name)
-{
-  std::vector<QPDFObjectHandle> pages = pdf->getAllPages();
-  if (pages.empty() || page_num > pages.size()) {
-    fprintf(stderr, "ERROR: Unable to add type1 font to requested PDF page\n");
-    return;
-  }
-
-  QPDFObjectHandle page = pages[page_num - 1];
-
-  QPDFObjectHandle resources = page.getKey("/Resources");
-  if (!resources.isDictionary())
-  {
-    fprintf(stderr, "ERROR: Malformed PDF.\n");
-    return;
-  }
-
-  QPDFObjectHandle font = QPDFObjectHandle::newDictionary();
-  font.replaceKey("/Type", QPDFObjectHandle::newName("/Font"));
-  font.replaceKey("/Subtype", QPDFObjectHandle::newName("/Type1"));
-  font.replaceKey("/BaseFont",
-                  QPDFObjectHandle::newName(std::string("/") + std::string(name)));
-
-  QPDFObjectHandle fonts = resources.getKey("/Font");
-  if (fonts.isNull())
-  {
-    fonts = QPDFObjectHandle::newDictionary();
-  }
-  else if (!fonts.isDictionary())
-  {
-    fprintf(stderr, "ERROR: Can't recognize Font resource in PDF template.\n");
-    return;
-  }
-
-  font = pdf->makeIndirectObject(font);
-  fonts.replaceKey("/bannertopdf-font", font);
-  resources.replaceKey("/Font", fonts);
-}
-
-
-/**
- * 'dict_lookup_rect()' - Lookup for an array of rectangle dimensions in a QPDF
- *                        dictionary object. If it is found, store the values in
- *                        an array and return true, else return false.
- * O - True / False, depending on whether the key is found in the dictionary
- * I - PDF dictionary object
- * I - Key to lookup for
- * I - array to store values if key is found
- */
-static bool dict_lookup_rect(QPDFObjectHandle object,
-                             std::string const& key,
-                             float rect[4])
-{
-  // preliminary checks
-  if (!object.isDictionary() || !object.hasKey(key))
-    return false;
-
-  // check if the key is array or some other type
-  QPDFObjectHandle value = object.getKey(key);
-  if (!value.isArray())
-    return false;
-  
-  // get values in a vector and assign it to rect
-  std::vector<QPDFObjectHandle> array = value.getArrayAsVector();
-  for (int i = 0; i < 4; ++i) {
-    // if the value in the array is not real, we have an invalid array 
-    if (!array[i].isReal() && !array[i].isInteger())
-      return false;
-    
-    rect[i] = array[i].getNumericValue();
-  }
-
-  return array.size() == 4;
-}
-
-
-/**
- * 'fit_rect()' - Update the scale of the page using old media box dimensions
- *                and new media box dimensions.
- * I - Old media box
- * I - New media box
- * I - Pointer to scale which needs to be updated
- */
-static void fit_rect(float oldrect[4],
-                     float newrect[4],
-                     float *scale)
-{
-  float oldwidth = oldrect[2] - oldrect[0];
-  float oldheight = oldrect[3] - oldrect[1];
-  float newwidth = newrect[2] - newrect[0];
-  float newheight = newrect[3] - newrect[1];
-
-  *scale = newwidth / oldwidth;
-  if (oldheight * *scale > newheight)
-    *scale = newheight / oldheight;
-}
-
-
-/**
- * 'pdf_resize_page()' - Resize page in a PDF with the given dimensions.
- * I - Pointer to QPDF object
- * I - Page number
- * I - Width of page to set
- * I - Length of page to set
- * I - Scale of page to set
- */
-extern "C" void pdf_resize_page (pdf_t *pdf,
-                                 unsigned page_num,
-                                 float width,
-                                 float length,
-                                 float *scale)
-{
-  std::vector<QPDFObjectHandle> pages = pdf->getAllPages();
-  if (pages.empty() || page_num > pages.size()) {
-    fprintf(stderr, "ERROR: Unable to resize requested PDF page\n");
-    return;
-  }
-
-  QPDFObjectHandle page = pages[page_num - 1];
-  float new_mediabox[4] = { 0.0, 0.0, width, length };
-  float old_mediabox[4];
-  QPDFObjectHandle media_box;
-
-  if (!dict_lookup_rect(page, "/MediaBox", old_mediabox)) {
-    fprintf(stderr, "ERROR: pdf doesn't contain a valid mediabox\n");
-    return;
-  }
-
-  fit_rect(old_mediabox, new_mediabox, scale);
-  media_box = makeRealBox(new_mediabox);
-
-  page.replaceKey("/ArtBox", media_box);
-  page.replaceKey("/BleedBox", media_box);
-  page.replaceKey("/CropBox", media_box);
-  page.replaceKey("/MediaBox", media_box);
-  page.replaceKey("/TrimBox", media_box);
-}
-
-
-/**
- * 'pdf_duplicate_page()' - Duplicate a specified pdf page in a PDF
- * I - Pointer to QPDF object
- * I - page number of the page to be duplicated
- * I - number of copies to be duplicated
- */
-extern "C" void pdf_duplicate_page (pdf_t *pdf,
-                                    unsigned page_num,
-                                    unsigned count)
-{
-  std::vector<QPDFObjectHandle> pages = pdf->getAllPages();
-  if (pages.empty() || page_num > pages.size()) {
-    fprintf(stderr, "ERROR: Unable to duplicate requested PDF page\n");
-    return;
-  }
-
-  QPDFObjectHandle page = pages[page_num - 1];
-  for (unsigned i = 0; i < count; ++i)
-  {
-    page = pdf->makeIndirectObject(page);
-    pdf->addPage(page, false);
-  }
-}
-
-
-/**
- * 'pdf_write()' - Write the contents of PDF object to an already open FILE*.
- * I - pointer to QPDF structure
- * I - File pointer to write to
- */
-extern "C" void pdf_write(pdf_t *pdf, FILE *file)
-{
-  QPDFWriter output(*pdf, "pdf_write", file, false);
-  output.write();
-}
-
-
-
-/*
- * 'lookup_opt()' - Get value according to key in the options list.
- * I - pointer to the opt_t type list
- * I - key to be found in the list
- * O - character string which corresponds to the value of the key or
- *     NULL if key is not found in the list.
- */
-std::string lookup_opt(opt_t *opt, std::string const& key) {
-    if ( ! opt || key.empty() ) {
-        return "";
-    }
-
-    while (opt) {
-        if (opt->key && opt->val) {
-            if ( strcmp(opt->key, key.c_str()) == 0 ) {
-                return std::string(opt->val);
-            }
-        }
-        opt = opt->next;
-    }
-
-    return "";
-}
-
-
-/*
- * 'pdf_fill_form()' -  1. Lookup in PDF template file for form.
- *                      2. Lookup for form fields' names.
- *                      3. Fill recognized fields with information.
- * I - Pointer to the QPDF structure
- * I - Pointer to the opt_t type list
- * O - status of form fill - 0 for failure, 1 for success
- */
-extern "C" int pdf_fill_form(pdf_t *doc, opt_t *opt)
-{
-    // initialize AcroFormDocumentHelper and PageDocumentHelper objects
-    // to work with forms in the PDF
-    QPDFAcroFormDocumentHelper afdh(*doc);
-    QPDFPageDocumentHelper pdh(*doc);
-
-    // check if the PDF has a form or not
-    if ( !afdh.hasAcroForm() ) {
-        fprintf(stderr, "DEBUG: PDF template file doesn't have form. It's okay.\n");
-        return 0;
-    }
-
-    // get the first page from the PDF to fill the form. Since this
-    // is a banner file,it must contain only a single page, and that
-    // check has already been performed in the `pdf_load_template()` function
-    std::vector<QPDFPageObjectHelper> pages = pdh.getAllPages();
-    if (pages.empty()) {
-        fprintf(stderr, "ERROR: Can't get page from PDF tamplate file.\n");
-        return 0;
-    }
-    QPDFPageObjectHelper page = pages.front();
-
-    // get the annotations in the page
-    std::vector<QPDFAnnotationObjectHelper> annotations =
-                  afdh.getWidgetAnnotationsForPage(page);
-
-    for (std::vector<QPDFAnnotationObjectHelper>::iterator annot_iter =
-                     annotations.begin();
-                 annot_iter != annotations.end(); ++annot_iter) {
-        // For each annotation, find its associated field. If it's a
-        // text field, we try to set its value. This will automatically
-        // update the document to indicate that appearance streams need
-        // to be regenerated. At the time of this writing, qpdf doesn't
-        // have any helper code to assist with appearance stream generation,
-        // though there's nothing that prevents it from being possible.
-        QPDFFormFieldObjectHelper ffh =
-            afdh.getFieldForAnnotation(*annot_iter);
-        if (ffh.getFieldType() == "/Tx") {
-            // Lookup the options setting for value of this field and fill the
-            // value accordingly. This will automatically set
-            // /NeedAppearances to true.
-            std::string const name = ffh.getFullyQualifiedName();
-            std::string fill_with = lookup_opt(opt, name);
-            if (fill_with.empty()) {
-                std::cerr << "DEBUG: Lack information for widget: " << name << ".\n";
-                fill_with = "N/A";
-            }
-
-            // convert the 'fill_with' string to UTF16 before filling to the widget 
-            QPDFObjectHandle fill_with_utf_16 = QPDFObjectHandle::newUnicodeString(fill_with);
-            ffh.setV(fill_with_utf_16);
-            std::cerr << "DEBUG: Fill widget name " << name << " with value "
-                      << fill_with_utf_16.getUTF8Value() << ".\n";
-        }
-    }
-
-    // status 1 notifies that the function successfully filled all the
-    // identifiable fields in the form
-    return 1;
-}
diff --git a/filter/pdf.h b/filter/pdf.h
deleted file mode 100644
index eaaf190..0000000
--- a/filter/pdf.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright 2012 Canonical Ltd.
- * Copyright 2018 Sahil Arora <sahilarora.535@gmail.com>
- *
- * This program is free software: you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 3, as published
- * by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranties of
- * MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
- * PURPOSE.  See the GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef pdf_h
-#define pdf_h
-
-#include <stdio.h>
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef struct QPDF pdf_t;
-
-typedef struct _opt opt_t;
-
-/*
- * Type to bunch PDF form field name and its value.
- */
-struct _opt {
-    const char* key;
-    const char* val;
-    opt_t *next;
-};
-
-pdf_t * pdf_load_template(const char *filename);
-void pdf_free(pdf_t *pdf);
-void pdf_write(pdf_t *doc, FILE *file);
-void pdf_prepend_stream(pdf_t *doc, unsigned page, char const *buf, size_t len);
-void pdf_add_type1_font(pdf_t *doc, unsigned page, const char *name);
-void pdf_resize_page(pdf_t *doc, unsigned page, float width, float length, float *scale);
-void pdf_duplicate_page (pdf_t *doc, unsigned page, unsigned count);
-int pdf_fill_form(pdf_t *doc, opt_t *opt);
-int pdf_pages(const char *filename);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff --git a/filter/pdftopdf/intervalset.cc b/filter/pdftopdf/intervalset.cc
deleted file mode 100644
index 2967d59..0000000
--- a/filter/pdftopdf/intervalset.cc
+++ /dev/null
@@ -1,121 +0,0 @@
-#include "intervalset.h"
-#include <stdio.h>
-#include <assert.h>
-#include <limits>
-#include <algorithm>
-
-const IntervalSet::key_t IntervalSet::npos=std::numeric_limits<IntervalSet::key_t>::max();
-
-void IntervalSet::clear() // {{{
-{
-  data.clear();
-}
-// }}}
-
-void IntervalSet::add(key_t start,key_t end) // {{{
-{
-  if (start<end) {
-    data.push_back(std::make_pair(start,end));
-  }
-}
-// }}}
-
-void IntervalSet::finish() // {{{
-{
-  data_t::iterator it=data.begin(),end=data.end(),pos=it;
-  if (it==end) {
-    return;
-  }
-
-  std::sort(it,end);
-
-  while (1) {
-    ++it;
-    if (it==end) {
-      ++pos;
-      break;
-    }
-    if (pos->second>=it->first) {
-      pos->second=it->second;
-    } else {
-      ++pos;
-      if (pos!=it) {
-        *pos=*it;
-      }
-    }
-  }
-
-  data.erase(pos,data.end());
-}
-// }}}
-
-bool IntervalSet::contains(key_t val) const // {{{
-{
-  data_t::const_iterator it=std::upper_bound(data.begin(),data.end(),std::make_pair(val,npos));
-  if (it==data.begin()) {
-    return false;
-  }
-  --it;
-  return (val<it->second);
-}
-// }}}
-
-IntervalSet::key_t IntervalSet::next(key_t val) const // {{{
-{
-  val++;
-  data_t::const_iterator it=std::upper_bound(data.begin(),data.end(),std::make_pair(val,npos));
-  if (it==data.begin()) {
-    if (it==data.end()) { // empty
-      return npos;
-    }
-    return it->first;
-  }
-  --it;
-  if (val<it->second) {
-    return val;
-  }
-  ++it;
-  if (it==data.end()) {
-    return npos;
-  }
-  return it->first;
-}
-// }}}
-
-bool IntervalSet::intersect(const value_t &a,const value_t &b) const // {{{
-{
-  return ((a.first>=b.first) && (a.first<b.second)) ||
-    ((b.first>=a.first) && (b.first<a.second));
-}
-// }}}
-
-void IntervalSet::unite(value_t &aret,const value_t &b) const // {{{
-{
-  assert(intersect(aret,b));
-  if (b.first<aret.first) {
-    aret.first=b.first;
-  }
-  if (b.second>aret.second) {
-    aret.second=b.second;
-  }
-}
-// }}}
-
-void IntervalSet::dump() const // {{{
-{
-  int len=data.size();
-  if (len==0) {
-    fprintf(stderr,"(empty)\n");
-    return;
-  }
-  len--;
-  for (int iA=0;iA<len;iA++) {
-    fprintf(stderr,"[%d,%d),",data[iA].first,data[iA].second);
-  }
-  if (data[len].second==npos) {
-    fprintf(stderr,"[%d,inf)\n",data[len].first);
-  } else {
-    fprintf(stderr,"[%d,%d)\n",data[len].first,data[len].second);
-  }
-}
-// }}}
diff --git a/filter/pdftopdf/intervalset.h b/filter/pdftopdf/intervalset.h
deleted file mode 100644
index 67b486f..0000000
--- a/filter/pdftopdf/intervalset.h
+++ /dev/null
@@ -1,34 +0,0 @@
-#ifndef INTERVALSET_H_
-#define INTERVALSET_H_
-
-#include <stddef.h>
-#include <vector>
-
-class IntervalSet {
-  typedef int key_t; // TODO?! template <typename T>
-  typedef std::pair<key_t,key_t> value_t;
-  typedef std::vector<value_t> data_t;
- public:
-  static const key_t npos;
-
-  void clear();
-  // [start;end) !
-  void add(key_t start,key_t end=npos);
-  void finish();
-
-  size_t size() const { return data.size(); }
-
-  // only after finish() has been called:
-  bool contains(key_t val) const;
-  key_t next(key_t val) const;
-
-  void dump() const;
- private:
-  // currently not used
-  bool intersect(const value_t &a,const value_t &b) const;
-  void unite(value_t &aret,const value_t &b) const;
- private:
-  data_t data;
-};
-
-#endif
diff --git a/filter/pdftopdf/nup.cc b/filter/pdftopdf/nup.cc
deleted file mode 100644
index 8be9b86..0000000
--- a/filter/pdftopdf/nup.cc
+++ /dev/null
@@ -1,265 +0,0 @@
-#include "nup.h"
-#include <stdio.h>
-#include <assert.h>
-#include <string.h>
-#include <utility>
-
-void NupParameters::dump() const // {{{
-{
-  fprintf(stderr,"NupX: %d, NupY: %d\n"
-                 "width: %f, height: %f\n",
-                 nupX,nupY,
-                 width,height);
-
-  int opos=-1,fpos=-1,spos=-1;
-  if (xstart==Position::LEFT) { // or Bottom
-    fpos=0;
-  } else if (xstart==Position::RIGHT) { // or Top
-    fpos=1;
-  }
-  if (ystart==Position::LEFT) { // or Bottom
-    spos=0;
-  } else if (ystart==Position::RIGHT) { // or Top
-    spos=1;
-  }
-  if (first==Axis::X) {
-    fprintf(stderr,"First Axis: X\n");
-    opos=0;
-  } else if (first==Axis::Y) {
-    fprintf(stderr,"First Axis: Y\n");
-    opos=2;
-    std::swap(fpos,spos);
-  }
-
-  if ( (opos==-1)||(fpos==-1)||(spos==-1) ) {
-    fprintf(stderr,"Bad Spec: %d; start: %d, %d\n\n",
-                   first,xstart,ystart);
-  } else {
-    static const char *order[4]={"lr","rl","bt","tb"};
-    fprintf(stderr,"Order: %s%s\n",
-                   order[opos+fpos],order[(opos+2)%4+spos]);
-  }
-
-  fputs("Alignment: ",stderr);
-  Position_dump(xalign,Axis::X);
-  fputs("/",stderr); 
-  Position_dump(yalign,Axis::Y);
-  fputs("\n",stderr);
-}
-// }}}
-
-bool NupParameters::possible(int nup) // {{{
-{
-  // 1 2 3 4 6 8 9 10 12 15 16
-  return (nup>=1)&&(nup<=16)&&
-         ( (nup!=5)&&(nup!=7)&&(nup!=11)&&(nup!=13)&&(nup!=14) );
-}
-// }}}
-
-void NupParameters::preset(int nup,NupParameters &ret) // {{{
-{
-  switch (nup) {
-  case 1:
-    ret.nupX=1;
-    ret.nupY=1;
-    break;
-  case 2:
-    ret.nupX=2;
-    ret.nupY=1;
-    ret.landscape=true;
-    break;
-  case 3:
-    ret.nupX=3;
-    ret.nupY=1;
-    ret.landscape=true;
-    break;
-  case 4:
-    ret.nupX=2;
-    ret.nupY=2;
-    break;
-  case 6:
-    ret.nupX=3;
-    ret.nupY=2;
-    ret.landscape=true;
-    break;
-  case 8:
-    ret.nupX=4;
-    ret.nupY=2;
-    ret.landscape=true;
-    break;
-  case 9:
-    ret.nupX=3;
-    ret.nupY=3;
-    break;
-  case 10:
-    ret.nupX=5;
-    ret.nupY=2;
-    ret.landscape=true;
-    break;
-  case 12:
-    ret.nupX=3;
-    ret.nupY=4;
-    break;
-  case 15:
-    ret.nupX=5;
-    ret.nupY=3;
-    ret.landscape=true;
-    break;
-  case 16:
-    ret.nupX=4;
-    ret.nupY=4;
-    break;
-  }
-}
-// }}}
-
-
-NupState::NupState(const NupParameters &param) // {{{
-  : param(param),
-    in_pages(0),out_pages(0),
-    nup(param.nupX*param.nupY),
-    subpage(nup)
-{
-  assert( (param.nupX>0)&&(param.nupY>0) );
-}
-// }}}
-
-void NupState::reset() // {{{
-{
-  in_pages=0;
-  out_pages=0;
-//  nup=param.nupX*param.nupY;
-  subpage=nup;
-}
-// }}}
-
-void NupPageEdit::dump() const // {{{
-{
-  fprintf(stderr,"xpos: %f, ypos: %f, scale: %f\n",
-                 xpos,ypos,scale);
-  sub.dump();
-}
-// }}}
-
-std::pair<int,int> NupState::convert_order(int subpage) const // {{{
-{
-  int subx,suby;
-  if (param.first==Axis::X) {
-    subx=subpage%param.nupX;
-    suby=subpage/param.nupX;
-  } else {
-    subx=subpage/param.nupY;
-    suby=subpage%param.nupY;
-  }
-
-  subx=(param.nupX-1)*(param.xstart+1)/2-param.xstart*subx;
-  suby=(param.nupY-1)*(param.ystart+1)/2-param.ystart*suby;
-
-  return std::make_pair(subx,suby);
-}
-// }}}
-
-static inline float lin(Position pos,float size) // {{{
-{
-  if (pos==-1) return 0;
-  else if (pos==0) return size/2;
-  else if (pos==1) return size;
-  return size*(pos+1)/2;
-}
-// }}}
-
-void NupState::calculate_edit(int subx,int suby,NupPageEdit &ret) const // {{{
-{
-  // dimensions of a "nup cell"
-  const float width=param.width/param.nupX,
-              height=param.height/param.nupY;
-
-  // first calculate only for bottom-left corner
-  ret.xpos=subx*width;
-  ret.ypos=suby*height;
-
-  const float scalex=width/ret.sub.width,
-              scaley=height/ret.sub.height;
-  float subwidth=ret.sub.width*scaley,
-        subheight=ret.sub.height*scalex;
-
-  // TODO?  if ( (!fitPlot)&&(ret.scale>1) ) ret.scale=1.0;
-  if (scalex>scaley) {
-    ret.scale=scaley;
-    subheight=height;
-    ret.xpos+=lin(param.xalign,width-subwidth);
-  } else {
-    ret.scale=scalex;
-    subwidth=width;
-    ret.ypos+=lin(param.yalign,height-subheight);
-  }
-
-  ret.sub.left=ret.xpos;
-  ret.sub.bottom=ret.ypos;
-  ret.sub.right=ret.sub.left+subwidth;
-  ret.sub.top=ret.sub.bottom+subheight;
-}
-// }}}
-
-bool NupState::nextPage(float in_width,float in_height,NupPageEdit &ret) // {{{
-{
-  in_pages++;
-  subpage++;
-  if (subpage>=nup) {
-    subpage=0;
-    out_pages++;
-  }
-
-  ret.sub.width=in_width;
-  ret.sub.height=in_height;
-
-  auto sub=convert_order(subpage);
-  calculate_edit(sub.first,sub.second,ret);
-
-  return (subpage==0);
-}
-// }}}
-
-
-static std::pair<Axis,Position> parsePosition(char a,char b) // {{{ returns ,CENTER(0) on invalid
-{
-  a|=0x20; // make lowercase
-  b|=0x20;
-  if ( (a=='l')&&(b=='r') ) {
-    return std::make_pair(Axis::X,Position::LEFT);
-  } else if ( (a=='r')&&(b=='l') ) {
-    return std::make_pair(Axis::X,Position::RIGHT);
-  } else if ( (a=='t')&&(b=='b') ) {
-    return std::make_pair(Axis::Y,Position::TOP);
-  } else if ( (a=='b')&&(b=='t') ) {
-    return std::make_pair(Axis::Y,Position::BOTTOM);
-  } 
-  return std::make_pair(Axis::X,Position::CENTER);
-}
-// }}}
-
-bool parseNupLayout(const char *val,NupParameters &ret) // {{{
-{
-  assert(val);
-  auto pos0=parsePosition(val[0],val[1]);
-  if (pos0.second==CENTER) {
-    return false;
-  }
-  auto pos1=parsePosition(val[2],val[3]);
-  if ( (pos1.second==CENTER)||(pos0.first==pos1.first) ) {
-    return false;
-  }
-
-  ret.first=pos0.first;
-  if (ret.first==Axis::X) {
-    ret.xstart=pos0.second;
-    ret.ystart=pos1.second;
-  } else {
-    ret.xstart=pos1.second;
-    ret.ystart=pos0.second;
-  }
-
-  return (val[4]==0); // everything seen?
-}
-// }}}
-
diff --git a/filter/pdftopdf/nup.h b/filter/pdftopdf/nup.h
deleted file mode 100644
index 0523cc7..0000000
--- a/filter/pdftopdf/nup.h
+++ /dev/null
@@ -1,91 +0,0 @@
-#ifndef NUP_H_
-#define NUP_H_
-
-#include "pptypes.h"
-#include <utility>
-
-// you have to provide this
-struct NupParameters {
-  NupParameters() 
-    : nupX(1),nupY(1),
-      width(NAN),height(NAN),
-      landscape(false),
-      first(X),
-      xstart(LEFT),ystart(TOP),
-      xalign(CENTER),yalign(CENTER)
-  {}
-
-  // --- "calculated" parameters ---
-  int nupX,nupY;
-  float width,height;
-  bool landscape; // post-rotate!
-
-  // --- other settings ---
-  // ordering
-  Axis first;
-  Position xstart,ystart;
-
-  Position xalign,yalign;
-
-  static bool possible(int nup); // TODO?  float in_ratio,float out_ratio
-  static void preset(int nup,NupParameters &ret);
-  static float calculate(int nup, float in_ratio, float out_ratio,NupParameters &ret); // returns "quality", 1 is best
-
-  void dump() const;
-};
-
-// you get this
-struct NupPageEdit {
-  // required transformation: first translate, then scale
-  float xpos,ypos;  // TODO:  already given by sub.left,sub.bottom    [but for rotation?]
-  float scale; // uniform
-
-// ? "landscape"  e.g. to rotate labels
-
-  // for border, clip, ...
-  // also stores in_width/in_height, unscaled!
-  // everything in "outer"-page coordinates
-  PageRect sub;
-
-  void dump() const;
-};
-
-/*
- This class does the number-up calculation. Example:
-
-  NupParameters param;
-  param.xyz=...; // fill it with your data!
-
-  NupState nup(param);
-  NupPageEdit edit;
-  for (auto page : your_pages) {
-    bool newPage=nup.nextPage(page.w,page.h,edit); // w,h from input page
-    // create newPage, if required; then place current page as specified in edit
-  }
-*/
-class NupState {
-public:
-  NupState(const NupParameters &param);
-
-  void reset();
-
-  // will overwrite ret with the new parameters
-  // returns true, if a new output page should be started first
-  bool nextPage(float in_width,float in_height,NupPageEdit &ret);
-
-private:
-  std::pair<int,int> convert_order(int subpage) const;
-  void calculate_edit(int subx,int suby,NupPageEdit &ret) const;
-private:
-  NupParameters param;
-
-  int in_pages,out_pages;
-  int nup; // max. per page (==nupX*nupY)
-  int subpage; // on the current output-page
-};
-
-// TODO? elsewhere
-// parsing functions for cups parameters (will not calculate nupX,nupY!)
-bool parseNupLayout(const char *val,NupParameters &ret); // lrtb, btlr, ...
-
-#endif
diff --git a/filter/pdftopdf/pdftopdf.cc b/filter/pdftopdf/pdftopdf.cc
deleted file mode 100644
index 8ad8109..0000000
--- a/filter/pdftopdf/pdftopdf.cc
+++ /dev/null
@@ -1,1326 +0,0 @@
-// Copyright (c) 2012 Tobias Hoffmann
-//
-// Copyright (c) 2006-2011, BBR Inc.  All rights reserved.
-// MIT Licensed.
-
-#include <config.h>
-#include <stdio.h>
-#include <assert.h>
-#include <cups/cups.h>
-#include <cups/ppd.h>
-#if (CUPS_VERSION_MAJOR > 1) || (CUPS_VERSION_MINOR > 6)
-#define HAVE_CUPS_1_7 1
-#endif
-#ifdef HAVE_CUPS_1_7
-#include <cups/pwg.h>
-#endif /* HAVE_CUPS_1_7 */
-#include <iomanip>
-#include <sstream>
-#include <memory>
-#include <unistd.h>
-#include <fcntl.h>
-#include <sys/types.h>
-#include <sys/wait.h>
-
-#include "pdftopdf_processor.h"
-#include "pdftopdf_jcl.h"
-
-#include <stdarg.h>
-static void error(const char *fmt,...) // {{{
-{
-  va_list ap;
-  va_start(ap,fmt);
-
-  fputs("ERROR: ",stderr);
-  vfprintf(stderr,fmt,ap);
-  fputs("\n",stderr);
-
-  va_end(ap);
-}
-// }}}
-
-// namespace {}
-
-void setFinalPPD(ppd_file_t *ppd,const ProcessingParameters &param)
-{
-  if ((param.booklet==BOOKLET_ON)&&(ppdFindOption(ppd,"Duplex"))) {
-    // TODO: elsewhere, better
-    ppdMarkOption(ppd,"Duplex","DuplexTumble");
-    // TODO? sides=two-sided-short-edge
-  }
-
-  // for compatibility
-  if ((param.setDuplex)&&(ppdFindOption(ppd,"Duplex")!=NULL)) {
-    ppdMarkOption(ppd,"Duplex","True");
-    ppdMarkOption(ppd,"Duplex","On");
-  }
-
-  // we do it, printer should not
-  ppd_choice_t *choice;
-  if ((choice=ppdFindMarkedChoice(ppd,"MirrorPrint")) != NULL) {
-    choice->marked=0;
-  }
-}
-
-// for choice, only overwrites ret if found in ppd
-static bool ppdGetInt(ppd_file_t *ppd,const char *name,int *ret) // {{{
-{
-  assert(ret);
-  ppd_choice_t *choice=ppdFindMarkedChoice(ppd,name); // !ppd is ok.
-  if (choice) {
-    *ret=atoi(choice->choice);
-    return true;
-  }
-  return false;
-}
-// }}}
-
-static bool optGetInt(const char *name,int num_options,cups_option_t *options,int *ret) // {{{
-{
-  assert(ret);
-  const char *val=cupsGetOption(name,num_options,options);
-  if (val) {
-    *ret=atoi(val);
-    return true;
-  }
-  return false;
-}
-// }}}
-
-static bool optGetFloat(const char *name,int num_options,cups_option_t *options,float *ret) // {{{
-{
-  assert(ret);
-  const char *val=cupsGetOption(name,num_options,options);
-  if (val) {
-    *ret=atof(val);
-    return true;
-  }
-  return false;
-}
-// }}}
-
-static bool is_false(const char *value) // {{{
-{
-  if (!value) {
-    return false;
-  }
-  return (strcasecmp(value,"no")==0)||
-    (strcasecmp(value,"off")==0)||
-    (strcasecmp(value,"false")==0);
-}
-// }}}
-
-static bool is_true(const char *value) // {{{
-{
-  if (!value) {
-    return false;
-  }
-  return (strcasecmp(value,"yes")==0)||
-    (strcasecmp(value,"on")==0)||
-    (strcasecmp(value,"true")==0);
-}
-// }}}
-
-static bool ppdGetDuplex(ppd_file_t *ppd) // {{{
-{
-  const char **option, **choice;
-  const char *option_names[] = {
-    "Duplex",
-    "JCLDuplex",
-    "EFDuplex",
-    "KD03Duplex",
-    NULL
-  };
-  const char *choice_names[] = {
-    "DuplexNoTumble",
-    "DuplexTumble",
-    "LongEdge",
-    "ShortEdge",
-    "Top",
-    "Bottom",
-    NULL
-  };
-  for (option = option_names; *option; option ++)
-    for (choice = choice_names; *choice; choice ++)
-      if (ppdIsMarked(ppd, *option, *choice))
-	return 1;
-  return 0;
-}
-// }}}
-
-// TODO: enum
-static bool ppdDefaultOrder(ppd_file_t *ppd) // {{{  -- is reverse?
-{
-  ppd_choice_t *choice;
-  ppd_attr_t *attr;
-  const char *val=NULL;
-
-  // Figure out the right default output order from the PPD file...
-  if ((choice=ppdFindMarkedChoice(ppd,"OutputOrder")) != NULL) {
-    val=choice->choice;
-  } else if (((choice=ppdFindMarkedChoice(ppd,"OutputBin")) != NULL)&&
-	     ((attr=ppdFindAttr(ppd,"PageStackOrder",choice->choice)) != NULL)) {
-    val=attr->value;
-  } else if ((attr=ppdFindAttr(ppd,"DefaultOutputOrder",0)) != NULL) {
-    val=attr->value;
-  }
-  if ((!val)||(strcasecmp(val,"Normal")==0)||(strcasecmp(val,"same-order")==0)) {
-    return false;
-  } else if (strcasecmp(val,"Reverse")==0||(strcasecmp(val,"reverse-order")==0)) {
-    return true;
-  }
-  error("Unsupported output-order value %s, using 'normal'!",val);
-  return false;
-}
-// }}}
-
-static bool optGetCollate(int num_options,cups_option_t *options) // {{{
-{
-  if (is_true(cupsGetOption("Collate",num_options,options))) {
-    return true;
-  }
-
-  const char *val=NULL;
-  if ((val=cupsGetOption("multiple-document-handling",num_options,options)) != NULL) {
-   /* This IPP attribute is unnecessarily complicated:
-    *   single-document, separate-documents-collated-copies, single-document-new-sheet:
-    *      -> collate (true)
-    *   separate-documents-uncollated-copies:
-    *      -> can be uncollated (false)
-    */
-    return (strcasecmp(val,"separate-documents-uncollated-copies")!=0);
-  }
-
-  if ((val=cupsGetOption("sheet-collate",num_options,options)) != NULL) {
-    return (strcasecmp(val,"uncollated")!=0);
-  }
-
-  return false;
-}
-// }}}
-
-static bool parsePosition(const char *value,Position &xpos,Position &ypos) // {{{
-{
-  // ['center','top','left','right','top-left','top-right','bottom','bottom-left','bottom-right']
-  xpos=Position::CENTER;
-  ypos=Position::CENTER;
-  int next=0;
-  if (strcasecmp(value,"center")==0) {
-    return true;
-  } else if (strncasecmp(value,"top",3)==0) {
-    ypos=Position::TOP;
-    next=3;
-  } else if (strncasecmp(value,"bottom",6)==0) {
-    ypos=Position::BOTTOM;
-    next=6;
-  }
-  if (next) {
-    if (value[next]==0) {
-      return true;
-    } else if (value[next]!='-') {
-      return false;
-    }
-    value+=next+1;
-  }
-  if (strcasecmp(value,"left")==0) {
-    xpos=Position::LEFT;
-  } else if (strcasecmp(value,"right")==0) {
-    xpos=Position::RIGHT;
-  } else {
-    return false;
-  }
-  return true;
-}
-// }}}
-
-#include <ctype.h>
-static void parseRanges(const char *range,IntervalSet &ret) // {{{
-{
-  ret.clear();
-  if (!range) {
-    ret.add(1); // everything
-    ret.finish();
-    return;
-  }
-
-  int lower,upper;
-  while (*range) {
-    if (*range=='-') {
-      range++;
-      upper=strtol(range,(char **)&range,10);
-      if (upper>=2147483647) { // see also   cups/encode.c
-        ret.add(1);
-      } else {
-        ret.add(1,upper+1);
-      }
-    } else {
-      lower=strtol(range,(char **)&range,10);
-      if (*range=='-') {
-        range++;
-        if (!isdigit(*range)) {
-          ret.add(lower);
-        } else {
-          upper=strtol(range,(char **)&range,10);
-          if (upper>=2147483647) {
-            ret.add(1);
-          } else {
-            ret.add(lower,upper+1);
-          }
-        }
-      } else {
-        ret.add(lower,lower+1);
-      }
-    }
-
-    if (*range!=',') {
-      break;
-    }
-    range++;
-  }
-  ret.finish();
-}
-// }}}
-
-static bool parseBorder(const char *val,BorderType &ret) // {{{
-{
-  assert(val);
-  if (strcasecmp(val,"none")==0) {
-    ret=BorderType::NONE;
-  } else if (strcasecmp(val,"single")==0) {
-    ret=BorderType::ONE_THIN;
-  } else if (strcasecmp(val,"single-thick")==0) {
-    ret=BorderType::ONE_THICK;
-  } else if (strcasecmp(val,"double")==0) {
-    ret=BorderType::TWO_THIN;
-  } else if (strcasecmp(val,"double-thick")==0) {
-    ret=BorderType::TWO_THICK;
-  } else {
-    return false;
-  }
-  return true;
-}
-// }}}
-
-void getParameters(ppd_file_t *ppd,int num_options,cups_option_t *options,ProcessingParameters &param) // {{{
-{
-  const char *val;
-
-  if ((val = cupsGetOption("copies",num_options,options)) != NULL) {
-    int copies = atoi(val);
-    if (copies > 0)
-      param.numCopies = copies;
-  }
-  // param.numCopies initially from commandline
-  if (param.numCopies==1) {
-    ppdGetInt(ppd,"Copies",&param.numCopies);
-  }
-  if (param.numCopies==0) {
-    param.numCopies=1;
-  }
-
-  if((val = cupsGetOption("ipp-attribute-fidelity",num_options,options))!=NULL) {
-    if(!strcasecmp(val,"true")||!strcasecmp(val,"yes") ||
-      !strcasecmp(val,"on"))
-      param.fidelity = true;
-  }
-
-  if((val = cupsGetOption("print-scaling",num_options,options)) != NULL) {
-    if(!strcasecmp(val,"auto"))
-      param.autoprint = true;
-    else if(!strcasecmp(val,"auto-fit"))
-      param.autofit = true;
-    else if(!strcasecmp(val,"fill"))
-      param.fillprint = true;
-    else if(!strcasecmp(val,"fit"))
-      param.fitplot = true;
-    else
-      param.cropfit = true;
-  }
-  else {
-  if ((val=cupsGetOption("fitplot",num_options,options)) == NULL) {
-    if ((val=cupsGetOption("fit-to-page",num_options,options)) == NULL) {
-      val=cupsGetOption("ipp-attribute-fidelity",num_options,options);
-    }
-  }
-  // TODO?  pstops checks =="true", pdftops !is_false  ... pstops says: fitplot only for PS (i.e. not for PDF, cmp. cgpdftopdf)
-  param.fitplot=(val)&&(!is_false(val));
-
-  if((val = cupsGetOption("fill",num_options,options))!=0) {
-    if(!strcasecmp(val,"true")||!strcasecmp(val,"yes"))
-    {
-      param.fillprint = true;
-    }
-  }
-  if((val = cupsGetOption("crop-to-fit",num_options,options))!= NULL){
-    if(!strcasecmp(val,"true")||!strcasecmp(val,"yes"))
-    {
-      param.cropfit=1;
-    }
-  }
-  }
-
-  if (ppd && (ppd->landscape < 0)) { // direction the printer rotates landscape (90 or -90)
-    param.normal_landscape=ROT_270;
-  } else {
-    param.normal_landscape=ROT_90;
-  }
-
-  int ipprot;
-  param.orientation=ROT_0;
-  if ((val=cupsGetOption("landscape",num_options,options)) != NULL) {
-    if (!is_false(val)) {
-      param.orientation=param.normal_landscape;
-    }
-  } else if (optGetInt("orientation-requested",num_options,options,&ipprot)) {
-    /* IPP orientation values are:
-     *   3: 0 degrees,  4: 90 degrees,  5: -90 degrees,  6: 180 degrees
-     */
-    if ((ipprot<3)||(ipprot>6)) {
-      error("Bad value (%d) for orientation-requested, using 0 degrees",ipprot);
-    } else {
-      static const Rotation ipp2rot[4]={ROT_0, ROT_90, ROT_270, ROT_180};
-      param.orientation=ipp2rot[ipprot-3];
-    }
-  } else {
-    param.noOrientation = true;
-  }
-
-  ppd_size_t *pagesize;
-  // param.page default is letter, border 36,18
-  if ((pagesize=ppdPageSize(ppd,0)) != NULL) { // "already rotated"
-    param.page.top=pagesize->top;
-    param.page.left=pagesize->left;
-    param.page.right=pagesize->right;
-    param.page.bottom=pagesize->bottom;
-    param.page.width=pagesize->width;
-    param.page.height=pagesize->length;
-  }
-#ifdef HAVE_CUPS_1_7
-  else {
-    if ((val = cupsGetOption("media-size", num_options, options)) != NULL ||
-	(val = cupsGetOption("MediaSize", num_options, options)) != NULL ||
-	(val = cupsGetOption("page-size", num_options, options)) != NULL ||
-	(val = cupsGetOption("PageSize", num_options, options)) != NULL) {
-      pwg_media_t *size_found = NULL;
-      fprintf(stderr, "DEBUG: Page size from command line: %s\n", val);
-      if ((size_found = pwgMediaForPWG(val)) == NULL)
-	if ((size_found = pwgMediaForPPD(val)) == NULL)
-	  size_found = pwgMediaForLegacy(val);
-      if (size_found != NULL) {
-	param.page.width = size_found->width * 72.0 / 2540.0;
-        param.page.height = size_found->length * 72.0 / 2540.0;
-	param.page.top=param.page.bottom=36.0;
-	param.page.right=param.page.left=18.0;
-	param.page.right=param.page.width-param.page.right;
-	param.page.top=param.page.height-param.page.top;
-	fprintf(stderr, "DEBUG: Width: %f, Length: %f\n", param.page.width, param.page.height);
-      }
-      else
-	fprintf(stderr, "DEBUG: Unsupported page size %s.\n", val);
-    }
-  }
-#endif /* HAVE_CUPS_1_7 */
-
-  param.paper_is_landscape=(param.page.width>param.page.height);
-
-  PageRect tmp; // borders (before rotation)
-
-  optGetFloat("page-top",num_options,options,&tmp.top);
-  optGetFloat("page-left",num_options,options,&tmp.left);
-  optGetFloat("page-right",num_options,options,&tmp.right);
-  optGetFloat("page-bottom",num_options,options,&tmp.bottom);
-
-  if ((val = cupsGetOption("media-top-margin", num_options, options))
-      != NULL)
-    tmp.top = atof(val) * 72.0 / 2540.0; 
-  if ((val = cupsGetOption("media-left-margin", num_options, options))
-      != NULL)
-    tmp.left = atof(val) * 72.0 / 2540.0; 
-  if ((val = cupsGetOption("media-right-margin", num_options, options))
-      != NULL)
-    tmp.right = atof(val) * 72.0 / 2540.0; 
-  if ((val = cupsGetOption("media-bottom-margin", num_options, options))
-      != NULL)
-    tmp.bottom = atof(val) * 72.0 / 2540.0; 
-
-  if ((param.orientation==ROT_90)||(param.orientation==ROT_270)) { // unrotate page
-    // NaN stays NaN
-    tmp.right=param.page.height-tmp.right;
-    tmp.top=param.page.width-tmp.top;
-    tmp.rotate_move(param.orientation,param.page.height,param.page.width);
-  } else {
-    tmp.right=param.page.width-tmp.right;
-    tmp.top=param.page.height-tmp.top;
-    tmp.rotate_move(param.orientation,param.page.width,param.page.height);
-  }
-
-  param.page.set(tmp); // replace values, where tmp.* != NaN  (because tmp needed rotation, param.page not!)
-
-  if (ppdGetDuplex(ppd)) {
-    param.duplex=true;
-  } else if (is_true(cupsGetOption("Duplex",num_options,options))) {
-    param.duplex=true;
-    param.setDuplex=true;
-  } else if ((val=cupsGetOption("sides",num_options,options)) != NULL) {
-    if ((strcasecmp(val,"two-sided-long-edge")==0)||
-	(strcasecmp(val,"two-sided-short-edge")==0)) {
-      param.duplex=true;
-      param.setDuplex=true;
-    } else if (strcasecmp(val,"one-sided")!=0) {
-      error("Unsupported sides value %s, using sides=one-sided!",val);
-    }
-  }
-
-  // default nup is 1
-  int nup=1;
-  if (optGetInt("number-up",num_options,options,&nup)) {
-    if (!NupParameters::possible(nup)) {
-      error("Unsupported number-up value %d, using number-up=1!",nup);
-      nup=1;
-    }
-// TODO   ;  TODO? nup enabled? ... fitplot
-//    NupParameters::calculate(nup,param.nup);
-    NupParameters::preset(nup,param.nup);
-  }
-
-  if ((val=cupsGetOption("number-up-layout",num_options,options)) != NULL) {
-    if (!parseNupLayout(val,param.nup)) {
-      error("Unsupported number-up-layout %s, using number-up-layout=lrtb!",val);
-      param.nup.first=Axis::X;
-      param.nup.xstart=Position::LEFT;
-      param.nup.ystart=Position::TOP;
-    }
-  }
-
-  if ((val=cupsGetOption("page-border",num_options,options)) != NULL) {
-    if (!parseBorder(val,param.border)) {
-      error("Unsupported page-border value %s, using page-border=none!",val);
-      param.border=BorderType::NONE;
-    }
-  }
-
-  if ((val=cupsGetOption("OutputOrder",num_options,options)) != NULL ||
-      (val=cupsGetOption("output-order",num_options,options)) != NULL ||
-      (val=cupsGetOption("page-delivery",num_options,options)) != NULL) {
-    param.reverse = (strcasecmp(val, "Reverse") == 0 ||
-		     strcasecmp(val, "reverse-order") == 0);
-  } else if (ppd) {
-    param.reverse=ppdDefaultOrder(ppd);
-  }
-
-  std::string rawlabel;
-  char *classification = getenv("CLASSIFICATION");
-  if (classification)
-    rawlabel.append (classification);
-
-  if ((val=cupsGetOption("page-label", num_options, options)) != NULL) {
-    if (!rawlabel.empty())
-      rawlabel.append (" - ");
-    rawlabel.append(cupsGetOption("page-label",num_options,options));
-  }
-
-  std::ostringstream cookedlabel;
-  for (std::string::iterator it = rawlabel.begin();
-       it != rawlabel.end ();
-       ++it) {
-    if (*it < 32 || *it > 126)
-      cookedlabel << "\\" << std::oct << std::setfill('0') << std::setw(3) << (unsigned int) *it;
-    else
-      cookedlabel.put (*it);
-  }
-  param.pageLabel = cookedlabel.str ();
-
-  if ((val=cupsGetOption("page-set",num_options,options)) != NULL) {
-    if (strcasecmp(val,"even")==0) {
-      param.oddPages=false;
-    } else if (strcasecmp(val,"odd")==0) {
-      param.evenPages=false;
-    } else if (strcasecmp(val,"all")!=0) {
-      error("Unsupported page-set value %s, using page-set=all!",val);
-    }
-  }
-
-  if ((val=cupsGetOption("page-ranges",num_options,options)) != NULL) {
-    parseRanges(val,param.pageRange);
-  }
-
-  ppd_choice_t *choice;
-  if ((choice=ppdFindMarkedChoice(ppd,"MirrorPrint")) != NULL) {
-    val=choice->choice;
-  } else {
-    val=cupsGetOption("mirror",num_options,options);
-  }
-  param.mirror=is_true(val);
-
-  if ((val=cupsGetOption("emit-jcl",num_options,options)) != NULL) {
-    param.emitJCL=!is_false(val)&&(strcmp(val,"0")!=0);
-  }
-
-  param.booklet=BookletMode::BOOKLET_OFF;
-  if ((val=cupsGetOption("booklet",num_options,options)) != NULL) {
-    if (strcasecmp(val,"shuffle-only")==0) {
-      param.booklet=BookletMode::BOOKLET_JUSTSHUFFLE;
-    } else if (is_true(val)) {
-      param.booklet=BookletMode::BOOKLET_ON;
-    } else if (!is_false(val)) {
-      error("Unsupported booklet value %s, using booklet=off!",val);
-    }
-  }
-  param.bookSignature=-1;
-  if (optGetInt("booklet-signature",num_options,options,&param.bookSignature)) {
-    if (param.bookSignature==0) {
-      error("Unsupported booklet-signature value, using booklet-signature=-1 (all)!",val);
-      param.bookSignature=-1;
-    }
-  }
-
-  if ((val=cupsGetOption("position",num_options,options)) != NULL) {
-    if (!parsePosition(val,param.xpos,param.ypos)) {
-      error("Unrecognized position value %s, using position=center!",val);
-      param.xpos=Position::CENTER;
-      param.ypos=Position::CENTER;
-    }
-  }
-
-  param.collate=optGetCollate(num_options,options);
-  // FIXME? pdftopdf also considers if ppdCollate is set (only when cupsGetOption is /not/ given) [and if is_true overrides param.collate=true]  -- pstops does not
-
-/*
-  // TODO: scaling
-  // TODO: natural-scaling
-
-  scaling
-
-
-  if ((val = cupsGetOption("scaling",num_options,options)) != 0) {
-    scaling = atoi(val) * 0.01;
-    fitplot = true;
-  } else if (fitplot) {
-    scaling = 1.0;
-  }
-  if ((val = cupsGetOption("natural-scaling",num_options,options)) != 0) {
-    naturalScaling = atoi(val) * 0.01;
-  }
-
-bool checkFeature(const char *feature, int num_options, cups_option_t *options) // {{{
-{
-  const char *val;
-  ppd_attr_t *attr;
-
-  return ((val=cupsGetOption(feature,num_options,options)) != NULL && is_true(val)) ||
-         ((attr=ppdFindAttr(ppd,feature,0)) != NULL && is_true(attr->val));
-}
-// }}}
-*/
-
-  // make pages a multiple of two (only considered when duplex is on).
-  // i.e. printer has hardware-duplex, but needs pre-inserted filler pages
-  // FIXME? pdftopdf also supports it as cmdline option (via checkFeature())
-  ppd_attr_t *attr;
-  if ((attr=ppdFindAttr(ppd,"cupsEvenDuplex",0)) != NULL) {
-    param.evenDuplex=is_true(attr->value);
-  }
-
-  // TODO? pdftopdf* ?
-  // TODO?! pdftopdfAutoRotate
-
-  // TODO?!  choose default by whether pdfautoratate filter has already been run (e.g. by mimetype)
-  param.autoRotate=(!is_false(cupsGetOption("pdfAutoRotate",num_options,options)) &&
-		    !is_false(cupsGetOption("pdftopdfAutoRotate",num_options,options)));
-
-  // Do we have to do the page logging in page_log?
-
-  // CUPS standard is that the last filter (not the backend, usually the
-  // printer driver) does page logging in the /var/log/cups/page_log file
-  // by outputting "PAGE: <# of current page> <# of copies>" to stderr.
-
-  // pdftopdf would have to do this only for PDF printers as in this case
-  // pdftopdf is the last filter, but some of the other filters are not
-  // able to do the logging because they do not have access to the number
-  // of pages of the file to be printed, so pdftopdf overtakes their logging
-  // duty.
-
-  // The filters currently are:
-  // - foomatic-rip (lets Ghostscript convert PDF to printer's format via
-  //   built-in drivers, no access to the PDF content)
-  // - gstopxl (uses Ghostscript, like foomatic-rip)
-  // - *toraster on IPP Everywhere printers (then *toraster gets the last
-  //   filter, the case if FINAL_CONTENT_TYPE env var is "image/pwg-raster")
-  // - hpps (bug)
-
-  // Check whether page logging is forced or suppressed by the command line
-  if ((val=cupsGetOption("page-logging",num_options,options)) != NULL) {
-    if (strcasecmp(val,"auto") == 0) {
-      param.page_logging = -1;
-      fprintf(stderr,
-	      "DEBUG: pdftopdf: Automatic page logging selected by command line.\n");
-    } else if (is_true(val)) {
-      param.page_logging = 1;
-      fprintf(stderr,
-	      "DEBUG: pdftopdf: Forced page logging selected by command line.\n");
-    } else if (is_false(val)) {
-      param.page_logging = 0;
-      fprintf(stderr,
-	      "DEBUG: pdftopdf: Suppressed page logging selected by command line.\n");
-    } else {
-      error("Unsupported page-logging value %s, using page-logging=auto!",val);
-      param.page_logging = -1;
-    }
-  }
-
-  if (param.page_logging == -1) {
-    // Determine the last filter in the chain via cupsFilter(2) lines of the
-    // PPD file and FINAL_CONTENT_TYPE
-    if (!ppd) {
-      // If there is no PPD do not log when not requested by command line
-      param.page_logging = 0;
-      fprintf(stderr,
-	      "DEBUG: pdftopdf: No PPD file specified, could not determine whether to log pages or not, so turned off page logging.\n");
-    } else {
-      char *final_content_type = getenv("FINAL_CONTENT_TYPE");
-      char *lastfilter = NULL;
-      if (final_content_type == NULL) {
-	// No FINAL_CONTENT_TYPE env variable set, we cannot determine
-	// whether we have to log pages, so do not log.
-	param.page_logging = 0;
-	fprintf(stderr,
-		"DEBUG: pdftopdf: No FINAL_CONTENT_TYPE environment variable, could not determine whether to log pages or not, so turned off page logging.\n");
-      // Proceed depending on number of cupsFilter(2) lines in PPD
-      } else if (ppd->num_filters == 0) {
-	// No filter line, manufacturer-supplied PostScript PPD
-	// In this case pstops, called by pdftops, does the logging
-	param.page_logging = 0;
-      } else if (ppd->num_filters == 1) {
-	// One filter line, so this one filter is the last filter
-	lastfilter = ppd->filters[0];
-      } else {
-	// More than one filter line, determine the one which got
-	// actually used via FINAL_CONTENT_TYPE
-	ppd_attr_t *ppd_attr;
-	if ((ppd_attr = ppdFindAttr(ppd, "cupsFilter2", NULL)) != NULL) {
-	  // We have cupsFilter2 lines, use only these
-	  do {
-	    // Go to the second work, which is the destination MIME type
-	    char *p = ppd_attr->value;
-	    while (!isspace(*p)) p ++;
-	    while (isspace(*p)) p ++;
-	    // Compare with FINAL_CONTEN_TYPE
-	    if (!strncasecmp(final_content_type, p,
-			     strlen(final_content_type))) {
-	      lastfilter = ppd_attr->value;
-	      break;
-	    }
-	  } while ((ppd_attr = ppdFindNextAttr(ppd, "cupsFilter2", NULL))
-		   != NULL);
-	} else {
-	  // We do not have cupsFilter2 lines, use the cupsFilter lines
-	  int i;
-	  for (i = 0; i < ppd->num_filters; i ++) {
-	    // Compare source MIME type (first word) with FINAL_CONTENT_TYPE
-	    if (!strncasecmp(final_content_type, ppd->filters[i],
-			     strlen(final_content_type))) {
-	      lastfilter = ppd->filters[i];
-	      break;
-	    }
-	  }
-	}
-      }
-      if (param.page_logging == -1) {
-	if (lastfilter) {
-	  // Get the name of the last filter, without mime type and cost
-	  char *p = lastfilter;
-	  char *q = p + strlen(p) - 1;
-	  while(!isspace(*q) && *q != '/') q --;
-	  lastfilter = q + 1;
-	  // Check whether we have to log
-	  if (!strcasecmp(lastfilter, "-")) {
-	    // No filter defined in the PPD
-	    // If output data (FINAL_CONTENT_TYPE) is PDF, pdftopdf is last
-	    // filter (PDF printer) and has to log
-	    // If output data (FINAL_CONTENT_TYPE) is PWG Raster, *toraster is
-	    // last filter (IPP Everywhere printer) and pdftopdf has to log
-	    if (strcasestr(final_content_type, "/pdf") ||
-		strcasestr(final_content_type, "/vnd.cups-pdf") ||
-		strcasestr(final_content_type, "/pwg-raster"))
-	      param.page_logging = 1;
-	    else
-	      param.page_logging = 0;
-	  } else if (!strcasecmp(lastfilter, "pdftopdf")) {
-	    // pdftopdf is last filter (PDF printer)
-	    param.page_logging = 1;
-	  } else if (!strcasecmp(lastfilter, "gstopxl")) {
-	    // gstopxl is last filter, this is a Ghostscript-based filter
-	    // without access to the pages of the file to be printed, so we
-	    // log the pages
-	    param.page_logging = 1;
-	  } else if (!strcasecmp(lastfilter + strlen(lastfilter) - 8,
-				 "toraster")) {
-	    // On IPP Everywhere printers which accept PWG Raster data one
-	    // of gstoraster, pdftoraster, or mupdftoraster is the last
-	    // filter. These filters do not log pages so pdftopdf has to
-	    // do it
-	    param.page_logging = 1;
-	  } else if (!strcasecmp(lastfilter, "foomatic-rip")) {
-	    // foomatic-rip is last filter, foomatic-rip is mainly used as
-	    // Ghostscript wrapper to use Ghostscript's built-in printer
-	    // drivers. Here there is also no access to the pages so that we
-	    // delegate the logging to pdftopdf
-	    param.page_logging = 1;
-	  } else if (!strcasecmp(lastfilter, "hpps")) {
-	    // hpps is last filter, hpps is part of HPLIP and it is a bug that
-	    // it does not do the page logging.
-	    param.page_logging = 1;
-	  } else {
-	    // All the other filters log pages as expected.
-	    param.page_logging = 0;
-	  }
-	} else {
-	  error("pdftopdf: Last filter could not get determined, page logging turned off.");
-	  param.page_logging = 0;
-	}
-      }
-      fprintf(stderr,
-	      "DEBUG: pdftopdf: Last filter determined by the PPD: %s; FINAL_CONTENT_TYPE: %s => pdftopdf will %slog pages in page_log.\n",
-	      (lastfilter ? lastfilter : "None"), final_content_type,
-	      (param.page_logging == 0 ? "not " : ""));
-    }
-  }
-}
-// }}}
-
-static bool printerWillCollate(ppd_file_t *ppd) // {{{
-{
-  ppd_choice_t *choice;
-
-  if (((choice=ppdFindMarkedChoice(ppd,"Collate")) != NULL)&&
-      (is_true(choice->choice))) {
-
-    // printer can collate, but also for the currently marked ppd features?
-    ppd_option_t *opt=ppdFindOption(ppd,"Collate");
-    return (opt)&&(!opt->conflicted);
-  }
-  return false;
-}
-// }}}
-
-void calculate(ppd_file_t *ppd,ProcessingParameters &param) // {{{
-{
-  if (param.reverse)
-    // Enable evenDuplex or the first page may be empty.
-    param.evenDuplex=true; // disabled later, if non-duplex
-
-  setFinalPPD(ppd,param);
-
-  if (param.numCopies==1) {
-    param.deviceCopies=1;
-    // collate is never needed for a single copy
-    param.collate=false; // (does not make a big difference for us)
-  } else if ((ppd)&&(!ppd->manual_copies)) { // hw copy generation available
-    param.deviceCopies=param.numCopies;
-    if (param.collate) { // collate requested by user
-      // Check output format (FINAL_CONTENT_TYPE env variable) whether it is
-      // of a driverless IPP printer (PDF, Apple Raster, PWG Raster, PCLm).
-      // These printers do always hardware collate if they do hardware copies.
-      // https://github.com/apple/cups/issues/5433
-      char *final_content_type = getenv("FINAL_CONTENT_TYPE");
-      if (final_content_type &&
-	  (strcasestr(final_content_type, "/pdf") ||
-	   strcasestr(final_content_type, "/vnd.cups-pdf") ||
-	   strcasestr(final_content_type, "/pwg-raster") ||
-	   strcasestr(final_content_type, "/urf") ||
-	   strcasestr(final_content_type, "/PCLm"))) {
-	param.deviceCollate = true;
-      } else {
-	// check collate device, with current/final(!) ppd settings
-	param.deviceCollate=printerWillCollate(ppd);
-	if (!param.deviceCollate) {
-	  // printer can't hw collate -> we must copy collated in sw
-	  param.deviceCopies=1;
-	}
-      }
-    } // else: printer copies w/o collate and takes care of duplex/evenDuplex
-  } else { // sw copies
-    param.deviceCopies=1;
-    if (param.duplex) { // &&(numCopies>1)
-      // sw collate + evenDuplex must be forced to prevent copies on the backsides
-      param.collate=true;
-      param.deviceCollate=false;
-    }
-  }
-
-  // TODO? FIXME:  unify code with emitJCLOptions, which does this "by-hand" now (and makes this code superfluous)
-  if (param.deviceCopies==1) {
-    // make sure any hardware copying is disabled
-    ppdMarkOption(ppd,"Copies","1");
-    ppdMarkOption(ppd,"JCLCopies","1");
-  } else { // hw copy
-    param.numCopies=1; // disable sw copy
-  }
-
-  if ((param.collate)&&(!param.deviceCollate)) { // software collate
-    ppdMarkOption(ppd,"Collate","False"); // disable any hardware-collate (in JCL)
-    param.evenDuplex=true; // fillers always needed
-  }
-
-  if (!param.duplex) {
-    param.evenDuplex=false;
-  }
-}
-// }}}
-
-// reads from stdin into temporary file. returns FILE *  or NULL on error
-FILE *copy_stdin_to_temp() // {{{
-{
-  char buf[BUFSIZ];
-  int n;
-
-  // FIXME:  what does >buf mean here?
-  int fd=cupsTempFd(buf,sizeof(buf));
-  if (fd<0) {
-    error("Can't create temporary file");
-    return NULL;
-  }
-  // remove name
-  unlink(buf);
-
-  // copy stdin to the tmp file
-  while ((n=read(0,buf,BUFSIZ)) > 0) {
-    if (write(fd,buf,n) != n) {
-      error("Can't copy stdin to temporary file");
-      close(fd);
-      return NULL;
-    }
-  }
-  if (lseek(fd,0,SEEK_SET) < 0) {
-    error("Can't rewind temporary file");
-    close(fd);
-    return NULL;
-  }
-
-  FILE *f;
-  if ((f=fdopen(fd,"rb")) == 0) {
-    error("Can't fdopen temporary file");
-    close(fd);
-    return NULL;
-  }
-  return f;
-}
-// }}}
-
-// check whether a given file is empty
-bool is_empty(FILE *f) // {{{
-{
-  char buf[1];
-
-  // Try to read a single byte of data
-  if (fread(buf, 1, 1, f) == 0)
-    return true;
-
-  rewind(f);
-
-  return false;
-}
-// }}}
-
-static int
-sub_process_spawn (const char *filename,
-          cups_array_t *sub_process_args,
-          FILE *fp) // {{{
-{
-  char *argument;
-  char buf[BUFSIZ];
-  char **sub_process_argv;
-  const char* apos;
-  int fds[2];
-  int i;
-  int n;
-  int numargs;
-  int pid;
-  int status = 65536;
-  int wstatus;
-
-  /* Put sub-process command line argument into an array for the "exec()"
-     call */
-  numargs = cupsArrayCount(sub_process_args);
-  sub_process_argv = (char **)calloc(numargs + 1, sizeof(char *));
-  for (argument = (char *)cupsArrayFirst(sub_process_args), i = 0; argument;
-       argument = (char *)cupsArrayNext(sub_process_args), i++) {
-    sub_process_argv[i] = argument;
-  }
-  sub_process_argv[i] = NULL;
-
-  /* Debug output: Full sub-process command line */
-  fprintf(stderr, "DEBUG: PDF form flattening command line:");
-  for (i = 0; sub_process_argv[i]; i ++) {
-    if ((strchr(sub_process_argv[i],' ')) || (strchr(sub_process_argv[i],'\t')))
-      apos = "'";
-    else
-      apos = "";
-    fprintf(stderr, " %s%s%s", apos, sub_process_argv[i], apos);
-  }
-  fprintf(stderr, "\n");
-
-  /* Create a pipe for feeding the job into sub-process */
-  if (pipe(fds))
-  {
-    fds[0] = -1;
-    fds[1] = -1;
-    fprintf(stderr, "ERROR: Unable to establish pipe for sub-process call\n");
-    goto out;
-  }
-
-  /* Set the "close on exec" flag on each end of the pipe... */
-  if (fcntl(fds[0], F_SETFD, fcntl(fds[0], F_GETFD) | FD_CLOEXEC))
-  {
-    close(fds[0]);
-    close(fds[1]);
-    fds[0] = -1;
-    fds[1] = -1;
-    fprintf(stderr, "ERROR: Unable to set \"close on exec\" flag on read end of the pipe for sub-process call\n");
-    goto out;
-  }
-  if (fcntl(fds[1], F_SETFD, fcntl(fds[1], F_GETFD) | FD_CLOEXEC))
-  {
-    close(fds[0]);
-    close(fds[1]);
-    fprintf(stderr, "ERROR: Unable to set \"close on exec\" flag on write end of the pipe for sub-process call\n");
-    goto out;
-  }
-
-  if ((pid = fork()) == 0)
-  {
-    /* Couple pipe with STDIN of sub-process */
-    if (fds[0] != 0) {
-      close(0);
-      if (fds[0] > 0) {
-        if (dup(fds[0]) < 0) {
-	  fprintf(stderr, "ERROR: Unable to couple pipe with STDIN of sub-process\n");
-	  goto out;
-	}
-      } else {
-        fprintf(stderr, "ERROR: Unable to couple pipe with STDIN of sub-process\n");
-        goto out;
-      }
-    }
-    close(fds[1]);
-
-    /* Execute sub-process command line ... */
-    execvp(filename, sub_process_argv);
-    perror(filename);
-    close(fds[0]);
-    goto out;
-  }
-
-  close(fds[0]);
-  /* Feed job data into the sub-process */
-  while ((n = fread(buf, 1, BUFSIZ, fp)) > 0) {
-    int count;
-retry_write:
-    count = write(fds[1], buf, n);
-    if (count != n) {
-      if (count == -1) {
-        if (errno == EINTR) {
-          goto retry_write;
-	}
-        fprintf(stderr, "ERROR: write failed: %s\n", strerror(errno));
-      }
-      fprintf(stderr, "ERROR: Can't feed job data into the sub-process\n");
-      goto out;
-    }
-  }
-  close (fds[1]);
-
-retry_wait:
-  if (waitpid (pid, &wstatus, 0) == -1) {
-    if (errno == EINTR)
-      goto retry_wait;
-    perror ("sub-process");
-    goto out;
-  }
-
-  /* How did the sub-process terminate */
-  if (WIFEXITED(wstatus))
-    /* Via exit() anywhere or return() in the main() function */
-    status = WEXITSTATUS(wstatus);
-  else if (WIFSIGNALED(wstatus))
-    /* Via signal */
-    status = 256 * WTERMSIG(wstatus);
-
-out:
-  free(sub_process_argv);
-  return status;
-}
-// }}}
-
-int main(int argc,char **argv)
-{
-  if ((argc<6)||(argc>7)) {
-    fprintf(stderr,"Usage: %s job-id user title copies options [file]\n",argv[0]);
-#ifdef DEBUG
-    ProcessingParameters param;
-    std::unique_ptr<PDFTOPDF_Processor> proc1(PDFTOPDF_Factory::processor());
-    param.page.width=595.276; // A4
-    param.page.height=841.89;
-
-    param.page.top=param.page.bottom=36.0;
-    param.page.right=param.page.left=18.0;
-    param.page.right=param.page.width-param.page.right;
-    param.page.top=param.page.height-param.page.top;
-
-    //param.nup.calculate(4,0.707,0.707,param.nup);
-    param.nup.nupX=2;
-    param.nup.nupY=2;
-    //param.nup.yalign=TOP;
-    param.border=BorderType::NONE;
-    //param.fillprint = true;
-    //param.mirror=true;
-    //param.reverse=true;
-    //param.numCopies=3;
-    if (!proc1->loadFilename("in.pdf",1)) return 2;
-    param.dump();
-    if (!processPDFTOPDF(*proc1,param)) return 3;
-    emitComment(*proc1,param);
-    proc1->emitFilename("out.pdf");
-#endif
-    return 1;
-  }
-
-  try {
-    ProcessingParameters param;
-
-    param.jobId=atoi(argv[1]);
-    param.user=argv[2];
-    param.title=argv[3];
-    param.numCopies=atoi(argv[4]);
-    param.copies_to_be_logged=atoi(argv[4]);
-
-    // TODO?! sanity checks
-
-    int num_options=0;
-    cups_option_t *options=NULL;
-    num_options=cupsParseOptions(argv[5],num_options,&options);
-
-    ppd_file_t *ppd=NULL;
-    ppd=ppdOpenFile(getenv("PPD")); // getenv (and thus ppd) may be null. This will not cause problems.
-    ppdMarkDefaults(ppd);
-
-    cupsMarkOptions(ppd,num_options,options);
-
-    getParameters(ppd,num_options,options,param);
-    calculate(ppd,param);
-
-#ifdef DEBUG
-    param.dump();
-#endif
-
-    /* Check with which method we will flatten interactive PDF forms
-       and annotations so that they get printed also after page
-       manipulations (scaling, N-up, ...). Flattening means to
-       integrate the filled in data and the printable annotations into
-       the pages themselves instead of holding them in an extra
-       layer. Default method is using QPDF, alternatives are the
-       external utilities pdftocairo or Ghostscript, but these make
-       the processing slower, especially due to extra piping of the
-       data between processes. */
-    int empty = 0;
-    int qpdf_flatten = 1;
-    int pdftocairo_flatten = 0;
-    int gs_flatten = 0;
-    int external_auto_flatten = 0;
-    const char	*val;
-    if ((val = cupsGetOption("pdftopdf-form-flattening", num_options, options)) != NULL) {
-      if (strcasecmp(val, "qpdf") == 0 || strcasecmp(val, "internal") == 0 ||
-	  strcasecmp(val, "auto") == 0) {
-	qpdf_flatten = 1;
-      } else if (strcasecmp(val, "external") == 0) {
-	qpdf_flatten = 0;
-	external_auto_flatten = 1;
-      } else if (strcasecmp(val, "pdftocairo") == 0) {
-	qpdf_flatten = 0;
-	pdftocairo_flatten = 1;
-      } else if (strcasecmp(val, "ghostscript") == 0 || strcasecmp(val, "gs") == 0) {
-	qpdf_flatten = 0;
-	gs_flatten = 1;
-      } else
-	fprintf(stderr,
-		"WARNING: Invalid value for \"pdftopdf-form-flattening\": \"%s\"\n", val);
-    }
-
-    cupsFreeOptions(num_options,options);
-
-    std::unique_ptr<PDFTOPDF_Processor> proc(PDFTOPDF_Factory::processor());
-
-    FILE *tmpfile = NULL;
-    if (argc==7) {
-      FILE *f = NULL;
-      if ((f = fopen(argv[6], "rb")) == NULL) {
-        ppdClose(ppd);
-        return 1;
-      } else if (is_empty(f)) {
-	fclose(f);
-	ppdClose(ppd);
-	empty = 1;
-      } else if (!proc->loadFilename(argv[6],qpdf_flatten)) {
-	fclose(f);
-        ppdClose(ppd);
-        return 1;
-      } else
-	fclose(f);
-    } else {
-      tmpfile = copy_stdin_to_temp();
-      if (tmpfile && is_empty(tmpfile)) {
-	fclose(tmpfile);
-	ppdClose(ppd);
-	empty = 1;
-      } else if ((!tmpfile)||
-		 (!proc->loadFile(tmpfile,WillStayAlive,qpdf_flatten))) {
-        ppdClose(ppd);
-	return 1;
-      }
-    }
-
-    if(empty)
-    {
-      fprintf(stderr, "DEBUG: Input is empty, outputting empty file.\n");
-      return 0;
-    }
-
-    /* If the input file contains a PDF form and we opted for not
-       using QPDF for flattening the form, we pipe the PDF through
-       pdftocairo or Ghostscript here */
-    if (!qpdf_flatten && proc->hasAcroForm()) {
-      /* Prepare the input file for being read by the form flattening
-	 process */
-      FILE *infile = NULL;
-      if (argc == 7) {
-	/* We read from a named file */
-	infile = fopen(argv[6], "r");
-      } else {
-	/* We read from a temporary file */
-	if (tmpfile) rewind(tmpfile);
-	infile = tmpfile;
-      }
-      if (infile == NULL) {
-	error("Could not open the input file for flattening the PDF form!");
-	return 1;
-      }
-      /* Create a temporary file for the output of the flattened PDF */
-      char buf[BUFSIZ];
-      int fd = cupsTempFd(buf,sizeof(buf));
-      if (fd<0) {
-	error("Can't create temporary file for flattened PDF form!");
-	return 1;
-      }
-      FILE *outfile = NULL;
-      if ((outfile=fdopen(fd,"rb")) == 0) {
-	error("Can't fdopen temporary file for the flattened PDF form!");
-	close(fd);
-	return 1;
-      }
-      int flattening_done = 0;
-      const char *command;
-      cups_array_t *args;
-      /* Choose the utility to be used and create its command line */
-      if (pdftocairo_flatten || external_auto_flatten) {
-	/* Try pdftocairo first, the preferred utility for form-flattening */
-	command = CUPS_POPPLER_PDFTOCAIRO;
-	args = cupsArrayNew(NULL, NULL);
-	cupsArrayAdd(args, strdup(command));
-	cupsArrayAdd(args, strdup("-pdf"));
-	cupsArrayAdd(args, strdup("-"));
-	cupsArrayAdd(args, strdup(buf));
-	/* Run the pdftocairo form flattening process */
-	rewind(infile);
-	int status = sub_process_spawn (command, args, infile);
-	cupsArrayDelete(args);
-	if (status == 0)
-	  flattening_done = 1;
-	else
-	  error("Unable to execute pdftocairo for form flattening!");
-      }
-      if (flattening_done == 0 &&
-	  (gs_flatten || external_auto_flatten)) {
-	/* Try Ghostscript */
-	command = CUPS_GHOSTSCRIPT;
-	args = cupsArrayNew(NULL, NULL);
-	cupsArrayAdd(args, strdup(command));
-	cupsArrayAdd(args, strdup("-dQUIET"));
-	cupsArrayAdd(args, strdup("-dPARANOIDSAFER"));
-	cupsArrayAdd(args, strdup("-dNOPAUSE"));
-	cupsArrayAdd(args, strdup("-dBATCH"));
-	cupsArrayAdd(args, strdup("-dNOINTERPOLATE"));
-	cupsArrayAdd(args, strdup("-dNOMEDIAATTRS"));
-	cupsArrayAdd(args, strdup("-sDEVICE=pdfwrite"));
-	cupsArrayAdd(args, strdup("-dShowAcroForm"));
-	cupsArrayAdd(args, strdup("-sstdout=%stderr"));
-	memmove(buf + 13, buf, sizeof(buf) - 13);
-	memcpy(buf, "-sOutputFile=", 13);
-	cupsArrayAdd(args, strdup(buf));
-	cupsArrayAdd(args, strdup("-"));
-	/* Run the Ghostscript form flattening process */
-	rewind(infile);
-	int status = sub_process_spawn (command, args, infile);
-	cupsArrayDelete(args);
-	if (status == 0)
-	  flattening_done = 1;
-	else
-	  error("Unable to execute Ghostscript for form flattening!");
-      }
-      if (flattening_done == 0) {
-	error("No suitable utility for flattening filled PDF forms available, no flattening performed. Filled in content will possibly not be printed.");
-	rewind(infile);
-      }
-      /* Clean up */
-      if (infile != tmpfile)
-	fclose(infile);
-      /* Load the flattened PDF file into our PDF processor */
-      if (flattening_done) {
-	rewind(outfile);
-	unlink(buf);
-	if (!proc->loadFile(outfile,TakeOwnership,0)) {
-	  error("Unable to create a PDF processor on the flattened form!"); 
-	  return 1;
-	}
-      }
-    } else if (qpdf_flatten)
-      fprintf(stderr, "DEBUG: PDF interactive form and annotation flattening done via QPDF\n");
-
-/* TODO
-    // color management
---- PPD:
-      copyPPDLine_(fp_dest, fp_src, "*PPD-Adobe: ");
-      copyPPDLine_(fp_dest, fp_src, "*cupsICCProfile ");
-      copyPPDLine_(fp_dest, fp_src, "*Manufacturer:");
-      copyPPDLine_(fp_dest, fp_src, "*ColorDevice:");
-      copyPPDLine_(fp_dest, fp_src, "*DefaultColorSpace:");
-    if (cupsICCProfile) {
-      proc.addCM(...,...);
-    }
-*/
-
-    if (!processPDFTOPDF(*proc,param)) {
-      ppdClose(ppd);
-      return 2;
-    }
-
-    emitPreamble(ppd,param); // ppdEmit, JCL stuff
-    emitComment(*proc,param); // pass information to subsequent filters via PDF comments
-
-    //proc->emitFile(stdout);
-    proc->emitFilename(NULL);
-
-    emitPostamble(ppd,param);
-    ppdClose(ppd);
-    if (tmpfile)
-      fclose(tmpfile);
-  } catch (std::exception &e) {
-    // TODO? exception type
-    error("Exception: %s",e.what());
-    return 5;
-  } catch (...) {
-    error("Unknown exception caught. Exiting.");
-    return 6;
-  }
-
-  return 0;
-}
diff --git a/filter/pdftopdf/pdftopdf_jcl.cc b/filter/pdftopdf/pdftopdf_jcl.cc
deleted file mode 100644
index 224d8b0..0000000
--- a/filter/pdftopdf/pdftopdf_jcl.cc
+++ /dev/null
@@ -1,202 +0,0 @@
-#include <ctype.h>
-#include "pdftopdf_processor.h"
-#include <cups/ppd.h>
-
-#include <string.h>
-
-// TODO: -currently changes ppd.  (Copies)
-//
-static void emitJCLOptions(FILE *fp, ppd_file_t *ppd, int deviceCopies) // {{{
-{
-  int section;
-  ppd_choice_t **choices;
-  int i;
-  char buf[1024];
-  ppd_attr_t *attr;
-  bool withJCL=false,
-    datawritten=false;
-
-  if (!ppd) return;
-
-  if ((attr = ppdFindAttr(ppd,"pdftopdfJCLBegin",NULL)) != NULL) {
-    withJCL=true;
-    const int n=strlen(attr->value);
-    for (i = 0;i < n;i++) {
-      if (attr->value[i] == '\r' || attr->value[i] == '\n') {
-        // skip new line
-        continue;
-      }
-      fputc(attr->value[i],fp);
-      datawritten=true;
-    }
-  }
-         
-  snprintf(buf,sizeof(buf),"%d",deviceCopies);
-  if (ppdFindOption(ppd,"Copies") != NULL) {
-    ppdMarkOption(ppd,"Copies",buf);
-  } else {
-    if ((attr = ppdFindAttr(ppd,"pdftopdfJCLCopies",buf)) != NULL) {
-      fputs(attr->value,fp);
-      datawritten=true;
-    } else if (withJCL) {
-      fprintf(fp,"Copies=%d;",deviceCopies);
-      datawritten=true;
-    }
-  }
-  for (section = (int)PPD_ORDER_ANY;
-       section <= (int)PPD_ORDER_PROLOG;section++) {
-    int n = ppdCollect(ppd,(ppd_section_t)section,&choices);
-    for (i = 0;i < n;i++) {
-      snprintf(buf,sizeof(buf),"pdftopdfJCL%s",
-	       ((ppd_option_t *)(choices[i]->option))->keyword);
-      if ((attr = ppdFindAttr(ppd,buf,choices[i]->choice)) != NULL) {
-        fputs(attr->value,fp);
-        datawritten=true;
-      } else if (withJCL) {
-        fprintf(fp,"%s=%s;",
-		((ppd_option_t *)(choices[i]->option))->keyword,
-		choices[i]->choice);
-        datawritten=true;
-      }
-    }
-  }
-  if (datawritten) {
-    fputc('\n',fp);
-  }
-}
-// }}}
-
-/* Copied ppd_decode() from CUPS which is not exported to the API; needed in emitPreamble() */
-// {{{ static int ppd_decode(char *string) 
-static int				/* O - Length of decoded string */
-ppd_decode(char *string)		/* I - String to decode */
-{
-  char	*inptr,				/* Input pointer */
-    *outptr;			/* Output pointer */
-
-  inptr  = string;
-  outptr = string;
-
-  while (*inptr != '\0')
-    if (*inptr == '<' && isxdigit(inptr[1] & 255)) {
-      /*
-       * Convert hex to 8-bit values...
-       */
-
-      inptr ++;
-      while (isxdigit(*inptr & 255)) {
-	if (isalpha(*inptr))
-	  *outptr = (tolower(*inptr) - 'a' + 10) << 4;
-	else
-	  *outptr = (*inptr - '0') << 4;
-
-	inptr ++;
-
-        if (!isxdigit(*inptr & 255))
-	  break;
-
-	if (isalpha(*inptr))
-	  *outptr |= tolower(*inptr) - 'a' + 10;
-	else
-	  *outptr |= *inptr - '0';
-
-	inptr ++;
-	outptr ++;
-      }
-
-      while (*inptr != '>' && *inptr != '\0')
-	inptr ++;
-      while (*inptr == '>')
-	inptr ++;
-    } else
-      *outptr++ = *inptr++;
-
-  *outptr = '\0';
-
-  return ((int)(outptr - string));
-}
-// }}}
-
-void emitPreamble(ppd_file_t *ppd,const ProcessingParameters &param) // {{{
-{
-  if (ppd == 0) return;
-
-  ppdEmit(ppd,stdout,PPD_ORDER_EXIT);
-
-  if (param.emitJCL) {
-    /* pdftopdf only adds JCL to the job if the printer is a native PDF
-       printer and the PPD is for this mode, having the "*JCLToPDFInterpreter:"
-       keyword. We need to read this keyword manually from the PPD and replace
-       the content of ppd->jcl_ps by the value of this keyword, so that
-       ppdEmitJCL() actually adds JCL based on the presence on 
-       "*JCLToPDFInterpreter:". */
-    ppd_attr_t *attr;
-    char buf[1024];
-    int devicecopies_done = 0;
-    char *old_jcl_ps = ppd->jcl_ps;
-    /* If there is a "Copies" option in the PPD file, assure that hardware
-       copies are implemented as described by this option */
-    if (ppdFindOption(ppd,"Copies") != NULL &&
-	param.deviceCopies > 1) {
-      snprintf(buf,sizeof(buf),"%d",param.deviceCopies);
-      ppdMarkOption(ppd,"Copies",buf);
-      devicecopies_done = 1;
-    }
-    if ((attr=ppdFindAttr(ppd,"JCLToPDFInterpreter",NULL)) != NULL) {
-      if (param.deviceCopies > 1 && devicecopies_done == 0 && // HW copies
-	  strncmp(ppd->jcl_begin, "\033%-12345X@", 10) == 0) { // PJL
-	/* Add a PJL command to implement the hardware copies */
-        const size_t size=strlen(attr->value)+1+30;
-        ppd->jcl_ps=(char *)malloc(size*sizeof(char));
-        if (param.deviceCollate) {
-          snprintf(ppd->jcl_ps, size, "@PJL SET QTY=%d\n%s",
-                   param.deviceCopies, attr->value);
-        } else {
-          snprintf(ppd->jcl_ps, size, "@PJL SET COPIES=%d\n%s",
-                   param.deviceCopies, attr->value);
-        }
-      } else
-	ppd->jcl_ps=strdup(attr->value);
-      ppd_decode(ppd->jcl_ps);
-    } else {
-      ppd->jcl_ps=NULL;
-    }
-    ppdEmitJCL(ppd,stdout,param.jobId,param.user,param.title);
-    emitJCLOptions(stdout,ppd,param.deviceCopies);
-    free(ppd->jcl_ps);
-    ppd->jcl_ps = old_jcl_ps; // cups uses pool allocator, not free()
-  }
-}
-// }}}
-
-void emitPostamble(ppd_file_t *ppd,const ProcessingParameters &param) // {{{
-{
-  if (param.emitJCL) { 
-    ppdEmitJCLEnd(ppd,stdout);
-  }
-}
-// }}}
-
-// pass information to subsequent filters via PDF comments
-void emitComment(PDFTOPDF_Processor &proc,const ProcessingParameters &param) // {{{
-{
-  std::vector<std::string> output;
-
-  output.push_back("% This file was generated by pdftopdf");
-
-  // This is not standard, but like PostScript. 
-  if (param.deviceCopies>0) {
-    char buf[256];
-    snprintf(buf,sizeof(buf),"%d",param.deviceCopies);
-    output.push_back(std::string("%%PDFTOPDFNumCopies : ")+buf);
-
-    if (param.deviceCollate) {
-      output.push_back("%%PDFTOPDFCollate : true");
-    } else {
-      output.push_back("%%PDFTOPDFCollate : false");
-    }
-  }
-
-  proc.setComments(output);
-}
-// }}}
diff --git a/filter/pdftopdf/pdftopdf_jcl.h b/filter/pdftopdf/pdftopdf_jcl.h
deleted file mode 100644
index ee6e315..0000000
--- a/filter/pdftopdf/pdftopdf_jcl.h
+++ /dev/null
@@ -1,12 +0,0 @@
-#ifndef PDFTOPDF_JCL_H
-#define PDFTOPDF_JCL_H
-
-struct ProcessingParameters;
-class PDFTOPDF_Processor;
-
-void emitPreamble(ppd_file_t *ppd,const ProcessingParameters &param);
-void emitPostamble(ppd_file_t *ppd,const ProcessingParameters &param);
-
-void emitComment(PDFTOPDF_Processor &proc,const ProcessingParameters &param);
-
-#endif
diff --git a/filter/pdftopdf/pdftopdf_processor.cc b/filter/pdftopdf/pdftopdf_processor.cc
deleted file mode 100644
index 6d2d32f..0000000
--- a/filter/pdftopdf/pdftopdf_processor.cc
+++ /dev/null
@@ -1,430 +0,0 @@
-#include "pdftopdf_processor.h"
-#include "qpdf_pdftopdf_processor.h"
-#include <stdio.h>
-#include <assert.h>
-#include <numeric>
-
-void BookletMode_dump(BookletMode bkm) // {{{
-{
-  static const char *bstr[3]={"Off","On","Shuffle-Only"};
-  if ((bkm<BOOKLET_OFF) || (bkm>BOOKLET_JUSTSHUFFLE)) {
-    fprintf(stderr,"(bad booklet mode: %d)",bkm);
-  } else {
-    fputs(bstr[bkm],stderr);
-  }
-}
-// }}}
-
-bool ProcessingParameters::withPage(int outno) const // {{{
-{
-  if (outno%2 == 0) { // 1-based
-    if (!evenPages) {
-      return false;
-    }
-  } else if (!oddPages) {
-    return false;
-  }
-  return pageRange.contains(outno);
-}
-// }}}
-
-void ProcessingParameters::dump() const // {{{
-{
-  fprintf(stderr,"jobId: %d, numCopies: %d\n",
-	  jobId,numCopies);
-  fprintf(stderr,"user: %s, title: %s\n",
-	  (user)?user:"(null)",(title)?title:"(null)");
-  fprintf(stderr,"fitplot: %s\n",
-	  (fitplot)?"true":"false");
-
-  page.dump();
-
-  fprintf(stderr,"Rotation(CCW): ");
-  Rotation_dump(orientation);
-  fprintf(stderr,"\n");
-
-  fprintf(stderr,"paper_is_landscape: %s\n",
-	  (paper_is_landscape)?"true":"false");
-
-  fprintf(stderr,"duplex: %s\n",
-	  (duplex)?"true":"false");
-
-  fprintf(stderr,"Border: ");
-  BorderType_dump(border);
-  fprintf(stderr,"\n");
-
-  nup.dump();
-
-  fprintf(stderr,"reverse: %s\n",
-	  (reverse)?"true":"false");
-
-  fprintf(stderr,"evenPages: %s, oddPages: %s\n",
-	  (evenPages)?"true":"false",
-	  (oddPages)?"true":"false");
-
-  fprintf(stderr,"page range: ");
-  pageRange.dump();
-
-  fprintf(stderr,"mirror: %s\n",
-	  (mirror)?"true":"false");
-
-  fprintf(stderr,"Position: ");
-  Position_dump(xpos,Axis::X);
-  fprintf(stderr,"/");
-  Position_dump(ypos,Axis::Y);
-  fprintf(stderr,"\n");
-
-  fprintf(stderr,"collate: %s\n",
-	  (collate)?"true":"false");
-
-  fprintf(stderr,"evenDuplex: %s\n",
-	  (evenDuplex)?"true":"false");
-
-  fprintf(stderr,"pageLabel: %s\n",
-	  pageLabel.empty () ? "(none)" : pageLabel.c_str());
-
-  fprintf(stderr,"bookletMode: ");
-  BookletMode_dump(booklet);
-  fprintf(stderr,"\nbooklet signature: %d\n",
-	  bookSignature);
-
-  fprintf(stderr,"autoRotate: %s\n",
-	  (autoRotate)?"true":"false");
-
-  fprintf(stderr,"emitJCL: %s\n",
-	  (emitJCL)?"true":"false");
-  fprintf(stderr,"deviceCopies: %d\n",
-	  deviceCopies);
-  fprintf(stderr,"deviceCollate: %s\n",
-	  (deviceCollate)?"true":"false");
-  fprintf(stderr,"setDuplex: %s\n",
-	  (setDuplex)?"true":"false");
-}
-// }}}
-
-
-PDFTOPDF_Processor *PDFTOPDF_Factory::processor()
-{
-  return new QPDF_PDFTOPDF_Processor();
-}
-
-// (1-based)
-//   9: [*] [1] [2] [*]  [*] [3] [4] [9]  [8] [5] [6] [7]   -> signature = 12 = 3*4 = ((9+3)/4)*4
-//       1   2   3   4    5   6   7   8    9   10  11  12
-// NOTE: psbook always fills the sig completely (results in completely white pages (4-set), depending on the input)
-
-// empty pages must be added for output values >=numPages
-std::vector<int> bookletShuffle(int numPages,int signature) // {{{
-{
-  if (signature<0) {
-    signature=(numPages+3)&~0x3;
-  }
-  assert(signature%4==0);
-
-  std::vector<int> ret;
-  ret.reserve(numPages+signature-1);
-
-  int curpage=0;
-  while (curpage<numPages) {
-    // as long as pages to be done -- i.e. multiple times the signature
-    int firstpage=curpage,
-      lastpage=curpage+signature-1;
-    // one signature
-    while (firstpage<lastpage) {
-      ret.push_back(lastpage--);
-      ret.push_back(firstpage++);
-      ret.push_back(firstpage++);
-      ret.push_back(lastpage--);
-    }
-    curpage+=signature;
-  }
-  return ret;
-}
-// }}}
-
-bool processPDFTOPDF(PDFTOPDF_Processor &proc,ProcessingParameters &param) // {{{
-{
-  if (!proc.check_print_permissions()) {
-    fprintf(stderr,"Not allowed to print\n");
-    return false;
-  }
-
-  if (param.autoRotate) {
-    const bool dst_lscape =
-      (param.paper_is_landscape ==
-       ((param.orientation == ROT_0) || (param.orientation == ROT_180)));
-    proc.autoRotateAll(dst_lscape,param.normal_landscape);
-  }
-
-  std::vector<std::shared_ptr<PDFTOPDF_PageHandle>> pages=proc.get_pages();
-  const int numOrigPages=pages.size();
-
-  // TODO FIXME? elsewhere
-  std::vector<int> shuffle;
-  if (param.booklet!=BOOKLET_OFF) {
-    shuffle=bookletShuffle(numOrigPages,param.bookSignature);
-    if (param.booklet==BOOKLET_ON) { // override options
-      // TODO? specifically "sides=two-sided-short-edge" / DuplexTumble
-      // param.duplex=true;
-      // param.setDuplex=true;  ?    currently done in setFinalPPD()
-      NupParameters::preset(2,param.nup); // TODO?! better
-    }
-  } else { // 0 1 2 3 ...
-    shuffle.resize(numOrigPages);
-    std::iota(shuffle.begin(),shuffle.end(),0);
-  }
-  const int numPages=std::max(shuffle.size(),pages.size());
-
-  if(param.autoprint||param.autofit){
-    bool margin_defined = true;
-    bool document_large = false;
-    int pw = param.page.right-param.page.left;
-    int ph = param.page.top-param.page.bottom;
-    int w=0,h=0;
-    Rotation tempRot=param.orientation;
-    PageRect r= pages[0]->getRect();
-    w = r.width;
-    h = r.height;
-
-    if(tempRot==ROT_90||tempRot==ROT_270)
-    {
-      std::swap(w,h);
-    }
-    if(w>=pw||h>=ph)
-    {
-      document_large = true;
-    }
-    if((param.page.width==pw)&&
-        (param.page.height==ph))
-        margin_defined = false;
-    if(param.autoprint){
-      if(param.fidelity||document_large) {
-        if(margin_defined)
-          param.fitplot = true;
-        else
-          param.fillprint = true;
-      }
-      else
-        param.cropfit = true;
-    }
-    else{
-      if(param.fidelity||document_large)
-        param.fitplot = true;
-      else
-        param.cropfit = true;
-    }
-  }
-
-  if(param.fillprint||param.cropfit){
-    fprintf(stderr,"[DEBUG]: Cropping input pdf and Enabling fitplot.\n");
-    if(param.noOrientation&&pages.size())
-    {
-      bool land = pages[0]->is_landscape(param.orientation);
-      if(land)
-        param.orientation = param.normal_landscape;
-    }
-    for(int i=0;i<(int)pages.size();i++)
-    {
-      std::shared_ptr<PDFTOPDF_PageHandle> page = pages[i];
-      page->crop(param.page,param.orientation,param.xpos,param.ypos,!param.cropfit);
-    }
-    param.fitplot = 1;
-  }
-
-  std::shared_ptr<PDFTOPDF_PageHandle> curpage;
-  int outputpage=0;
-  int outputno=0;
-
-  if ((param.nup.nupX==1)&&(param.nup.nupY==1)&&(!param.fitplot)) {
-    // TODO? fitplot also without xobject?
-    /*
-      param.nup.width=param.page.width;
-      param.nup.height=param.page.height;
-    */
-
-    for (int iA=0;iA<numPages;iA++) {
-      if (!param.withPage(iA+1)) {
-        continue;
-      }
-
-      // Log page in /var/log/cups/page_log
-      if (param.page_logging == 1)
-	fprintf(stderr, "PAGE: %d %d\n", iA + 1, param.copies_to_be_logged);
-
-      if (shuffle[iA]>=numOrigPages) {
-        // add empty page as filler
-        proc.add_page(proc.new_page(param.page.width,param.page.height),param.reverse);
-	outputno++;
-        continue; // no border, etc.
-      }
-      auto page=pages[shuffle[iA]];
-
-      page->rotate(param.orientation);
-
-      if (param.mirror) {
-        page->mirror();
-      }
-
-      if (!param.pageLabel.empty()) {
-        page->add_label(param.page, param.pageLabel);
-      }
-
-      // place border
-      if ((param.border!=BorderType::NONE)&&(iA<numOrigPages)) {
-#if 0 // would be nice, but is not possible
-        PageRect rect=page->getRect();
-
-        rect.left+=param.page.left;
-        rect.bottom+=param.page.bottom;
-        rect.top-=param.page.top;
-        rect.right-=param.page.right;
-        // width,height not needed for add_border_rect (FIXME?)
-
-        page->add_border_rect(rect,param.border,1.0);
-#else // this is what pstops does
-        page->add_border_rect(param.page,param.border,1.0);
-#endif
-      }
-
-      proc.add_page(page,param.reverse); // reverse -> insert at beginning
-      outputno++;
-    }
-  } else {
-    param.nup.width=param.page.right-param.page.left;
-    param.nup.height=param.page.top-param.page.bottom;
-
-    double xpos=param.page.left,
-      ypos=param.page.bottom; // for whole page... TODO from position...
-
-    const bool origls=param.nup.landscape;
-    if ((param.orientation==ROT_90)||(param.orientation==ROT_270)) {
-      std::swap(param.nup.nupX,param.nup.nupY);
-      param.nup.landscape=!param.nup.landscape;
-      param.orientation=param.orientation-param.normal_landscape;
-    }
-    if (param.nup.landscape) {
-      // pages[iA]->rotate(param.normal_landscape);
-      param.orientation=param.orientation+param.normal_landscape;
-      // TODO? better
-      xpos=param.page.bottom;
-      ypos=param.page.width - param.page.right;
-      std::swap(param.page.width,param.page.height);
-      std::swap(param.nup.width,param.nup.height);
-    }
-
-    NupState nupstate(param.nup);
-    NupPageEdit pgedit;
-    for (int iA=0;iA<numPages;iA++) {
-      std::shared_ptr<PDFTOPDF_PageHandle> page;
-      if (shuffle[iA]>=numOrigPages) {
-        // add empty page as filler
-        page=proc.new_page(param.page.width,param.page.height);
-      } else {
-        page=pages[shuffle[iA]];
-      }
-
-      PageRect rect;
-      if (param.fitplot) {
-        rect=page->getRect();
-      } else {
-        rect.width=param.page.width;
-        rect.height=param.page.height;
-
-	// TODO? better
-        if (origls) {
-          std::swap(rect.width,rect.height);
-        }
-
-        rect.left=0;
-        rect.bottom=0;
-        rect.right=rect.width;
-        rect.top=rect.height;
-      }
-      // rect.dump();
-
-      bool newPage=nupstate.nextPage(rect.width,rect.height,pgedit);
-      if (newPage) {
-        if ((curpage)&&(param.withPage(outputpage))) {
-          curpage->rotate(param.orientation);
-          if (param.mirror) {
-            curpage->mirror();
-	    // TODO? update rect? --- not needed any more
-          }
-          proc.add_page(curpage,param.reverse); // reverse -> insert at beginning
-	  // Log page in /var/log/cups/page_log
-	  outputno++;
-	  if (param.page_logging == 1)
-	    fprintf(stderr, "PAGE: %d %d\n", outputno,
-		    param.copies_to_be_logged);
-        }
-        curpage=proc.new_page(param.page.width,param.page.height);
-        outputpage++;
-      }
-      if (shuffle[iA]>=numOrigPages) {
-        continue;
-      }
-
-      if (param.border!=BorderType::NONE) {
-        // TODO FIXME... border gets cutted away, if orignal page had wrong size
-        // page->"uncrop"(rect);  // page->setMedia()
-        // Note: currently "fixed" in add_subpage(...&rect);
-        page->add_border_rect(rect,param.border,1.0/pgedit.scale);
-      }
-
-      if (!param.pageLabel.empty()) {
-        page->add_label(param.page, param.pageLabel);
-      }
-
-      if (!param.fitplot) {
-        curpage->add_subpage(page,pgedit.xpos+xpos,pgedit.ypos+ypos,pgedit.scale,&rect);
-      } else {
-        if(param.cropfit){
-          double xpos2 = (param.page.right-param.page.left-(page->getRect().width))/2;
-          double ypos2 = (param.page.top-param.page.bottom-(page->getRect().height))/2;
-          if(param.orientation==ROT_270||param.orientation==ROT_90)
-          {
-            xpos2 = (param.page.right-param.page.left-(page->getRect().height))/2;
-            ypos2 = (param.page.top-param.page.bottom-(page->getRect().width))/2;
-            curpage->add_subpage(page,ypos2+param.page.bottom,xpos2+param.page.left,1);
-          }else{
-          curpage->add_subpage(page,xpos2+param.page.left,ypos2+param.page.bottom,1);
-          }
-        }
-        else
-          curpage->add_subpage(page,pgedit.xpos+xpos,pgedit.ypos+ypos,pgedit.scale);
-      }
-
-#ifdef DEBUG
-      if (auto dbg=dynamic_cast<QPDF_PDFTOPDF_PageHandle *>(curpage.get())) {
-	// dbg->debug(pgedit.sub,xpos,ypos);
-      }
-#endif
-
-      // pgedit.dump();
-    }
-    if ((curpage)&&(param.withPage(outputpage))) {
-      curpage->rotate(param.orientation);
-      if (param.mirror) {
-        curpage->mirror();
-      }
-      proc.add_page(curpage,param.reverse); // reverse -> insert at beginning
-      // Log page in /var/log/cups/page_log
-      outputno ++;
-      if (param.page_logging == 1)
-	fprintf(stderr, "PAGE: %d %d\n", outputno, param.copies_to_be_logged);
-    }
-  }
-
-  if ((param.evenDuplex || !param.oddPages) && (outputno & 1)) {
-    // need to output empty page to not confuse duplex
-    proc.add_page(proc.new_page(param.page.width,param.page.height),param.reverse);
-    // Log page in /var/log/cups/page_log
-    if (param.page_logging == 1)
-      fprintf(stderr, "PAGE: %d %d\n", outputno + 1, param.copies_to_be_logged);
-  }
-
-  proc.multiply(param.numCopies,param.collate);
-
-  return true;
-}
-// }}}
diff --git a/filter/pdftopdf/pdftopdf_processor.h b/filter/pdftopdf/pdftopdf_processor.h
deleted file mode 100644
index ec7b299..0000000
--- a/filter/pdftopdf/pdftopdf_processor.h
+++ /dev/null
@@ -1,174 +0,0 @@
-#ifndef PDFTOPDF_PROCESSOR_H
-#define PDFTOPDF_PROCESSOR_H
-
-#include "pptypes.h"
-#include "nup.h"
-#include "intervalset.h"
-#include <vector>
-#include <string>
-
-enum BookletMode { BOOKLET_OFF, BOOKLET_ON, BOOKLET_JUSTSHUFFLE };
-
-struct ProcessingParameters {
-ProcessingParameters()
-: jobId(0),numCopies(1),
-    user(0),title(0),
-    fitplot(false),
-    fillprint(false),  //print-scaling = fill
-    cropfit(false),
-    autoprint(false),
-    autofit(false),
-    fidelity(false),
-    noOrientation(false),
-    orientation(ROT_0),normal_landscape(ROT_270),
-    paper_is_landscape(false),
-    duplex(false),
-    border(NONE),
-    reverse(false),
-
-    pageLabel(),
-    evenPages(true),oddPages(true),
-
-    mirror(false),
-
-    xpos(CENTER),ypos(CENTER),
-
-    collate(false),
-    evenDuplex(false),
-
-    booklet(BOOKLET_OFF),bookSignature(-1),
-
-    autoRotate(false),
-
-    emitJCL(true),deviceCopies(1),
-    deviceCollate(false),setDuplex(false),
-
-    page_logging(-1)
-  {
-    page.width=612.0; // letter
-    page.height=792.0;
-    page.top=page.height-36.0;
-    page.bottom=36.0;
-    page.left=18.0;
-    page.right=page.width-18.0;
-
-    // everything
-    pageRange.add(1);
-    pageRange.finish();
-  }
-
-  int jobId, numCopies;
-  const char *user, *title; // will stay around
-  bool fitplot;
-  bool fillprint;   //print-scaling = fill
-  bool cropfit;     // -o crop-to-fit
-  bool autoprint;   // print-scaling = auto
-  bool autofit;     // print-scaling = auto-fit
-  bool fidelity;
-  bool noOrientation;
-  PageRect page;
-  Rotation orientation,normal_landscape;  // normal_landscape (i.e. default direction) is e.g. needed for number-up=2
-  bool paper_is_landscape;
-  bool duplex;
-  BorderType border;
-  NupParameters nup;
-  bool reverse;
-
-  std::string pageLabel;
-  bool evenPages,oddPages;
-  IntervalSet pageRange;
-
-  bool mirror;
-
-  Position xpos,ypos;
-
-  bool collate;
-
-  bool evenDuplex; // make number of pages a multiple of 2
-
-  BookletMode booklet;
-  int bookSignature;
-
-  bool autoRotate;
-
-  // ppd/jcl changes
-  bool emitJCL;
-  int deviceCopies;
-  bool deviceCollate;
-  bool setDuplex;
-  // unsetMirror  (always)
-
-  int page_logging;
-  int copies_to_be_logged;
-
-  // helper functions
-  bool withPage(int outno) const; // 1 based
-  void dump() const;
-};
-
-#include <stdio.h>
-#include <memory>
-
-enum ArgOwnership { WillStayAlive,MustDuplicate,TakeOwnership };
-
-class PDFTOPDF_PageHandle {
- public:
-  virtual ~PDFTOPDF_PageHandle() {}
-  virtual PageRect getRect() const =0;
-  // fscale:  inverse_scale (from nup, fitplot)
-  virtual void add_border_rect(const PageRect &rect,BorderType border,float fscale) =0;
-  // TODO?! add standalone crop(...) method (not only for subpages)
-  virtual Rotation crop(const PageRect &cropRect,Rotation orientation,Position xpos,Position ypos,bool scale) =0;
-  virtual bool is_landscape(Rotation orientation) =0 ;
-  virtual void add_subpage(const std::shared_ptr<PDFTOPDF_PageHandle> &sub,float xpos,float ypos,float scale,const PageRect *crop=NULL) =0;
-  virtual void mirror() =0;
-  virtual void rotate(Rotation rot) =0;
-  virtual void add_label(const PageRect &rect, const std::string label) =0;
-};
-
-// TODO: ... error output?
-class PDFTOPDF_Processor { // abstract interface
- public:
-  virtual ~PDFTOPDF_Processor() {}
-
-  // TODO: ... qpdf wants password at load time
-  virtual bool loadFile(FILE *f,ArgOwnership take=WillStayAlive,int flatten_forms=1) =0;
-  virtual bool loadFilename(const char *name,int flatten_forms=1) =0;
-
-  // TODO? virtual bool may_modify/may_print/?
-  virtual bool check_print_permissions() =0;
-
-  virtual std::vector<std::shared_ptr<PDFTOPDF_PageHandle>> get_pages() =0; // shared_ptr because of type erasure (deleter)
-
-  virtual std::shared_ptr<PDFTOPDF_PageHandle> new_page(float width,float height) =0;
-
-  virtual void add_page(std::shared_ptr<PDFTOPDF_PageHandle> page,bool front) =0; // at back/front -- either from get_pages() or new_page()+add_subpage()-calls  (or [also allowed]: empty)
-
-  //  void remove_page(std::shared_ptr<PDFTOPDF_PageHandle> ph);  // not needed: we construct from scratch, at least conceptually.
-
-  virtual void multiply(int copies,bool collate) =0;
-
-  virtual void autoRotateAll(bool dst_lscape,Rotation normal_landscape) =0; // TODO elsewhere?!
-  virtual void addCM(const char *defaulticc,const char *outputicc) =0;
-
-  virtual void setComments(const std::vector<std::string> &comments) =0;
-
-  virtual void emitFile(FILE *dst,ArgOwnership take=WillStayAlive) =0;
-  virtual void emitFilename(const char *name) =0; // NULL -> stdout
-
-  virtual bool hasAcroForm() =0;
-};
-
-class PDFTOPDF_Factory {
- public:
-  // never NULL, but may throw.
-  static PDFTOPDF_Processor *processor();
-};
-
-//bool checkBookletSignature(int signature) { return (signature%4==0); }
-std::vector<int> bookletShuffle(int numPages,int signature=-1);
-
-// This is all we want:
-bool processPDFTOPDF(PDFTOPDF_Processor &proc,ProcessingParameters &param);
-
-#endif
diff --git a/filter/pdftopdf/pptypes.cc b/filter/pdftopdf/pptypes.cc
deleted file mode 100644
index 5421766..0000000
--- a/filter/pdftopdf/pptypes.cc
+++ /dev/null
@@ -1,177 +0,0 @@
-#include "pptypes.h"
-#include <utility>
-#include <stdio.h>
-#include <assert.h>
-
-void Position_dump(Position pos) // {{{
-{
-  static const char *pstr[3]={"Left/Bottom","Center","Right/Top"};
-  if ((pos < LEFT) || (pos > RIGHT)) {
-    fprintf(stderr,"(bad position: %d)",pos);
-  } else {
-    fputs(pstr[pos+1],stderr);
-  }
-}
-// }}}
-
-void Position_dump(Position pos,Axis axis) // {{{
-{
-  assert((axis == Axis::X) || (axis == Axis::Y));
-  if ((pos < LEFT) || (pos > RIGHT)) {
-    fprintf(stderr,"(bad position: %d)",pos);
-    return;
-  }
-  if (axis==Axis::X) {
-    static const char *pxstr[3]={"Left","Center","Right"};
-    fputs(pxstr[pos+1],stderr);
-  } else {
-    static const char *pystr[3]={"Bottom","Center","Top"};
-    fputs(pystr[pos+1],stderr);
-  }
-}
-// }}}
-
-void Rotation_dump(Rotation rot) // {{{
-{
-  static const char *rstr[4]={"0 deg","90 deg","180 deg","270 deg"}; // CCW
-  if ((rot < ROT_0) || (rot > ROT_270)) {
-    fprintf(stderr,"(bad rotation: %d)",rot);
-  } else {
-    fputs(rstr[rot],stderr);
-  }
-}
-// }}}
-
-Rotation operator+(Rotation lhs,Rotation rhs) // {{{
-{
-  return (Rotation)(((int)lhs+(int)rhs)%4);
-}
-// }}}
-
-Rotation operator-(Rotation lhs,Rotation rhs) // {{{
-{
-  return (Rotation)((((int)lhs-(int)rhs)%4+4)%4);
-}
-// }}}
-
-Rotation operator-(Rotation rhs) // {{{
-{
-  return (Rotation)((4-(int)rhs)%4);
-}
-// }}}
-
-void BorderType_dump(BorderType border) // {{{
-{
-  if ((border < NONE) || (border == 1) || (border > TWO_THICK)) {
-    fprintf(stderr,"(bad border: %d)",border);
-  } else {
-    static const char *bstr[6]={"None",NULL,"one thin","one thick","two thin","two thick"};
-    fputs(bstr[border],stderr);
-  }
-}
-// }}}
-
-void PageRect::rotate_move(Rotation r,float pwidth,float pheight) // {{{
-{
-#if 1
-  if (r>=ROT_180) {
-    std::swap(top,bottom);
-    std::swap(left,right);
-  }
-  if ((r == ROT_90) || (r == ROT_270)) {
-    const float tmp=bottom;
-    bottom=left;
-    left=top;
-    top=right;
-    right=tmp;
-
-    std::swap(width,height);
-    std::swap(pwidth,pheight);
-  }
-  if ((r == ROT_90) || (r == ROT_180)) {
-    left=pwidth-left;
-    right=pwidth-right;
-  }
-  if ((r == ROT_270) || (r == ROT_180)) {
-    top=pheight-top;
-    bottom=pheight-bottom;
-  }
-#else
-  switch (r) {
-  case ROT_0: // no-op
-    break;
-  case ROT_90:
-    const float tmp0=bottom;
-    bottom=left;
-    left=pheight-top;
-    top=right;
-    right=pheight-tmp0;
-
-    std::swap(width,height);
-    break;
-  case ROT_180:
-    const float tmp1=left;
-    left=pwidth-right;
-    right=pwidth-tmp1;
-
-    const float tmp2=top;
-    top=pheight-bottom;
-    bottom=pheight-tmp2;
-    break;
-  case ROT_270:
-    const float tmp3=top;
-    top=pwidth-left;
-    left=bottom;
-    bottom=pwidth-right;
-    right=tmp3;
-
-    std::swap(width,height);
-    break;
-  }
-#endif
-}
-// }}}
-
-void PageRect::scale(float mult) // {{{
-{
-  if (mult==1.0) {
-    return;
-  }
-  assert(mult!=0.0);
-
-  bottom*=mult;
-  left*=mult;
-  top*=mult;
-  right*=mult;
-
-  width*=mult;
-  height*=mult;
-}
-// }}}
-
-void PageRect::translate(float tx,float ty) // {{{
-{
-  left+=tx;
-  bottom+=ty;
-  right+=tx;
-  top+=ty;
-}
-// }}}
-
-void PageRect::set(const PageRect &rhs) // {{{
-{
-  if (!std::isnan(rhs.top)) top=rhs.top;
-  if (!std::isnan(rhs.left)) left=rhs.left;
-  if (!std::isnan(rhs.right)) right=rhs.right;
-  if (!std::isnan(rhs.bottom)) bottom=rhs.bottom;
-}
-// }}}
-
-void PageRect::dump() const // {{{
-{
-  fprintf(stderr,"top: %f, left: %f, right: %f, bottom: %f\n"
-	  "width: %f, height: %f\n",
-	  top,left,right,bottom,
-	  width,height);
-}
-// }}}
diff --git a/filter/pdftopdf/pptypes.h b/filter/pdftopdf/pptypes.h
deleted file mode 100644
index 4f4df6d..0000000
--- a/filter/pdftopdf/pptypes.h
+++ /dev/null
@@ -1,39 +0,0 @@
-#ifndef PPTYPES_H_
-#define PPTYPES_H_
-
-#include <cmath> // NAN
-
-// namespace PPTypes {}   TODO?
-
-enum Axis { X, Y };
-enum Position { CENTER=0, LEFT=-1, RIGHT=1, TOP=1, BOTTOM=-1 }; // PS order
-void Position_dump(Position pos);
-void Position_dump(Position pos,Axis axis);
-
-enum Rotation { ROT_0, ROT_90, ROT_180, ROT_270 };  // CCW
-void Rotation_dump(Rotation rot);
-Rotation operator+(Rotation lhs,Rotation rhs);
-Rotation operator-(Rotation lhs,Rotation rhs);
-Rotation operator-(Rotation rhs);
-//Rotation operator+=(Rotation &lhs,Rotation rhs);
-
-enum BorderType { NONE=0, ONE_THIN=2, ONE_THICK=3, TWO_THIN=4, TWO_THICK=5,
-                  ONE=0x02, TWO=0x04, THICK=0x01};
-void BorderType_dump(BorderType border);
-
-struct PageRect {
-PageRect() : top(NAN),left(NAN),right(NAN),bottom(NAN),width(NAN),height(NAN) {}
-  float top,left,right,bottom; // i.e. margins
-  float width,height;
-
-  void rotate_move(Rotation r,float pwidth,float pheight); // pwidth original "page size" (i.e. before rotation)
-  void scale(float mult);
-  void translate(float tx,float ty);
-
-  void set(const PageRect &rhs); // only for rhs.* != NAN
-  void dump() const;
-};
-
-//  bool parseBorder(const char *val,BorderType &ret); // none,single,...,double-thick
-
-#endif
diff --git a/filter/pdftopdf/qpdf_cm.cc b/filter/pdftopdf/qpdf_cm.cc
deleted file mode 100644
index f5ee6ab..0000000
--- a/filter/pdftopdf/qpdf_cm.cc
+++ /dev/null
@@ -1,151 +0,0 @@
-#include "qpdf_cm.h"
-#include <stdio.h>
-#include <assert.h>
-
-#include <stdexcept>
-
-// TODO? instead use qpdf's StreamDataProvider, FileInputSource, Buffer etc.
-static std::string load_file(const char *filename) // {{{
-{
-  if (!filename) {
-    throw std::invalid_argument("NULL filename not allowed");
-  }
-
-  FILE *f=fopen(filename,"r");
-  if (!f) {
-    throw std::runtime_error(std::string("file ") + filename + " could not be opened");
-  }
-
-  const int bsize=2048;
-  int pos=0;
-
-  std::string ret;
-  while (!feof(f)) {
-    ret.resize(pos+bsize);
-    int res=fread(&ret[pos],1,bsize,f);
-    pos+=res;
-    if (res<bsize) {
-      ret.resize(pos);
-      break;
-    }
-  }
-
-  fclose(f);
-  return ret;
-}
-// }}}
-
-
-// TODO?
-// TODO? test
-bool hasOutputIntent(QPDF &pdf) // {{{
-{
-  auto catalog=pdf.getRoot();
-  if (!catalog.hasKey("/OutputIntents")) {
-    return false;
-  }
-  return true; // TODO?
-}
-// }}}
-
-// TODO: test
-// TODO? find existing , replace and return  (?)
-void addOutputIntent(QPDF &pdf,const char *filename) // {{{
-{
-  std::string icc=load_file(filename);
-  // TODO: check icc  fitness
-  // ICC data, subject to "version limitations" per pdf version...
-
-  QPDFObjectHandle outicc=QPDFObjectHandle::newStream(&pdf,icc);
-
-  auto sdict=outicc.getDict();
-  sdict.replaceKey("/N",QPDFObjectHandle::newInteger(4)); // must match ICC
-  // /Range ?  // must match ICC, default [0.0 1.0 ...]
-  // /Alternate ?  (/DeviceCMYK for N=4)
-
-  auto intent=QPDFObjectHandle::parse(
-    "<<"
-    "  /Type /OutputIntent"       // Must be so (the standard requires).
-    "  /S /GTS_PDFX"              // Must be so (the standard requires).
-    "  /OutputCondition (Commercial and specialty printing)"  // TODO: Customize [optional(?)]
-    "  /Info (none)"              // TODO: Customize
-    "  /OutputConditionIdentifier (CGATS TR001)"  // TODO: FIXME: Customize
-    "  /RegistryName (http://www.color.org)"      // Must be so (the standard requires).
-    "  /DestOutputProfile null "
-    ">>");
-  intent.replaceKey("/DestOutputProfile",outicc);
-
-  auto catalog=pdf.getRoot();
-  if (!catalog.hasKey("/OutputIntents")) {
-    catalog.replaceKey("/OutputIntents",QPDFObjectHandle::newArray());
-  }
-  catalog.getKey("/OutputIntents").appendItem(intent);
-}
-// }}}
-
-
-/* for color management:
-   Use /DefaultGray, /DefaultRGB, /DefaultCMYK ...  from *current* resource dictionary ...
-   i.e. set 
-   /Resources <<
-   /ColorSpace <<    --- can use just one indirect ref for this (probably)
-   /DefaultRGB [/ICCBased 5 0 R]   ... sensible use is sRGB  for DefaultRGB, etc.
-   >>
-   >>
-   for every page  (what with form /XObjects?)  and most importantly RGB (leave CMYK, Gray for now, as this is already printer native(?))
-
-   ? also every  form XObject, pattern, type3 font, annotation appearance stream(=form xobject +X)
-
-   ? what if page already defines /Default?   -- probably keep!
-
-   ? maybe we need to set /ColorSpace  in /Images ?    [gs idea is to just add the /Default-key and then reprocess...]
-   
-*/
-
-// TODO? test
-void addDefaultRGB(QPDF &pdf,QPDFObjectHandle srcicc) // {{{
-{
-  srcicc.assertStream();
-
-  auto pages=pdf.getAllPages();
-  for (auto it=pages.begin(),end=pages.end();it!=end;++it) {
-    if (!it->hasKey("/Resources")) {
-      it->replaceKey("/Resources",QPDFObjectHandle::newDictionary());
-    }
-    auto rdict=it->getKey("/Resources");
-
-    if (!rdict.hasKey("/ColorSpace")) {
-      rdict.replaceKey("/ColorSpace",QPDFObjectHandle::newDictionary());
-    }
-    auto cdict=rdict.getKey("/ColorSpace");
-
-    if (!cdict.hasKey("/DefaultRGB")) {
-      cdict.replaceKey("/DefaultRGB",QPDFObjectHandle::parse("[/ICCBased ]"));
-      cdict.getKey("/DefaultRGB").appendItem(srcicc);
-    }
-  }
-}
-// }}}
-
-// TODO? test
-// TODO: find existing , replace and return  (?)
-// TODO: check icc  fitness
-QPDFObjectHandle setDefaultICC(QPDF &pdf,const char *filename) // {{{
-{
-  // TODO: find existing , replace and return  (?)
-
-  std::string icc=load_file(filename);
-  // TODO: check icc  fitness
-  // ICC data, subject to "version limitations" per pdf version...
-
-  QPDFObjectHandle ret=QPDFObjectHandle::newStream(&pdf,icc);
-
-  auto sdict=ret.getDict();
-  sdict.replaceKey("/N",QPDFObjectHandle::newInteger(3)); // must match ICC
-  // /Range ?  // must match ICC, default [0.0 1.0 ...]
-  // /Alternate ?  (/DeviceRGB for N=3)
-
-  return ret;
-}
-// }}}
-
diff --git a/filter/pdftopdf/qpdf_cm.h b/filter/pdftopdf/qpdf_cm.h
deleted file mode 100644
index 5eb2759..0000000
--- a/filter/pdftopdf/qpdf_cm.h
+++ /dev/null
@@ -1,12 +0,0 @@
-#ifndef QPDF_CM_H_
-#define QPDF_CM_H_
-
-#include <qpdf/QPDF.hh>
-
-bool hasOutputIntent(QPDF &pdf);
-void addOutputIntent(QPDF &pdf,const char *filename);
-
-void addDefaultRGB(QPDF &pdf,QPDFObjectHandle srcicc);
-QPDFObjectHandle setDefaultICC(QPDF &pdf,const char *filename);
-
-#endif
diff --git a/filter/pdftopdf/qpdf_pdftopdf.cc b/filter/pdftopdf/qpdf_pdftopdf.cc
deleted file mode 100644
index 68cd8ef..0000000
--- a/filter/pdftopdf/qpdf_pdftopdf.cc
+++ /dev/null
@@ -1,225 +0,0 @@
-#include "qpdf_pdftopdf.h"
-#include <assert.h>
-#include <stdexcept>
-#include <qpdf/QUtil.hh>
-
-PageRect getBoxAsRect(QPDFObjectHandle box) // {{{
-{
-  PageRect ret;
-
-  ret.left=box.getArrayItem(0).getNumericValue();
-  ret.bottom=box.getArrayItem(1).getNumericValue();
-  ret.right=box.getArrayItem(2).getNumericValue();
-  ret.top=box.getArrayItem(3).getNumericValue();
-
-  ret.width=ret.right-ret.left;
-  ret.height=ret.top-ret.bottom;
-
-  return ret;
-}
-// }}}
-
-Rotation getRotate(QPDFObjectHandle page) // {{{
-{
-  if (!page.hasKey("/Rotate")) {
-    return ROT_0;
-  }
-  double rot=page.getKey("/Rotate").getNumericValue();
-  rot=fmod(rot,360.0);
-  if (rot<0) {
-    rot+=360.0;
-  }
-  if (rot==90.0) { // CW 
-    return ROT_270; // CCW
-  } else if (rot==180.0) {
-    return ROT_180;
-  } else if (rot==270.0) {
-    return ROT_90;
-  } else if (rot!=0.0) {
-    throw std::runtime_error("Unexpected /Rotation value: "+QUtil::double_to_string(rot));
-  }
-  return ROT_0;
-}
-// }}}
-
-double getUserUnit(QPDFObjectHandle page) // {{{
-{
-  if (!page.hasKey("/UserUnit")) {
-    return 1.0;
-  }
-  return page.getKey("/UserUnit").getNumericValue();
-}
-// }}}
-
-QPDFObjectHandle makeRotate(Rotation rot) // {{{
-{
-  switch (rot) {
-  case ROT_0:
-    return QPDFObjectHandle::newNull();
-  case ROT_90: // CCW
-    return QPDFObjectHandle::newInteger(270); // CW
-  case ROT_180:
-    return QPDFObjectHandle::newInteger(180);
-  case ROT_270:
-    return QPDFObjectHandle::newInteger(90);
-  default:
-    throw std::invalid_argument("Bad rotation");
-  }
-}
-// }}}
-
-#include "qpdf_tools.h"
-
-QPDFObjectHandle getRectAsBox(const PageRect &rect) // {{{
-{
-  return makeBox(rect.left,rect.bottom,rect.right,rect.top);
-}
-// }}}
-
-#include <qpdf/QUtil.hh>
-
-Matrix::Matrix() // {{{
-  : ctm{1,0,0,1,0,0}
-{
-}
-// }}}
-
-Matrix::Matrix(QPDFObjectHandle ar) // {{{
-{
-  if (ar.getArrayNItems()!=6) {
-    throw std::runtime_error("Not a ctm matrix");
-  }
-  for (int iA=0;iA<6;iA++) {
-    ctm[iA]=ar.getArrayItem(iA).getNumericValue();
-  }
-}
-// }}}
-
-Matrix &Matrix::rotate(Rotation rot) // {{{
-{
-  switch (rot) {
-  case ROT_0:
-    break;
-  case ROT_90:
-    std::swap(ctm[0],ctm[2]);
-    std::swap(ctm[1],ctm[3]);
-    ctm[2]=-ctm[2];
-    ctm[3]=-ctm[3];
-    break;
-  case ROT_180:
-    ctm[0]=-ctm[0];
-    ctm[3]=-ctm[3];
-    break;
-  case ROT_270:
-    std::swap(ctm[0],ctm[2]);
-    std::swap(ctm[1],ctm[3]);
-    ctm[0]=-ctm[0];
-    ctm[1]=-ctm[1];
-    break;
-  default:
-    assert(0);
-  }
-  return *this;
-}
-// }}}
-
-// TODO: test
-Matrix &Matrix::rotate_move(Rotation rot,double width,double height) // {{{
-{
-  rotate(rot);
-  switch (rot) {
-  case ROT_0:
-    break;
-  case ROT_90:
-    translate(width,0);
-    break;
-  case ROT_180:
-    translate(width,height);
-    break;
-  case ROT_270:
-    translate(0,height);
-    break;
-  }
-  return *this;
-}
-// }}}
-
-Matrix &Matrix::rotate(double rad) // {{{
-{
-  Matrix tmp;
-
-  tmp.ctm[0]=cos(rad);
-  tmp.ctm[1]=sin(rad);
-  tmp.ctm[2]=-sin(rad);
-  tmp.ctm[3]=cos(rad);
-
-  return (*this*=tmp);
-}
-// }}}
-
-Matrix &Matrix::translate(double tx,double ty) // {{{
-{
-  ctm[4]+=ctm[0]*tx+ctm[2]*ty;
-  ctm[5]+=ctm[1]*tx+ctm[3]*ty;
-  return *this;
-}
-// }}}
-
-Matrix &Matrix::scale(double sx,double sy) // {{{
-{
-  ctm[0]*=sx;
-  ctm[1]*=sx;
-  ctm[2]*=sy;
-  ctm[3]*=sy;
-  return *this;
-}
-// }}}
-
-Matrix &Matrix::operator*=(const Matrix &rhs) // {{{
-{
-  double tmp[6];
-  std::copy(ctm,ctm+6,tmp);
-
-  ctm[0] = tmp[0]*rhs.ctm[0] + tmp[2]*rhs.ctm[1];
-  ctm[1] = tmp[1]*rhs.ctm[0] + tmp[3]*rhs.ctm[1];
-
-  ctm[2] = tmp[0]*rhs.ctm[2] + tmp[2]*rhs.ctm[3];
-  ctm[3] = tmp[1]*rhs.ctm[2] + tmp[3]*rhs.ctm[3];
-
-  ctm[4] = tmp[0]*rhs.ctm[4] + tmp[2]*rhs.ctm[5] + tmp[4];
-  ctm[5] = tmp[1]*rhs.ctm[4] + tmp[3]*rhs.ctm[5] + tmp[5];
-
-  return *this;
-}
-// }}}
-
-QPDFObjectHandle Matrix::get() const // {{{
-{
-  QPDFObjectHandle ret=QPDFObjectHandle::newArray();
-  ret.appendItem(QPDFObjectHandle::newReal(ctm[0]));
-  ret.appendItem(QPDFObjectHandle::newReal(ctm[1]));
-  ret.appendItem(QPDFObjectHandle::newReal(ctm[2]));
-  ret.appendItem(QPDFObjectHandle::newReal(ctm[3]));
-  ret.appendItem(QPDFObjectHandle::newReal(ctm[4]));
-  ret.appendItem(QPDFObjectHandle::newReal(ctm[5]));
-  return ret;
-}
-// }}}
-
-std::string Matrix::get_string() const // {{{
-{
-  std::string ret;
-  ret.append(QUtil::double_to_string(ctm[0]));
-  ret.append(" ");
-  ret.append(QUtil::double_to_string(ctm[1]));
-  ret.append(" ");
-  ret.append(QUtil::double_to_string(ctm[2]));
-  ret.append(" ");
-  ret.append(QUtil::double_to_string(ctm[3]));
-  ret.append(" ");
-  ret.append(QUtil::double_to_string(ctm[4]));
-  ret.append(" ");
-  ret.append(QUtil::double_to_string(ctm[5]));
-  return ret;
-}
-// }}}
diff --git a/filter/pdftopdf/qpdf_pdftopdf.h b/filter/pdftopdf/qpdf_pdftopdf.h
deleted file mode 100644
index 9cb1536..0000000
--- a/filter/pdftopdf/qpdf_pdftopdf.h
+++ /dev/null
@@ -1,41 +0,0 @@
-#ifndef QPDF_PDFTOPDF_H
-#define QPDF_PDFTOPDF_H
-
-#include <qpdf/QPDFObjectHandle.hh>
-#include "pptypes.h"
-
-// helper functions
-
-PageRect getBoxAsRect(QPDFObjectHandle box);
-QPDFObjectHandle getRectAsBox(const PageRect &rect);
-
-// Note that PDF specification is CW, but our Rotation is CCW
-Rotation getRotate(QPDFObjectHandle page);
-QPDFObjectHandle makeRotate(Rotation rot); // Integer
-
-double getUserUnit(QPDFObjectHandle page);
-
-// PDF CTM
-class Matrix {
- public:
-  Matrix(); // identity
-  Matrix(QPDFObjectHandle ar);
-  
-  Matrix &rotate(Rotation rot);
-  Matrix &rotate_move(Rotation rot,double width,double height);
-  Matrix &rotate(double rad);
-  //  Matrix &rotate_deg(double deg);
-
-  Matrix &translate(double tx,double ty);
-  Matrix &scale(double sx,double sy);
-  Matrix &scale(double s) { return scale(s,s); }
-
-  Matrix &operator*=(const Matrix &rhs);
-
-  QPDFObjectHandle get() const;
-  std::string get_string() const;
- private:
-  double ctm[6];
-};
-
-#endif
diff --git a/filter/pdftopdf/qpdf_pdftopdf_processor.cc b/filter/pdftopdf/qpdf_pdftopdf_processor.cc
deleted file mode 100644
index d06ca5f..0000000
--- a/filter/pdftopdf/qpdf_pdftopdf_processor.cc
+++ /dev/null
@@ -1,763 +0,0 @@
-#include "qpdf_pdftopdf_processor.h"
-#include <stdio.h>
-#include <stdarg.h>
-#include <assert.h>
-#include <stdexcept>
-#include <qpdf/QPDFWriter.hh>
-#include <qpdf/QUtil.hh>
-#include <qpdf/QPDFPageDocumentHelper.hh>
-#include <qpdf/QPDFAcroFormDocumentHelper.hh>
-#include "qpdf_tools.h"
-#include "qpdf_xobject.h"
-#include "qpdf_pdftopdf.h"
-
-// Use: content.append(debug_box(pe.sub,xpos,ypos));
-static std::string debug_box(const PageRect &box,float xshift,float yshift) // {{{
-{
-  return std::string("q 1 w 0.1 G\n ")+
-    QUtil::double_to_string(box.left+xshift)+" "+QUtil::double_to_string(box.bottom+yshift)+" m  "+
-    QUtil::double_to_string(box.right+xshift)+" "+QUtil::double_to_string(box.top+yshift)+" l "+"S \n "+
-
-    QUtil::double_to_string(box.right+xshift)+" "+QUtil::double_to_string(box.bottom+yshift)+" m  "+
-    QUtil::double_to_string(box.left+xshift)+" "+QUtil::double_to_string(box.top+yshift)+" l "+"S \n "+
-
-    QUtil::double_to_string(box.left+xshift)+" "+QUtil::double_to_string(box.bottom+yshift)+"  "+
-    QUtil::double_to_string(box.right-box.left)+" "+QUtil::double_to_string(box.top-box.bottom)+" re "+"S Q\n";
-}
-// }}}
-
-QPDF_PDFTOPDF_PageHandle::QPDF_PDFTOPDF_PageHandle(QPDFObjectHandle page,int orig_no) // {{{
-  : page(page),
-    no(orig_no),
-    rotation(ROT_0)
-{
-}
-// }}}
-
-QPDF_PDFTOPDF_PageHandle::QPDF_PDFTOPDF_PageHandle(QPDF *pdf,float width,float height) // {{{
-  : no(0),
-    rotation(ROT_0)
-{
-  assert(pdf);
-  page=QPDFObjectHandle::parse(
-    "<<"
-    "  /Type /Page"
-    "  /Resources <<"
-    "    /XObject null "
-    "  >>"
-    "  /MediaBox null "
-    "  /Contents null "
-    ">>");
-  page.replaceKey("/MediaBox",makeBox(0,0,width,height));
-  page.replaceKey("/Contents",QPDFObjectHandle::newStream(pdf));
-  // xobjects: later (in get())
-  content.assign("q\n");  // TODO? different/not needed
-
-  page=pdf->makeIndirectObject(page); // stores *pdf
-}
-// }}}
-
-// Note: PDFTOPDF_Processor always works with "/Rotate"d and "/UserUnit"-scaled pages/coordinates/..., having 0,0 at left,bottom of the TrimBox
-PageRect QPDF_PDFTOPDF_PageHandle::getRect() const // {{{
-{
-  page.assertInitialized();
-  PageRect ret=getBoxAsRect(getTrimBox(page));
-  ret.translate(-ret.left,-ret.bottom);
-  ret.rotate_move(getRotate(page),ret.width,ret.height);
-  ret.scale(getUserUnit(page));
-  return ret;
-}
-// }}}
-
-bool QPDF_PDFTOPDF_PageHandle::isExisting() const // {{{
-{
-  page.assertInitialized();
-  return content.empty();
-}
-// }}}
-
-QPDFObjectHandle QPDF_PDFTOPDF_PageHandle::get() // {{{
-{
-  QPDFObjectHandle ret=page;
-  if (!isExisting()) { // finish up page
-    page.getKey("/Resources").replaceKey("/XObject",QPDFObjectHandle::newDictionary(xobjs));
-    content.append("Q\n");
-    page.getKey("/Contents").replaceStreamData(content,QPDFObjectHandle::newNull(),QPDFObjectHandle::newNull());
-    page.replaceOrRemoveKey("/Rotate",makeRotate(rotation));
-  } else {
-    Rotation rot=getRotate(page)+rotation;
-    page.replaceOrRemoveKey("/Rotate",makeRotate(rot));
-  }
-  page=QPDFObjectHandle(); // i.e. uninitialized
-  return ret;
-}
-// }}}
-
-// TODO: we probably need a function "ungetRect()"  to transform to page/form space
-// TODO: as member
-static PageRect ungetRect(PageRect rect,const QPDF_PDFTOPDF_PageHandle &ph,Rotation rotation,QPDFObjectHandle page)
-{
-  PageRect pg1=ph.getRect();
-  PageRect pg2=getBoxAsRect(getTrimBox(page));
-
-  // we have to invert /Rotate, /UserUnit and the left,bottom (TrimBox) translation
-  //Rotation_dump(rotation);
-  //Rotation_dump(getRotate(page));
-  rect.width=pg1.width;
-  rect.height=pg1.height;
-  //std::swap(rect.width,rect.height);
-  //rect.rotate_move(-rotation,rect.width,rect.height);
-
-  rect.rotate_move(-getRotate(page),pg1.width,pg1.height);
-  rect.scale(1.0/getUserUnit(page));
-
-  //  PageRect pg2=getBoxAsRect(getTrimBox(page));
-  rect.translate(pg2.left,pg2.bottom);
-  //rect.dump();
-
-  return rect;
-}
-
-// TODO FIXME rotations are strange  ... (via ungetRect)
-// TODO? for non-existing (either drop comment or facility to create split streams needed)
-void QPDF_PDFTOPDF_PageHandle::add_border_rect(const PageRect &_rect,BorderType border,float fscale) // {{{
-{
-  assert(isExisting());
-  assert(border!=BorderType::NONE);
-
-  // straight from pstops
-  const double lw=(border&THICK)?0.5:0.24;
-  double line_width=lw*fscale;
-  double margin=2.25*fscale;
-  // (PageLeft+margin,PageBottom+margin) rect (PageRight-PageLeft-2*margin,...)   ... for nup>1: PageLeft=0,etc.
-  //  if (double)  margin+=2*fscale ...rect...
-
-  PageRect rect=ungetRect(_rect,*this,rotation,page);
-
-  assert(rect.left<=rect.right);
-  assert(rect.bottom<=rect.top);
-
-  std::string boxcmd="q\n";
-  boxcmd+="  "+QUtil::double_to_string(line_width)+" w 0 G \n";
-  boxcmd+="  "+QUtil::double_to_string(rect.left+margin)+" "+QUtil::double_to_string(rect.bottom+margin)+"  "+
-    QUtil::double_to_string(rect.right-rect.left-2*margin)+" "+QUtil::double_to_string(rect.top-rect.bottom-2*margin)+" re S \n";
-  if (border&TWO) {
-    margin+=2*fscale;
-    boxcmd+="  "+QUtil::double_to_string(rect.left+margin)+" "+QUtil::double_to_string(rect.bottom+margin)+"  "+
-      QUtil::double_to_string(rect.right-rect.left-2*margin)+" "+QUtil::double_to_string(rect.top-rect.bottom-2*margin)+" re S \n";
-  }
-  boxcmd+="Q\n";
-
-  // if (!isExisting()) {
-  //   // TODO: only after
-  //   return;
-  // }
-  
-  assert(page.getOwningQPDF()); // existing pages are always indirect
-#ifdef DEBUG  // draw it on top
-  static const char *pre="%pdftopdf q\n"
-    "q\n",
-    *post="%pdftopdf Q\n"
-    "Q\n";
-
-  QPDFObjectHandle stm1=QPDFObjectHandle::newStream(page.getOwningQPDF(),pre),
-    stm2=QPDFObjectHandle::newStream(page.getOwningQPDF(),std::string(post)+boxcmd);
-
-  page.addPageContents(stm1,true); // before
-  page.addPageContents(stm2,false); // after
-#else
-  QPDFObjectHandle stm=QPDFObjectHandle::newStream(page.getOwningQPDF(),boxcmd);
-  page.addPageContents(stm,true); // before
-#endif
-}
-// }}}
-/*
- *  This crop function is written for print-scaling=fill option.
- *  Trim Box is used for trimming the page in required size.
- *  scale tells if we need to scale input file.
- */
-Rotation QPDF_PDFTOPDF_PageHandle::crop(const PageRect &cropRect,Rotation orientation,Position xpos,Position ypos,bool scale)
-{
-  page.assertInitialized();
-  if(orientation==ROT_0||orientation==ROT_180)
-    page.replaceOrRemoveKey("/Rotate",makeRotate(ROT_90));
-  else
-    page.replaceOrRemoveKey("/Rotate",makeRotate(ROT_0));
-
-  PageRect currpage= getBoxAsRect(getTrimBox(page));
-  double width = currpage.right-currpage.left;
-  double height = currpage.top-currpage.bottom;
-  double pageWidth = cropRect.right-cropRect.left;
-  double pageHeight = cropRect.top-cropRect.bottom;
-  double final_w,final_h;   //Width and height of cropped image.
-
-  Rotation pageRot = getRotate(page);
-  if(pageRot==ROT_0||pageRot==ROT_180)
-  {
-    std::swap(pageHeight,pageWidth);
-  }
-  if(scale)
-  {
-    if(width*pageHeight/pageWidth<=height)
-    {
-      final_w = width;
-      final_h = width*pageHeight/pageWidth;
-    }
-    else{
-      final_w = height*pageWidth/pageHeight;
-      final_h = height;
-    }
-  }
-  else{
-    final_w = std::min(width,pageWidth);
-    final_h = std::min(height,pageHeight);
-  }
-  fprintf(stderr,"After Cropping: %lf %lf %lf %lf\n",width,height,final_w,final_h);
-  double posw = (width-final_w)/2,
-        posh = (height-final_h)/2;
-  // posw, posh : Position along width and height respectively.
-  // Calculating required position.  
-  if(xpos==Position::LEFT)        
-    posw =0;
-  else if(xpos==Position::RIGHT)
-    posw*=2;
-  
-  if(ypos==Position::TOP)
-    posh*=2;
-  else if(ypos==Position::BOTTOM)
-    posh=0;
-
-  // making PageRect for cropping.
-  currpage.left += posw;
-  currpage.bottom += posh;
-  currpage.top =currpage.bottom+final_h;
-  currpage.right=currpage.left+final_w;
-  //Cropping.
-  // TODO: Borders are covered by the image. buffer space?
-  page.replaceKey("/TrimBox",makeBox(currpage.left,currpage.bottom,currpage.right,currpage.top));
-  page.replaceOrRemoveKey("/Rotate",makeRotate(ROT_0));
-  return getRotate(page);
-}
-
-bool QPDF_PDFTOPDF_PageHandle::is_landscape(Rotation orientation)
-{
-  page.assertInitialized();
-  if(orientation==ROT_0||orientation==ROT_180)
-    page.replaceOrRemoveKey("/Rotate",makeRotate(ROT_90));
-  else
-    page.replaceOrRemoveKey("/Rotate",makeRotate(ROT_0));
-
-  PageRect currpage= getBoxAsRect(getTrimBox(page));
-  double width = currpage.right-currpage.left;
-  double height = currpage.top-currpage.bottom;
-  if(width>height)
-    return true;
-  return false;
-}
-
-// TODO: better cropping
-// TODO: test/fix with qsub rotation
-void QPDF_PDFTOPDF_PageHandle::add_subpage(const std::shared_ptr<PDFTOPDF_PageHandle> &sub,float xpos,float ypos,float scale,const PageRect *crop) // {{{
-{
-  auto qsub=dynamic_cast<QPDF_PDFTOPDF_PageHandle *>(sub.get());
-  assert(qsub);
-
-  std::string xoname="/X"+QUtil::int_to_string((qsub->no!=-1)?qsub->no:++no);
-  if (crop) {
-    PageRect pg=qsub->getRect(),tmp=*crop;
-    // we need to fix a too small cropbox.
-    tmp.width=tmp.right-tmp.left;
-    tmp.height=tmp.top-tmp.bottom;
-    tmp.rotate_move(-getRotate(qsub->page),tmp.width,tmp.height); // TODO TODO (pg.width? / unneeded?)
-    // TODO: better
-    // TODO: we need to obey page./Rotate
-    if (pg.width<tmp.width) {
-      pg.right=pg.left+tmp.width;
-    }
-    if (pg.height<tmp.height) {
-      pg.top=pg.bottom+tmp.height;
-    }
-
-    PageRect rect=ungetRect(pg,*qsub,ROT_0,qsub->page);
-
-    qsub->page.replaceKey("/TrimBox",makeBox(rect.left,rect.bottom,rect.right,rect.top));
-    // TODO? do everything for cropping here?
-  }
-  xobjs[xoname]=makeXObject(qsub->page.getOwningQPDF(),qsub->page); // trick: should be the same as page->getOwningQPDF() [only after it's made indirect]
-
-  Matrix mtx;
-  mtx.translate(xpos,ypos);
-  mtx.scale(scale);
-  mtx.rotate(qsub->rotation); // TODO? -sub.rotation ?  // TODO FIXME: this might need another translation!?
-  if (crop) { // TODO? other technique: set trim-box before makeXObject (but this modifies original page)
-    mtx.translate(crop->left,crop->bottom);
-    // crop->dump();
-  }
-
-  content.append("q\n  ");
-  content.append(mtx.get_string()+" cm\n  ");
-  if (crop) {
-    content.append("0 0 "+QUtil::double_to_string(crop->right-crop->left)+" "+QUtil::double_to_string(crop->top-crop->bottom)+" re W n\n  ");
-    //    content.append("0 0 "+QUtil::double_to_string(crop->right-crop->left)+" "+QUtil::double_to_string(crop->top-crop->bottom)+" re S\n  ");
-  }
-  content.append(xoname+" Do\n");
-  content.append("Q\n");
-}
-// }}}
-
-void QPDF_PDFTOPDF_PageHandle::mirror() // {{{
-{
-  PageRect orig=getRect();
-
-  if (isExisting()) {
-    // need to wrap in XObject to keep patterns correct
-    // TODO? refactor into internal ..._subpage fn ?
-    std::string xoname="/X"+QUtil::int_to_string(no);
-
-    QPDFObjectHandle subpage=get();  // this->page, with rotation
-
-    // replace all our data
-    *this=QPDF_PDFTOPDF_PageHandle(subpage.getOwningQPDF(),orig.width,orig.height);
-
-    xobjs[xoname]=makeXObject(subpage.getOwningQPDF(),subpage); // we can only now set this->xobjs
-
-    // content.append(std::string("1 0 0 1 0 0 cm\n  ");
-    content.append(xoname+" Do\n");
-
-    assert(!isExisting());
-  }
-
-  static const char *pre="%pdftopdf cm\n";
-  // Note: we don't change (TODO need to?) the media box
-  std::string mrcmd("-1 0 0 1 "+
-                    QUtil::double_to_string(orig.right)+" 0 cm\n");
-
-  content.insert(0,std::string(pre)+mrcmd);
-}
-// }}}
-
-void QPDF_PDFTOPDF_PageHandle::rotate(Rotation rot) // {{{
-{
-  rotation=rot; // "rotation += rot;" ?
-}
-// }}}
-
-void QPDF_PDFTOPDF_PageHandle::add_label(const PageRect &_rect, const std::string label) // {{{
-{
-  assert(isExisting());
-
-  PageRect rect = ungetRect (_rect, *this, rotation, page);
-
-  assert (rect.left <= rect.right);
-  assert (rect.bottom <= rect.top);
-
-  // TODO: Only add in the font once, not once per page.
-  QPDFObjectHandle font = page.getOwningQPDF()->makeIndirectObject
-    (QPDFObjectHandle::parse(
-      "<<"
-      " /Type /Font"
-      " /Subtype /Type1"
-      " /Name /pagelabel-font"
-      " /BaseFont /Helvetica" // TODO: support UTF-8 labels?
-      ">>"));
-  QPDFObjectHandle resources = page.getKey ("/Resources");
-  QPDFObjectHandle rfont = resources.getKey ("/Font");
-  rfont.replaceKey ("/pagelabel-font", font);
-
-  double margin = 2.25;
-  double height = 12;
-
-  std::string boxcmd = "q\n";
-
-  // White filled rectangle (top)
-  boxcmd += "  1 1 1 rg\n";
-  boxcmd += "  " +
-    QUtil::double_to_string(rect.left + margin) + " " +
-    QUtil::double_to_string(rect.top - height - 2 * margin) + " " +
-    QUtil::double_to_string(rect.right - rect.left - 2 * margin) + " " +
-    QUtil::double_to_string(height + 2 * margin) + " re f\n";
-
-  // White filled rectangle (bottom)
-  boxcmd += "  " +
-    QUtil::double_to_string(rect.left + margin) + " " +
-    QUtil::double_to_string(rect.bottom + height + margin) + " " +
-    QUtil::double_to_string(rect.right - rect.left - 2 * margin) + " " +
-    QUtil::double_to_string(height + 2 * margin) + " re f\n";
-
-  // Black outline (top)
-  boxcmd += "  0 0 0 RG\n";
-  boxcmd += "  " +
-    QUtil::double_to_string(rect.left + margin) + " " +
-    QUtil::double_to_string(rect.top - height - 2 * margin) + " " +
-    QUtil::double_to_string(rect.right - rect.left - 2 * margin) + " " +
-    QUtil::double_to_string(height + 2 * margin) + " re S\n";
-
-  // Black outline (bottom)
-  boxcmd += "  " +
-    QUtil::double_to_string(rect.left + margin) + " " +
-    QUtil::double_to_string(rect.bottom + height + margin) + " " +
-    QUtil::double_to_string(rect.right - rect.left - 2 * margin) + " " +
-    QUtil::double_to_string(height + 2 * margin) + " re S\n";
-
-  // Black text (top)
-  boxcmd += "  0 0 0 rg\n";
-  boxcmd += "  BT\n";
-  boxcmd += "  /pagelabel-font 12 Tf\n";
-  boxcmd += "  " +
-    QUtil::double_to_string(rect.left + 2 * margin) + " " +
-    QUtil::double_to_string(rect.top - height - margin) + " Td\n";
-  boxcmd += "  (" + label + ") Tj\n";
-  boxcmd += "  ET\n";
-
-  // Black text (bottom)
-  boxcmd += "  BT\n";
-  boxcmd += "  /pagelabel-font 12 Tf\n";
-  boxcmd += "  " +
-    QUtil::double_to_string(rect.left + 2 * margin) + " " +
-    QUtil::double_to_string(rect.bottom + height + 2 * margin) + " Td\n";
-  boxcmd += "  (" + label + ") Tj\n";
-  boxcmd += "  ET\n";
-
-  boxcmd += "Q\n";
-
-  assert(page.getOwningQPDF()); // existing pages are always indirect
-  static const char *pre="%pdftopdf q\n"
-    "q\n",
-    *post="%pdftopdf Q\n"
-    "Q\n";
-
-  QPDFObjectHandle stm1=QPDFObjectHandle::newStream(page.getOwningQPDF(),
-						    std::string(pre)),
-    stm2=QPDFObjectHandle::newStream(page.getOwningQPDF(),
-				     std::string(post) + boxcmd);
-
-  page.addPageContents(stm1,true); // before
-  page.addPageContents(stm2,false); // after
-}
-// }}}
-
-void QPDF_PDFTOPDF_PageHandle::debug(const PageRect &rect,float xpos,float ypos) // {{{
-{
-  assert(!isExisting());
-  content.append(debug_box(rect,xpos,ypos));
-}
-// }}}
-
-void QPDF_PDFTOPDF_Processor::closeFile() // {{{
-{
-  pdf.reset();
-  hasCM=false;
-}
-// }}}
-
-void QPDF_PDFTOPDF_Processor::error(const char *fmt,...) // {{{
-{
-  va_list ap;
-
-  va_start(ap,fmt);
-  fputs("ERROR: ",stderr);
-  vfprintf(stderr,fmt,ap);
-  fputs("\n",stderr);
-  va_end(ap);
-}
-// }}}
-
-// TODO?  try/catch for PDF parsing errors?
-
-bool QPDF_PDFTOPDF_Processor::loadFile(FILE *f,ArgOwnership take,int flatten_forms) // {{{
-{
-  closeFile();
-  if (!f) {
-    throw std::invalid_argument("loadFile(NULL,...) not allowed");
-  }
-  try {
-    pdf.reset(new QPDF);
-  } catch (...) {
-    if (take==TakeOwnership) {
-      fclose(f);
-    }
-    throw;
-  }
-  switch (take) {
-  case WillStayAlive:
-    try {
-      pdf->processFile("temp file",f,false);
-    } catch (const std::exception &e) {
-      error("loadFile failed: %s",e.what());
-      return false;
-    }
-    break;
-  case TakeOwnership:
-    try {
-      pdf->processFile("temp file",f,true);
-    } catch (const std::exception &e) {
-      error("loadFile failed: %s",e.what());
-      return false;
-    }
-    break;
-  case MustDuplicate:
-    error("loadFile with MustDuplicate is not supported");
-    return false;
-  }
-  start(flatten_forms);
-  return true;
-}
-// }}}
-
-bool QPDF_PDFTOPDF_Processor::loadFilename(const char *name,int flatten_forms) // {{{
-{
-  closeFile();
-  try {
-    pdf.reset(new QPDF);
-    pdf->processFile(name);
-  } catch (const std::exception &e) {
-    error("loadFilename failed: %s",e.what());
-    return false;
-  }
-  start(flatten_forms);
-  return true;
-}
-// }}}
-
-void QPDF_PDFTOPDF_Processor::start(int flatten_forms) // {{{
-{
-  assert(pdf);
-
-  if (flatten_forms) {
-    QPDFAcroFormDocumentHelper afdh(*pdf);
-    afdh.generateAppearancesIfNeeded();
-
-    QPDFPageDocumentHelper dh(*pdf);
-    dh.flattenAnnotations(an_print);
-  }
-
-  pdf->pushInheritedAttributesToPage();
-  orig_pages=pdf->getAllPages();
-
-  // remove them (just unlink, data still there)
-  const int len=orig_pages.size();
-  for (int iA=0;iA<len;iA++) {
-    pdf->removePage(orig_pages[iA]);
-  }
-
-  // we remove stuff that becomes defunct (probably)  TODO
-  pdf->getRoot().removeKey("/PageMode");
-  pdf->getRoot().removeKey("/Outlines");
-  pdf->getRoot().removeKey("/OpenAction");
-  pdf->getRoot().removeKey("/PageLabels");
-}
-// }}}
-
-bool QPDF_PDFTOPDF_Processor::check_print_permissions() // {{{
-{
-  if (!pdf) {
-    error("No PDF loaded");
-    return false;
-  }
-  return pdf->allowPrintHighRes() || pdf->allowPrintLowRes(); // from legacy pdftopdf
-}
-// }}}
-
-std::vector<std::shared_ptr<PDFTOPDF_PageHandle>> QPDF_PDFTOPDF_Processor::get_pages() // {{{
-{
-  std::vector<std::shared_ptr<PDFTOPDF_PageHandle>> ret;
-  if (!pdf) {
-    error("No PDF loaded");
-    assert(0);
-    return ret;
-  }
-  const int len=orig_pages.size();
-  ret.reserve(len);
-  for (int iA=0;iA<len;iA++) {
-    ret.push_back(std::shared_ptr<PDFTOPDF_PageHandle>(new QPDF_PDFTOPDF_PageHandle(orig_pages[iA],iA+1)));
-  }
-  return ret;
-}
-// }}}
-
-std::shared_ptr<PDFTOPDF_PageHandle> QPDF_PDFTOPDF_Processor::new_page(float width,float height) // {{{
-{
-  if (!pdf) {
-    error("No PDF loaded");
-    assert(0);
-    return std::shared_ptr<PDFTOPDF_PageHandle>();
-  }
-  return std::shared_ptr<QPDF_PDFTOPDF_PageHandle>(new QPDF_PDFTOPDF_PageHandle(pdf.get(),width,height));
-  // return std::make_shared<QPDF_PDFTOPDF_PageHandle>(pdf.get(),width,height);
-  // problem: make_shared not friend
-}
-// }}}
-
-void QPDF_PDFTOPDF_Processor::add_page(std::shared_ptr<PDFTOPDF_PageHandle> page,bool front) // {{{
-{
-  assert(pdf);
-  auto qpage=dynamic_cast<QPDF_PDFTOPDF_PageHandle *>(page.get());
-  if (qpage) {
-    pdf->addPage(qpage->get(),front);
-  }
-}
-// }}}
-
-#if 0
-// we remove stuff now probably defunct  TODO
-pdf->getRoot().removeKey("/PageMode");
-pdf->getRoot().removeKey("/Outlines");
-pdf->getRoot().removeKey("/OpenAction");
-pdf->getRoot().removeKey("/PageLabels");
-#endif
-
-void QPDF_PDFTOPDF_Processor::multiply(int copies,bool collate) // {{{
-{
-  assert(pdf);
-  assert(copies>0);
-
-  std::vector<QPDFObjectHandle> pages=pdf->getAllPages(); // need copy
-  const int len=pages.size();
-
-  if (collate) {
-    for (int iA=1;iA<copies;iA++) {
-      for (int iB=0;iB<len;iB++) {
-        pdf->addPage(pages[iB].shallowCopy(),false);
-      }
-    }
-  } else {
-    for (int iB=0;iB<len;iB++) {
-      for (int iA=1;iA<copies;iA++) {
-        pdf->addPageAt(pages[iB].shallowCopy(),false,pages[iB]);
-      }
-    }
-  }
-}
-// }}}
-
-// TODO? elsewhere?
-void QPDF_PDFTOPDF_Processor::autoRotateAll(bool dst_lscape,Rotation normal_landscape) // {{{
-{
-  assert(pdf);
-
-  const int len=orig_pages.size();
-  for (int iA=0;iA<len;iA++) {
-    QPDFObjectHandle page=orig_pages[iA];
-
-    Rotation src_rot=getRotate(page);
-
-    // copy'n'paste from QPDF_PDFTOPDF_PageHandle::getRect
-    PageRect ret=getBoxAsRect(getTrimBox(page));
-    // ret.translate(-ret.left,-ret.bottom);
-    ret.rotate_move(src_rot,ret.width,ret.height);
-    // ret.scale(getUserUnit(page));
-
-    const bool src_lscape=(ret.width>ret.height);
-    if (src_lscape!=dst_lscape) {
-      Rotation rotation=normal_landscape;
-      // TODO? other rotation direction, e.g. if (src_rot==ROT_0)&&(param.orientation==ROT_270) ... etc.
-      // rotation=ROT_270;
-
-      page.replaceOrRemoveKey("/Rotate",makeRotate(src_rot+rotation));
-    }
-  }
-}
-// }}}
-
-#include "qpdf_cm.h"
-
-// TODO
-void QPDF_PDFTOPDF_Processor::addCM(const char *defaulticc,const char *outputicc) // {{{
-{
-  assert(pdf);
-
-  if (hasOutputIntent(*pdf)) {
-    return; // nothing to do
-  }
-
-  QPDFObjectHandle srcicc=setDefaultICC(*pdf,defaulticc); // TODO? rename to putDefaultICC?
-  addDefaultRGB(*pdf,srcicc);
-
-  addOutputIntent(*pdf,outputicc);
-
-  hasCM=true;
-}
-// }}}
-
-void QPDF_PDFTOPDF_Processor::setComments(const std::vector<std::string> &comments) // {{{
-{
-  extraheader.clear();
-  const int len=comments.size();
-  for (int iA=0;iA<len;iA++) {
-    assert(comments[iA].at(0)=='%');
-    extraheader.append(comments[iA]);
-    extraheader.push_back('\n');
-  }
-}
-// }}}
-
-void QPDF_PDFTOPDF_Processor::emitFile(FILE *f,ArgOwnership take) // {{{
-{
-  if (!pdf) {
-    return;
-  }
-  QPDFWriter out(*pdf);
-  switch (take) {
-  case WillStayAlive:
-    out.setOutputFile("temp file",f,false);
-    break;
-  case TakeOwnership:
-    out.setOutputFile("temp file",f,true);
-    break;
-  case MustDuplicate:
-    error("emitFile with MustDuplicate is not supported");
-    return;
-  }
-  if (hasCM) {
-    out.setMinimumPDFVersion("1.4");
-  } else {
-    out.setMinimumPDFVersion("1.2");
-  }
-  if (!extraheader.empty()) {
-    out.setExtraHeaderText(extraheader);
-  }
-  out.setPreserveEncryption(false);
-  out.write();
-}
-// }}}
-
-void QPDF_PDFTOPDF_Processor::emitFilename(const char *name) // {{{
-{
-  if (!pdf) {
-    return;
-  }
-  // special case: name==NULL -> stdout
-  QPDFWriter out(*pdf,name);
-  if (hasCM) {
-    out.setMinimumPDFVersion("1.4");
-  } else {
-    out.setMinimumPDFVersion("1.2");
-  }
-  if (!extraheader.empty()) {
-    out.setExtraHeaderText(extraheader);
-  }
-  out.setPreserveEncryption(false);
-  std::vector<QPDFObjectHandle> pages=pdf->getAllPages();
-  int len=pages.size();
-  if (len)
-  out.write();
-  else
-  fprintf(stderr, "DEBUG: No pages left, outputting empty file.\n");
-}
-// }}}
-
-// TODO:
-//   loadPDF();   success?
-
-bool QPDF_PDFTOPDF_Processor::hasAcroForm() // {{{
-{
-  if (!pdf) {
-    return false;
-  }
-  QPDFObjectHandle root=pdf->getRoot();
-  if (!root.hasKey("/AcroForm")) {
-    return false;
-  }
-  return true;
-}
-// }}}
diff --git a/filter/pdftopdf/qpdf_pdftopdf_processor.h b/filter/pdftopdf/qpdf_pdftopdf_processor.h
deleted file mode 100644
index f721d93..0000000
--- a/filter/pdftopdf/qpdf_pdftopdf_processor.h
+++ /dev/null
@@ -1,74 +0,0 @@
-#ifndef QPDF_PDFTOPDF_PROCESSOR_H
-#define QPDF_PDFTOPDF_PROCESSOR_H
-
-#include "pdftopdf_processor.h"
-#include <qpdf/QPDF.hh>
-
-class QPDF_PDFTOPDF_PageHandle : public PDFTOPDF_PageHandle {
- public:
-  virtual PageRect getRect() const;
-  virtual void add_border_rect(const PageRect &rect,BorderType border,float fscale);
-  virtual void add_subpage(const std::shared_ptr<PDFTOPDF_PageHandle> &sub,float xpos,float ypos,float scale,const PageRect *crop=NULL);
-  virtual void mirror();
-  virtual void rotate(Rotation rot);
-  virtual void add_label(const PageRect &rect, const std::string label);
-  virtual Rotation crop(const PageRect &cropRect,Rotation orientation,Position xpos,Position ypos,bool scale);
-  virtual bool is_landscape(Rotation orientation);
-  void debug(const PageRect &rect,float xpos,float ypos);
- private:
-  bool isExisting() const;
-  QPDFObjectHandle get(); // only once!
- private:
-  friend class QPDF_PDFTOPDF_Processor;
-  // 1st mode: existing
-  QPDF_PDFTOPDF_PageHandle(QPDFObjectHandle page,int orig_no=-1);
-  QPDFObjectHandle page;
-  int no;
-
-  // 2nd mode: create new
-  QPDF_PDFTOPDF_PageHandle(QPDF *pdf,float width,float height);
-  std::map<std::string,QPDFObjectHandle> xobjs;
-  std::string content;
-
-  Rotation rotation;
-};
-
-class QPDF_PDFTOPDF_Processor : public PDFTOPDF_Processor {
- public:
-  virtual bool loadFile(FILE *f,ArgOwnership take=WillStayAlive,int flatten_forms=1);
-  virtual bool loadFilename(const char *name,int flatten_forms=1);
-
-  // TODO: virtual bool may_modify/may_print/?
-  virtual bool check_print_permissions();
-
-  // virtual bool setProcess(const ProcessingParameters &param) =0;
-
-  virtual std::vector<std::shared_ptr<PDFTOPDF_PageHandle>> get_pages();
-  virtual std::shared_ptr<PDFTOPDF_PageHandle> new_page(float width,float height);
-
-  virtual void add_page(std::shared_ptr<PDFTOPDF_PageHandle> page,bool front);
-
-  virtual void multiply(int copies,bool collate);
-
-  virtual void autoRotateAll(bool dst_lscape,Rotation normal_landscape);
-  virtual void addCM(const char *defaulticc,const char *outputicc);
-
-  virtual void setComments(const std::vector<std::string> &comments);
-
-  virtual void emitFile(FILE *dst,ArgOwnership take=WillStayAlive);
-  virtual void emitFilename(const char *name);
-
-  virtual bool hasAcroForm();
- private:
-  void closeFile();
-  void error(const char *fmt,...);
-  void start(int flatten_forms);
- private:
-  std::unique_ptr<QPDF> pdf;
-  std::vector<QPDFObjectHandle> orig_pages;
-
-  bool hasCM;
-  std::string extraheader;
-};
-
-#endif
diff --git a/filter/pdftopdf/qpdf_tools.cc b/filter/pdftopdf/qpdf_tools.cc
deleted file mode 100644
index 44cb981..0000000
--- a/filter/pdftopdf/qpdf_tools.cc
+++ /dev/null
@@ -1,69 +0,0 @@
-#include "qpdf_tools.h"
-
-QPDFObjectHandle getMediaBox(QPDFObjectHandle page) // {{{
-{
-  return page.getKey("/MediaBox");
-}
-// }}}
-
-QPDFObjectHandle getCropBox(QPDFObjectHandle page) // {{{
-{
-  if (page.hasKey("/CropBox")) {
-    return page.getKey("/CropBox");
-  }
-  return page.getKey("/MediaBox");
-}
-// }}}
-
-QPDFObjectHandle getBleedBox(QPDFObjectHandle page) // {{{
-{
-  if (page.hasKey("/BleedBox")) {
-    return page.getKey("/BleedBox");
-  }
-  return getCropBox(page);
-}
-// }}}
-
-QPDFObjectHandle getTrimBox(QPDFObjectHandle page) // {{{
-{
-  if (page.hasKey("/TrimBox")) {
-    return page.getKey("/TrimBox");
-  }
-  return getCropBox(page);
-}
-// }}}
-
-QPDFObjectHandle getArtBox(QPDFObjectHandle page) // {{{
-{
-  if (page.hasKey("/ArtBox")) {
-    return page.getKey("/ArtBox");
-  }
-  return getCropBox(page);
-}
-// }}}
-
-QPDFObjectHandle makePage(QPDF &pdf,const std::map<std::string,QPDFObjectHandle> &xobjs,QPDFObjectHandle mediabox,const std::string &content) // {{{
-{
-  QPDFObjectHandle ret=QPDFObjectHandle::newDictionary();
-  ret.replaceKey("/Type",QPDFObjectHandle::newName("/Page"));
-
-  auto resdict=QPDFObjectHandle::newDictionary();
-  resdict.replaceKey("/XObject",QPDFObjectHandle::newDictionary(xobjs));
-  ret.replaceKey("/Resources",resdict);
-  ret.replaceKey("/MediaBox",mediabox);
-  ret.replaceKey("/Contents",QPDFObjectHandle::newStream(&pdf,content));
-
-  return ret;
-}
-// }}}
-
-QPDFObjectHandle makeBox(double x1,double y1,double x2,double y2) // {{{
-{
-  QPDFObjectHandle ret=QPDFObjectHandle::newArray();
-  ret.appendItem(QPDFObjectHandle::newReal(x1));
-  ret.appendItem(QPDFObjectHandle::newReal(y1));
-  ret.appendItem(QPDFObjectHandle::newReal(x2));
-  ret.appendItem(QPDFObjectHandle::newReal(y2));
-  return ret;
-}
-// }}}
diff --git a/filter/pdftopdf/qpdf_tools.h b/filter/pdftopdf/qpdf_tools.h
deleted file mode 100644
index 20a19fb..0000000
--- a/filter/pdftopdf/qpdf_tools.h
+++ /dev/null
@@ -1,18 +0,0 @@
-#ifndef QPDF_TOOLS_H_
-#define QPDF_TOOLS_H_
-
-#include <qpdf/QPDFObjectHandle.hh>
-#include <map>
-#include <string>
-
-QPDFObjectHandle getMediaBox(QPDFObjectHandle page);
-QPDFObjectHandle getCropBox(QPDFObjectHandle page);
-QPDFObjectHandle getBleedBox(QPDFObjectHandle page);
-QPDFObjectHandle getTrimBox(QPDFObjectHandle page);
-QPDFObjectHandle getArtBox(QPDFObjectHandle page);
-
-QPDFObjectHandle makePage(QPDF &pdf,const std::map<std::string,QPDFObjectHandle> &xobjs,QPDFObjectHandle mediabox,const std::string &content);
-
-QPDFObjectHandle makeBox(double x1,double y1,double x2,double y2);
-
-#endif
diff --git a/filter/pdftopdf/qpdf_xobject.cc b/filter/pdftopdf/qpdf_xobject.cc
deleted file mode 100644
index cc33f43..0000000
--- a/filter/pdftopdf/qpdf_xobject.cc
+++ /dev/null
@@ -1,170 +0,0 @@
-#include "qpdf_xobject.h"
-//#include <qpdf/Types.h>
-#include <qpdf/QPDF.hh>
-#include <qpdf/Pl_Discard.hh>
-#include <qpdf/Pl_Count.hh>
-#include <qpdf/Pl_Concatenate.hh>
-#include "qpdf_tools.h"
-#include "qpdf_pdftopdf.h"
-
-// TODO: need to remove  Struct Parent stuff  (or fix)
-
-// NOTE: use /TrimBox to position content inside Nup cell, /BleedBox to clip against
-
-class CombineFromContents_Provider : public QPDFObjectHandle::StreamDataProvider {
-public:
-  CombineFromContents_Provider(const std::vector<QPDFObjectHandle> &contents);
-
-  void provideStreamData(int objid, int generation, Pipeline* pipeline);
-private:
-  std::vector<QPDFObjectHandle> contents;
-};
-
-CombineFromContents_Provider::CombineFromContents_Provider(const std::vector<QPDFObjectHandle> &contents)
-  : contents(contents)
-{
-}
-
-void CombineFromContents_Provider::provideStreamData(int objid, int generation, Pipeline* pipeline)
-{
-  Pl_Concatenate concat("concat", pipeline);
-  const int clen=contents.size();
-  for (int iA=0;iA<clen;iA++) {
-    contents[iA].pipeStreamData(&concat, true, false, false);
-  }
-  concat.manualFinish();
-}
-
-/*
-  To convert a page to an XObject there are several keys to consider:
-
-  /Type /Page        -> /Type /XObject (/Type optional for XObject)
-                     -> /Subtype /Form
-                     -> [/FormType 1]  (optional)
-  /Parent ? ? R      -> remove
-  /Resources dict    -> copy
-  /MediaBox rect [/CropBox /BleedBox /TrimBox /ArtBox] 
-                     -> /BBox  (use TrimBox [+ Bleed consideration?], with fallback to /MediaBox)
-                        note that /BBox is in *Form Space*, see /Matrix!
-  [/BoxColorInfo dict]   (used for guidelines that may be shown by viewer)
-                     -> ignore/remove
-  [/Contents asfd]   -> concatenate into stream data of the XObject (page is a dict, XObject a stream)
-
-  [/Rotate 90]   ... must be handled (either use CTM where XObject is /used/ -- or set /Matrix)
-  [/UserUnit] (PDF 1.6)   -> to /Matrix ?   -- it MUST be handled.
-
-  [/Group dict]      -> copy
-  [/Thumb stream]    -> remove, not needed any more / would have to be regenerated (combined)
-  [/B]               article beads -- ignore for now
-  [/Dur]             -> remove  (transition duration)
-  [/Trans]           -> remove  (transitions)
-  [/AA]              -> remove  (additional-actions)
-
-  [/Metadata]        what shall we do?? (kill: we can't combine XML)
-  [/PieceInfo]       -> remove, we can't combine private app data (?)
-  [/LastModified  date]  (opt except /PieceInfo)  -> see there
-
-  [/PZ]              -> remove, can't combine/keep (preferred zoom level)
-  [/SeparationInfo]  -> remove, no way to keep this (needed for separation)
-
-  [/ID]              related to web capture -- ignore/kill?
-  [/StructParents]   (opt except pdf contains "structural content items")
-                     -> copy (is this correct?)
-
-  [/Annots]          annotations -- ignore for now
-  [/Tabs]            tab order for annotations (/R row, /C column, /S structure order) -- see /Annots
-
-  [/TemplateInstantiated]  (reqd, if page was created from named page obj, 1.5) -- ? just ignore?
-  [/PresSteps]       -> remove (sub-page navigation for presentations) [no subpage navigation for printing / nup]
-  [/VP]              viewport rects -- ignore/drop or recalculate into new page
-
-*/
-QPDFObjectHandle makeXObject(QPDF *pdf,QPDFObjectHandle page)
-{
-  page.assertPageObject();
-
-  QPDFObjectHandle ret=QPDFObjectHandle::newStream(pdf);
-  QPDFObjectHandle dict=ret.getDict();
-
-  dict.replaceKey("/Type",QPDFObjectHandle::newName("/XObject")); // optional
-  dict.replaceKey("/Subtype",QPDFObjectHandle::newName("/Form")); // required
-  // dict.replaceKey("/FormType",QPDFObjectHandle::newInteger(1)); // optional
-
-  QPDFObjectHandle box=getTrimBox(page); // already in "form space"
-  dict.replaceKey("/BBox",box); // reqd
-
-  // [/Matrix .]   ...  default is [1 0 0 1 0 0]; we incorporate /UserUnit and /Rotate here
-  Matrix mtx;
-  if (page.hasKey("/UserUnit")) {
-    mtx.scale(page.getKey("/UserUnit").getNumericValue());
-  }
-
-  // transform, so that bbox is [0 0 w h]  (in outer space, but after UserUnit)
-  Rotation rot=getRotate(page);
-  
-  // calculate rotation effect on [0 0 w h]
-  PageRect bbox=getBoxAsRect(box),tmp;
-  tmp.left=0;
-  tmp.bottom=0;
-  tmp.right=0;
-  tmp.top=0;
-  tmp.rotate_move(rot,bbox.width,bbox.height);
-  // tmp.rotate_move moves the bbox; we must achieve this move with the matrix.
-  mtx.translate(tmp.left,tmp.bottom); // 1. move origin to end up at left,bottom after rotation
-
-  mtx.rotate(rot);  // 2. rotate coordinates according to /Rotate
-  mtx.translate(-bbox.left,-bbox.bottom);  // 3. move origin from 0,0 to "form space"
-
-  dict.replaceKey("/Matrix",mtx.get());
-
-  dict.replaceKey("/Resources",page.getKey("/Resources"));
-  if (page.hasKey("/Group")) {
-    dict.replaceKey("/Group",page.getKey("/Group")); // (transparency); opt, copy if there
-  }
-
-  // ?? /StructParents   ... can basically copy from page, but would need fixup in Structure Tree
-  // FIXME: remove (globally) Tagged spec (/MarkInfo), and Structure Tree
-
-  // Note: [/Name]  (reqd. only in 1.0 -- but there we even can't use our normal img/patter procedures)
-
-  // none:
-  //  QPDFObjectHandle filter=QPDFObjectHandle::newArray();
-  //  QPDFObjectHandle decode_parms=QPDFObjectHandle::newArray();
-  // null leads to use of "default filters" from qpdf's settings
-  QPDFObjectHandle filter=QPDFObjectHandle::newNull();
-  QPDFObjectHandle decode_parms=QPDFObjectHandle::newNull();
-
-  std::vector<QPDFObjectHandle> contents=page.getPageContents();  // (will assertPageObject)
-
-  auto ph=PointerHolder<QPDFObjectHandle::StreamDataProvider>(new CombineFromContents_Provider(contents));
-  ret.replaceStreamData(ph,filter,decode_parms);
-
-  return ret;
-}
-
-/*
-  we will have to fix up the structure tree (e.g. /K in element), when copying  /StructParents;
-  (there is /Pg, which has to point to the containing page, /Stm when it's not part of the page's content stream 
-  i.e. when it is in our XObject!; then there is /StmOwn ...)
-  when not copying, we have to remove the structure tree completely (also /MarkInfo dict)
-  Still this might not be sufficient(?), as there are probably BDC and EMC operators in the stream.
-*/
-
-/* /XObject /Form has
-   [/Type /XObject]
-   /Subtype /Form
-   [/FormType 1]
-   /BBox rect         from crop box, or recalculate
-   [/Matrix .]   ...  default is [1 0 0 1 0 0] ---   we have to incorporate /UserUnit here?!
-   [/Resources dict]  from page.
-   [/Group dict]      used for transparency -- can copy from page
-   [/Ref dict]        not needed; for external reference
-   [/Metadata]        not, as long we can not combine.
-   [/PieceInfo]       can copy, but not combine 
-   [/LastModified date]    copy if /PieceInfo there
-   [/StructParent]    . don't want to be one   ... have to read more spec
-   [/StructParents]   . copy from page!
-   [/OPI]             no opi version. don't set
-   [/OC]              is this optional content? NO! not needed.
-   [/Name]            (only reqd. in 1.0 -- but there we even can't use our normal img/patter procedures)
-*/
diff --git a/filter/pdftopdf/qpdf_xobject.h b/filter/pdftopdf/qpdf_xobject.h
deleted file mode 100644
index 096b56d..0000000
--- a/filter/pdftopdf/qpdf_xobject.h
+++ /dev/null
@@ -1,8 +0,0 @@
-#ifndef QPDF_XOBJECT_H_
-#define QPDF_XOBJECT_H_
-
-#include <qpdf/QPDFObjectHandle.hh>
-
-QPDFObjectHandle makeXObject(QPDF *pdf,QPDFObjectHandle page);
-
-#endif
diff --git a/filter/pdftops.c b/filter/pdftops.c
deleted file mode 100644
index a2bb323..0000000
--- a/filter/pdftops.c
+++ /dev/null
@@ -1,1645 +0,0 @@
-/*
- *   PDF to PostScript filter front-end for CUPS.
- *
- *   Copyright 2007-2011 by Apple Inc.
- *   Copyright 1997-2006 by Easy Software Products.
- *   Copyright 2011-2013 by Till Kamppeter
- *
- *   These coded instructions, statements, and computer programs are the
- *   property of Apple Inc. and are protected by Federal copyright
- *   law.  Distribution and use rights are outlined in the file "COPYING"
- *   which should have been included with this file.
- *
- * Contents:
- *
- *   parsePDFTOPDFComment() - Check whether we are executed after pdftopdf
- *   remove_options()       - Remove unwished entries from an option list
- *   log_command_line()     - Log the command line of a program which we call
- *   main()                 - Main entry for filter...
- *   cancel_job()           - Flag the job as canceled.
- */
-
-/*
- * Include necessary headers...
- */
-
-#include "pdf.h"
-#include <config.h>
-#include <cups/cups.h>
-#include <cups/ppd.h>
-#include <cups/file.h>
-#include <signal.h>
-#include <sys/wait.h>
-#include <fcntl.h>
-#include <errno.h>
-#include <string.h>
-#include <ctype.h>
-#include <cupsfilters/image-private.h>
-
-#define MAX_CHECK_COMMENT_LINES	20
-
-/*
- * Type definitions
- */
-
-typedef unsigned renderer_t;
-enum renderer_e {GS = 0, PDFTOPS = 1, ACROREAD = 2, PDFTOCAIRO = 3, MUPDF = 4, HYBRID = 5};
-
-/*
- * Local functions...
- */
-
-static void		cancel_job(int sig);
-
-
-/*
- * Local globals...
- */
-
-static int		job_canceled = 0;
-int			pdftopdfapplied = 0;
-char			deviceCopies[32] = "1";
-int			deviceCollate = 0;
-char                    make_model[128] = "";
-
-
-/*
- * When calling the "pstops" filter we exclude the following options from its
- * command line as we have applied these options already to the PDF input,
- * either on the "pdftops"/Ghostscript call in this filter or by use of the
- * "pdftopdf" filter before this filter.
- */
-
-const char *pstops_exclude_general[] = {
-  "crop-to-fit",
-  "fill",
-  "fitplot",
-  "fit-to-page",
-  "landscape",
-  "orientation-requested",
-  NULL
-};
-
-const char *pstops_exclude_page_management[] = {
-  "brightness",
-  "Collate",
-  "cupsEvenDuplex",
-  "gamma",
-  "hue",
-  "ipp-attribute-fidelity",
-  "MirrorPrint",
-  "mirror",
-  "multiple-document-handling",
-  "natural-scaling",
-  "number-up",
-  "number-up-layout",
-  "OutputOrder",
-  "page-border",
-  "page-bottom",
-  "page-label",
-  "page-left",
-  "page-ranges",
-  "page-right",
-  "page-set",
-  "page-top",
-  "position",
-  "saturation",
-  "scaling",
-  NULL
-};
-
-
-/*
- * Check whether we were called after the "pdftopdf" filter and extract
- * parameters passed over by "pdftopdf" in the header comments of the PDF
- * file
- */
-
-static void parsePDFTOPDFComment(char *filename)
-{
-  char buf[4096];
-  int i;
-  FILE *fp;
-
-  if ((fp = fopen(filename,"rb")) == 0) {
-    fprintf(stderr, "ERROR: pdftops - cannot open print file \"%s\"\n",
-            filename);
-    return;
-  }
-
-  /* skip until PDF start header */
-  while (fgets(buf,sizeof(buf),fp) != 0) {
-    if (strncmp(buf,"%PDF",4) == 0) {
-      break;
-    }
-  }
-  for (i = 0;i < MAX_CHECK_COMMENT_LINES;i++) {
-    if (fgets(buf,sizeof(buf),fp) == 0) break;
-    if (strncmp(buf,"%%PDFTOPDFNumCopies",19) == 0) {
-      char *p;
-
-      p = strchr(buf+19,':') + 1;
-      while (*p == ' ' || *p == '\t') p++;
-      strncpy(deviceCopies, p, sizeof(deviceCopies));
-      deviceCopies[sizeof(deviceCopies) - 1] = '\0';
-      p = deviceCopies + strlen(deviceCopies) - 1;
-      while (*p == ' ' || *p == '\t'  || *p == '\r'  || *p == '\n') p--;
-      *(p + 1) = '\0';
-      pdftopdfapplied = 1;
-    } else if (strncmp(buf,"%%PDFTOPDFCollate",17) == 0) {
-      char *p;
-
-      p = strchr(buf+17,':') + 1;
-      while (*p == ' ' || *p == '\t') p++;
-      if (strncasecmp(p,"true",4) == 0) {
-	deviceCollate = 1;
-      } else {
-	deviceCollate = 0;
-      }
-      pdftopdfapplied = 1;
-    } else if (strcmp(buf,"% This file was generated by pdftopdf") == 0) {
-      pdftopdfapplied = 1;
-    }
-  }
-
-  fclose(fp);
-}
-
-
-/*
- * Remove all options in option_list from the string option_str, including
- * option values after an "=" sign and preceded "no" before boolean options
- */
-
-void remove_options(char *options_str, const char **option_list)
-{
-  const char	**option;		/* Option to be removed now */
-  char		*option_start,		/* Start of option in string */
-		*option_end;		/* End of option in string */
-
-  for (option = option_list; *option; option ++)
-  {
-    option_start = options_str;
-
-    while ((option_start = strcasestr(option_start, *option)) != NULL)
-    {
-      if (!option_start[strlen(*option)] ||
-          isspace(option_start[strlen(*option)] & 255) ||
-          option_start[strlen(*option)] == '=')
-      {
-        /*
-         * Strip option...
-         */
-
-        option_end = option_start + strlen(*option);
-
-        /* Remove preceding "no" of boolean option */
-        if ((option_start - options_str) >= 2 &&
-            !strncasecmp(option_start - 2, "no", 2))
-          option_start -= 2;
-
-	/* Is match of the searched option name really at the beginning of
-	   the name of the option in the command line? */
-	if ((option_start > options_str) &&
-	    (!isspace(*(option_start - 1) & 255)))
-	{
-	  /* Prevent the same option to be found again. */
-	  option_start += 1;
-	  /* Skip */
-	  continue;
-	}
-
-        /* Remove "=" and value */
-        while (*option_end && !isspace(*option_end & 255))
-          option_end ++;
-
-        /* Remove spaces up to next option */
-        while (*option_end && isspace(*option_end & 255))
-          option_end ++;
-
-        memmove(option_start, option_end, strlen(option_end) + 1);
-      } else {
-        /* Prevent the same option to be found again. */
-        option_start += 1;
-      }
-    }
-  }
-}
-
-
-/*
- * Check whether given file is empty
- */
-
-int is_empty(char *filename)
-{
-  FILE *fp = NULL;
-  fp = fopen(filename, "rb");
-  if (fp == NULL)
-  {
-    fprintf(stderr, "ERROR: pdftops - cannot open print file \"%s\"\n",
-            filename);
-    exit(1);
-  }
-  else
-  {
-    char buf[1];
-    rewind(fp);
-    if (fread(buf, 1, 1, fp) == 0) {
-      fclose(fp);
-      fprintf(stderr, "DEBUG: Input is empty, outputting empty file.\n");
-      return 1;
-    }
-    fclose(fp);
-    int pages = pdf_pages(filename);
-    if (pages == 0) {
-      fprintf(stderr, "DEBUG: No pages left, outputting empty file.\n");
-      return 1;
-    }
-    if (pages > 0)
-      return 0;
-    exit(1);
-  }
-}
-
-
-/*
- * Before calling any command line utility, log its command line in CUPS'
- * debug mode
- */
-
-void
-log_command_line(const char* file, char *const argv[])
-{
-  int i;
-  char *apos;
-
-  /* Debug output: Full command line of program to be called */
-  fprintf(stderr, "DEBUG: Running command line for %s:",
-	  (file ? file : argv[0]));
-  if (file)
-    fprintf(stderr, " %s", file);
-  for (i = (file ? 1 : 0); argv[i]; i ++) {
-    if ((strchr(argv[i],' ')) || (strchr(argv[i],'\t')))
-      apos = "'";
-    else
-      apos = "";
-    fprintf(stderr, " %s%s%s", apos, argv[i], apos);
-  }
-  fprintf(stderr, "\n");
-}
-
-
-/*
- * 'main()' - Main entry for filter...
- */
-
-int					/* O - Exit status */
-main(int  argc,				/* I - Number of command-line args */
-     char *argv[])			/* I - Command-line arguments */
-{
-  renderer_t    renderer = CUPS_PDFTOPS_RENDERER; /* Renderer: gs or pdftops or acroread or pdftocairo or hybrid */
-  int		fd = 0;			/* Copy file descriptor */
-  char		*filename,		/* PDF file to convert */
-		tempfile[1024];		/* Temporary file */
-  char		buffer[8192];		/* Copy buffer */
-  int		bytes;			/* Bytes copied */
-  int		num_options;		/* Number of options */
-  cups_option_t	*options;		/* Options */
-  const char	*val;			/* Option value */
-  ppd_file_t	*ppd;			/* PPD file */
-  char		resolution[128] = "";   /* Output resolution */
-  int           xres = 0, yres = 0,     /* resolution values */
-                mres, res,
-                maxres = CUPS_PDFTOPS_MAX_RESOLUTION,
-                                        /* Maximum image rendering resolution */
-                numvalues;              /* Number of values actually read */
-  ppd_choice_t  *choice;
-  ppd_attr_t    *attr;
-  cups_page_header2_t header;
-  cups_file_t	*fp;			/* Post-processing input file */
-  int		pdf_pid,		/* Process ID for pdftops/gs */
-		pdf_argc = 0,		/* Number of args for pdftops/gs */
-		pstops_pid,		/* Process ID of pstops filter */
-		pstops_pipe[2],		/* Pipe to pstops filter */
-		need_post_proc = 0,     /* Post-processing needed? */
-		post_proc_pid = 0,	/* Process ID of post-processing */
-		post_proc_pipe[2],	/* Pipe to post-processing */
-		wait_children,		/* Number of child processes left */
-		wait_pid,		/* Process ID from wait() */
-		wait_status,		/* Status from child */
-		exit_status = 0;	/* Exit status */
-  int gray_output = 0; /* Checking for monochrome/grayscale PostScript output */
-  char		*pdf_argv[100],		/* Arguments for pdftops/gs */
-		pstops_path[1024],	/* Path to pstops program */
-		*pstops_argv[7],	/* Arguments for pstops filter */
-		*pstops_options,	/* Options for pstops filter */
-		*pstops_end,		/* End of pstops filter option */
-		*ptr;			/* Pointer into value */
-  const char	*cups_serverbin;	/* CUPS_SERVERBIN environment
-					   variable */
-  int		duplex, tumble;         /* Duplex settings for PPD-less
-					   printing */
-#if defined(HAVE_SIGACTION) && !defined(HAVE_SIGSET)
-  struct sigaction action;		/* Actions for POSIX signals */
-#endif /* HAVE_SIGACTION && !HAVE_SIGSET */
-
-
- /*
-  * Make sure status messages are not buffered...
-  */
-
-  setbuf(stderr, NULL);
-
- /*
-  * Ignore broken pipe signals...
-  */
-
-  signal(SIGPIPE, SIG_IGN);
-
- /*
-  * Make sure we have the right number of arguments for CUPS!
-  */
-
-  if (argc < 6 || argc > 7)
-  {
-    fprintf(stderr, "Usage: %s job user title copies options [file]\n",
-	    argv[0]);
-    return (1);
-  }
-
- /*
-  * Register a signal handler to cleanly cancel a job.
-  */
-
-#ifdef HAVE_SIGSET /* Use System V signals over POSIX to avoid bugs */
-  sigset(SIGTERM, cancel_job);
-#elif defined(HAVE_SIGACTION)
-  memset(&action, 0, sizeof(action));
-
-  sigemptyset(&action.sa_mask);
-  action.sa_handler = cancel_job;
-  sigaction(SIGTERM, &action, NULL);
-#else
-  signal(SIGTERM, cancel_job);
-#endif /* HAVE_SIGSET */
-
- /*
-  * Copy stdin if needed...
-  */
-
-  if (argc == 6)
-  {
-   /*
-    * Copy stdin to a temp file...
-    */
-
-    if ((fd = cupsTempFd(tempfile, sizeof(tempfile))) < 0)
-    {
-      perror("DEBUG: Unable to copy PDF file");
-      return (1);
-    }
-
-    fprintf(stderr, "DEBUG: pdftops - copying to temp print file \"%s\"\n",
-            tempfile);
-
-    while ((bytes = fread(buffer, 1, sizeof(buffer), stdin)) > 0)
-      bytes = write(fd, buffer, bytes);
-
-    close(fd);
-
-    filename = tempfile;
-  }
-  else
-  {
-   /*
-    * Use the filename on the command-line...
-    */
-
-    filename    = argv[6];
-    tempfile[0] = '\0';
-  }
-
-  if (is_empty(filename))
-    return 0;
-
- /*
-  * Read out copy counts and collate setting passed over by pdftopdf
-  */
-
-  parsePDFTOPDFComment(filename);
-
- /*
-  * Read out the options from the fifth command line argument
-  */
-
-  num_options = cupsParseOptions(argv[5], 0, &options);
-
- /*
-  * Load the PPD file and mark options...
-  */
-
-  ppd = ppdOpenFile(getenv("PPD"));
-  if (ppd)
-  {
-    ppdMarkDefaults(ppd);
-    cupsMarkOptions(ppd, num_options, options);
-  }
-
-  if ((val = cupsGetOption("make-and-model", num_options, options)) != NULL)
-  {
-    strncpy(make_model, val, sizeof(make_model) - 1);
-    if (strlen(val) > 127)
-      make_model[127] = '\0';
-    for (ptr = make_model; *ptr; ptr ++)
-      if (*ptr == '-') *ptr = ' ';
-  }
-  else if (ppd)
-  {
-    snprintf(make_model, sizeof(make_model), "%s %s", ppd->manufacturer,
-	     ppd->product + 1);
-    make_model[strlen(make_model) - 1] = '\0';
-  }
-  fprintf(stderr, "DEBUG: Printer make and model: %s\n", make_model);
-
- /*
-  * Select the PDF renderer: Ghostscript (gs), Poppler (pdftops),
-  * Adobe Reader (arcoread), Poppler with Cairo (pdftocairo), or
-  * Hybrid (hybrid, Poppler for Brother, Minolta, Konica Minolta, Dell, and
-  * old HP LaserJets and Ghostscript otherwise)
-  */
-
-  if ((val = cupsGetOption("pdftops-renderer", num_options, options)) != NULL)
-  {
-    if (strcasecmp(val, "gs") == 0)
-      renderer = GS;
-    else if (strcasecmp(val, "pdftops") == 0)
-      renderer = PDFTOPS;
-    else if (strcasecmp(val, "acroread") == 0)
-      renderer = ACROREAD;
-    else if (strcasecmp(val, "pdftocairo") == 0)
-      renderer = PDFTOCAIRO;
-    else if (strcasecmp(val, "mupdf") == 0)
-      renderer = MUPDF;
-    else if (strcasecmp(val, "hybrid") == 0)
-      renderer = HYBRID;
-    else
-      fprintf(stderr,
-	      "WARNING: Invalid value for \"pdftops-renderer\": \"%s\"\n", val);
-  }
-
-  if (renderer == HYBRID)
-  {
-    if (make_model[0] &&
-	(!strncasecmp(make_model, "Brother", 7) ||
-	 !strncasecmp(make_model, "Dell", 4) ||
-	 strcasestr(make_model, "Minolta") ||
-	 (!strncasecmp(make_model, "Apple", 5) &&
-	  (ptr = strcasestr(make_model, "LaserWriter")) &&
-	  ((ptr = strcasestr(ptr + 11, "4")) || (ptr = strcasestr(ptr + 11, "12")) ||
-	   (ptr = strcasestr(ptr + 11, "16"))) &&
-	  ((ptr = strcasestr(ptr + 2, "600")) || (ptr = strcasestr(ptr + 2, "640")) ||
-	   (ptr = strcasestr(ptr + 2, "660"))))))
-    {
-      fprintf(stderr, "DEBUG: Switching to Poppler's pdftops instead of Ghostscript for Brother, Minolta, Konica Minolta, Dell, and Apple LaserWriter 16/600, 4/600, 12/640, 12/600, 12/660 to work around bugs in the printer's PS interpreters\n");
-      renderer = PDFTOPS;
-    }
-    else
-      renderer = GS;
-   /*
-    * Use Poppler instead of Ghostscript for old HP LaserJet printers due to
-    * a bug in their PS interpreters. They are very slow with Ghostscript.
-    * A LaserJet is considered old if its model number does not have a letter
-    * in the beginning, like LaserJet 3 or LaserJet 4000, not LaserJet P2015.
-    * See https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=742765
-    */
-    if (make_model[0] &&
-	((!strncasecmp(make_model, "HP", 2) ||
-	  !strncasecmp(make_model, "Hewlett-Packard", 15) ||
-	  !strncasecmp(make_model, "Hewlett Packard", 15)) &&
-	 (ptr = strcasestr(make_model, "LaserJet"))))
-    {
-      for (ptr += 8; *ptr; ptr ++)
-      {
-	if (isspace(*ptr)) continue;
-	if (isdigit(*ptr))
-	{
-	  fprintf(stderr, "DEBUG: Switching to Poppler's pdftops instead of Ghostscript for old HP LaserJet (\"LaserJet <number>\", no letters before <number>) printers to work around bugs in the printer's PS interpreters\n");
-	  renderer = PDFTOPS;
-	}
-	break;
-      }
-    }
-  }
-
- /*
-  * Build the pstops command-line...
-  */
-
-  if ((cups_serverbin = getenv("CUPS_SERVERBIN")) == NULL)
-    cups_serverbin = CUPS_SERVERBIN;
-
-  snprintf(pstops_path, sizeof(pstops_path), "%s/filter/pstops",
-           cups_serverbin);
-
-  pstops_options = strdup(argv[5]);
-
-  /*
-   * Strip options which "pstops" does not need to apply any more
-   */
-  remove_options(pstops_options, pstops_exclude_general);
-  if (pdftopdfapplied)
-    remove_options(pstops_options, pstops_exclude_page_management);
-
-  if (pdftopdfapplied && deviceCollate)
-  {
-   /*
-    * Add collate option to the pstops call if pdftopdf has found out that the
-    * printer does hardware collate.
-    */
-
-    pstops_options = realloc(pstops_options, strlen(pstops_options) + 9);
-    if (!pstops_options) {
-      fprintf(stderr, "ERROR: Can't allocate pstops_options\n");
-      exit(2);
-    }   
-    pstops_end = pstops_options + strlen(pstops_options);
-    strcpy(pstops_end, " Collate");
-  }
-
-  pstops_argv[0] = argv[0];		/* Printer */
-  pstops_argv[1] = argv[1];		/* Job */
-  pstops_argv[2] = argv[2];		/* User */
-  pstops_argv[3] = argv[3];		/* Title */
-  if (pdftopdfapplied)
-    pstops_argv[4] = deviceCopies;     	/* Copies */
-  else
-    pstops_argv[4] = argv[4];		/* Copies */
-  pstops_argv[5] = pstops_options;	/* Options */
-  pstops_argv[6] = NULL;
-
-  log_command_line("pstops", pstops_argv);
-
- /*
-  * Force monochrome/grayscale PostScript output 
-  * if job is to be printed in monochrome/grayscale
-  */
-  if (ppd && ppd->color_device == 0)  /* Monochrome printer */
-    gray_output = 1;
-  else  /*Color Printer - user option for Grayscale */
-  {
-    if ((val = cupsGetOption("pwg-raster-document-type", num_options,
-               options)) != NULL ||
-      (val = cupsGetOption("PwgRasterDocumentType", num_options,
-               options)) != NULL ||
-      (val = cupsGetOption("print-color-mode", num_options,
-               options)) != NULL ||
-      (val = cupsGetOption("PrintColorMode", num_options,
-               options)) != NULL ||
-      (val = cupsGetOption("color-space", num_options,
-               options)) != NULL ||
-      (val = cupsGetOption("ColorSpace", num_options,
-               options)) != NULL ||
-      (val = cupsGetOption("color-model", num_options,
-               options)) != NULL ||
-      (val = cupsGetOption("ColorModel", num_options,
-               options)) != NULL ||
-      (val = cupsGetOption("output-mode", num_options,
-               options)) != NULL ||
-      (val = cupsGetOption("OutputMode", num_options,
-               options)) != NULL)
-      {
-          if (strcasestr(val, "Black") ||
-	      strcasestr(val, "Gray") ||
-	      strcasestr(val, "Mono"))
-            gray_output = 1;
-      }
-  }
-
- /*
-  * Build the command-line for the pdftops, gs, mutool, pdftocairo, or
-  * acroread filter...
-  */
-
-  if (renderer == PDFTOPS)
-  {
-    pdf_argv[0] = (char *)"pdftops";
-    pdf_argc    = 1;
-  }
-  else if (renderer == GS)
-  {
-    pdf_argv[0] = (char *)"gs";
-    pdf_argv[1] = (char *)"-q";
-    pdf_argv[2] = (char *)"-dNOPAUSE";
-    pdf_argv[3] = (char *)"-dBATCH";
-    pdf_argv[4] = (char *)"-dSAFER";
-    pdf_argv[5] = (char *)"-dNOMEDIAATTRS";
-    pdf_argv[6] = (char *)"-sstdout=%stderr";
-#    ifdef HAVE_GHOSTSCRIPT_PS2WRITE
-    pdf_argv[7] = (char *)"-sDEVICE=ps2write";
-#    else
-    pdf_argv[7] = (char *)"-sDEVICE=pswrite";
-#    endif /* HAVE_GHOSTSCRIPT_PS2WRITE */
-    pdf_argv[8] = (char *)"-dShowAcroForm";
-    pdf_argv[9] = (char *)"-sOUTPUTFILE=%stdout";
-    if (gray_output == 1) /* Checking for monochrome/grayscale PostScript
-			     output */
-    {
-      pdf_argv[10] = (char *)"-sProcessColorModel=DeviceGray";
-      pdf_argv[11] = (char *)"-sColorConversionStrategy=Gray";
-      pdf_argc = 12;
-    }
-    else
-      pdf_argc = 10;
-  }
-  else if (renderer == MUPDF)
-  {
-    pdf_argv[0] = (char *)"mutool";
-    pdf_argv[1] = (char *)"draw";
-    pdf_argv[2] = (char *)"-L";
-    pdf_argv[3] = (char *)"-smtf";
-    pdf_argv[4] = (char *)"-Fps";
-    pdf_argv[5] = (char *)"-o-";
-    if (gray_output == 1) /* Checking for monochrome/grayscale PostScript
-			     output */
-      pdf_argv[6] = (char *)"-cgray";
-    else
-      pdf_argv[6] = (char *)"-crgb";
-    pdf_argc = 7;
-  }
-  else if (renderer == PDFTOCAIRO)
-  {
-    pdf_argv[0] = (char *)"pdftocairo";
-    pdf_argv[1] = (char *)"-ps";
-    pdf_argc    = 2;
-  }
-  else if (renderer == ACROREAD)
-  {
-    pdf_argv[0] = (char *)"acroread";
-    pdf_argv[1] = (char *)"-toPostScript";
-    pdf_argc    = 2;
-  }
-
- /*
-  * Set language level and TrueType font handling...
-  */
-
-  if (ppd)
-  {
-    if (ppd->language_level == 1)
-    {
-      if (renderer == PDFTOPS)
-      {
-	pdf_argv[pdf_argc++] = (char *)"-level1";
-	pdf_argv[pdf_argc++] = (char *)"-noembtt";
-      }
-      else if (renderer == GS)
-	pdf_argv[pdf_argc++] = (char *)"-dLanguageLevel=1";
-      else if (renderer == PDFTOCAIRO)
-        fprintf(stderr, "WARNING: Level 1 PostScript not supported by pdftocairo.\n");
-      else if (renderer == ACROREAD)
-        fprintf(stderr, "WARNING: Level 1 PostScript not supported by acroread.\n");
-      else if (renderer == MUPDF)
-        fprintf(stderr, "WARNING: Level 1 PostScript not supported by mutool.\n");
-    }
-    else if (ppd->language_level == 2)
-    {
-      if (renderer == PDFTOPS)
-      {
-	pdf_argv[pdf_argc++] = (char *)"-level2";
-	if (!ppd->ttrasterizer)
-	  pdf_argv[pdf_argc++] = (char *)"-noembtt";
-      }
-      else if (renderer == GS)
-	pdf_argv[pdf_argc++] = (char *)"-dLanguageLevel=2";
-      else if (renderer != MUPDF) /* MuPDF is PS level 2 only */
-	/* PDFTOCAIRO, ACROREAD */
-        pdf_argv[pdf_argc++] = (char *)"-level2";
-    }
-    else
-    {
-      if (renderer == PDFTOPS)
-      {
-        /* Do not emit PS Level 3 with Poppler on Brother and HP PostScript
-	   laser printers as some do not like it.
-	   See https://bugs.launchpad.net/bugs/277404 and
-	   https://bugs.launchpad.net/bugs/1306849 comment #42. */
-	if (!make_model[0] ||
-	    !strncasecmp(make_model, "Brother", 7) ||
-	    ((!strncasecmp(make_model, "HP", 2) ||
-	      !strncasecmp(make_model, "Hewlett-Packard", 15) ||
-	      !strncasecmp(make_model, "Hewlett Packard", 15)) &&
-	     (strcasestr(make_model, "LaserJet"))))
-	  pdf_argv[pdf_argc++] = (char *)"-level2";
-	else
-	  pdf_argv[pdf_argc++] = (char *)"-level3";
-      }
-      else if (renderer == GS)
-      {
-        /* Do not emit PS Level 3 with Ghostscript on Brother PostScript
-	   laser printers as some do not like it.
-	   See https://bugs.launchpad.net/bugs/1306849 comment #42. */
-	if (!make_model[0] ||
-	    !strncasecmp(make_model, "Brother", 7))
-	  pdf_argv[pdf_argc++] = (char *)"-dLanguageLevel=2";
-	else
-	  pdf_argv[pdf_argc++] = (char *)"-dLanguageLevel=3";
-      }
-      else if (renderer == MUPDF)
-        fprintf(stderr, "WARNING: Level 3 PostScript not supported by mutool.\n");
-      else /* PDFTOCAIRO || ACROREAD */
-        pdf_argv[pdf_argc++] = (char *)"-level3";
-    }
-  }
-  else
-  {
-    if (renderer == PDFTOPS)
-    {
-      /* Do not emit PS Level 3 with Poppler on HP PostScript laser printers
-	 as some do not like it. See https://bugs.launchpad.net/bugs/277404.*/
-      if (!make_model[0] ||
-	  ((!strncasecmp(make_model, "HP", 2) ||
-	    !strncasecmp(make_model, "Hewlett-Packard", 15) ||
-	    !strncasecmp(make_model, "Hewlett Packard", 15)) &&
-	   (strcasestr(make_model, "LaserJet"))))
-	pdf_argv[pdf_argc++] = (char *)"-level2";
-      else
-	pdf_argv[pdf_argc++] = (char *)"-level3";
-      pdf_argv[pdf_argc++] = (char *)"-noembtt";
-    }
-    else if (renderer == GS)
-      pdf_argv[pdf_argc++] = (char *)"-dLanguageLevel=3";
-    else if (renderer != MUPDF) /* MuPDF is PS level 2 only */
-      /* PDFTOCAIRO || ACROREAD */
-      pdf_argv[pdf_argc++] = (char *)"-level3";
-  }
-
-#ifdef HAVE_POPPLER_PDFTOPS_WITH_ORIGPAGESIZES
-  if ((renderer == PDFTOPS) || (renderer == PDFTOCAIRO))
-  {
-   /*
-    *  Use the page sizes of the original PDF document, this way documents
-    *  which contain pages of different sizes can be printed correctly
-    */
-
-    pdf_argv[pdf_argc++] = (char *)"-origpagesizes";
-    pdf_argv[pdf_argc++] = (char *)"-nocenter";
-  }
-  else
-#endif /* HAVE_POPPLER_PDFTOPS_WITH_ORIGPAGESIZES */
-  if (renderer == ACROREAD)
-  {
-   /*
-    * Use the page sizes of the original PDF document, this way documents
-    * which contain pages of different sizes can be printed correctly
-    */
-
-    pdf_argv[pdf_argc++] = (char *)"-choosePaperByPDFPageSize";
-  }
-
- /*
-  * Set output resolution ...
-  */
-
-  if (ppd)
-  {
-    /* Ignore error exits of cupsRasterInterpretPPD(), if it found a resolution
-       setting before erroring it is OK for us */
-    cupsRasterInterpretPPD(&header, ppd, num_options, options, NULL);
-    /* 100 dpi is default, this means that if we have 100 dpi here this
-       method failed to find the printing resolution */
-    if (header.HWResolution[0] > 100 && header.HWResolution[1] > 100)
-    {
-      xres = header.HWResolution[0];
-      yres = header.HWResolution[1];
-    }
-    else if ((choice = ppdFindMarkedChoice(ppd, "Resolution")) != NULL)
-      strncpy(resolution, choice->choice, sizeof(resolution));
-    else if ((attr = ppdFindAttr(ppd,"DefaultResolution",NULL)) != NULL)
-      strncpy(resolution, attr->value, sizeof(resolution));
-    resolution[sizeof(resolution)-1] = '\0';
-    if ((xres == 0) && (yres == 0) &&
-	((numvalues = sscanf(resolution, "%dx%d", &xres, &yres)) <= 0))
-      fprintf(stderr,
-	      "DEBUG: No resolution information found in the PPD file.\n");
-  }
-  if ((xres == 0) && (yres == 0))
-  {
-    if ((val = cupsGetOption("printer-resolution", num_options,
-			   options)) != NULL ||
-	(val = cupsGetOption("Resolution", num_options, options)) != NULL)
-    {
-      xres = yres = strtol(val, (char **)&ptr, 10);
-      if (ptr > val && xres > 0)
-      {
-	if (*ptr == 'x')
-	  yres = strtol(ptr + 1, (char **)&ptr, 10);
-      }
-
-      if (ptr <= val || xres <= 0 || yres <= 0 || !ptr ||
-	  (*ptr != '\0' &&
-	   strcasecmp(ptr, "dpi") &&
-	   strcasecmp(ptr, "dpc") &&
-	   strcasecmp(ptr, "dpcm")))
-      {
-	fprintf(stderr, "DEBUG: Bad resolution value \"%s\".\n", val);
-      }
-      else
-      {
-	if (!strcasecmp(ptr, "dpc") ||
-	    !strcasecmp(ptr, "dpcm"))
-	{
-	  xres = xres * 254 / 100;
-	  yres = yres * 254 / 100;
-	}
-      }
-    }
-  }
-  if ((xres > 0) || (yres > 0))
-  {
-    if (yres == 0) yres = xres;
-    if (xres == 0) xres = yres;
-    if (xres > yres)
-      res = yres;
-    else
-      res = xres;
-  }
-  else
-    res = 300;
-
- /*
-  * Get the ceiling for the image rendering resolution
-  */
-
-  if ((val = cupsGetOption("pdftops-max-image-resolution", num_options, options)) != NULL)
-  {
-    if ((numvalues = sscanf(val, "%d", &mres)) > 0)
-      maxres = mres;
-    else
-      fprintf(stderr,
-	      "WARNING: Invalid value for \"pdftops-max-image-resolution\": \"%s\"\n", val);
-  }
-
- /*
-  * Reduce the image rendering resolution to not exceed a given maximum
-  * to make processing of jobs by the PDF->PS converter and the printer faster
-  *
-  * maxres = 0 means no limit
-  */
-
-  if (maxres)
-    while (res > maxres)
-      res = res / 2;
-
-  if ((renderer == PDFTOPS) || (renderer == PDFTOCAIRO))
-  {
-#ifdef HAVE_POPPLER_PDFTOPS_WITH_RESOLUTION
-   /*
-    * Set resolution to avoid slow processing by the printer when the
-    * resolution of embedded images does not match the printer's resolution
-    */
-    pdf_argv[pdf_argc++] = (char *)"-r";
-    snprintf(resolution, sizeof(resolution), "%d", res);
-    pdf_argv[pdf_argc++] = resolution;
-    fprintf(stderr, "DEBUG: Using image rendering resolution %d dpi\n", res);
-#endif /* HAVE_POPPLER_PDFTOPS_WITH_RESOLUTION */
-    if (gray_output == 1) /* Checking for monochrome/grayscale PostScript output */
-    {
-      /* Poppler does not explicitly support turning colored PDF files into
-	 grayscale PostScript. As a workaround, one could let the "pdftops"
-         command line utility generate PostScript level 1 output which is
-         always grayscale, but output files get huge and printing too 
-         slow.
-	 Recommended solution is to not use Poppler as PDF renderer for
-	 printing, especially if one uses a color PostScript printer and
-	 wants to have the possibility to print jobs also in grayscale.
-	 See the use of the "pdftops-renderer" option in the README file. */
-      /* Example code for PostScript level1 workaround: */
-      /* pdf_argv[1] = (char *)"-level1";
-	 pdf_argv[pdf_argc++] = (char *)"-optimizecolorspace"; */
-      /* Issue a warning message when printing a grayscale job with Poppler */
-      fprintf(stderr, "WARNING: Grayscale/monochrome printing requested for this job but Poppler is not able to convert to grayscale/monochrome PostScript.\n");
-      fprintf(stderr, "WARNING: Use \"pdftops-renderer\" option (see README file) to use Ghostscript or MuPDF for the PDF -> PostScript conversion.\n");
-    }
-    pdf_argv[pdf_argc++] = filename;
-    pdf_argv[pdf_argc++] = (char *)"-";
-  }
-  else if (renderer == GS)
-  {
-   /*
-    * Set resolution to avoid slow processing by the printer when the
-    * resolution of embedded images does not match the printer's resolution
-    */
-    snprintf(resolution, 127, "-r%d", res);
-    pdf_argv[pdf_argc++] = resolution;
-    fprintf(stderr, "DEBUG: Using image rendering resolution %d dpi\n", res);
-   /*
-    * PostScript debug mode: If you send a job with "lpr -o psdebug" Ghostscript
-    * will not compress the pages, so that the PostScript code can get
-    * analysed. This is especially important if a PostScript printer errors or
-    * misbehaves on Ghostscript's output.
-    * On Kyocera and Utax (uses Kyocera hard- and software) printers we always
-    * suppress page compression, to avoid slow processing of raster images.
-    */
-    val = cupsGetOption("psdebug", num_options, options);
-    if ((val && strcasecmp(val, "no") && strcasecmp(val, "off") &&
-	 strcasecmp(val, "false")) ||
-	(make_model[0] &&
-	 (!strncasecmp(make_model, "Kyocera", 7) ||
-	  !strncasecmp(make_model, "Utax", 4))))
-    {
-      fprintf(stderr, "DEBUG: Deactivated compression of pages in Ghostscript's PostScript output (\"psdebug\" debug mode or Kyocera/Utax printer)\n");
-      pdf_argv[pdf_argc++] = (char *)"-dCompressPages=false";
-    }
-   /*
-    * The PostScript interpreters on many printers have bugs which make
-    * the interpreter crash, error out, or otherwise misbehave on too
-    * heavily compressed input files, especially if code with compressed
-    * elements is compressed again. Therefore we reduce compression here.
-    */
-    pdf_argv[pdf_argc++] = (char *)"-dCompressFonts=false";
-    pdf_argv[pdf_argc++] = (char *)"-dNoT3CCITT";
-    if (make_model[0] &&
-	!strncasecmp(make_model, "Brother", 7))
-    {
-      fprintf(stderr, "DEBUG: Deactivation of Ghostscript's image compression for Brother printers to workarounmd PS interpreter bug\n");
-      pdf_argv[pdf_argc++] = (char *)"-dEncodeMonoImages=false";
-      pdf_argv[pdf_argc++] = (char *)"-dEncodeColorImages=false";
-    }
-   /*
-    * Toshiba's PS interpreters have an issue with how we handle
-    * TrueType/Type42 fonts, therefore we add command line options to turn
-    * the TTF outlines into bitmaps, usually Type 3 PostScript fonts, only
-    * large glyphs into normal image data.
-    * See https://bugs.launchpad.net/bugs/978120
-    */
-    if (make_model[0] &&
-	!strncasecmp(make_model, "Toshiba", 7))
-    {
-      fprintf(stderr, "DEBUG: To work around a bug in Toshiba's PS interpreters turn TTF font glyphs into bitmaps, usually Type 3 PS fonts, or images for large characters\n");
-      pdf_argv[pdf_argc++] = (char *)"-dHaveTrueTypes=false";
-    }
-    pdf_argv[pdf_argc++] = (char *)"-dNOINTERPOLATE";
-    pdf_argv[pdf_argc++] = (char *)"-c";
-    if (make_model[0] &&
-	!strncasecmp(make_model, "Toshiba", 7))
-      pdf_argv[pdf_argc++] = (char *)"<< /MaxFontItem 500000 >> setuserparams";
-    pdf_argv[pdf_argc++] = (char *)"save pop";
-    pdf_argv[pdf_argc++] = (char *)"-f";
-    pdf_argv[pdf_argc++] = filename;
-  }
-  else if (renderer == MUPDF)
-  {
-   /*
-    * Add Resolution option to avoid slow processing by the printer when the
-    * resolution of embedded images does not match the printer's resolution
-    */
-    snprintf(resolution, 127, "-r%dx%d", res, res);
-    pdf_argv[pdf_argc++] = resolution;
-   /*
-    * Add input file name
-    */
-    pdf_argv[pdf_argc++] = filename;
-  }
-
-  pdf_argv[pdf_argc] = NULL;
-
-  log_command_line(NULL, pdf_argv);
-
- /*
-  * Do we need post-processing of the PostScript output to work around bugs
-  * of the printer's PostScript interpreter?
-  */
-
-  if ((renderer == PDFTOPS) || (renderer == PDFTOCAIRO) ||
-      (renderer == MUPDF))
-    need_post_proc = 0;
-  else if (renderer == GS)
-    need_post_proc =
-      (make_model[0] &&
-       (!strncasecmp(make_model, "Kyocera", 7) ||
-	!strncasecmp(make_model, "Utax", 4) ||
-	!strncasecmp(make_model, "Brother", 7)) ? 1 : 0);
-  else
-    need_post_proc = 1;
-
- /*
-  * Do we need post-processing of the PostScript output to apply option
-  * settings when doing PPD-less printing?
-  */
-
-  if (!ppd)
-    need_post_proc = 1;
-
- /*
-  * Execute "pdftops/gs/mutool [ | PS post-processing ] | pstops"...
-  */
-
-
- /*
-  * Create a pipe for each pair of subsequent processes. The variables
-  * are named by the receiving process.
-  */
-  
-  if (pipe(pstops_pipe))
-  {
-    perror("DEBUG: Unable to create pipe for pstops");
-
-    exit_status = 1;
-    goto error;
-  }
-
-  if (need_post_proc)
-  {
-    if (pipe(post_proc_pipe))
-    {
-      perror("DEBUG: Unable to create pipe for post-processing");
-
-      exit_status = 1;
-      goto error;
-    }
-  }
-
-  if ((pdf_pid = fork()) == 0)
-  {
-   /*
-    * Child comes here...
-    */
-
-    if (need_post_proc)
-    {
-      dup2(post_proc_pipe[1], 1);
-      close(post_proc_pipe[0]);
-      close(post_proc_pipe[1]);
-    }
-    else
-      dup2(pstops_pipe[1], 1);
-    close(pstops_pipe[0]);
-    close(pstops_pipe[1]);
-
-    if (renderer == PDFTOPS)
-    {
-      execvp(CUPS_POPPLER_PDFTOPS, pdf_argv);
-      perror("DEBUG: Unable to execute pdftops program");
-    }
-    else if (renderer == GS)
-    {
-      execvp(CUPS_GHOSTSCRIPT, pdf_argv);
-      perror("DEBUG: Unable to execute gs program");
-    }
-    else if (renderer == PDFTOCAIRO)
-    {
-      execvp(CUPS_POPPLER_PDFTOCAIRO, pdf_argv);
-      perror("DEBUG: Unable to execute pdftocairo program");
-    }
-    else if (renderer == ACROREAD)
-    {
-      /*
-       * use filename as stdin for acroread to force output to stdout
-       */
-
-      if ((fd = open(filename, O_RDONLY)))
-      {
-        dup2(fd, 0);
-        close(fd);
-      }
-     
-      execvp(CUPS_ACROREAD, pdf_argv);
-      perror("DEBUG: Unable to execute acroread program");
-    }
-    else if (renderer == MUPDF)
-    {
-      execvp(CUPS_MUTOOL, pdf_argv);
-      perror("DEBUG: Unable to execute mutool program");
-    }
-
-    exit(1);
-  }
-  else if (pdf_pid < 0)
-  {
-   /*
-    * Unable to fork!
-    */
-
-    if (renderer == PDFTOPS)
-      perror("DEBUG: Unable to execute pdftops program");
-    else if (renderer == GS)
-      perror("DEBUG: Unable to execute gs program");
-    else if (renderer == PDFTOCAIRO)
-      perror("DEBUG: Unable to execute pdftocairo program");
-    else if (renderer == ACROREAD)
-      perror("DEBUG: Unable to execute acroread program");
-    else if (renderer == MUPDF)
-      perror("DEBUG: Unable to execute mutool program");
-
-    exit_status = 1;
-    goto error;
-  }
-
-  fprintf(stderr, "DEBUG: Started filter %s (PID %d)\n", pdf_argv[0], pdf_pid);
-
-  if (need_post_proc)
-  {
-    if ((post_proc_pid = fork()) == 0)
-    {
-     /*
-      * Child comes here...
-      */
-
-      dup2(post_proc_pipe[0], 0);
-      close(post_proc_pipe[0]);
-      close(post_proc_pipe[1]);
-      dup2(pstops_pipe[1], 1);
-      close(pstops_pipe[0]);
-      close(pstops_pipe[1]);
-
-      fp = cupsFileStdin();
-
-      if (renderer == ACROREAD)
-      {
-       /*
-        * Set %Title and %For from filter arguments since acroread inserts
-        * garbage for these when using -toPostScript
-        */
-
-        while ((bytes = cupsFileGetLine(fp, buffer, sizeof(buffer))) > 0 &&
-               strncmp(buffer, "%%BeginProlog", 13))
-        {
-          if (strncmp(buffer, "%%Title", 7) == 0)
-            printf("%%%%Title: %s\n", argv[3]);
-          else if (strncmp(buffer, "%%For", 5) == 0)
-            printf("%%%%For: %s\n", argv[2]);
-          else
-            printf("%s", buffer);
-        }
-
-       /*
-	* Copy the rest of the file
-	*/
-	while ((bytes = cupsFileRead(fp, buffer, sizeof(buffer))) > 0)
-	  fwrite(buffer, 1, bytes, stdout);
-      }
-      else
-      {
-
-       /*
-	* Copy everything until after initial comments (Prolog section)
-	*/
-	while ((bytes = cupsFileGetLine(fp, buffer, sizeof(buffer))) > 0 &&
-	       strncmp(buffer, "%%BeginProlog", 13) &&
-	       strncmp(buffer, "%%EndProlog", 11) &&
-	       strncmp(buffer, "%%BeginSetup", 12) &&
-	       strncmp(buffer, "%%Page:", 7))
-	  printf("%s", buffer);
-
-	if (bytes > 0)
-	{
-	 /*
-	  * Insert PostScript interpreter bug fix code in the beginning of
-	  * the Prolog section (before the first active PostScript code)
-	  */
-	  if (strncmp(buffer, "%%BeginProlog", 13))
-	  {
-	    /* No Prolog section, create one */
-	    fprintf(stderr, "DEBUG: Adding Prolog section for workaround PostScript code\n");
-	    puts("%%BeginProlog");
-	  }
-	  else
-	    printf("%s", buffer);
-
-	  if (renderer == GS && make_model[0])
-	  {
-
-	   /*
-	    * Kyocera (and Utax) printers have a bug in their PostScript
-	    * interpreter making them crashing on PostScript input data
-	    * generated by Ghostscript's "ps2write" output device.
-	    *
-	    * The problem can be simply worked around by preceding the
-	    * PostScript code with some extra bits.
-	    *
-	    * See https://bugs.launchpad.net/bugs/951627
-	    *
-	    * In addition, at least some of Kyocera's PostScript printers are
-	    * very slow on rendering images which request interpolation. So we
-	    * also add some code to eliminate interpolation requests.
-	    *
-	    * See https://bugs.launchpad.net/bugs/1026974
-	    */
-
-	    if (!strncasecmp(make_model, "Kyocera", 7) ||
-		!strncasecmp(make_model, "Utax", 4))
-	    {
-	      fprintf(stderr, "DEBUG: Inserted workaround PostScript code for Kyocera and Utax printers\n");
-	      puts("% ===== Workaround insertion by pdftops CUPS filter =====");
-	      puts("% Kyocera's/Utax's PostScript interpreter crashes on early name binding,");
-	      puts("% so eliminate all \"bind\"s by redefining \"bind\" to no-op");
-	      puts("/bind {} bind def");
-	      puts("% Some Kyocera and Utax printers have an unacceptably slow implementation");
-	      puts("% of image interpolation.");
-	      puts("/image");
-	      puts("{");
-	      puts("  dup /Interpolate known");
-	      puts("  {");
-	      puts("    dup /Interpolate undef");
-	      puts("  } if");
-	      puts("  systemdict /image get exec");
-	      puts("} def");
-	      puts("% =====");
-	    }
-
-	   /*
-	    * Brother printers have a bug in their PostScript interpreter
-	    * making them printing one blank page if PostScript input data
-	    * generated by Ghostscript's "ps2write" output device is used.
-	    *
-	    * The problem can be simply worked around by preceding the PostScript
-	    * code with some extra bits.
-	    *
-	    * See https://bugs.launchpad.net/bugs/950713
-	    */
-
-	    else if (!strncasecmp(make_model, "Brother", 7))
-	    {
-	      fprintf(stderr, "DEBUG: Inserted workaround PostScript code for Brother printers\n");
-	      puts("% ===== Workaround insertion by pdftops CUPS filter =====");
-	      puts("% Brother's PostScript interpreter spits out the current page");
-	      puts("% and aborts the job on the \"currenthalftone\" operator, so redefine");
-	      puts("% it to null");
-	      puts("/currenthalftone {//null} bind def");
-	      puts("/orig.sethalftone systemdict /sethalftone get def");
-	      puts("/sethalftone {dup //null eq not {//orig.sethalftone}{pop} ifelse} bind def");
-	      puts("% =====");
-	    }
-	  }
-
-	  if (strncmp(buffer, "%%BeginProlog", 13))
-	  {
-	    /* Close newly created Prolog section */
-	    if (strncmp(buffer, "%%EndProlog", 11))
-	      puts("%%EndProlog");
-	    printf("%s", buffer);
-	  }
-
-	  if (!ppd)
-	  {
-	   /*
-	    * Copy everything until the setup section
-	    */
-	    while (bytes > 0 &&
-		   strncmp(buffer, "%%BeginSetup", 12) &&
-		   strncmp(buffer, "%%EndSetup", 10) &&
-		   strncmp(buffer, "%%Page:", 7))
-	    {
-	      bytes = cupsFileGetLine(fp, buffer, sizeof(buffer));
-	      if (strncmp(buffer, "%%Page:", 7) &&
-		  strncmp(buffer, "%%EndSetup", 10))
-		printf("%s", buffer);
-	    }
-	  
-	    if (bytes > 0)
-	    {
-	     /*
-	      * Insert option PostScript code in Setup section
-	      */
-	      if (strncmp(buffer, "%%BeginSetup", 12))
-	      {
-		/* No Setup section, create one */
-		fprintf(stderr, "DEBUG: Adding Setup section for option PostScript code\n");
-		puts("%%BeginSetup");
-	      }
-
-	     /*
-	      * Duplex
-	      */
-	      duplex = 0;
-	      tumble = 0;
-	      if ((val = cupsGetOption("sides", num_options, options)) != NULL ||
-		  (val = cupsGetOption("Duplex", num_options, options)) != NULL)
-	      {
-		if (!strcasecmp(val, "On") ||
-			 !strcasecmp(val, "True") || !strcasecmp(val, "Yes") ||
-			 !strncasecmp(val, "two-sided", 9) ||
-			 !strncasecmp(val, "TwoSided", 8) ||
-			 !strncasecmp(val, "Duplex", 6))
-		{
-		  duplex = 1;
-		  if (!strncasecmp(val, "DuplexTumble", 12))
-		    tumble = 1;
-		}
-	      }
-
-	      if ((val = cupsGetOption("sides", num_options, options)) != NULL ||
-		  (val = cupsGetOption("Tumble", num_options, options)) != NULL)
-	      {
-		if (!strcasecmp(val, "None") || !strcasecmp(val, "Off") ||
-		    !strcasecmp(val, "False") || !strcasecmp(val, "No") ||
-		    !strcasecmp(val, "one-sided") || !strcasecmp(val, "OneSided") ||
-		    !strcasecmp(val, "two-sided-long-edge") ||
-		    !strcasecmp(val, "TwoSidedLongEdge") ||
-		    !strcasecmp(val, "DuplexNoTumble"))
-		  tumble = 0;
-		else if (!strcasecmp(val, "On") ||
-			 !strcasecmp(val, "True") || !strcasecmp(val, "Yes") ||
-			 !strcasecmp(val, "two-sided-short-edge") ||
-			 !strcasecmp(val, "TwoSidedShortEdge") ||
-			 !strcasecmp(val, "DuplexTumble"))
-		  tumble = 1;
-	      }
-
-	      if (duplex)
-	      {
-		if (tumble)
-		  puts("<</Duplex true /Tumble true>> setpagedevice");
-		else
-		  puts("<</Duplex true /Tumble false>> setpagedevice");
-	      }
-	      else
-		puts("<</Duplex false>> setpagedevice");
-
-	     /*
-	      * Resolution
-	      */
-	      if ((xres > 0) && (yres > 0))
-		printf("<</HWResolution[%d %d]>> setpagedevice\n", xres, yres);
-
-	     /*
-	      * InputSlot/MediaSource
-	      */
-	      if ((val = cupsGetOption("media-position", num_options,
-				       options)) != NULL ||
-		  (val = cupsGetOption("MediaPosition", num_options,
-				       options)) != NULL ||
-		  (val = cupsGetOption("media-source", num_options,
-				       options)) != NULL ||
-		  (val = cupsGetOption("MediaSource", num_options,
-				       options)) != NULL ||
-		  (val = cupsGetOption("InputSlot", num_options,
-				       options)) != NULL)
-	      {
-		if (!strncasecmp(val, "Auto", 4) ||
-		    !strncasecmp(val, "Default", 7))
-		  puts("<</ManualFeed false /MediaPosition 7>> setpagedevice");
-		else if (!strcasecmp(val, "Main"))
-		  puts("<</MediaPosition 0 /ManualFeed false>> setpagedevice");
-		else if (!strcasecmp(val, "Alternate"))
-		  puts("<</MediaPosition 1 /ManualFeed false>> setpagedevice");
-		else if (!strcasecmp(val, "Manual"))
-		  puts("<</MediaPosition 3 /ManualFeed true>> setpagedevice");
-		else if (!strcasecmp(val, "Top"))
-		  puts("<</MediaPosition 0 /ManualFeed false>> setpagedevice");
-		else if (!strcasecmp(val, "Bottom"))
-		  puts("<</MediaPosition 1 /ManualFeed false>> setpagedevice");
-		else if (!strcasecmp(val, "ByPassTray"))
-		  puts("<</MediaPosition 3 /ManualFeed false>> setpagedevice");
-		else if (!strcasecmp(val, "Tray1"))
-		  puts("<</MediaPosition 3 /ManualFeed false>> setpagedevice");
-		else if (!strcasecmp(val, "Tray2"))
-		  puts("<</MediaPosition 0 /ManualFeed false>> setpagedevice");
-		else if (!strcasecmp(val, "Tray3"))
-		  puts("<</MediaPosition 1 /ManualFeed false>> setpagedevice");
-	      }
-
-	     /*
-	      * ColorModel
-	      */
-	      if ((val = cupsGetOption("pwg-raster-document-type", num_options,
-				       options)) != NULL ||
-		  (val = cupsGetOption("PwgRasterDocumentType", num_options,
-				       options)) != NULL ||
-		  (val = cupsGetOption("print-color-mode", num_options,
-				       options)) != NULL ||
-		  (val = cupsGetOption("PrintColorMode", num_options,
-				       options)) != NULL ||
-		  (val = cupsGetOption("color-space", num_options,
-				       options)) != NULL ||
-		  (val = cupsGetOption("ColorSpace", num_options,
-				       options)) != NULL ||
-		  (val = cupsGetOption("color-model", num_options,
-				       options)) != NULL ||
-		  (val = cupsGetOption("ColorModel", num_options,
-				       options)) != NULL)
-	      {
-		if (!strncasecmp(val, "Black", 5))
-		  puts("<</ProcessColorModel /DeviceGray>> setpagedevice");
-		else if (!strncasecmp(val, "Cmyk", 4))
-		  puts("<</ProcessColorModel /DeviceCMYK>> setpagedevice");
-		else if (!strncasecmp(val, "Cmy", 3))
-		  puts("<</ProcessColorModel /DeviceCMY>> setpagedevice");
-		else if (!strncasecmp(val, "Rgb", 3))
-		  puts("<</ProcessColorModel /DeviceRGB>> setpagedevice");
-		else if (!strncasecmp(val, "Gray", 4))
-		  puts("<</ProcessColorModel /DeviceGray>> setpagedevice");
-		else if (!strncasecmp(val, "Color", 5))
-		  puts("<</ProcessColorModel /DeviceRGB>> setpagedevice");
-	      }
-
-	      if (strncmp(buffer, "%%BeginSetup", 12))
-	      {
-		/* Close newly created Setup section */
-		if (strncmp(buffer, "%%EndSetup", 10))
-		  puts("%%EndSetup");
-		printf("%s", buffer);
-	      }
-	    }
-	  }
-
-	 /*
-	  * Copy the rest of the file
-	  */
-	  while ((bytes = cupsFileRead(fp, buffer, sizeof(buffer))) > 0)
-	    fwrite(buffer, 1, bytes, stdout);
-	}
-      }
-
-      exit(0);
-    }
-    else if (post_proc_pid < 0)
-    {
-     /*
-      * Unable to fork!
-      */
-
-      perror("DEBUG: Unable to execute post-processing process");
-
-      exit_status = 1;
-      goto error;
-    }
-
-    fprintf(stderr, "DEBUG: Started post-processing (PID %d)\n", post_proc_pid);
-  }
-
-  if ((pstops_pid = fork()) == 0)
-  {
-   /*
-    * Child comes here...
-    */
-
-    dup2(pstops_pipe[0], 0);
-    close(pstops_pipe[0]);
-    close(pstops_pipe[1]);
-    if (need_post_proc)
-    {
-      close(post_proc_pipe[0]);
-      close(post_proc_pipe[1]);
-    }
-
-    execvp(pstops_path, pstops_argv);
-    perror("DEBUG: Unable to execute pstops program");
-
-    exit(1);
-  }
-  else if (pstops_pid < 0)
-  {
-   /*
-    * Unable to fork!
-    */
-
-    perror("DEBUG: Unable to execute pstops program");
-
-    exit_status = 1;
-    goto error;
-  }
-
-  fprintf(stderr, "DEBUG: Started filter pstops (PID %d)\n", pstops_pid);
-
-  close(pstops_pipe[0]);
-  close(pstops_pipe[1]);
-  if (need_post_proc)
-  {
-    close(post_proc_pipe[0]);
-    close(post_proc_pipe[1]);
-  }
-
- /*
-  * Wait for the child processes to exit...
-  */
-
-  wait_children = 2 + need_post_proc;
-
-  while (wait_children > 0)
-  {
-   /*
-    * Wait until we get a valid process ID or the job is canceled...
-    */
-
-    while ((wait_pid = wait(&wait_status)) < 0 && errno == EINTR)
-    {
-      if (job_canceled)
-      {
-	kill(pdf_pid, SIGTERM);
-	if (need_post_proc)
-	  kill(post_proc_pid, SIGTERM);
-	kill(pstops_pid, SIGTERM);
-
-	job_canceled = 0;
-      }
-    }
-
-    if (wait_pid < 0)
-      break;
-
-    wait_children --;
-
-   /*
-    * Report child status...
-    */
-
-    if (wait_status)
-    {
-      if (WIFEXITED(wait_status))
-      {
-	exit_status = WEXITSTATUS(wait_status);
-
-	fprintf(stderr, "DEBUG: PID %d (%s) stopped with status %d!\n",
-		wait_pid,
-		wait_pid == pdf_pid ?
-		(renderer == PDFTOPS ? "pdftops" :
-                (renderer == PDFTOCAIRO ? "pdftocairo" :
-		(renderer == GS ? "gs" :
-		(renderer == ACROREAD ? "acroread" :
-		(renderer == MUPDF ? "mutool" :
-		 "Unknown renderer"))))) :
-		(wait_pid == pstops_pid ? "pstops" :
-		(wait_pid == post_proc_pid ? "Post-processing" :
-		 "Unknown process")),
-		exit_status);
-      }
-      else if (WTERMSIG(wait_status) == SIGTERM)
-      {
-	fprintf(stderr,
-		"DEBUG: PID %d (%s) was terminated normally with signal %d!\n",
-		wait_pid,
-		wait_pid == pdf_pid ?
-		(renderer == PDFTOPS ? "pdftops" :
-                (renderer == PDFTOCAIRO ? "pdftocairo" :
-		(renderer == GS ? "gs" :
-		(renderer == ACROREAD ? "acroread" :
-		(renderer == MUPDF ? "mutool" :
-		 "Unknown renderer"))))) :
-		(wait_pid == pstops_pid ? "pstops" :
-		(wait_pid == post_proc_pid ? "Post-processing" :
-		 "Unknown process")),
-		exit_status);
-      }
-      else
-      {
-	exit_status = WTERMSIG(wait_status);
-
-	fprintf(stderr, "DEBUG: PID %d (%s) crashed on signal %d!\n",
-		wait_pid,
-		wait_pid == pdf_pid ?
-		(renderer == PDFTOPS ? "pdftops" :
-                (renderer == PDFTOCAIRO ? "pdftocairo" :
-		(renderer == GS ? "gs" :
-		(renderer == ACROREAD ? "acroread" :
-		(renderer == MUPDF ? "mutool" :
-		 "Unknown renderer"))))) :
-		(wait_pid == pstops_pid ? "pstops" :
-		(wait_pid == post_proc_pid ? "Post-processing" :
-		 "Unknown process")),
-		exit_status);
-      }
-    }
-    else
-    {
-      fprintf(stderr, "DEBUG: PID %d (%s) exited with no errors.\n",
-	      wait_pid,
-	      wait_pid == pdf_pid ?
-	      (renderer == PDFTOPS ? "pdftops" :
-	      (renderer == PDFTOCAIRO ? "pdftocairo" :
-	      (renderer == GS ? "gs" :
-	      (renderer == ACROREAD ? "acroread" :
-	      (renderer == MUPDF ? "mutool" :
-	       "Unknown renderer"))))) :
-	      (wait_pid == pstops_pid ? "pstops" :
-	      (wait_pid == post_proc_pid ? "Post-processing" :
-	       "Unknown process")));
-    }
-  }
-
- /*
-  * Cleanup and exit...
-  */
-
-  error:
-
-  if (tempfile[0])
-    unlink(tempfile);
-
-  return (exit_status);
-}
-
-
-/*
- * 'cancel_job()' - Flag the job as canceled.
- */
-
-static void
-cancel_job(int sig)			/* I - Signal number (unused) */
-{
-  (void)sig;
-
-  job_canceled = 1;
-}
-
diff --git a/filter/pdftoraster.cxx b/filter/pdftoraster.cxx
deleted file mode 100644
index 4b1b846..0000000
--- a/filter/pdftoraster.cxx
+++ /dev/null
@@ -1,2171 +0,0 @@
-/*
-Copyright (c) 2008-2011 BBR Inc.  All rights reserved.
-Copyright (c) 2012-2019 by Till Kamppeter
-Copyright (c) 2019 by Tanmay Anand.
-
-Permission is hereby granted, free of charge, to any person obtaining
-a copy of this software and associated documentation files (the
-"Software"), to deal in the Software without restriction, including
-without limitation the rights to use, copy, modify, merge, publish,
-distribute, sublicense, and/or sell copies of the Software, and to
-permit persons to whom the Software is furnished to do so, subject to
-the following conditions:
-
-The above copyright notice and this permission notice shall be included
-in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-*/
-/*
- pdftoraster.cc
- pdf to raster filter
-*/
-
-#include <config.h>
-#include <cups/cups.h>
-#if (CUPS_VERSION_MAJOR > 1) || (CUPS_VERSION_MINOR > 6)
-#define HAVE_CUPS_1_7 1
-#endif
-
-#define USE_CMS
-
-#include <stdio.h>
-#include <stdlib.h>
-#ifdef HAVE_CPP_POPPLER_VERSION_H
-#include <poppler/cpp/poppler-version.h>
-#endif
-#include <cups/ppd.h>
-#include <stdarg.h>
-#include <cups/raster.h>
-#include <cupsfilters/image.h>
-#include <cupsfilters/raster.h>
-#include <cupsfilters/colormanager.h>
-#include <strings.h>
-#include <math.h>
-#include <poppler/cpp/poppler-document.h>
-#include <poppler/cpp/poppler-page.h>
-#include <poppler/cpp/poppler-global.h>
-#include <poppler/cpp/poppler-image.h>
-#include <poppler/cpp/poppler-page-renderer.h>
-#include <poppler/cpp/poppler-rectangle.h>
-#ifdef USE_LCMS1
-#include <lcms.h>
-#define cmsColorSpaceSignature icColorSpaceSignature
-#define cmsSetLogErrorHandler cmsSetErrorHandler
-#define cmsToneCurve LPGAMMATABLE
-#define cmsSigXYZData icSigXYZData
-#define cmsSigLuvData icSigLuvData
-#define cmsSigLabData icSigLabData
-#define cmsSigYCbCrData icSigYCbCrData
-#define cmsSigYxyData icSigYxyData
-#define cmsSigRgbData icSigRgbData
-#define cmsSigHsvData icSigHsvData
-#define cmsSigHlsData icSigHlsData
-#define cmsSigCmyData icSigCmyData
-#define cmsSig3colorData icSig3colorData
-#define cmsSigGrayData icSigGrayData
-#define cmsSigCmykData icSigCmykData
-#define cmsSig4colorData icSig4colorData
-#define cmsSig2colorData icSig2colorData
-#define cmsSig5colorData icSig5colorData
-#define cmsSig6colorData icSig6colorData
-#define cmsSig7colorData icSig7colorData
-#define cmsSig8colorData icSig8colorData
-#define cmsSig9colorData icSig9colorData
-#define cmsSig10colorData icSig10colorData
-#define cmsSig11colorData icSig11colorData
-#define cmsSig12colorData icSig12colorData
-#define cmsSig13colorData icSig13colorData
-#define cmsSig14colorData icSig14colorData
-#define cmsSig15colorData icSig15colorData
-#else
-#include <lcms2.h>
-#endif
-
-#define MAX_CHECK_COMMENT_LINES	20
-#define MAX_BYTES_PER_PIXEL 32
-
-namespace {
-  typedef unsigned char *(*ConvertLineFunc)(unsigned char *src,
-    unsigned char *dst, unsigned int row, unsigned int plane,
-    unsigned int pixels, unsigned int size);
-  typedef unsigned char *(*ConvertCSpaceFunc)(unsigned char *src,
-    unsigned char *pixelBuf, unsigned int x, unsigned int y);
-  typedef unsigned char *(*ConvertBitsFunc)(unsigned char *src,
-    unsigned char *dst, unsigned int x, unsigned int y);
-  typedef void (*WritePixelFunc)(unsigned char *dst,
-    unsigned int plane, unsigned int pixeli, unsigned char *pixelBuf);
-
-  int exitCode = 0;
-  int pwgraster = 0;
-  int deviceCopies = 1;
-  bool deviceCollate = false;
-  cups_page_header2_t header;
-  ppd_file_t *ppd = 0;
-  char pageSizeRequested[64];
-  unsigned int bitmapoffset[2];
-  unsigned int popplerBitsPerPixel;
-  unsigned int popplerNumColors;
-  /* image swapping */
-  bool swap_image_x = false;
-  bool swap_image_y = false;
-  /* margin swapping */
-  bool swap_margin_x = false;
-  bool swap_margin_y = false;
-  bool allocLineBuf = false;
-  ConvertLineFunc convertLineOdd;
-  ConvertLineFunc convertLineEven;
-  ConvertCSpaceFunc convertCSpace;
-  ConvertBitsFunc convertBits;
-  WritePixelFunc writePixel;
-  unsigned int nplanes;
-  unsigned int nbands;
-  unsigned int bytesPerLine; /* number of bytes per line */
-                        /* Note: When CUPS_ORDER_BANDED,
-                           cupsBytesPerLine = bytesPerLine*cupsNumColors */
-  unsigned char revTable[256] = {
-0x00,0x80,0x40,0xc0,0x20,0xa0,0x60,0xe0,0x10,0x90,0x50,0xd0,0x30,0xb0,0x70,0xf0,
-0x08,0x88,0x48,0xc8,0x28,0xa8,0x68,0xe8,0x18,0x98,0x58,0xd8,0x38,0xb8,0x78,0xf8,
-0x04,0x84,0x44,0xc4,0x24,0xa4,0x64,0xe4,0x14,0x94,0x54,0xd4,0x34,0xb4,0x74,0xf4,
-0x0c,0x8c,0x4c,0xcc,0x2c,0xac,0x6c,0xec,0x1c,0x9c,0x5c,0xdc,0x3c,0xbc,0x7c,0xfc,
-0x02,0x82,0x42,0xc2,0x22,0xa2,0x62,0xe2,0x12,0x92,0x52,0xd2,0x32,0xb2,0x72,0xf2,
-0x0a,0x8a,0x4a,0xca,0x2a,0xaa,0x6a,0xea,0x1a,0x9a,0x5a,0xda,0x3a,0xba,0x7a,0xfa,
-0x06,0x86,0x46,0xc6,0x26,0xa6,0x66,0xe6,0x16,0x96,0x56,0xd6,0x36,0xb6,0x76,0xf6,
-0x0e,0x8e,0x4e,0xce,0x2e,0xae,0x6e,0xee,0x1e,0x9e,0x5e,0xde,0x3e,0xbe,0x7e,0xfe,
-0x01,0x81,0x41,0xc1,0x21,0xa1,0x61,0xe1,0x11,0x91,0x51,0xd1,0x31,0xb1,0x71,0xf1,
-0x09,0x89,0x49,0xc9,0x29,0xa9,0x69,0xe9,0x19,0x99,0x59,0xd9,0x39,0xb9,0x79,0xf9,
-0x05,0x85,0x45,0xc5,0x25,0xa5,0x65,0xe5,0x15,0x95,0x55,0xd5,0x35,0xb5,0x75,0xf5,
-0x0d,0x8d,0x4d,0xcd,0x2d,0xad,0x6d,0xed,0x1d,0x9d,0x5d,0xdd,0x3d,0xbd,0x7d,0xfd,
-0x03,0x83,0x43,0xc3,0x23,0xa3,0x63,0xe3,0x13,0x93,0x53,0xd3,0x33,0xb3,0x73,0xf3,
-0x0b,0x8b,0x4b,0xcb,0x2b,0xab,0x6b,0xeb,0x1b,0x9b,0x5b,0xdb,0x3b,0xbb,0x7b,0xfb,
-0x07,0x87,0x47,0xc7,0x27,0xa7,0x67,0xe7,0x17,0x97,0x57,0xd7,0x37,0xb7,0x77,0xf7,
-0x0f,0x8f,0x4f,0xcf,0x2f,0xaf,0x6f,0xef,0x1f,0x9f,0x5f,0xdf,0x3f,0xbf,0x7f,0xff
-  };
-  unsigned int dither1[16][16] = {
-    {0,128,32,160,8,136,40,168,2,130,34,162,10,138,42,170},
-    {192,64,224,96,200,72,232,104,194,66,226,98,202,74,234,106},
-    {48,176,16,144,56,184,24,152,50,178,18,146,58,186,26,154},
-    {240,112,208,80,248,120,216,88,242,114,210,82,250,122,218,90},
-    {12,140,44,172,4,132,36,164,14,142,46,174,6,134,38,166},
-    {204,76,236,108,196,68,228,100,206,78,238,110,198,70,230,102},
-    {60,188,28,156,52,180,20,148,62,190,30,158,54,182,22,150},
-    {252,124,220,92,244,116,212,84,254,126,222,94,246,118,214,86},
-    {3,131,35,163,11,139,43,171,1,129,33,161,9,137,41,169},
-    {195,67,227,99,203,75,235,107,193,65,225,97,201,73,233,105},
-    {51,179,19,147,59,187,27,155,49,177,17,145,57,185,25,153},
-    {243,115,211,83,251,123,219,91,241,113,209,81,249,121,217,89},
-    {15,143,47,175,7,135,39,167,13,141,45,173,5,133,37,165},
-    {207,79,239,111,199,71,231,103,205,77,237,109,197,69,229,101},
-    {63,191,31,159,55,183,23,151,61,189,29,157,53,181,21,149},
-    {255,127,223,95,247,119,215,87,253,125,221,93,245,117,213,85}
-  };
-  unsigned int dither2[8][8] = {
-    {0,32,8,40,2,34,10,42},
-    {48,16,56,24,50,18,58,26},
-    {12,44,4,36,14,46,6,38},
-    {60,28,52,20,62,30,54,22},
-    {3,35,11,43,1,33,9,41},
-    {51,19,59,27,49,17,57,25},
-    {15,47,7,39,13,45,5,37},
-    {63,31,55,23,61,29,53,21}
-  };
-  unsigned int dither4[4][4] = {
-    {0,8,2,10},
-    {12,4,14,6},
-    {3,11,1,9},
-    {15,7,13,5}
-  };
-
-  /* for color profiles */
-  cmsHPROFILE colorProfile = NULL;
-  cmsHPROFILE popplerColorProfile = NULL;
-  cmsHTRANSFORM colorTransform = NULL;
-  cmsCIEXYZ D65WhitePoint;
-  int renderingIntent = INTENT_PERCEPTUAL;
-  int cm_disabled = 0;
-  cm_calibration_t cm_calibrate;
-}
-
-cmsCIExyY adobergb_wp()
-{
-    double * xyY = cmWhitePointAdobeRgb();
-    cmsCIExyY wp;
-
-    wp.x = xyY[0];
-    wp.y = xyY[1];
-    wp.Y = xyY[2];
-
-    return wp;
-}
-
-cmsCIExyY sgray_wp()
-{
-    double * xyY = cmWhitePointSGray();
-    cmsCIExyY wp;
-
-    wp.x = xyY[0];
-    wp.y = xyY[1];
-    wp.Y = xyY[2];
-
-    return wp;
-}
-
-cmsCIExyYTRIPLE adobergb_matrix()
-{
-    cmsCIExyYTRIPLE m;
-
-    double * matrix = cmMatrixAdobeRgb();
-
-    m.Red.x = matrix[0];
-    m.Red.y = matrix[1];
-    m.Red.Y = matrix[2];
-    m.Green.x = matrix[3];
-    m.Green.y = matrix[4];
-    m.Green.Y = matrix[5];
-    m.Blue.x = matrix[6];
-    m.Blue.y = matrix[7];
-    m.Blue.Y = matrix[8];
-
-    return m;
-}
-
-cmsHPROFILE adobergb_profile()
-{
-    cmsHPROFILE adobergb;
-
-    cmsCIExyY wp;
-    cmsCIExyYTRIPLE primaries;
-
-#if USE_LCMS1
-    cmsToneCurve Gamma = cmsBuildGamma(256, 2.2);
-    cmsToneCurve Gamma3[3];
-#else
-    cmsToneCurve * Gamma = cmsBuildGamma(NULL, 2.2);
-    cmsToneCurve * Gamma3[3];
-#endif
-    Gamma3[0] = Gamma3[1] = Gamma3[2] = Gamma;
-
-    // Build AdobeRGB profile
-    primaries = adobergb_matrix();
-    wp = adobergb_wp();
-    adobergb = cmsCreateRGBProfile(&wp, &primaries, Gamma3);
-
-    return adobergb;
-}
-
-cmsHPROFILE sgray_profile()
-{
-    cmsHPROFILE sgray;
-
-    cmsCIExyY wp;
-
-#if USE_LCMS1
-    cmsToneCurve Gamma = cmsBuildGamma(256, 2.2);
-#else
-    cmsToneCurve * Gamma = cmsBuildGamma(NULL, 2.2);
-#endif
-    // Build sGray profile
-    wp = sgray_wp();
-    sgray = cmsCreateGrayProfile(&wp, Gamma);
-
-    return sgray;
-}
-
-
-#ifdef USE_LCMS1
-static int lcmsErrorHandler(int ErrorCode, const char *ErrorText)
-{
-  fprintf(stderr, "ERROR: %s\n",ErrorText);
-  return 1;
-}
-#else
-static void lcmsErrorHandler(cmsContext contextId, cmsUInt32Number ErrorCode,
-   const char *ErrorText)
-{
-  fprintf(stderr, "ERROR: %s\n",ErrorText);
-}
-#endif
-
-
-
-static void  handleRqeuiresPageRegion() {
-  ppd_choice_t *mf;
-  ppd_choice_t *is;
-  ppd_attr_t *rregions = NULL;
-  ppd_size_t *size;
-
-  if ((size = ppdPageSize(ppd,NULL)) == NULL) return;
-  mf = ppdFindMarkedChoice(ppd,"ManualFeed");
-  if ((is = ppdFindMarkedChoice(ppd,"InputSlot")) != NULL) {
-    rregions = ppdFindAttr(ppd,"RequiresPageRegion",is->choice);
-  }
-  if (rregions == NULL) {
-    rregions = ppdFindAttr(ppd,"RequiresPageRegion","All");
-  }
-  if (!strcasecmp(size->name,"Custom") || (!mf && !is) ||
-      (mf && !strcasecmp(mf->choice,"False") &&
-       (!is || (is->code && !is->code[0]))) ||
-      (!rregions && ppd->num_filters > 0)) {
-    ppdMarkOption(ppd,"PageSize",size->name);
-  } else if (rregions && rregions->value
-      && !strcasecmp(rregions->value,"True")) {
-    ppdMarkOption(ppd,"PageRegion",size->name);
-  } else {
-    ppd_choice_t *page;
-
-    if ((page = ppdFindMarkedChoice(ppd,"PageSize")) != NULL) {
-      page->marked = 0;
-      cupsArrayRemove(ppd->marked,page);
-    }
-    if ((page = ppdFindMarkedChoice(ppd,"PageRegion")) != NULL) {
-      page->marked = 0;
-      cupsArrayRemove(ppd->marked, page);
-    }
-  }
-}
-
-static void parseOpts(int argc, char **argv)
-{
-  int num_options = 0;
-  cups_option_t *options = 0;
-  char *profile = 0;
-  const char *t = NULL;
-  ppd_attr_t *attr;
-
-  if (argc < 6 || argc > 7) {
-    fprintf(stderr, "ERROR: Usage: %s job-id user title copies options [file]\n",
-	    argv[0]);
-    exit(1);
-  }
-
-#ifdef HAVE_CUPS_1_7
-  t = getenv("FINAL_CONTENT_TYPE");
-  if (t && strcasestr(t, "pwg"))
-    pwgraster = 1;
-#endif /* HAVE_CUPS_1_7 */
-
-  ppd = ppdOpenFile(getenv("PPD"));
-  if (ppd == NULL)
-    fprintf(stderr, "DEBUG: PPD file is not specified.\n");
-  if (ppd)
-    ppdMarkDefaults(ppd);
-  options = NULL;
-  num_options = cupsParseOptions(argv[5],0,&options);
-  if (ppd) {
-    cupsMarkOptions(ppd,num_options,options);
-    handleRqeuiresPageRegion();
-    cupsRasterInterpretPPD(&header,ppd,num_options,options,0);
-    attr = ppdFindAttr(ppd,"pdftorasterRenderingIntent",NULL);
-    if (attr != NULL && attr->value != NULL) {
-      if (strcasecmp(attr->value,"PERCEPTUAL") != 0) {
-	renderingIntent = INTENT_PERCEPTUAL;
-      } else if (strcasecmp(attr->value,"RELATIVE_COLORIMETRIC") != 0) {
-	renderingIntent = INTENT_RELATIVE_COLORIMETRIC;
-      } else if (strcasecmp(attr->value,"SATURATION") != 0) {
-	renderingIntent = INTENT_SATURATION;
-      } else if (strcasecmp(attr->value,"ABSOLUTE_COLORIMETRIC") != 0) {
-	renderingIntent = INTENT_ABSOLUTE_COLORIMETRIC;
-      }
-    }
-    if (header.Duplex) {
-      /* analyze options relevant to Duplex */
-      const char *backside = "";
-      /* APDuplexRequiresFlippedMargin */
-      enum {
-	FM_NO, FM_FALSE, FM_TRUE
-      } flippedMargin = FM_NO;
-
-      attr = ppdFindAttr(ppd,"cupsBackSide",NULL);
-      if (attr != NULL && attr->value != NULL) {
-	ppd->flip_duplex = 0;
-	backside = attr->value;
-      } else if (ppd->flip_duplex) {
-	backside = "Rotated"; /* compatible with Max OS and GS 8.71 */
-      }
-
-      attr = ppdFindAttr(ppd,"APDuplexRequiresFlippedMargin",NULL);
-      if (attr != NULL && attr->value != NULL) {
-	if (strcasecmp(attr->value,"true") == 0) {
-	  flippedMargin = FM_TRUE;
-	} else {
-	  flippedMargin = FM_FALSE;
-	}
-      }
-      if (strcasecmp(backside,"ManualTumble") == 0 && header.Tumble) {
-	swap_image_x = swap_image_y = true;
-	swap_margin_x = swap_margin_y = true;
-	if (flippedMargin == FM_TRUE) {
-	  swap_margin_y = false;
-	}
-      } else if (strcasecmp(backside,"Rotated") == 0 && !header.Tumble) {
-	swap_image_x = swap_image_y = true;
-	swap_margin_x = swap_margin_y = true;
-	if (flippedMargin == FM_TRUE) {
-	  swap_margin_y = false;
-	}
-      } else if (strcasecmp(backside,"Flipped") == 0) {
-	if (header.Tumble) {
-	  swap_image_x = true;
-	  swap_margin_x = swap_margin_y = true;
-	} else {
-	  swap_image_y = true;
-	}
-	if (flippedMargin == FM_FALSE) {
-	  swap_margin_y = !swap_margin_y;
-	}
-      }
-    }
-
-    /* support the CUPS "cm-calibration" option */
-    cm_calibrate = cmGetCupsColorCalibrateMode(options, num_options);
-
-    if (cm_calibrate == CM_CALIBRATION_ENABLED)
-      cm_disabled = 1;
-    else
-      cm_disabled = cmIsPrinterCmDisabled(getenv("PRINTER"));
-
-    if (!cm_disabled)
-      cmGetPrinterIccProfile(getenv("PRINTER"), &profile, ppd);
-
-    if (profile != NULL) {
-      colorProfile = cmsOpenProfileFromFile(profile,"r");
-      free(profile);
-    }
-
-#ifdef HAVE_CUPS_1_7
-    if ((attr = ppdFindAttr(ppd,"PWGRaster",0)) != 0 &&
-	(!strcasecmp(attr->value, "true")
-	 || !strcasecmp(attr->value, "on") ||
-	 !strcasecmp(attr->value, "yes")))
-      pwgraster = 1;
-    if (pwgraster == 1)
-      cupsRasterParseIPPOptions(&header, num_options, options, pwgraster, 0);
-#endif /* HAVE_CUPS_1_7 */
-  } else {
-#ifdef HAVE_CUPS_1_7
-    pwgraster = 1;
-    t = cupsGetOption("media-class", num_options, options);
-    if (t == NULL)
-      t = cupsGetOption("MediaClass", num_options, options);
-    if (t != NULL)
-    {
-      if (strcasestr(t, "pwg"))
-	pwgraster = 1;
-      else
-	pwgraster = 0;
-    }
-    cupsRasterParseIPPOptions(&header,num_options,options,pwgraster,1);
-#else
-    fprintf(stderr, "ERROR: No PPD file specified.\n");
-    exit(1);
-#endif /* HAVE_CUPS_1_7 */
-  }
-  strncpy(pageSizeRequested, header.cupsPageSizeName, 64);
-  fprintf(stderr, "DEBUG: Page size requested: %s\n",
-	  header.cupsPageSizeName);
-}
-
-static void parsePDFTOPDFComment(FILE *fp)
-{
-  char buf[4096];
-  int i;
-
-  /* skip until PDF start header */
-  while (fgets(buf,sizeof(buf),fp) != 0) {
-    if (strncmp(buf,"%PDF",4) == 0) {
-      break;
-    }
-  }
-  for (i = 0;i < MAX_CHECK_COMMENT_LINES;i++) {
-    if (fgets(buf,sizeof(buf),fp) == 0) break;
-    if (strncmp(buf,"%%PDFTOPDFNumCopies",19) == 0) {
-      char *p;
-
-      p = strchr(buf+19,':');
-      deviceCopies = atoi(p+1);
-    } else if (strncmp(buf,"%%PDFTOPDFCollate",17) == 0) {
-      char *p;
-
-      p = strchr(buf+17,':');
-      while (*p == ' ' || *p == '\t') p++;
-      if (strncasecmp(p,"true",4) == 0) {
-	deviceCollate = true;
-      } else {
-	deviceCollate = false;
-      }
-    }
-  }
-}
-
-static unsigned char *reverseLine(unsigned char *src, unsigned char *dst,
-     unsigned int row, unsigned int plane, unsigned int pixels,
-     unsigned int size)
-{
-  unsigned char *p = src;
-
-  for (unsigned int j = 0;j < size;j++,p++) {
-    *p = ~*p;
-  }
-  return src;
-}
-
-static unsigned char *reverseLineSwapByte(unsigned char *src,
-    unsigned char *dst, unsigned int row, unsigned int plane,
-    unsigned int pixels, unsigned int size)
-{
-  unsigned char *bp = src+size-1;
-  unsigned char *dp = dst;
-
-  for (unsigned int j = 0;j < size;j++,bp--,dp++) {
-    *dp = ~*bp;
-  }
-  return dst;
-}
-
-
-static unsigned char *reverseLineSwapBit(unsigned char *src,
-  unsigned char *dst, unsigned int row, unsigned int plane,
-  unsigned int pixels, unsigned int size)
-{
-  unsigned char *bp;
-  unsigned char *dp;
-  unsigned int npadbits = (size*8)-pixels;
-
-  if (npadbits == 0) {
-    bp = src+size-1;
-    dp = dst;
-    for (unsigned int j = 0;j < size;j++,bp--,dp++) {
-      *dp = revTable[(unsigned char)(~*bp)];
-    }
-  } else {
-    unsigned int pd,d;
-    unsigned int sw;
-
-    size = (pixels+7)/8;
-    sw = (size*8)-pixels;
-    bp = src+size-1;
-    dp = dst;
-
-    pd = *bp--;
-    for (unsigned int j = 1;j < size;j++,bp--,dp++) {
-      d = *bp;
-      *dp = ~revTable[(((d << 8) | pd) >> sw) & 0xff];
-      pd = d;
-    }
-    *dp = ~revTable[(pd >> sw) & 0xff];
-  }
-  return dst;
-}
-
-static unsigned char *rgbToCMYKLine(unsigned char *src, unsigned char *dst,
-     unsigned int row, unsigned int plane, unsigned int pixels,
-     unsigned int size)
-{
-  cupsImageRGBToCMYK(src,dst,pixels);
-  return dst;
-}
-
-static unsigned char *rgbToCMYKLineSwap(unsigned char *src, unsigned char *dst,
-     unsigned int row, unsigned int plane, unsigned int pixels,
-     unsigned int size)
-{
-  unsigned char *bp = src+(pixels-1)*3;
-  unsigned char *dp = dst;
-
-  for (unsigned int i = 0;i < pixels;i++, bp -= 3, dp += 4) {
-    cupsImageRGBToCMYK(bp,dp,1);
-  }
-  return dst;
-}
-
-static unsigned char *rgbToCMYLine(unsigned char *src, unsigned char *dst,
-     unsigned int row, unsigned int plane, unsigned int pixels,
-     unsigned int size)
-{
-  cupsImageRGBToCMY(src,dst,pixels);
-  return dst;
-}
-
-static unsigned char *rgbToCMYLineSwap(unsigned char *src, unsigned char *dst,
-     unsigned int row, unsigned int plane, unsigned int pixels,
-     unsigned int size)
-{
-  unsigned char *bp = src+size-3;
-  unsigned char *dp = dst;
-
-  for (unsigned int i = 0;i < pixels;i++, bp -= 3, dp += 3) {
-    cupsImageRGBToCMY(bp,dp,1);
-  }
-  return dst;
-}
-
-static unsigned char *rgbToKCMYLine(unsigned char *src, unsigned char *dst,
-     unsigned int row, unsigned int plane, unsigned int pixels,
-     unsigned int size)
-{
-  unsigned char *bp = src;
-  unsigned char *dp = dst;
-  unsigned char d;
-
-  cupsImageRGBToCMYK(src,dst,pixels);
-  /* CMYK to KCMY */
-  for (unsigned int i = 0;i < pixels;i++, bp += 3, dp += 4) {
-    d = dp[3];
-    dp[3] = dp[2];
-    dp[2] = dp[1];
-    dp[1] = dp[0];
-    dp[0] = d;
-  }
-  return dst;
-}
-
-static unsigned char *rgbToKCMYLineSwap(unsigned char *src, unsigned char *dst,
-     unsigned int row, unsigned int plane, unsigned int pixels,
-     unsigned int size)
-{
-  unsigned char *bp = src+(pixels-1)*3;
-  unsigned char *dp = dst;
-  unsigned char d;
-
-  for (unsigned int i = 0;i < pixels;i++, bp -= 3, dp += 4) {
-    cupsImageRGBToCMYK(bp,dp,1);
-    /* CMYK to KCMY */
-    d = dp[3];
-    dp[3] = dp[2];
-    dp[2] = dp[1];
-    dp[1] = dp[0];
-    dp[0] = d;
-  }
-  return dst;
-}
-
-static unsigned char *lineNoop(unsigned char *src, unsigned char *dst,
-     unsigned int row, unsigned int plane, unsigned int pixels,
-     unsigned int size)
-{
-  /* do nothing */
-  return src;
-}
-
-static unsigned char *lineSwap24(unsigned char *src, unsigned char *dst,
-     unsigned int row, unsigned int plane, unsigned int pixels,
-     unsigned int size)
-{
-  unsigned char *bp = src+size-3;
-  unsigned char *dp = dst;
-
-  for (unsigned int i = 0;i < pixels;i++, bp -= 3, dp += 3) {
-    dp[0] = bp[0];
-    dp[1] = bp[1];
-    dp[2] = bp[2];
-  }
-  return dst;
-}
-
-static unsigned char *lineSwapByte(unsigned char *src, unsigned char *dst,
-     unsigned int row, unsigned int plane, unsigned int pixels,
-     unsigned int size)
-{
-  unsigned char *bp = src+size-1;
-  unsigned char *dp = dst;
-
-  for (unsigned int j = 0;j < size;j++,bp--,dp++) {
-    *dp = *bp;
-  }
-  return dst;
-}
-
-static unsigned char *lineSwapBit(unsigned char *src, unsigned char *dst,
-     unsigned int row, unsigned int plane, unsigned int pixels,
-     unsigned int size)
-{
-  unsigned char *bp;
-  unsigned char *dp;
-  unsigned int npadbits = (size*8)-pixels;
-
-  if (npadbits == 0) {
-    bp = src+size-1;
-    dp = dst;
-    for (unsigned int j = 0;j < size;j++,bp--,dp++) {
-      *dp = revTable[*bp];
-    }
-  } else {
-    unsigned int pd,d;
-    unsigned int sw;
-
-    size = (pixels+7)/8;
-    sw = (size*8)-pixels;
-    bp = src+size-1;
-    dp = dst;
-
-    pd = *bp--;
-    for (unsigned int j = 1;j < size;j++,bp--,dp++) {
-      d = *bp;
-      *dp = revTable[(((d << 8) | pd) >> sw) & 0xff];
-      pd = d;
-    }
-    *dp = revTable[(pd >> sw) & 0xff];
-  }
-  return dst;
-}
-
-typedef struct _funcTable {
-  enum cups_cspace_e cspace;
-  unsigned int bitsPerPixel;
-  unsigned int bitsPerColor;
-  ConvertLineFunc convertLine;
-  bool allocLineBuf;
-  ConvertLineFunc convertLineSwap;
-  bool allocLineBufSwap;
-} FuncTable;
-
-static FuncTable specialCaseFuncs[] = {
-  {CUPS_CSPACE_K,8,8,reverseLine,false,reverseLineSwapByte,true},
-  {CUPS_CSPACE_K,1,1,reverseLine,false,reverseLineSwapBit,true},
-  {CUPS_CSPACE_GOLD,8,8,reverseLine,false,reverseLineSwapByte,true},
-  {CUPS_CSPACE_GOLD,1,1,reverseLine,false,reverseLineSwapBit,true},
-  {CUPS_CSPACE_SILVER,8,8,reverseLine,false,reverseLineSwapByte,true},
-  {CUPS_CSPACE_SILVER,1,1,reverseLine,false,reverseLineSwapBit,true},
-  {CUPS_CSPACE_CMYK,32,8,rgbToCMYKLine,true,rgbToCMYKLineSwap,true},
-  {CUPS_CSPACE_KCMY,32,8,rgbToKCMYLine,true,rgbToKCMYLineSwap,true},
-  {CUPS_CSPACE_CMY,24,8,rgbToCMYLine,true,rgbToCMYLineSwap,true},
-  {CUPS_CSPACE_RGB,24,8,lineNoop,false,lineSwap24,true},
-  {CUPS_CSPACE_SRGB,24,8,lineNoop,false,lineSwap24,true},
-  {CUPS_CSPACE_ADOBERGB,24,8,lineNoop,false,lineSwap24,true},
-  {CUPS_CSPACE_W,8,8,lineNoop,false,lineSwapByte,true},
-  {CUPS_CSPACE_W,1,1,lineNoop,false,lineSwapBit,true},
-  {CUPS_CSPACE_SW,8,8,lineNoop,false,lineSwapByte,true},
-  {CUPS_CSPACE_SW,1,1,lineNoop,false,lineSwapBit,true},
-  {CUPS_CSPACE_WHITE,8,8,lineNoop,false,lineSwapByte,true},
-  {CUPS_CSPACE_WHITE,1,1,lineNoop,false,lineSwapBit,true},
-  {CUPS_CSPACE_RGB,0,0,NULL,false,NULL,false} /* end mark */
-};
-
-static unsigned char *convertCSpaceNone(unsigned char *src,
-  unsigned char *pixelBuf, unsigned int x, unsigned int y)
-{
-  return src;
-}
-
-static unsigned char *convertCSpaceWithProfiles(unsigned char *src,
-  unsigned char *pixelBuf, unsigned int x, unsigned int y)
-{
-  cmsDoTransform(colorTransform,src,pixelBuf,1);
-  return pixelBuf;
-}
-
-static unsigned char *convertCSpaceXYZ8(unsigned char *src,
-  unsigned char *pixelBuf, unsigned int x, unsigned int y)
-{
-  double alab[3];
-
-  cmsDoTransform(colorTransform,src,alab,1);
-  cmsCIELab lab;
-  cmsCIEXYZ xyz;
-
-  lab.L = alab[0];
-  lab.a = alab[1];
-  lab.b = alab[2];
-
-  cmsLab2XYZ(&D65WhitePoint,&xyz,&lab);
-  pixelBuf[0] = 231.8181*xyz.X+0.5;
-  pixelBuf[1] = 231.8181*xyz.Y+0.5;
-  pixelBuf[2] = 231.8181*xyz.Z+0.5;
-  return pixelBuf;
-}
-
-static unsigned char *convertCSpaceXYZ16(unsigned char *src,
-  unsigned char *pixelBuf, unsigned int x, unsigned int y)
-{
-  double alab[3];
-  unsigned short *sd = (unsigned short *)pixelBuf;
-
-  cmsDoTransform(colorTransform,src,alab,1);
-  cmsCIELab lab;
-  cmsCIEXYZ xyz;
-
-  lab.L = alab[0];
-  lab.a = alab[1];
-  lab.b = alab[2];
-
-  cmsLab2XYZ(&D65WhitePoint,&xyz,&lab);
-  sd[0] = 59577.2727*xyz.X+0.5;
-  sd[1] = 59577.2727*xyz.Y+0.5;
-  sd[2] = 59577.2727*xyz.Z+0.5;
-  return pixelBuf;
-}
-
-static unsigned char *convertCSpaceLab8(unsigned char *src,
-  unsigned char *pixelBuf, unsigned int x, unsigned int y)
-{
-  double lab[3];
-  cmsDoTransform(colorTransform,src,lab,1);
-  pixelBuf[0] = 2.55*lab[0]+0.5;
-  pixelBuf[1] = lab[1]+128.5;
-  pixelBuf[2] = lab[2]+128.5;
-  return pixelBuf;
-}
-
-static unsigned char *convertCSpaceLab16(unsigned char *src,
-  unsigned char *pixelBuf, unsigned int x, unsigned int y)
-{
-  double lab[3];
-  cmsDoTransform(colorTransform,src,lab,1);
-  unsigned short *sd = (unsigned short *)pixelBuf;
-  sd[0] = 655.35*lab[0]+0.5;
-  sd[1] = 256*(lab[1]+128)+0.5;
-  sd[2] = 256*(lab[2]+128)+0.5;
-  return pixelBuf;
-}
-
-static unsigned char *RGB8toRGBA(unsigned char *src, unsigned char *pixelBuf,
-  unsigned int x, unsigned int y)
-{
-  unsigned char *dp = pixelBuf;
-
-  for (int i = 0;i < 3;i++) {
-    *dp++ = *src++;
-  }
-  *dp = 255;
-  return pixelBuf;
-}
-
-static unsigned char *RGB8toRGBW(unsigned char *src, unsigned char *pixelBuf,
-  unsigned int x, unsigned int y)
-{
-  unsigned char cmyk[4];
-  unsigned char *dp = pixelBuf;
-
-  cupsImageRGBToCMYK(src,cmyk,1);
-  for (int i = 0;i < 4;i++) {
-    *dp++ = ~cmyk[i];
-  }
-  return pixelBuf;
-}
-
-static unsigned char *RGB8toCMYK(unsigned char *src, unsigned char *pixelBuf,
-  unsigned int x, unsigned int y)
-{
-  cupsImageRGBToCMYK(src,pixelBuf,1);
-  return pixelBuf;
-}
-
-static unsigned char *RGB8toCMY(unsigned char *src, unsigned char *pixelBuf,
-  unsigned int x, unsigned int y)
-{
-  cupsImageRGBToCMY(src,pixelBuf,1);
-  return pixelBuf;
-}
-
-static unsigned char *RGB8toYMC(unsigned char *src, unsigned char *pixelBuf,
-  unsigned int x, unsigned int y)
-{
-  cupsImageRGBToCMY(src,pixelBuf,1);
-  /* swap C and Y */
-  unsigned char d = pixelBuf[0];
-  pixelBuf[0] = pixelBuf[2];
-  pixelBuf[2] = d;
-  return pixelBuf;
-}
-
-static unsigned char *RGB8toKCMY(unsigned char *src, unsigned char *pixelBuf,
-  unsigned int x, unsigned int y)
-{
-  cupsImageRGBToCMYK(src,pixelBuf,1);
-  unsigned char d = pixelBuf[3];
-  pixelBuf[3] = pixelBuf[2];
-  pixelBuf[2] = pixelBuf[1];
-  pixelBuf[1] = pixelBuf[0];
-  pixelBuf[0] = d;
-  return pixelBuf;
-}
-
-static unsigned char *RGB8toKCMYcm(unsigned char *src, unsigned char *pixelBuf,
-  unsigned int x, unsigned int y)
-{
-  unsigned char cmyk[4];
-  unsigned char c;
-  unsigned char d;
-
-  cupsImageRGBToCMYK(src,cmyk,1);
-  c = 0;
-  d = dither1[y & 0xf][x & 0xf];
-  /* K */
-  if (cmyk[3] > d) {
-    c |= 0x20;
-  }
-  /* C */
-  if (cmyk[0] > d) {
-    c |= 0x10;
-  }
-  /* M */
-  if (cmyk[1] > d) {
-    c |= 0x08;
-  }
-  /* Y */
-  if (cmyk[2] > d) {
-    c |= 0x04;
-  }
-  if (c == 0x18) { /* Blue */
-    c = 0x11; /* cyan + light magenta */
-  } else if (c == 0x14) { /* Green */
-    c = 0x06; /* light cyan + yellow */
-  }
-  *pixelBuf = c;
-  return pixelBuf;
-}
-
-static unsigned char *RGB8toYMCK(unsigned char *src, unsigned char *pixelBuf,
-  unsigned int x, unsigned int y)
-{
-  cupsImageRGBToCMYK(src,pixelBuf,1);
-  /* swap C and Y */
-  unsigned char d = pixelBuf[0];
-  pixelBuf[0] = pixelBuf[2];
-  pixelBuf[2] = d;
-  return pixelBuf;
-}
-
-static unsigned char *W8toK8(unsigned char *src, unsigned char *pixelBuf,
-  unsigned int x, unsigned int y)
-{
-  *pixelBuf = ~(*src);
-  return pixelBuf;
-}
-
-static unsigned char *convertBitsNoop(unsigned char *src, unsigned char *dst,
-    unsigned int x, unsigned int y)
-{
-    return src;
-}
-
-static unsigned char *convert8to1(unsigned char *src, unsigned char *dst,
-    unsigned int x, unsigned int y)
-{
-  unsigned char c = 0;
-  /* assumed that max number of colors is 4 */
-  for (unsigned int i = 0;i < header.cupsNumColors;i++) {
-    c <<= 1;
-    /* ordered dithering */
-    if (src[i] > dither1[y & 0xf][x & 0xf]) {
-      c |= 0x1;
-    }
-  }
-  *dst = c;
-  return dst;
-}
-
-static unsigned char *convert8to2(unsigned char *src, unsigned char *dst,
-    unsigned int x, unsigned int y)
-{
-  unsigned char c = 0;
-  /* assumed that max number of colors is 4 */
-  for (unsigned int i = 0;i < header.cupsNumColors;i++) {
-    unsigned int d;
-
-    c <<= 2;
-    /* ordered dithering */
-    d = src[i] + dither2[y & 0x7][x & 0x7];
-    if (d > 255) d = 255;
-    c |= d >> 6;
-  }
-  *dst = c;
-  return dst;
-}
-
-static unsigned char *convert8to4(unsigned char *src, unsigned char *dst,
-    unsigned int x, unsigned int y)
-{
-  unsigned short c = 0;
-
-  /* assumed that max number of colors is 4 */
-  for (unsigned int i = 0;i < header.cupsNumColors;i++) {
-    unsigned int d;
-
-    c <<= 4;
-    /* ordered dithering */
-    d = src[i] + dither4[y & 0x3][x & 0x3];
-    if (d > 255) d = 255;
-    c |= d >> 4;
-  }
-  if (header.cupsNumColors < 3) {
-    dst[0] = c;
-  } else {
-    dst[0] = c >> 8;
-    dst[1] = c;
-  }
-  return dst;
-}
-
-static unsigned char *convert8to16(unsigned char *src, unsigned char *dst,
-    unsigned int x, unsigned int y)
-{
-  /* assumed that max number of colors is 4 */
-  for (unsigned int i = 0;i < header.cupsNumColors;i++) {
-    dst[i*2] = src[i];
-    dst[i*2+1] = src[i];
-  }
-  return dst;
-}
-
-static void writePixel1(unsigned char *dst,
-    unsigned int plane, unsigned int pixeli, unsigned char *pixelBuf)
-{
-  switch (header.cupsNumColors) {
-  case 1:
-    {
-      unsigned int bo = pixeli & 0x7;
-      if ((pixeli & 7) == 0) dst[pixeli/8] = 0;
-      dst[pixeli/8] |= *pixelBuf << (7-bo);
-    }
-    break;
-  case 6:
-    dst[pixeli] = *pixelBuf;
-    break;
-  case 3:
-  case 4:
-  default:
-    {
-      unsigned int qo = (pixeli & 0x1)*4;
-      if ((pixeli & 1) == 0) dst[pixeli/2] = 0;
-      dst[pixeli/2] |= *pixelBuf << (4-qo);
-    }
-    break;
-  }
-}
-
-static void writePlanePixel1(unsigned char *dst,
-    unsigned int plane, unsigned int pixeli, unsigned char *pixelBuf)
-{
-  unsigned int bo = pixeli & 0x7;
-  unsigned char so = header.cupsNumColors - plane - 1;
-  if ((pixeli & 7) == 0) dst[pixeli/8] = 0;
-  dst[pixeli/8] |= ((*pixelBuf >> so) & 1) << (7-bo);
-}
-
-static void writePixel2(unsigned char *dst,
-    unsigned int plane, unsigned int pixeli, unsigned char *pixelBuf)
-{
-  switch (header.cupsNumColors) {
-  case 1:
-    {
-      unsigned int bo = (pixeli & 0x3)*2;
-      if ((pixeli & 3) == 0) dst[pixeli/4] = 0;
-      dst[pixeli/4] |= *pixelBuf << (6-bo);
-    }
-    break;
-  case 3:
-  case 4:
-  default:
-    dst[pixeli] = *pixelBuf;
-    break;
-  }
-}
-
-static void writePlanePixel2(unsigned char *dst,
-    unsigned int plane, unsigned int pixeli, unsigned char *pixelBuf)
-{
-  unsigned int bo = (pixeli & 0x3)*2;
-  unsigned char so = (header.cupsNumColors - plane - 1)*2;
-  if ((pixeli & 3) == 0) dst[pixeli/4] = 0;
-  dst[pixeli/4] |= ((*pixelBuf >> so) & 3) << (6-bo);
-}
-
-static void writePixel4(unsigned char *dst,
-    unsigned int plane, unsigned int pixeli, unsigned char *pixelBuf)
-{
-  switch (header.cupsNumColors) {
-  case 1:
-    {
-      unsigned int bo = (pixeli & 0x1)*4;
-      if ((pixeli & 1) == 0) dst[pixeli/2] = 0;
-      dst[pixeli/2] |= *pixelBuf << (4-bo);
-    }
-    break;
-  case 3:
-  case 4:
-  default:
-    dst[pixeli*2] = pixelBuf[0];
-    dst[pixeli*2+1] = pixelBuf[1];
-    break;
-  }
-}
-
-static void writePlanePixel4(unsigned char *dst,
-    unsigned int plane, unsigned int pixeli, unsigned char *pixelBuf)
-{
-  unsigned short c = (pixelBuf[0] << 8) | pixelBuf[1];
-  unsigned int bo = (pixeli & 0x1)*4;
-  unsigned char so = (header.cupsNumColors - plane - 1)*4;
-  if ((pixeli & 1) == 0) dst[pixeli/2] = 0;
-  dst[pixeli/2] |= ((c >> so) & 0xf) << (4-bo);
-}
-
-static void writePixel8(unsigned char *dst,
-    unsigned int plane, unsigned int pixeli, unsigned char *pixelBuf)
-{
-  unsigned char *dp = dst + pixeli*header.cupsNumColors;
-  for (unsigned int i = 0;i < header.cupsNumColors;i++) {
-    dp[i] = pixelBuf[i];
-  }
-}
-
-static void writePlanePixel8(unsigned char *dst,
-    unsigned int plane, unsigned int pixeli, unsigned char *pixelBuf)
-{
-  dst[pixeli] = pixelBuf[plane];
-}
-
-static void writePixel16(unsigned char *dst,
-    unsigned int plane, unsigned int pixeli, unsigned char *pixelBuf)
-{
-  unsigned char *dp = dst + pixeli*header.cupsNumColors*2;
-  for (unsigned int i = 0;i < header.cupsNumColors*2;i++) {
-    dp[i] = pixelBuf[i];
-  }
-}
-
-static void writePlanePixel16(unsigned char *dst,
-    unsigned int plane, unsigned int pixeli, unsigned char *pixelBuf)
-{
-  dst[pixeli*2] = pixelBuf[plane*2];
-  dst[pixeli*2+1] = pixelBuf[plane*2+1];
-}
-
-static unsigned char *convertLineChunked(unsigned char *src, unsigned char *dst,
-     unsigned int row, unsigned int plane, unsigned int pixels,
-     unsigned int size)
-{
-  /* Assumed that BitsPerColor is 8 */
-  for (unsigned int i = 0;i < pixels;i++) {
-      unsigned char pixelBuf1[MAX_BYTES_PER_PIXEL];
-      unsigned char pixelBuf2[MAX_BYTES_PER_PIXEL];
-      unsigned char *pb;
-
-      pb = convertCSpace(src+i*popplerNumColors,pixelBuf1,i,row);
-      pb = convertBits(pb,pixelBuf2,i,row);
-      writePixel(dst,0,i,pb);
-  }
-  return dst;
-}
-
-static unsigned char *convertLineChunkedSwap(unsigned char *src,
-     unsigned char *dst, unsigned int row, unsigned int plane,
-     unsigned int pixels, unsigned int size)
-{
-  /* Assumed that BitsPerColor is 8 */
-  for (unsigned int i = 0;i < pixels;i++) {
-      unsigned char pixelBuf1[MAX_BYTES_PER_PIXEL];
-      unsigned char pixelBuf2[MAX_BYTES_PER_PIXEL];
-      unsigned char *pb;
-
-      pb = convertCSpace(src+(pixels-i-1)*popplerNumColors,pixelBuf1,i,row);
-      pb = convertBits(pb,pixelBuf2,i,row);
-      writePixel(dst,0,i,pb);
-  }
-  return dst;
-}
-
-static unsigned char *convertLinePlane(unsigned char *src, unsigned char *dst,
-     unsigned int row, unsigned int plane, unsigned int pixels,
-     unsigned int size)
-{
-  /* Assumed that BitsPerColor is 8 */
-  for (unsigned int i = 0;i < pixels;i++) {
-      unsigned char pixelBuf1[MAX_BYTES_PER_PIXEL];
-      unsigned char pixelBuf2[MAX_BYTES_PER_PIXEL];
-      unsigned char *pb;
-
-      pb = convertCSpace(src+i*popplerNumColors,pixelBuf1,i,row);
-      pb = convertBits(pb,pixelBuf2,i,row);
-      writePixel(dst,plane,i,pb);
-  }
-  return dst;
-}
-
-static unsigned char *convertLinePlaneSwap(unsigned char *src,
-    unsigned char *dst, unsigned int row, unsigned int plane,
-    unsigned int pixels, unsigned int size)
-{
-  for (unsigned int i = 0;i < pixels;i++) {
-      unsigned char pixelBuf1[MAX_BYTES_PER_PIXEL];
-      unsigned char pixelBuf2[MAX_BYTES_PER_PIXEL];
-      unsigned char *pb;
-
-      pb = convertCSpace(src+(pixels-i-1)*popplerNumColors,pixelBuf1,i,row);
-      pb = convertBits(pb,pixelBuf2,i,row);
-      writePixel(dst,plane,i,pb);
-  }
-  return dst;
-}
-
-/* handle special cases which are appear in gutenprint's PPDs. */
-static bool selectSpecialCase()
-{
-  int i;
-
-  for (i = 0;specialCaseFuncs[i].bitsPerPixel > 0;i++) {
-    if (header.cupsColorSpace == specialCaseFuncs[i].cspace
-       && header.cupsBitsPerPixel == specialCaseFuncs[i].bitsPerPixel
-       && header.cupsBitsPerColor == specialCaseFuncs[i].bitsPerColor) {
-      convertLineOdd = specialCaseFuncs[i].convertLine;
-      if (header.Duplex && swap_image_x) {
-        convertLineEven = specialCaseFuncs[i].convertLineSwap;
-        allocLineBuf = specialCaseFuncs[i].allocLineBufSwap;
-      } else {
-        convertLineEven = specialCaseFuncs[i].convertLine;
-        allocLineBuf = specialCaseFuncs[i].allocLineBuf;
-      }
-      return true; /* found */
-    }
-  }
-  return false;
-}
-
-static unsigned int getCMSColorSpaceType(cmsColorSpaceSignature cs)
-{
-    switch (cs) {
-    case cmsSigXYZData:
-      return PT_XYZ;
-      break;
-    case cmsSigLabData:
-      return PT_Lab;
-      break;
-    case cmsSigLuvData:
-      return PT_YUV;
-      break;
-    case cmsSigYCbCrData:
-      return PT_YCbCr;
-      break;
-    case cmsSigYxyData:
-      return PT_Yxy;
-      break;
-    case cmsSigRgbData:
-      return PT_RGB;
-      break;
-    case cmsSigGrayData:
-      return PT_GRAY;
-      break;
-    case cmsSigHsvData:
-      return PT_HSV;
-      break;
-    case cmsSigHlsData:
-      return PT_HLS;
-      break;
-    case cmsSigCmykData:
-      return PT_CMYK;
-      break;
-    case cmsSigCmyData:
-      return PT_CMY;
-      break;
-    case cmsSig2colorData:
-    case cmsSig3colorData:
-    case cmsSig4colorData:
-    case cmsSig5colorData:
-    case cmsSig6colorData:
-    case cmsSig7colorData:
-    case cmsSig8colorData:
-    case cmsSig9colorData:
-    case cmsSig10colorData:
-    case cmsSig11colorData:
-    case cmsSig12colorData:
-    case cmsSig13colorData:
-    case cmsSig14colorData:
-    case cmsSig15colorData:
-    default:
-      break;
-    }
-    return PT_RGB;
-}
-
-/* select convertLine function */
-static void selectConvertFunc(cups_raster_t *raster)
-{
-  if ((colorProfile == NULL || popplerColorProfile == colorProfile)
-      && (header.cupsColorOrder == CUPS_ORDER_CHUNKED
-       || header.cupsNumColors == 1)) {
-    if (selectSpecialCase()) return;
-  }
-
-  switch (header.cupsColorOrder) {
-  case CUPS_ORDER_BANDED:
-  case CUPS_ORDER_PLANAR:
-    if (header.cupsNumColors > 1) {
-      convertLineEven = convertLinePlaneSwap;
-      convertLineOdd = convertLinePlane;
-      break;
-    }
-  default:
-  case CUPS_ORDER_CHUNKED:
-    convertLineEven = convertLineChunkedSwap;
-    convertLineOdd = convertLineChunked;
-    break;
-  }
-  if (!header.Duplex || !swap_image_x) {
-    convertLineEven = convertLineOdd;
-  }
-  allocLineBuf = true;
-
-  if (colorProfile != NULL && popplerColorProfile != colorProfile) {
-    unsigned int bytes;
-
-    switch (header.cupsColorSpace) {
-    case CUPS_CSPACE_CIELab:
-    case CUPS_CSPACE_ICC1:
-    case CUPS_CSPACE_ICC2:
-    case CUPS_CSPACE_ICC3:
-    case CUPS_CSPACE_ICC4:
-    case CUPS_CSPACE_ICC5:
-    case CUPS_CSPACE_ICC6:
-    case CUPS_CSPACE_ICC7:
-    case CUPS_CSPACE_ICC8:
-    case CUPS_CSPACE_ICC9:
-    case CUPS_CSPACE_ICCA:
-    case CUPS_CSPACE_ICCB:
-    case CUPS_CSPACE_ICCC:
-    case CUPS_CSPACE_ICCD:
-    case CUPS_CSPACE_ICCE:
-    case CUPS_CSPACE_ICCF:
-      if (header.cupsBitsPerColor == 8) {
-        convertCSpace = convertCSpaceLab8;
-      } else {
-        /* 16 bits */
-        convertCSpace = convertCSpaceLab16;
-      }
-      bytes = 0; /* double */
-      break;
-    case CUPS_CSPACE_CIEXYZ:
-      if (header.cupsBitsPerColor == 8) {
-        convertCSpace = convertCSpaceXYZ8;
-      } else {
-        /* 16 bits */
-        convertCSpace = convertCSpaceXYZ16;
-      }
-      bytes = 0; /* double */
-      break;
-    default:
-      convertCSpace = convertCSpaceWithProfiles;
-      bytes = header.cupsBitsPerColor/8;
-      break;
-    }
-    convertBits = convertBitsNoop; /* convert bits in convertCSpace */
-    if (popplerColorProfile == NULL) {
-      popplerColorProfile = cmsCreate_sRGBProfile();
-    }
-    unsigned int dcst = getCMSColorSpaceType(cmsGetColorSpace(colorProfile));
-    if ((colorTransform = cmsCreateTransform(popplerColorProfile,
-            COLORSPACE_SH(PT_RGB) |CHANNELS_SH(3) | BYTES_SH(1),
-            colorProfile,
-            COLORSPACE_SH(dcst) |
-            CHANNELS_SH(header.cupsNumColors) | BYTES_SH(bytes),
-            renderingIntent,0)) == 0) {
-      fprintf(stderr, "ERROR: Can't create color transform");
-      exit(1);
-    }
-  } else {
-    /* select convertCSpace function */
-    switch (header.cupsColorSpace) {
-    case CUPS_CSPACE_CIELab:
-    case CUPS_CSPACE_ICC1:
-    case CUPS_CSPACE_ICC2:
-    case CUPS_CSPACE_ICC3:
-    case CUPS_CSPACE_ICC4:
-    case CUPS_CSPACE_ICC5:
-    case CUPS_CSPACE_ICC6:
-    case CUPS_CSPACE_ICC7:
-    case CUPS_CSPACE_ICC8:
-    case CUPS_CSPACE_ICC9:
-    case CUPS_CSPACE_ICCA:
-    case CUPS_CSPACE_ICCB:
-    case CUPS_CSPACE_ICCC:
-    case CUPS_CSPACE_ICCD:
-    case CUPS_CSPACE_ICCE:
-    case CUPS_CSPACE_ICCF:
-    case CUPS_CSPACE_CIEXYZ:
-      convertCSpace = convertCSpaceNone;
-      break;
-    case CUPS_CSPACE_CMY:
-      convertCSpace = RGB8toCMY;
-      break;
-    case CUPS_CSPACE_YMC:
-      convertCSpace = RGB8toYMC;
-      break;
-    case CUPS_CSPACE_CMYK:
-      convertCSpace = RGB8toCMYK;
-      break;
-    case CUPS_CSPACE_KCMY:
-      convertCSpace = RGB8toKCMY;
-      break;
-    case CUPS_CSPACE_KCMYcm:
-      if (header.cupsBitsPerColor > 1) {
-        convertCSpace = RGB8toKCMY;
-      } else {
-        convertCSpace = RGB8toKCMYcm;
-      }
-      break;
-    case CUPS_CSPACE_GMCS:
-    case CUPS_CSPACE_GMCK:
-    case CUPS_CSPACE_YMCK:
-      convertCSpace = RGB8toYMCK;
-      break;
-    case CUPS_CSPACE_RGBW:
-      convertCSpace = RGB8toRGBW;
-      break;
-    case CUPS_CSPACE_RGBA:
-      convertCSpace = RGB8toRGBA;
-      break;
-    case CUPS_CSPACE_RGB:
-    case CUPS_CSPACE_SRGB:
-    case CUPS_CSPACE_ADOBERGB:
-      convertCSpace = convertCSpaceNone;
-      break;
-    case CUPS_CSPACE_W:
-    case CUPS_CSPACE_SW:
-    case CUPS_CSPACE_WHITE:
-      convertCSpace = convertCSpaceNone;
-      break;
-    case CUPS_CSPACE_K:
-    case CUPS_CSPACE_GOLD:
-    case CUPS_CSPACE_SILVER:
-      convertCSpace = W8toK8;
-      break;
-    default:
-      fprintf(stderr, "ERROR: Specified ColorSpace is not supported\n" );
-      exit(1);
-      break;
-    }
-    /* select convertBits function */
-    switch (header.cupsBitsPerColor) {
-    case 2:
-      convertBits = convert8to2;
-      break;
-    case 4:
-      convertBits = convert8to4;
-      break;
-    case 16:
-      convertBits = convert8to16;
-      break;
-    case 1:
-      if (header.cupsNumColors == 1
-          || header.cupsColorSpace == CUPS_CSPACE_KCMYcm) {
-          convertBits = convertBitsNoop;
-      } else {
-          convertBits = convert8to1;
-      }
-      break;
-    case 8:
-    default:
-      convertBits = convertBitsNoop;
-      break;
-    }
-  }
-  /* select writePixel function */
-  switch (header.cupsBitsPerColor) {
-  case 2:
-    if (header.cupsColorOrder == CUPS_ORDER_CHUNKED
-        || header.cupsNumColors == 1) {
-      writePixel = writePixel2;
-    } else {
-      writePixel = writePlanePixel2;
-    }
-    break;
-  case 4:
-    if (header.cupsColorOrder == CUPS_ORDER_CHUNKED
-        || header.cupsNumColors == 1) {
-      writePixel = writePixel4;
-    } else {
-      writePixel = writePlanePixel4;
-    }
-    break;
-  case 16:
-    if (header.cupsColorOrder == CUPS_ORDER_CHUNKED
-        || header.cupsNumColors == 1) {
-      writePixel = writePixel16;
-    } else {
-      writePixel = writePlanePixel16;
-    }
-    break;
-  case 1:
-    if (header.cupsColorOrder == CUPS_ORDER_CHUNKED
-        || header.cupsNumColors == 1) {
-      writePixel = writePixel1;
-    } else {
-      writePixel = writePlanePixel1;
-    }
-    break;
-  case 8:
-  default:
-    if (header.cupsColorOrder == CUPS_ORDER_CHUNKED
-        || header.cupsNumColors == 1) {
-      writePixel = writePixel8;
-    } else {
-      writePixel = writePlanePixel8;
-    }
-    break;
-  }
-}
-
-static unsigned char *onebitpixel(unsigned char *src, unsigned char *dst, unsigned int width, unsigned int height){
-  unsigned char *temp;
-  temp=dst;
-  int cnt=0;
-  for(unsigned int i=0;i<height;i++){
-    for(unsigned int j=0;j<width;j+=8){
-      unsigned char tem=0;
-      for(int k=0;k<8;k++){
-        cnt++;
-          tem <<=1;
-          unsigned int var=*src;
-          if(var > dither1[i & 0xf][(j+k) & 0xf]){
-            tem |= 0x1;
-          }
-          src +=1;
-      }
-      *dst=tem;
-      dst+=1;
-    }
-  }
-  return temp;
-}
-
-
-static unsigned char *removeAlpha(unsigned char *src, unsigned char *dst, unsigned int width, unsigned int height){
-  unsigned char *temp;
-  temp=dst;
-  for(unsigned int i=0;i<height;i++){
-    for(unsigned int j=0;j<width;j++){
-      dst[0]=src[2];
-      dst[1]=src[1];
-      dst[2]=src[0];
-      src+=4;
-      dst+=3;
-    }
-  }
-  return temp;
-}
-
-static void writePageImage(cups_raster_t *raster, poppler::document *doc,
-  int pageNo)
-{
-  ConvertLineFunc convertLine;
-  unsigned char *lineBuf = NULL;
-  unsigned char *dp;
-  unsigned int rowsize;
-
-  poppler::page *current_page =doc->create_page(pageNo-1);
-  poppler::page_renderer pr;
-  pr.set_render_hint(poppler::page_renderer::antialiasing, true);
-  pr.set_render_hint(poppler::page_renderer::text_antialiasing, true);
-
-  unsigned char *colordata,*newdata,*graydata,*onebitdata;
-  unsigned int pixel_count;
-  poppler::image im;
-  //render the page according to the colourspace and generate the requried data
-  switch (header.cupsColorSpace) {
-   case CUPS_CSPACE_W://gray
-   case CUPS_CSPACE_K://black
-   case CUPS_CSPACE_SW://sgray
-    if(header.cupsBitsPerColor==1){ //special case for 1-bit colorspaces
-      im = pr.render_page(current_page,header.HWResolution[0],header.HWResolution[1],bitmapoffset[0],bitmapoffset[1],bytesPerLine*8,header.cupsHeight);
-    newdata = (unsigned char *)malloc(sizeof(char)*3*im.width()*im.height());
-    newdata = removeAlpha((unsigned char *)im.const_data(),newdata,im.width(),im.height());
-    graydata=(unsigned char *)malloc(sizeof(char)*im.width()*im.height());
-    cupsImageRGBToWhite(newdata,graydata,im.width()*im.height());
-    onebitdata=(unsigned char *)malloc(sizeof(char)*bytesPerLine*im.height());
-    onebitpixel(graydata,onebitdata,im.width(),im.height());
-    colordata=onebitdata;
-    rowsize=bytesPerLine;
-    }
-    else{
-      im = pr.render_page(current_page,header.HWResolution[0],header.HWResolution[1],bitmapoffset[0],bitmapoffset[1],header.cupsWidth,header.cupsHeight);
-      newdata = (unsigned char *)malloc(sizeof(char)*3*im.width()*im.height());
-      newdata = removeAlpha((unsigned char *)im.const_data(),newdata,im.width(),im.height());
-      pixel_count=im.width()*im.height();
-      graydata=(unsigned char *)malloc(sizeof(char)*im.width()*im.height());
-      cupsImageRGBToWhite(newdata,graydata,pixel_count);
-      colordata=graydata;
-      rowsize=header.cupsWidth;
-    }
-
-    break;
-   case CUPS_CSPACE_RGB:
-   case CUPS_CSPACE_ADOBERGB:
-   case CUPS_CSPACE_CMYK:
-   case CUPS_CSPACE_SRGB:
-   case CUPS_CSPACE_CMY:
-   case CUPS_CSPACE_RGBW:
-   default:
-   im = pr.render_page(current_page,header.HWResolution[0],header.HWResolution[1],bitmapoffset[0],bitmapoffset[1],header.cupsWidth,header.cupsHeight);
-   newdata = (unsigned char *)malloc(sizeof(char)*3*im.width()*im.height());
-   newdata = removeAlpha((unsigned char *)im.const_data(),newdata,im.width(),im.height());
-   pixel_count=im.width()*im.height();
-   rowsize=header.cupsWidth*3;
-   colordata=newdata;
-     break;
-  }
-
-
-  if (allocLineBuf) lineBuf = new unsigned char [bytesPerLine];
-  if ((pageNo & 1) == 0) {
-    convertLine = convertLineEven;
-  } else {
-    convertLine = convertLineOdd;
-  }
-  if (header.Duplex && (pageNo & 1) == 0 && swap_image_y) {
-    for (unsigned int plane = 0;plane < nplanes;plane++) {
-      unsigned char *bp = colordata + (header.cupsHeight - 1) * rowsize;
-
-      for (unsigned int h = header.cupsHeight;h > 0;h--) {
-        for (unsigned int band = 0;band < nbands;band++) {
-          dp = convertLine(bp,lineBuf,h - 1,plane+band,header.cupsWidth,
-                 bytesPerLine);
-          cupsRasterWritePixels(raster,dp,bytesPerLine);
-        }
-        bp -= rowsize;
-      }
-    }
-  } else {
-    for (unsigned int plane = 0;plane < nplanes;plane++) {
-      unsigned char *bp = colordata;
-
-      for (unsigned int h = 0;h < header.cupsHeight;h++) {
-        for (unsigned int band = 0;band < nbands;band++) {
-          dp = convertLine(bp,lineBuf,h,plane+band,header.cupsWidth,
-                 bytesPerLine);
-          cupsRasterWritePixels(raster,dp,bytesPerLine);
-        }
-        bp += rowsize;
-      }
-    }
-  }
-  if (allocLineBuf) delete[] lineBuf;
-}
-
-static void outPage(poppler::document *doc, int pageNo,
-  cups_raster_t *raster)
-{
-  int rotate = 0;
-  double paperdimensions[2], /* Physical size of the paper */
-    margins[4];	/* Physical margins of print */
-  ppd_size_t *size;		/* Page size */
-  ppd_size_t *size_matched = NULL;
-  double l, swap;
-  int imageable_area_fit = 0;
-  int i;
-
-  poppler::page *current_page =doc->create_page(pageNo-1);
-  poppler::page_box_enum box = poppler::page_box_enum::media_box;
-  poppler::rectf mediaBox = current_page->page_rect(box);
-  poppler::page::orientation_enum orient = current_page->orientation();
-  switch (orient) {
-    case poppler::page::landscape: rotate=90;
-     break;
-    case poppler::page::upside_down: rotate=180;
-     break;
-    case poppler::page::seascape: rotate=270;
-     break;
-     default:rotate=0;
-  }
-  fprintf(stderr, "DEBUG: mediaBox = [ %f %f %f %f ]; rotate = %d\n",
-	  mediaBox.left(), mediaBox.top(), mediaBox.right(), mediaBox.bottom(), rotate);
-  l = mediaBox.width();
-  if (l < 0) l = -l;
-  if (rotate == 90 || rotate == 270)
-    header.PageSize[1] = (unsigned)l;
-  else
-    header.PageSize[0] = (unsigned)l;
-  l = mediaBox.height();
-  if (l < 0) l = -l;
-  if (rotate == 90 || rotate == 270)
-    header.PageSize[0] = (unsigned)l;
-  else
-    header.PageSize[1] = (unsigned)l;
-
-  memset(paperdimensions, 0, sizeof(paperdimensions));
-  memset(margins, 0, sizeof(margins));
-  if (ppd) {
-    imageable_area_fit = 0;
-    size_matched = NULL;
-    for (i = ppd->num_sizes, size = ppd->sizes;
-	 i > 0;
-	 i --, size ++)
-      /* Skip page sizes which conflict with settings of the other options */
-      /* TODO XXX */
-      /* Find size of document's page under the PPD page sizes */
-      if (fabs(header.PageSize[1] - size->length) / size->length < 0.01 &&
-	  fabs(header.PageSize[0] - size->width) / size->width < 0.01 &&
-	  (size_matched == NULL ||
-	   !strcasecmp(pageSizeRequested, size->name)))
-	size_matched = size;
-    if (size_matched == NULL)
-      /* Input page size does not fit any of the PPD's sizes, try to fit
-	 the input page size into the imageable areas of the PPD's sizes */
-      for (i = ppd->num_sizes, size = ppd->sizes;
-	   i > 0;
-	   i --, size ++)
-	if (fabs(header.PageSize[1] - size->top + size->bottom) /
-	    size->length < 0.01 &&
-	    fabs(header.PageSize[0] - size->right + size->left) /
-	    size->width < 0.01 &&
-	    (size_matched == NULL ||
-	     !strcasecmp(pageSizeRequested, size->name))) {
-	  fprintf(stderr, "DEBUG: Imageable area fit\n");
-	  imageable_area_fit = 1;
-	  size_matched = size;
-	}
-    if (size_matched) {
-      /*
-       * Standard size...
-       */
-      size = size_matched;
-      fprintf(stderr, "DEBUG: size = %s\n", size->name);
-      paperdimensions[0] = size->width;
-      paperdimensions[1] = size->length;
-      if (pwgraster == 0) {
-	margins[0] = size->left;
-	margins[1] = size->bottom;
-	margins[2] = size->width - size->right;
-	margins[3] = size->length - size->top;
-      }
-      strncpy(header.cupsPageSizeName, size->name, 64);
-    } else {
-      /*
-       * No matching portrait size; look for a matching size in
-       * landscape orientation...
-       */
-
-      imageable_area_fit = 0;
-      size_matched = 0;
-      for (i = ppd->num_sizes, size = ppd->sizes;
-	   i > 0;
-	   i --, size ++)
-	if (fabs(header.PageSize[0] - size->length) / size->length < 0.01 &&
-	    fabs(header.PageSize[1] - size->width) / size->width < 0.01 &&
-	    (size_matched == NULL ||
-	     !strcasecmp(pageSizeRequested, size->name)))
-	  size_matched = size;
-      if (size_matched == NULL)
-	/* Input page size does not fit any of the PPD's sizes, try to fit
-	   the input page size into the imageable areas of the PPD's sizes */
-	for (i = ppd->num_sizes, size = ppd->sizes;
-	     i > 0;
-	     i --, size ++)
-	  if (fabs(header.PageSize[0] - size->top + size->bottom) /
-	      size->length < 0.01 &&
-	      fabs(header.PageSize[1] - size->right + size->left) /
-	      size->width < 0.01 &&
-	      (size_matched == NULL ||
-	       !strcasecmp(pageSizeRequested, size->name))) {
-	    fprintf(stderr, "DEBUG: Imageable area fit\n");
-	    imageable_area_fit = 1;
-	    size_matched = size;
-	  }
-      if (size_matched) {
-	/*
-	 * Standard size in landscape orientation...
-	 */
-	size = size_matched;
-	fprintf(stderr, "DEBUG: landscape size = %s\n", size->name);
-	paperdimensions[0] = size->width;
-	paperdimensions[1] = size->length;
-	if (pwgraster == 0) {
-	  margins[0] = size->left;
-	  margins[1] = size->bottom;
-	  margins[2] = size->width - size->right;
-	  margins[3] = size->length - size->top;
-	}
-	strncpy(header.cupsPageSizeName, size->name, 64);
-      } else {
-	/*
-	 * Custom size...
-	 */
-	fprintf(stderr, "DEBUG: size = Custom\n");
-	paperdimensions[1] = size->length;
-	for (i = 0; i < 2; i ++)
-	  paperdimensions[i] = header.PageSize[i];
-	if (pwgraster == 0)
-	  for (i = 0; i < 4; i ++)
-	    margins[i] = ppd->custom_margins[i];
-	snprintf(header.cupsPageSizeName, 64,
-		 "Custom.%dx%d",
-		 header.PageSize[0], header.PageSize[1]);
-      }
-    }
-  } else {
-    for (i = 0; i < 2; i ++)
-      paperdimensions[i] = header.PageSize[i];
-    if (header.cupsImagingBBox[3] > 0.0) {
-      /* Set margins if we have a bounding box defined ... */
-      if (pwgraster == 0) {
-	margins[0] = header.cupsImagingBBox[0];
-	margins[1] = header.cupsImagingBBox[1];
-	margins[2] = paperdimensions[0] - header.cupsImagingBBox[2];
-	margins[3] = paperdimensions[1] - header.cupsImagingBBox[3];
-      }
-    } else
-      /* ... otherwise use zero margins */
-      for (i = 0; i < 4; i ++)
-	margins[i] = 0.0;
-    /*margins[0] = 0.0;
-    margins[1] = 0.0;
-    margins[2] = header.PageSize[0];
-    margins[3] = header.PageSize[1];*/
-  }
-
-  if (header.Duplex && (pageNo & 1) == 0) {
-    /* backside: change margin if needed */
-    if (swap_margin_x) {
-      swap = margins[2]; margins[2] = margins[0]; margins[0] = swap;
-    }
-    if (swap_margin_y) {
-      swap = margins[3]; margins[3] = margins[1]; margins[1] = swap;
-    }
-  }
-
-  if (imageable_area_fit == 0) {
-    bitmapoffset[0] = margins[0] / 72.0 * header.HWResolution[0];
-    bitmapoffset[1] = margins[3] / 72.0 * header.HWResolution[1];
-  } else {
-    bitmapoffset[0] = 0;
-    bitmapoffset[1] = 0;
-  }
-
-  /* write page header */
-  if (pwgraster == 0) {
-    header.cupsWidth = ((paperdimensions[0] - margins[0] - margins[2]) /
-			72.0 * header.HWResolution[0]) + 0.5;
-    header.cupsHeight = ((paperdimensions[1] - margins[1] - margins[3]) /
-			 72.0 * header.HWResolution[1]) + 0.5;
-  } else {
-    header.cupsWidth = (paperdimensions[0] /
-			72.0 * header.HWResolution[0]) + 0.5;
-    header.cupsHeight = (paperdimensions[1] /
-			 72.0 * header.HWResolution[1]) + 0.5;
-  }
-  for (i = 0; i < 2; i ++) {
-    header.cupsPageSize[i] = paperdimensions[i];
-    header.PageSize[i] = (unsigned int)(header.cupsPageSize[i] + 0.5);
-    if (pwgraster == 0)
-      header.Margins[i] = margins[i] + 0.5;
-    else
-      header.Margins[i] = 0;
-  }
-  if (pwgraster == 0) {
-    header.cupsImagingBBox[0] = margins[0];
-    header.cupsImagingBBox[1] = margins[1];
-    header.cupsImagingBBox[2] = paperdimensions[0] - margins[2];
-    header.cupsImagingBBox[3] = paperdimensions[1] - margins[3];
-    for (i = 0; i < 4; i ++)
-      header.ImagingBoundingBox[i] =
-	(unsigned int)(header.cupsImagingBBox[i] + 0.5);
-  } else
-    for (i = 0; i < 4; i ++) {
-      header.cupsImagingBBox[i] = 0.0;
-      header.ImagingBoundingBox[i] = 0;
-    }
-
-  bytesPerLine = header.cupsBytesPerLine = (header.cupsBitsPerPixel *
-    header.cupsWidth + 7) / 8;
-  if (header.cupsColorOrder == CUPS_ORDER_BANDED) {
-    header.cupsBytesPerLine *= header.cupsNumColors;
-  }
-  if (!cupsRasterWriteHeader2(raster,&header)) {
-      fprintf(stderr, "ERROR: Can't write page %d header\n",pageNo );
-      exit(1);
-  }
-
-  /* write page image */
-  writePageImage(raster,doc,pageNo);
-}
-
-static void setPopplerColorProfile()
-{
-  if (header.cupsBitsPerColor != 8 && header.cupsBitsPerColor != 16) {
-    /* color Profile is not supported */
-    return;
-  }
-  /* set poppler color profile */
-  switch (header.cupsColorSpace) {
-  case CUPS_CSPACE_CIELab:
-  case CUPS_CSPACE_ICC1:
-  case CUPS_CSPACE_ICC2:
-  case CUPS_CSPACE_ICC3:
-  case CUPS_CSPACE_ICC4:
-  case CUPS_CSPACE_ICC5:
-  case CUPS_CSPACE_ICC6:
-  case CUPS_CSPACE_ICC7:
-  case CUPS_CSPACE_ICC8:
-  case CUPS_CSPACE_ICC9:
-  case CUPS_CSPACE_ICCA:
-  case CUPS_CSPACE_ICCB:
-  case CUPS_CSPACE_ICCC:
-  case CUPS_CSPACE_ICCD:
-  case CUPS_CSPACE_ICCE:
-  case CUPS_CSPACE_ICCF:
-    if (colorProfile == NULL) {
-      cmsCIExyY wp;
-#ifdef USE_LCMS1
-      cmsWhitePointFromTemp(6504,&wp); /* D65 White point */
-#else
-      cmsWhitePointFromTemp(&wp,6504); /* D65 White point */
-#endif
-      colorProfile = cmsCreateLab4Profile(&wp);
-    }
-    break;
-  case CUPS_CSPACE_CIEXYZ:
-    if (colorProfile == NULL) {
-      /* tansform color space via CIELab */
-      cmsCIExyY wp;
-#ifdef USE_LCMS1
-      cmsWhitePointFromTemp(6504,&wp); /* D65 White point */
-#else
-      cmsWhitePointFromTemp(&wp,6504); /* D65 White point */
-#endif
-      cmsxyY2XYZ(&D65WhitePoint,&wp);
-      colorProfile = cmsCreateLab4Profile(&wp);
-    }
-    break;
-  case CUPS_CSPACE_SRGB:
-    colorProfile = cmsCreate_sRGBProfile();
-    break;
-  case CUPS_CSPACE_ADOBERGB:
-    colorProfile = adobergb_profile();
-    break;
-  case CUPS_CSPACE_SW:
-    colorProfile = sgray_profile();
-    break;
-  case CUPS_CSPACE_RGB:
-  case CUPS_CSPACE_K:
-  case CUPS_CSPACE_W:
-  case CUPS_CSPACE_WHITE:
-  case CUPS_CSPACE_GOLD:
-  case CUPS_CSPACE_SILVER:
-    /* We can set specified profile to poppler profile */
-    popplerColorProfile = colorProfile;
-    break;
-  case CUPS_CSPACE_CMYK:
-  case CUPS_CSPACE_KCMY:
-  case CUPS_CSPACE_KCMYcm:
-  case CUPS_CSPACE_YMCK:
-  case CUPS_CSPACE_RGBA:
-  case CUPS_CSPACE_RGBW:
-  case CUPS_CSPACE_GMCK:
-  case CUPS_CSPACE_GMCS:
-  case CUPS_CSPACE_CMY:
-  case CUPS_CSPACE_YMC:
-    /* use standard RGB */
-    popplerColorProfile = NULL;
-    break;
-  default:
-    fprintf(stderr, "ERROR: Specified ColorSpace is not supported\n" );
-    exit(1);
-    break;
-  }
-}
-
-int main(int argc, char *argv[]) {
-  poppler::document *doc;
-  int i;
-  int npages=0;
-  cups_raster_t *raster;
-
-  cmsSetLogErrorHandler(lcmsErrorHandler);
-  parseOpts(argc, argv);
-
-  if (argc == 6) {
-    /* stdin */
-    int fd;
-    char name[BUFSIZ];
-    char buf[BUFSIZ];
-    int n;
-
-    fd = cupsTempFd(name,sizeof(name));
-    if (fd < 0) {
-      fprintf(stderr, "ERROR: Can't create temporary file\n");
-      exit(1);
-    }
-
-    /* copy stdin to the tmp file */
-    while ((n = read(0,buf,BUFSIZ)) > 0) {
-      if (write(fd,buf,n) != n) {
-        fprintf(stderr, "ERROR: Can't copy stdin to temporary file\n" );
-        close(fd);
-	exit(1);
-      }
-    }
-    close(fd);
-    doc=poppler::document::load_from_file(name,"","");
-    /* remove name */
-    unlink(name);
-  } else {
-    /* argc == 7 filenmae is specified */
-    FILE *fp;
-
-    if ((fp = fopen(argv[6],"rb")) == 0) {
-        fprintf(stderr, "ERROR: Can't open input file %s\n",argv[6]);
-	exit(1);
-    }
-    parsePDFTOPDFComment(fp);
-    fclose(fp);
-    doc=poppler::document::load_from_file(argv[6],"","");
-  }
-
-  if(doc != NULL)
-    npages = doc->pages();
-
-  /* fix NumCopies, Collate ccording to PDFTOPDFComments */
-  header.NumCopies = deviceCopies;
-  header.Collate = deviceCollate ? CUPS_TRUE : CUPS_FALSE;
-  /* fixed other values that pdftopdf handles */
-  header.MirrorPrint = CUPS_FALSE;
-  header.Orientation = CUPS_ORIENT_0;
-
-  if (header.cupsBitsPerColor != 1
-     && header.cupsBitsPerColor != 2
-     && header.cupsBitsPerColor != 4
-     && header.cupsBitsPerColor != 8
-     && header.cupsBitsPerColor != 16) {
-    fprintf(stderr, "ERROR: Specified color format is not supported\n");
-    exit(1);
-  }
-  if (header.cupsColorOrder == CUPS_ORDER_PLANAR) {
-    nplanes = header.cupsNumColors;
-  } else {
-    nplanes = 1;
-  }
-  if (header.cupsColorOrder == CUPS_ORDER_BANDED) {
-    nbands = header.cupsNumColors;
-  } else {
-    nbands = 1;
-  }
-  /* set image's values */
-  switch (header.cupsColorSpace) {
-  case CUPS_CSPACE_CIELab:
-  case CUPS_CSPACE_ICC1:
-  case CUPS_CSPACE_ICC2:
-  case CUPS_CSPACE_ICC3:
-  case CUPS_CSPACE_ICC4:
-  case CUPS_CSPACE_ICC5:
-  case CUPS_CSPACE_ICC6:
-  case CUPS_CSPACE_ICC7:
-  case CUPS_CSPACE_ICC8:
-  case CUPS_CSPACE_ICC9:
-  case CUPS_CSPACE_ICCA:
-  case CUPS_CSPACE_ICCB:
-  case CUPS_CSPACE_ICCC:
-  case CUPS_CSPACE_ICCD:
-  case CUPS_CSPACE_ICCE:
-  case CUPS_CSPACE_ICCF:
-  case CUPS_CSPACE_CIEXYZ:
-    if (header.cupsColorOrder != CUPS_ORDER_CHUNKED
-       || (header.cupsBitsPerColor != 8
-          && header.cupsBitsPerColor != 16)) {
-      fprintf(stderr, "ERROR: Specified color format is not supported\n");
-      exit(1);
-    }
-  case CUPS_CSPACE_RGB:
-  case CUPS_CSPACE_SRGB:
-  case CUPS_CSPACE_ADOBERGB:
-  case CUPS_CSPACE_CMY:
-  case CUPS_CSPACE_YMC:
-  case CUPS_CSPACE_CMYK:
-  case CUPS_CSPACE_KCMY:
-  case CUPS_CSPACE_KCMYcm:
-  case CUPS_CSPACE_YMCK:
-  case CUPS_CSPACE_RGBA:
-  case CUPS_CSPACE_RGBW:
-  case CUPS_CSPACE_GMCK:
-  case CUPS_CSPACE_GMCS:
-    popplerBitsPerPixel = 24;
-    popplerNumColors = 3;
-    break;
-  case CUPS_CSPACE_K:
-  case CUPS_CSPACE_W:
-  case CUPS_CSPACE_SW:
-  case CUPS_CSPACE_WHITE:
-  case CUPS_CSPACE_GOLD:
-  case CUPS_CSPACE_SILVER:
-    if (header.cupsBitsPerColor == 1
-       && header.cupsBitsPerPixel == 1) {
-      popplerBitsPerPixel = 1;
-    } else {
-      popplerBitsPerPixel = 8;
-    }
-    /* set paper color white */
-    popplerNumColors = 1;
-    break;
-  default:
-    fprintf(stderr, "ERROR: Specified ColorSpace is not supported\n");
-    exit(1);
-    break;
-  }
-
-  if (!cm_disabled) {
-    setPopplerColorProfile();
-  }
-
-  if ((raster = cupsRasterOpen(1, pwgraster ? CUPS_RASTER_WRITE_PWG :
-			       CUPS_RASTER_WRITE)) == 0) {
-        fprintf(stderr, "ERROR: Can't open raster stream\n");
-	exit(1);
-  }
-  selectConvertFunc(raster);
-  if(doc != NULL){
-    for (i = 1;i <= npages;i++) {
-      outPage(doc,i,raster);
-    }
-  } else
-    fprintf(stderr, "DEBUG: Input is empty, outputting empty file.\n");
-
-  cupsRasterClose(raster);
-
-  delete doc;
-  if (ppd != NULL) {
-    ppdClose(ppd);
-  }
-  if (colorProfile != NULL) {
-    cmsCloseProfile(colorProfile);
-  }
-  if (popplerColorProfile != NULL && popplerColorProfile != colorProfile) {
-    cmsCloseProfile(popplerColorProfile);
-  }
-  if (colorTransform != NULL) {
-    cmsDeleteTransform(colorTransform);
-  }
-
-  return exitCode;
-}
-
-/* replace memory allocation methods for memory check */
-/* For compatibility with g++ >= 4.7 compilers _GLIBCXX_THROW
- *  should be used as a guard, otherwise use traditional definition */
-#ifndef _GLIBCXX_THROW
-#define _GLIBCXX_THROW throw
-#endif
-
-void * operator new(size_t size) _GLIBCXX_THROW (std::bad_alloc)
-{
-  return malloc(size);
-}
-
-void operator delete(void *p) throw ()
-{
-  free(p);
-}
-
-void * operator new[](size_t size) _GLIBCXX_THROW (std::bad_alloc)
-{
-  return malloc(size);
-}
-
-void operator delete[](void *p) throw ()
-{
-  free(p);
-}
diff --git a/filter/pdfutils.c b/filter/pdfutils.c
deleted file mode 100644
index 8dbf65d..0000000
--- a/filter/pdfutils.c
+++ /dev/null
@@ -1,431 +0,0 @@
-/*
- *   PDF file output routines.
- *
- *   Copyright 2008 by Tobias Hoffmann.
- *
- *   This file is licensed as noted in "COPYING" 
- *   which should have been included with this file.
- *
- */
-#include <stdio.h>
-#include <assert.h>
-#include <stdarg.h>
-#include <memory.h>
-#include <stdlib.h>
-#include <string.h>
-#include "pdfutils.h"
-#include "fontembed/embed.h"
-
-void pdfOut_printf(pdfOut *pdf,const char *fmt,...) // {{{
-{
-  assert(pdf);
-  int len;
-  va_list ap;
-
-  va_start(ap,fmt);
-  len=vprintf(fmt,ap);
-  va_end(ap);
-  pdf->filepos+=len;
-}
-// }}}
-
-void pdfOut_putString(pdfOut *pdf,const char *str,int len) // {{{ - >len==-1: strlen()
-{
-  assert(pdf);
-  assert(str);
-  if (len==-1) {
-    len=strlen(str);
-  }
-  putc('(',stdout);
-  // escape special chars: \0 \\ \( \)  -- don't bother about balanced parens
-  int iA=0;
-  for (;len>0;iA++,len--) {
-    if ( (str[iA]<32)||(str[iA]>126) ) {
-      fwrite(str,1,iA,stdout);
-      fprintf(stdout,"\\%03o",(unsigned char)str[iA]);
-      pdf->filepos+=iA+4;
-      str+=iA+1;
-      iA=-1;
-    } else if ( (str[iA]=='(')||(str[iA]==')')||(str[iA]=='\\') ) {
-      fwrite(str,1,iA,stdout);
-      fprintf(stdout,"\\%c",str[iA]);
-      pdf->filepos+=iA+2;
-      str+=iA+1;
-      iA=-1;
-    }
-  }
-  pdf->filepos+=iA+2;
-  fwrite(str,1,iA,stdout);
-  putc(')',stdout);
-}
-// }}}
-
-void pdfOut_putHexString(pdfOut *pdf,const char *str,int len) // {{{ - >len==-1: strlen()
-{
-  assert(pdf);
-  assert(str);
-  if (len==-1) {
-    len=strlen(str);
-  }
-  pdf->filepos+=2*len+2;
-  putc('<',stdout);
-  for (;len>0;str++,len--) {
-    fprintf(stdout,"%02x",(unsigned char)*str);
-  }
-  putc('>',stdout);
-}
-// }}}
-
-pdfOut *pdfOut_new() // {{{ -  NULL on error 
-{
-  pdfOut *ret=malloc(sizeof(pdfOut));
-  if (ret) {
-    memset(ret,0,sizeof(pdfOut));
-  }
-
-  return ret;
-}
-// }}}
-
-// NOTE: uses statically allocated buffer
-const char *pdfOut_to_pdfdate(struct tm *curtm) // {{{
-{
-  static char curdate[250];
-  if (!curtm) {
-    time_t curtime;
-    curtime = time(NULL);
-    curtm   = localtime(&curtime);
-  }
-  strftime(curdate, sizeof(curdate), "D:%Y%m%d%H%M%S%z", curtm);
-  curdate[23]=0;
-  curdate[22]='\'';
-  curdate[21]=curdate[18];
-  curdate[20]=curdate[17];
-  curdate[19]='\'';
-  return curdate;
-}
-// }}}
-
-int pdfOut_add_xref(pdfOut *pdf) // {{{  -  returns obj_no
-{
-  assert(pdf);
-  assert(pdf->xrefsize<=pdf->xrefalloc);
-
-  if (pdf->xrefsize==pdf->xrefalloc) {
-    long *tmp;
-    pdf->xrefalloc+=50;
-    tmp=realloc(pdf->xref,sizeof(long)*pdf->xrefalloc);
-    if (!tmp) {
-      pdf->xrefalloc=-1;
-      return -1;
-    }
-    pdf->xref=tmp;
-  }
-  pdf->xref[pdf->xrefsize++]=pdf->filepos;
-  return pdf->xrefsize; // xrefsize+1
-}
-// }}}
-
-int pdfOut_add_page(pdfOut *pdf,int obj) // {{{ -  returns false on error
-{
-  assert(pdf);
-  assert(obj>0);
-  assert(pdf->pagessize<=pdf->pagesalloc);
-
-  if (pdf->pagessize==pdf->pagesalloc) {
-    int *tmp;
-    pdf->pagesalloc+=10;
-    tmp=realloc(pdf->pages,sizeof(int)*pdf->pagesalloc);
-    if (!tmp) {
-      pdf->pagesalloc=-1;
-      return 0;
-    }
-    pdf->pages=tmp;
-  }
-  pdf->pages[pdf->pagessize++]=obj;
-  return 1;
-}
-// }}}
-
-int pdfOut_add_kv(pdfOut *pdf,const char *key,const char *val) // {{{ -  returns false on error
-{
-  assert(pdf);
-  assert(pdf->kvsize<=pdf->kvalloc);
-
-  if (pdf->kvsize==pdf->kvalloc) {
-    struct keyval_t *tmp;
-    pdf->kvalloc+=10;
-    tmp=realloc(pdf->kv,sizeof(struct keyval_t)*pdf->kvalloc);
-    if (!tmp) {
-      pdf->kvalloc=-1;
-      return 0;
-    }
-    pdf->kv=tmp;
-  }
-  pdf->kv[pdf->kvsize].key=strdup(key);
-  pdf->kv[pdf->kvsize].value=strdup(val);
-  if ( (!pdf->kv[pdf->kvsize].key)||(!pdf->kv[pdf->kvsize].value) ) {
-    return 0;
-  }
-  pdf->kvsize++;
-  return 1;
-}
-// }}}
-
-int pdfOut_begin_pdf(pdfOut *pdf) // ,...output_device?...) // {{{ - false on error
-{
-  assert(pdf);
-  assert(pdf->kvsize==0); // otherwise: finish_pdf has not been called
-  int pages_obj;
-
-  pdf->xrefsize=pdf->pagessize=0;
-  pdf->filepos=0;
-  pages_obj=pdfOut_add_xref(pdf); // fixed later
-  if (pages_obj!=1) {
-    return 0;
-  }
-  pdfOut_printf(pdf,"%%PDF-1.3\n");
-  return 1;
-}
-// }}}
-
-void pdfOut_finish_pdf(pdfOut *pdf) // {{{
-{
-  int iA;
-  int root_obj,info_obj=0,xref_start;
-  assert( (pdf)&&(pdf->filepos!=-1) );
-
-  // pages 
-  const int pages_obj=1;
-  pdf->xref[0]=pdf->filepos; // now fix it
-  pdfOut_printf(pdf,"%d 0 obj\n"
-                    "<</Type/Pages\n"
-                    "  /Count %d\n"
-                    "  /Kids [",
-                    pages_obj,pdf->pagessize);
-  for (iA=0;iA<pdf->pagessize;iA++) {
-    pdfOut_printf(pdf,"%d 0 R ",pdf->pages[iA]);
-  }
-  pdfOut_printf(pdf,"]\n"
-                    ">>\n"
-                    "endobj\n");
-
-  // rootdict
-  root_obj=pdfOut_add_xref(pdf);
-  pdfOut_printf(pdf,"%d 0 obj\n"
-                    "<</Type/Catalog\n"
-                    "  /Pages %d 0 R\n"
-                    ">>\n"
-                    "endobj\n",
-                    root_obj,pages_obj);
-
-  // info 
-  if (pdf->kvsize) {
-    info_obj=pdfOut_add_xref(pdf);
-    pdfOut_printf(pdf,"%d 0 obj\n"
-                      "<<\n",
-                      info_obj);
-    for (iA=0;iA<pdf->kvsize;iA++) {
-      pdfOut_printf(pdf,"  /%s ",pdf->kv[iA].key);
-      pdfOut_putString(pdf,pdf->kv[iA].value,-1);
-      pdfOut_printf(pdf,"\n");
-    }
-    pdfOut_printf(pdf,">>\n"
-                      "endobj\n");
-  }
-  // TODO: some return-value checking (??)
- 
-  // write xref
-  xref_start=pdf->filepos;
-  pdfOut_printf(pdf,"xref\n"
-                    "%d %d\n"
-                    "%010d 65535 f \n",
-                    0,pdf->xrefsize+1,0);
-  for (iA=0;iA<pdf->xrefsize;iA++) {
-    pdfOut_printf(pdf,"%010ld 00000 n \n",
-                      pdf->xref[iA]);
-  }
-  pdfOut_printf(pdf,"trailer\n"
-                    "<<\n"
-                    "  /Size %d\n"
-                    "  /Root %d 0 R\n",
-                    pdf->xrefsize+1,
-                    root_obj);
-  if (info_obj) {
-    pdfOut_printf(pdf,"  /Info %d 0 R\n",info_obj);
-  }
-  pdfOut_printf(pdf,">>\n"
-                    "startxref\n"
-                    "%d\n"
-                    "%%%%EOF\n",
-                    xref_start);
-
-  // set to done
-  pdf->filepos=-1;
-  for (iA=0;iA<pdf->kvsize;iA++) {
-    free(pdf->kv[iA].key);
-    free(pdf->kv[iA].value);
-  }
-  pdf->kvsize=0;
-}
-// }}}
-
-void pdfOut_free(pdfOut *pdf) // {{{
-{
-  if (pdf) {
-    assert(pdf->kvsize==0); // otherwise: finish_pdf has not been called
-    free(pdf->kv);
-    free(pdf->pages);
-    free(pdf->xref);
-    free(pdf);
-  }
-}
-// }}}
-
-static void pdfOut_outfn(const char *buf,int len,void *context) // {{{
-{
-  pdfOut *pdf=(pdfOut *)context;
-
-  if (fwrite(buf,1,len,stdout)!=len) {
-    perror("Short write");
-    assert(0);
-    return;
-  }
-  pdf->filepos+=len;
-}
-// }}}
-
-int pdfOut_write_font(pdfOut *pdf,EMB_PARAMS *emb) // {{{ 
-{
-  assert(pdf);
-  assert(emb);
-
-  EMB_PDF_FONTDESCR *fdes=emb_pdf_fontdescr(emb);
-  if (!fdes) {
-    if (emb->outtype==EMB_FMT_STDFONT) { // std-14 font
-      const int f_obj=pdfOut_add_xref(pdf);
-      char *res=emb_pdf_simple_stdfont(emb);
-      if (!res) {
-        return 0;
-      }
-
-      pdfOut_printf(pdf,"%d 0 obj\n"
-                        "%s"
-                        "endobj\n"
-                        ,f_obj,res);
-      free(res);
-      return f_obj;
-    }
-    return 0;
-  }
-
-  const int ff_obj=pdfOut_add_xref(pdf);
-  pdfOut_printf(pdf,"%d 0 obj\n"
-                    "<</Length %d 0 R\n"
-                    ,ff_obj,ff_obj+1);
-  if (emb_pdf_get_fontfile_subtype(emb)) {
-    pdfOut_printf(pdf,"  /Subtype /%s\n",
-                      emb_pdf_get_fontfile_subtype(emb));
-  }
-  if (emb->outtype==EMB_FMT_TTF) {
-    pdfOut_printf(pdf,"  /Length1 %d 0 R\n"
-                      ,ff_obj+2);
-  } else if (emb->outtype==EMB_FMT_T1) { // TODO
-    pdfOut_printf(pdf,"  /Length1 ?\n"
-                      "  /Length2 ?\n"
-                      "  /Length3 ?\n"
-                      );
-  }
-  pdfOut_printf(pdf,">>\n"
-                    "stream\n");
-  long streamsize=-pdf->filepos;
-  const int outlen=emb_embed(emb,pdfOut_outfn,pdf);
-  streamsize+=pdf->filepos;
-  pdfOut_printf(pdf,"\nendstream\n"
-                    "endobj\n");
-
-  const int l0_obj=pdfOut_add_xref(pdf);
-  assert(l0_obj==ff_obj+1);
-  pdfOut_printf(pdf,"%d 0 obj\n"
-                    "%ld\n"
-                    "endobj\n"
-                    ,l0_obj,streamsize);
-
-  if (emb->outtype==EMB_FMT_TTF) {
-    const int l1_obj=pdfOut_add_xref(pdf);
-    assert(l1_obj==ff_obj+2);
-    pdfOut_printf(pdf,"%d 0 obj\n"
-                      "%d\n"
-                      "endobj\n"
-                      ,l1_obj,outlen);
-  }
-
-  const int fd_obj=pdfOut_add_xref(pdf);
-  char *res=emb_pdf_simple_fontdescr(emb,fdes,ff_obj);
-  if (!res) {
-    free(fdes);
-    return 0;
-  }
-  pdfOut_printf(pdf,"%d 0 obj\n"
-                    "%s"
-                    "endobj\n"
-                    ,fd_obj,res);
-  free(res);
-
-  EMB_PDF_FONTWIDTHS *fwid=emb_pdf_fontwidths(emb);
-  if (!fwid) {
-    free(fdes);
-    return 0;
-  }
-  const int f_obj=pdfOut_add_xref(pdf);
-  res=emb_pdf_simple_font(emb,fdes,fwid,fd_obj);
-  if (!res) {
-    free(fwid);
-    free(fdes);
-    return 0;
-  }
-  pdfOut_printf(pdf,"%d 0 obj\n"
-                    "%s"
-                    "endobj\n"
-                    ,f_obj,res);
-  free(res);
-  free(fwid);
-
-  if (emb->plan&EMB_A_MULTIBYTE) {
-    res=emb_pdf_simple_cidfont(emb,fdes->fontname,f_obj);
-    if (!res) {
-      free(fdes);
-      return 0;
-    }
-    const int cf_obj=pdfOut_add_xref(pdf);
-    pdfOut_printf(pdf,"%d 0 obj\n"
-                      "%s"
-                      "endobj\n"
-                      ,cf_obj,res);
-    free(res);
-    free(fdes);
-    return cf_obj;
-  }
-
-  free(fdes);
-  return f_obj;
-}
-// }}}
-
-#if 0
-one_page(...parent,resources,mediabox,contents);
-{
-//                    "  /Resources %d 0 R\n"
-  pdfOut_printf(pdf,"%d 0 obj\n"
-                    "<</Type/Page\n"
-                    "  /Parent 1 0 R\n"
-                    "  /MediaBox [0 0 %d %d]\n"
-                    "  /Contents %d 0 R\n"
-                    ">>\n"
-                    "endobj\n"
-                    ,,,PageWidth,PageLength // TODO: into pdf->
-  ...
-}
-
-... pfb_embedder ... pfa?
-#endif
diff --git a/filter/pdfutils.h b/filter/pdfutils.h
deleted file mode 100644
index 7c53477..0000000
--- a/filter/pdfutils.h
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- *   PDF file output routines.
- *
- *   Copyright 2008 by Tobias Hoffmann.
- *
- *   This file is licensed as noted in "COPYING" 
- *   which should have been included with this file.
- *
- */
-#include <time.h>
-
-struct keyval_t {
-  char *key,*value;
-};
-
-typedef struct {
-  long filepos;
-
-  int pagessize,pagesalloc;
-  int *pages;
-
-  int xrefsize,xrefalloc;
-  long *xref;
-
-  int kvsize,kvalloc;
-  struct keyval_t *kv;
-} pdfOut;
-
-/* allocates a new pdfOut structure
- * returns NULL on error
- */
-pdfOut *pdfOut_new();
-void pdfOut_free(pdfOut *pdf);
-
-/* start outputting a pdf
- * returns false on error
- */
-int pdfOut_begin_pdf(pdfOut *pdf);
-void pdfOut_finish_pdf(pdfOut *pdf);
-
-/* General output routine for our pdf.
- * Keeps track of characters actually written out
- */
-void pdfOut_printf(pdfOut *pdf,const char *fmt,...)
-  __attribute__((format(printf, 2, 3)));
-
-/* write out an escaped pdf string: e.g.  (Text \(Test\)\n)
- * >len==-1: use strlen(str) 
- */
-void pdfOut_putString(pdfOut *pdf,const char *str,int len);
-void pdfOut_putHexString(pdfOut *pdf,const char *str,int len);
-
-/* Format the broken up timestamp according to
- * pdf requirements for /CreationDate
- * NOTE: uses statically allocated buffer 
- */
-const char *pdfOut_to_pdfdate(struct tm *curtm);
-
-/* begin a new object at current point of the 
- * output stream and add it to the xref table.
- * returns the obj number.
- */
-int pdfOut_add_xref(pdfOut *pdf);
-
-/* adds page dictionary >obj to the global Pages tree
- * returns false on error
- */
-int pdfOut_add_page(pdfOut *pdf,int obj);
-
-/* add a >key,>val pair to the document's Info dictionary
- * returns false on error
- */
-int pdfOut_add_kv(pdfOut *pdf,const char *key,const char *val);
-
-/* Writes the font >emb including descriptor to the pdf 
- * and returns the object number.
- * On error 0 is returned.
- */
-struct _EMB_PARAMS;
-int pdfOut_write_font(pdfOut *pdf,struct _EMB_PARAMS *emb);
diff --git a/filter/rastertopdf.cpp b/filter/rastertopdf.cpp
deleted file mode 100644
index 76c07da..0000000
--- a/filter/rastertopdf.cpp
+++ /dev/null
@@ -1,1544 +0,0 @@
-/**
- * This program is free software: you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation, either version 3 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- * @brief Convert PWG Raster to a PDF/PCLm file
- * @file rastertopdf.cpp
- * @author Neil 'Superna' Armstrong <superna9999@gmail.com> (C) 2010
- * @author Tobias Hoffmann <smilingthax@gmail.com> (c) 2012
- * @author Till Kamppeter <till.kamppeter@gmail.com> (c) 2014
- * @author Sahil Arora <sahilarora.535@gmail.com> (c) 2017
- */
-
-#include <config.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdint.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <string.h>
-#include <limits>
-#include <signal.h>
-#include <cups/cups.h>
-#include <cups/raster.h>
-#include <cupsfilters/colormanager.h>
-#include <cupsfilters/image.h>
-
-#include <arpa/inet.h>   // ntohl
-
-#include <vector>
-#include <qpdf/QPDF.hh>
-#include <qpdf/QPDFWriter.hh>
-#include <qpdf/QUtil.hh>
-
-#include <qpdf/Pl_Flate.hh>
-#include <qpdf/Pl_Buffer.hh>
-#ifdef QPDF_HAVE_PCLM
-#include <qpdf/Pl_RunLength.hh>
-#include <qpdf/Pl_DCT.hh>
-#endif
-
-#ifdef USE_LCMS1
-#include <lcms.h>
-#define cmsColorSpaceSignature icColorSpaceSignature
-#define cmsSetLogErrorHandler cmsSetErrorHandler
-#define cmsSigXYZData icSigXYZData
-#define cmsSigLuvData icSigLuvData
-#define cmsSigLabData icSigLabData
-#define cmsSigYCbCrData icSigYCbCrData
-#define cmsSigYxyData icSigYxyData
-#define cmsSigRgbData icSigRgbData
-#define cmsSigHsvData icSigHsvData
-#define cmsSigHlsData icSigHlsData
-#define cmsSigCmyData icSigCmyData
-#define cmsSig3colorData icSig3colorData
-#define cmsSigGrayData icSigGrayData
-#define cmsSigCmykData icSigCmykData
-#define cmsSig4colorData icSig4colorData
-#define cmsSig2colorData icSig2colorData
-#define cmsSig5colorData icSig5colorData
-#define cmsSig6colorData icSig6colorData
-#define cmsSig7colorData icSig7colorData
-#define cmsSig8colorData icSig8colorData
-#define cmsSig9colorData icSig9colorData
-#define cmsSig10colorData icSig10colorData
-#define cmsSig11colorData icSig11colorData
-#define cmsSig12colorData icSig12colorData
-#define cmsSig13colorData icSig13colorData
-#define cmsSig14colorData icSig14colorData
-#define cmsSig15colorData icSig15colorData
-#define cmsSaveProfileToMem _cmsSaveProfileToMem
-#else
-#include <lcms2.h>
-#endif
-
-#define DEFAULT_PDF_UNIT 72   // 1/72 inch
-
-#define PROGRAM "rastertopdf"
-
-#define dprintf(format, ...) fprintf(stderr, "DEBUG2: (" PROGRAM ") " format, __VA_ARGS__)
-
-#define iprintf(format, ...) fprintf(stderr, "INFO: (" PROGRAM ") " format, __VA_ARGS__)
-
-typedef enum {
-  OUTPUT_FORMAT_PDF,
-  OUTPUT_FORMAT_PCLM
-} OutFormatType;
-
-// Compression method for providing data to PCLm Streams.
-typedef enum {
-  DCT_DECODE = 0,
-  FLATE_DECODE,
-  RLE_DECODE
-} CompressionMethod;
-
-// Color conversion function
-typedef unsigned char *(*convertFunction)(unsigned char *src,
-  unsigned char *dst, unsigned int pixels);
-
-// Bit conversion function
-typedef unsigned char *(*bitFunction)(unsigned char *src,
-  unsigned char *dst, unsigned int pixels);
-
-// PDF color conversion function
-typedef void (*pdfConvertFunction)(struct pdf_info * info);
-
-cmsHPROFILE         colorProfile = NULL;     // ICC Profile to be applied to PDF
-int                 cm_disabled = 0;         // Flag rasied if color management is disabled 
-cm_calibration_t    cm_calibrate;            // Status of CUPS color management ("on" or "off")
-convertFunction     conversion_function;     // Raster color conversion function
-bitFunction         bit_function;            // Raster bit function
-
-
-#ifdef USE_LCMS1
-static int lcmsErrorHandler(int ErrorCode, const char *ErrorText)
-{
-  fprintf(stderr, "ERROR: %s\n",ErrorText);
-  return 1;
-}
-#else
-static void lcmsErrorHandler(cmsContext contextId, cmsUInt32Number ErrorCode,
-   const char *ErrorText)
-{
-  fprintf(stderr, "ERROR: %s\n",ErrorText);
-}
-#endif
-
-
-
-// Bit conversion functions
-
-unsigned char *invertBits(unsigned char *src, unsigned char *dst, unsigned int pixels)
-{ 
-    unsigned int i;
-
-    // Invert black to grayscale...
-    for (i = pixels, dst = src; i > 0; i --, dst ++)
-      *dst = ~*dst;
-
-    return dst;
-}	
-
-unsigned char *noBitConversion(unsigned char *src, unsigned char *dst, unsigned int pixels)
-{
-    return src;
-}
-
-// Color conversion functions
-
-unsigned char *rgbToCmyk(unsigned char *src, unsigned char *dst, unsigned int pixels)
-{
-    cupsImageRGBToCMYK(src,dst,pixels);
-    return dst;
-}
-unsigned char *whiteToCmyk(unsigned char *src, unsigned char *dst, unsigned int pixels)
-{
-    cupsImageWhiteToCMYK(src,dst,pixels);
-    return dst;
-}
-
-unsigned char *cmykToRgb(unsigned char *src, unsigned char *dst, unsigned int pixels)
-{
-    cupsImageCMYKToRGB(src,dst,pixels);
-    return dst;
-}
-
-unsigned char *whiteToRgb(unsigned char *src, unsigned char *dst, unsigned int pixels)
-{
-    cupsImageWhiteToRGB(src,dst,pixels);
-    return dst;
-}
-
-unsigned char *rgbToWhite(unsigned char *src, unsigned char *dst, unsigned int pixels)
-{
-    cupsImageRGBToWhite(src,dst,pixels);
-    return dst;
-}
-
-unsigned char *cmykToWhite(unsigned char *src, unsigned char *dst, unsigned int pixels)
-{
-    cupsImageCMYKToWhite(src,dst,pixels);
-    return dst;
-}
-
-unsigned char *noColorConversion(unsigned char *src,
-  unsigned char *dst, unsigned int pixels)
-{
-    return src;
-}
-
-/**
- * 'split_strings()' - Split a string to a vector of strings given some delimiters
- * O - std::vector of std::string after splitting
- * I - input string to be split
- * I - string containing delimiters
- */
-static std::vector<std::string>
-split_strings(std::string const &str, std::string delimiters = ",")
-{
-  std::vector<std::string> vec(0);
-  std::string value = "";
-  bool push_flag = false;
-
-  for (size_t i = 0; i < str.size(); i ++)
-  {
-    if (push_flag && !(value.empty()))
-    {
-      vec.push_back(value);
-      push_flag = false;
-      value.clear();
-    }
-
-    if (delimiters.find(str[i]) != std::string::npos)
-      push_flag = true;
-    else
-      value += str[i];
-  }
-  if (!value.empty())
-    vec.push_back(value);
-  return vec;
-}
-
-/**
- * 'num_digits()' - Calculates the number of digits in an integer
- * O - number of digits in the input integer
- * I - the integer whose digits needs to be calculated
- */
-int num_digits(int n)
-{
-  if (n == 0) return 1;
-  int digits = 0;
-  while (n)
-  {
-    ++digits;
-    n /= 10;
-  }
-  return digits;
-}
-
-/**
- * 'int_to_fwstring()' - Convert a number to fixed width string by padding with zeroes
- * O - converted string
- * I - the integee which needs to be converted to string
- * I - width of string required
- */
-std::string int_to_fwstring(int n, int width)
-{
-  int num_zeroes = width - num_digits(n);
-  if (num_zeroes < 0)
-    num_zeroes = 0;
-  return std::string(num_zeroes, '0') + QUtil::int_to_string(n);
-}
-
-void die(const char * str)
-{
-    fprintf(stderr, "ERROR: (" PROGRAM ") %s\n", str);
-    exit(1);
-}
-
-
-//------------- PDF ---------------
-
-struct pdf_info
-{
-    pdf_info() 
-      : pagecount(0),
-        width(0),height(0),
-        line_bytes(0),
-        bpp(0), bpc(0),
-        pclm_num_strips(0),
-        pclm_strip_height_preferred(16),  /* default strip height */
-        pclm_strip_height(0),
-        pclm_strip_height_supported(1, 16),
-        pclm_compression_method_preferred(0),
-        pclm_source_resolution_supported(0),
-        pclm_source_resolution_default(""),
-        pclm_raster_back_side(""),
-        pclm_strip_data(0),
-        render_intent(""),
-        color_space(CUPS_CSPACE_K),
-        page_width(0),page_height(0),
-        outformat(OUTPUT_FORMAT_PDF)
-    {
-    }
-
-    QPDF pdf;
-    QPDFObjectHandle page;
-    unsigned pagecount;
-    unsigned width;
-    unsigned height;
-    unsigned line_bytes;
-    unsigned bpp;
-    unsigned bpc;
-    unsigned                  pclm_num_strips;
-    unsigned                  pclm_strip_height_preferred;
-    std::vector<unsigned>     pclm_strip_height;
-    std::vector<unsigned>     pclm_strip_height_supported;
-    std::vector<CompressionMethod> pclm_compression_method_preferred;
-    std::vector<std::string>  pclm_source_resolution_supported;
-    std::string               pclm_source_resolution_default;
-    std::string               pclm_raster_back_side;
-    std::vector< PointerHolder<Buffer> > pclm_strip_data;
-    std::string render_intent;
-    cups_cspace_t color_space;
-    PointerHolder<Buffer> page_data;
-    double page_width,page_height;
-    OutFormatType outformat;
-};
-
-int create_pdf_file(struct pdf_info * info, const OutFormatType & outformat)
-{
-    try {
-        info->pdf.emptyPDF();
-        info->outformat = outformat;
-    } catch (...) {
-        return 1;
-    }
-    return 0;
-}
-
-QPDFObjectHandle makeRealBox(double x1, double y1, double x2, double y2)
-{
-    QPDFObjectHandle ret=QPDFObjectHandle::newArray();
-    ret.appendItem(QPDFObjectHandle::newReal(x1));
-    ret.appendItem(QPDFObjectHandle::newReal(y1));
-    ret.appendItem(QPDFObjectHandle::newReal(x2));
-    ret.appendItem(QPDFObjectHandle::newReal(y2));
-    return ret;
-}
-
-QPDFObjectHandle makeIntegerBox(int x1, int y1, int x2, int y2)
-{
-    QPDFObjectHandle ret = QPDFObjectHandle::newArray();
-    ret.appendItem(QPDFObjectHandle::newInteger(x1));
-    ret.appendItem(QPDFObjectHandle::newInteger(y1));
-    ret.appendItem(QPDFObjectHandle::newInteger(x2));
-    ret.appendItem(QPDFObjectHandle::newInteger(y2));
-    return ret;
-}
-
-
-
-
-// PDF color conversion functons...
-
-void modify_pdf_color(struct pdf_info * info, int bpp, int bpc, convertFunction fn)
-{
-    unsigned old_bpp = info->bpp;
-    unsigned old_bpc = info->bpc;
-    double old_ncolor = old_bpp/old_bpc;
-
-    unsigned old_line_bytes = info->line_bytes;
-
-    double new_ncolor = (bpp/bpc);
-
-    info->line_bytes = (unsigned)old_line_bytes*(new_ncolor/old_ncolor);
-    info->bpp = bpp;
-    info->bpc = bpc;
-    conversion_function = fn; 
-
-    return;
-}
-
-void convertPdf_NoConversion(struct pdf_info * info)
-{
-    conversion_function = noColorConversion;
-    bit_function = noBitConversion;
-}
-
-void convertPdf_Cmyk8ToWhite8(struct pdf_info * info)
-{
-    modify_pdf_color(info, 8, 8, cmykToWhite);
-    bit_function = noBitConversion;
-}
-
-void convertPdf_Rgb8ToWhite8(struct pdf_info * info)
-{
-    modify_pdf_color(info, 8, 8, rgbToWhite);
-    bit_function = noBitConversion;
-}
-
-void convertPdf_Cmyk8ToRgb8(struct pdf_info * info)
-{
-    modify_pdf_color(info, 24, 8, cmykToRgb);
-    bit_function = noBitConversion;
-}
-
-void convertPdf_White8ToRgb8(struct pdf_info * info)
-{
-    modify_pdf_color(info, 24, 8, whiteToRgb);
-    bit_function = invertBits;
-}
-
-void convertPdf_Rgb8ToCmyk8(struct pdf_info * info)
-{
-    modify_pdf_color(info, 32, 8, rgbToCmyk);
-    bit_function = noBitConversion;
-}
-
-void convertPdf_White8ToCmyk8(struct pdf_info * info)
-{
-    modify_pdf_color(info, 32, 8, whiteToCmyk);
-    bit_function = invertBits;
-}
-
-void convertPdf_InvertColors(struct pdf_info * info)
-{
-    conversion_function = noColorConversion;
-    bit_function = invertBits;
-}
-
-
-#define PRE_COMPRESS
-
-// Create an '/ICCBased' array and embed a previously 
-// set ICC Profile in the PDF
-QPDFObjectHandle embedIccProfile(QPDF &pdf)
-{
-    if (colorProfile == NULL) {
-      return QPDFObjectHandle::newNull();
-    }
-    
-    // Return handler
-    QPDFObjectHandle ret;
-    // ICCBased array
-    QPDFObjectHandle array = QPDFObjectHandle::newArray();
-    // Profile stream dictionary
-    QPDFObjectHandle iccstream;
-
-    std::map<std::string,QPDFObjectHandle> dict;
-    std::map<std::string,QPDFObjectHandle> streamdict;
-    std::string n_value = "";
-    std::string alternate_cs = "";
-    PointerHolder<Buffer>ph;
-
-#ifdef USE_LCMS1
-    size_t profile_size;
-#else
-    unsigned int profile_size;
-#endif
-
-    cmsColorSpaceSignature css = cmsGetColorSpace(colorProfile);
-
-    // Write color component # for /ICCBased array in stream dictionary
-    switch(css){
-      case cmsSigGrayData:
-        n_value = "1";
-        alternate_cs = "/DeviceGray";
-        break;
-      case cmsSigRgbData:
-        n_value = "3";
-        alternate_cs = "/DeviceRGB";
-        break;
-      case cmsSigCmykData:
-        n_value = "4";
-        alternate_cs = "/DeviceCMYK";
-        break;
-      default:
-        fputs("DEBUG: Failed to embed ICC Profile.\n", stderr);
-        return QPDFObjectHandle::newNull();
-    }
-
-    streamdict["/Alternate"]=QPDFObjectHandle::newName(alternate_cs);
-    streamdict["/N"]=QPDFObjectHandle::newName(n_value);
-
-    // Read profile into memory
-    cmsSaveProfileToMem(colorProfile, NULL, &profile_size);
-    unsigned char *buff =
-        (unsigned char *)calloc(profile_size, sizeof(unsigned char));
-    cmsSaveProfileToMem(colorProfile, buff, &profile_size);
-
-    // Write ICC profile buffer into PDF
-    ph = new Buffer(buff, profile_size);  
-    iccstream = QPDFObjectHandle::newStream(&pdf, ph);
-    iccstream.replaceDict(QPDFObjectHandle::newDictionary(streamdict));
-
-    array.appendItem(QPDFObjectHandle::newName("/ICCBased"));
-    array.appendItem(iccstream);
-
-    // Return a PDF object reference to an '/ICCBased' array
-    ret = pdf.makeIndirectObject(array);
-
-    free(buff);
-    fputs("DEBUG: ICC Profile embedded in PDF.\n", stderr); 
-
-    return ret;
-}
-
-QPDFObjectHandle embedSrgbProfile(QPDF &pdf)
-{
-    QPDFObjectHandle iccbased_reference;
-
-    // Create an sRGB profile from lcms
-    colorProfile = cmsCreate_sRGBProfile();
-    // Embed it into the profile
-    iccbased_reference = embedIccProfile(pdf);
-
-    return iccbased_reference;
-}
-
-/* 
-Calibration function for non-Lab PDF color spaces 
-Requires white point data, and if available, gamma or matrix numbers.
-
-Output:
-  [/'color_space' 
-     << /Gamma ['gamma[0]'...'gamma[n]']
-        /WhitePoint ['wp[0]' 'wp[1]' 'wp[2]']
-        /Matrix ['matrix[0]'...'matrix[n*n]']
-     >>
-  ]        
-*/
-QPDFObjectHandle getCalibrationArray(const char * color_space, double wp[], 
-                                     double gamma[], double matrix[], double bp[])
-{    
-    // Check for invalid input
-    if ((!strcmp("/CalGray", color_space) && matrix != NULL) ||
-         wp == NULL)
-      return QPDFObjectHandle();
-
-    QPDFObjectHandle ret;
-    std::string csString = color_space;
-    std::string colorSpaceArrayString = "";
-
-    char gamma_str[128];
-    char bp_str[256];
-    char wp_str[256];
-    char matrix_str[512];
-
-
-    // Convert numbers into string data for /Gamma, /WhitePoint, and/or /Matrix
-
-
-    // WhitePoint
-    snprintf(wp_str, sizeof(wp_str), "/WhitePoint [%g %g %g]", 
-                wp[0], wp[1], wp[2]); 
-
-
-    // Gamma
-    if (!strcmp("/CalGray", color_space) && gamma != NULL)
-      snprintf(gamma_str, sizeof(gamma_str), "/Gamma %g", 
-                  gamma[0]);
-    else if (!strcmp("/CalRGB", color_space) && gamma != NULL) 
-      snprintf(gamma_str, sizeof(gamma_str), "/Gamma [%g %g %g]", 
-                  gamma[0], gamma[1], gamma[2]); 
-    else
-      gamma_str[0] = '\0';
-    
-
-    // BlackPoint
-    if (bp != NULL)
-      snprintf(bp_str, sizeof(bp_str), "/BlackPoint [%g %g %g]", 
-                  bp[0], bp[1], bp[2]); 
-    else
-      bp_str[0] = '\0';
-
-
-    // Matrix
-    if (!strcmp("/CalRGB", color_space) && matrix != NULL) {
-      snprintf(matrix_str, sizeof(matrix_str), "/Matrix [%g %g %g %g %g %g %g %g %g]", 
-                  matrix[0], matrix[1], matrix[2],
-                  matrix[3], matrix[4], matrix[5],
-                  matrix[6], matrix[7], matrix[8]);
-    } else
-      matrix_str[0] = '\0';
-
-
-    // Write array string...
-    colorSpaceArrayString = "[" + csString + " <<" 
-                            + gamma_str + " " + wp_str + " " + matrix_str + " " + bp_str
-                            + " >>]";
-                           
-    ret = QPDFObjectHandle::parse(colorSpaceArrayString);
-
-    return ret;
-}
-
-QPDFObjectHandle getCalRGBArray(double wp[3], double gamma[3], double matrix[9], double bp[3])
-{
-    QPDFObjectHandle ret = getCalibrationArray("/CalRGB", wp, gamma, matrix, bp);
-    return ret;
-}
-
-QPDFObjectHandle getCalGrayArray(double wp[3], double gamma[1], double bp[3])
-{
-    QPDFObjectHandle ret = getCalibrationArray("/CalGray", wp, gamma, 0, bp);
-    return ret;
-}
-
-#ifdef QPDF_HAVE_PCLM
-/**
- * 'makePclmStrips()' - return an std::vector of QPDFObjectHandle, each containing the
- *                      stream data of the various strips which make up a PCLm page.
- * O - std::vector of QPDFObjectHandle
- * I - QPDF object
- * I - number of strips per page
- * I - std::vector of PointerHolder<Buffer> containing data for each strip
- * I - strip width
- * I - strip height
- * I - color space
- * I - bits per component
- */
-std::vector<QPDFObjectHandle>
-makePclmStrips(QPDF &pdf, unsigned num_strips,
-               std::vector< PointerHolder<Buffer> > &strip_data,
-               std::vector<CompressionMethod> &compression_methods,
-               unsigned width, std::vector<unsigned>& strip_height, cups_cspace_t cs, unsigned bpc)
-{
-    std::vector<QPDFObjectHandle> ret(num_strips);
-    for (size_t i = 0; i < num_strips; i ++)
-      ret[i] = QPDFObjectHandle::newStream(&pdf);
-
-    // Strip stream dictionary
-    std::map<std::string,QPDFObjectHandle> dict;
-
-    dict["/Type"]=QPDFObjectHandle::newName("/XObject");
-    dict["/Subtype"]=QPDFObjectHandle::newName("/Image");
-    dict["/Width"]=QPDFObjectHandle::newInteger(width);
-    dict["/BitsPerComponent"]=QPDFObjectHandle::newInteger(bpc);
-
-    J_COLOR_SPACE color_space;
-    unsigned components;
-    /* Write "/ColorSpace" dictionary based on raster input */
-    switch(cs) {
-      case CUPS_CSPACE_K:
-      case CUPS_CSPACE_SW:
-        dict["/ColorSpace"]=QPDFObjectHandle::newName("/DeviceGray");
-        color_space = JCS_GRAYSCALE;
-        components = 1;
-        break;
-      case CUPS_CSPACE_RGB:
-      case CUPS_CSPACE_SRGB:
-      case CUPS_CSPACE_ADOBERGB:
-        dict["/ColorSpace"]=QPDFObjectHandle::newName("/DeviceRGB");
-        color_space = JCS_RGB;
-        components = 3;
-        break;
-      default:
-        fputs("DEBUG: Color space not supported.\n", stderr); 
-        return std::vector<QPDFObjectHandle>(num_strips, QPDFObjectHandle());
-    }
-
-    // We deliver already compressed content (instead of letting QPDFWriter do it)
-    // to avoid using excessive memory. For that we first get preferred compression
-    // method to pre-compress content for strip streams.
-
-    // Use the compression method with highest priority of the available methods
-    // __________________
-    // Priority | Method
-    // ------------------
-    // 0        | DCT
-    // 1        | FLATE
-    // 2        | RLE
-    // ------------------
-    CompressionMethod compression = compression_methods.front();
-    for (std::vector<CompressionMethod>::iterator it = compression_methods.begin();
-         it != compression_methods.end(); ++it)
-      compression = compression > *it ? compression : *it;
-
-    // write compressed stream data
-    for (size_t i = 0; i < num_strips; i ++)
-    {
-      dict["/Height"]=QPDFObjectHandle::newInteger(strip_height[i]);
-      ret[i].replaceDict(QPDFObjectHandle::newDictionary(dict));
-      Pl_Buffer psink("psink");
-      if (compression == FLATE_DECODE)
-      {
-        Pl_Flate pflate("pflate", &psink, Pl_Flate::a_deflate);
-        pflate.write(strip_data[i]->getBuffer(), strip_data[i]->getSize());
-        pflate.finish();
-        ret[i].replaceStreamData(PointerHolder<Buffer>(psink.getBuffer()),
-                              QPDFObjectHandle::newName("/FlateDecode"),QPDFObjectHandle::newNull());
-      }
-      else if (compression == RLE_DECODE)
-      {
-        Pl_RunLength prle("prle", &psink, Pl_RunLength::a_encode);
-        prle.write(strip_data[i]->getBuffer(),strip_data[i]->getSize());
-        prle.finish();
-        ret[i].replaceStreamData(PointerHolder<Buffer>(psink.getBuffer()),
-                              QPDFObjectHandle::newName("/RunLengthDecode"),QPDFObjectHandle::newNull());
-      }
-      else if (compression == DCT_DECODE)
-      {
-        Pl_DCT pdct("pdct", &psink, width, strip_height[i], components, color_space);
-        pdct.write(strip_data[i]->getBuffer(),strip_data[i]->getSize());
-        pdct.finish();
-        ret[i].replaceStreamData(PointerHolder<Buffer>(psink.getBuffer()),
-                              QPDFObjectHandle::newName("/DCTDecode"),QPDFObjectHandle::newNull());
-      }
-    }
-    return ret;
-}
-#endif
-
-QPDFObjectHandle makeImage(QPDF &pdf, PointerHolder<Buffer> page_data, unsigned width, 
-                           unsigned height, std::string render_intent, cups_cspace_t cs, unsigned bpc)
-{
-    QPDFObjectHandle ret = QPDFObjectHandle::newStream(&pdf);
-
-    QPDFObjectHandle icc_ref;
-
-    int use_blackpoint = 0;
-    std::map<std::string,QPDFObjectHandle> dict;
-
-    dict["/Type"]=QPDFObjectHandle::newName("/XObject");
-    dict["/Subtype"]=QPDFObjectHandle::newName("/Image");
-    dict["/Width"]=QPDFObjectHandle::newInteger(width);
-    dict["/Height"]=QPDFObjectHandle::newInteger(height);
-    dict["/BitsPerComponent"]=QPDFObjectHandle::newInteger(bpc);
-
-    if (!cm_disabled) {
-      // Write rendering intent into the PDF based on raster settings
-      if (render_intent == "Perceptual") {
-        dict["/Intent"]=QPDFObjectHandle::newName("/Perceptual");
-      } else if (render_intent == "Absolute") {
-        dict["/Intent"]=QPDFObjectHandle::newName("/AbsoluteColorimetric");
-      } else if (render_intent == "Relative") {
-        dict["/Intent"]=QPDFObjectHandle::newName("/RelativeColorimetric");
-      } else if (render_intent == "Saturation") {
-        dict["/Intent"]=QPDFObjectHandle::newName("/Saturation");
-      } else if (render_intent == "RelativeBpc") {
-        /* Enable blackpoint compensation */
-        dict["/Intent"]=QPDFObjectHandle::newName("/RelativeColorimetric");
-        use_blackpoint = 1;
-      }
-    }
-
-    /* Write "/ColorSpace" dictionary based on raster input */
-    if (colorProfile != NULL && !cm_disabled) {
-      icc_ref = embedIccProfile(pdf);
-
-      if (!icc_ref.isNull())
-        dict["/ColorSpace"]=icc_ref;
-    } else if (!cm_disabled) {
-        switch (cs) {
-            case CUPS_CSPACE_DEVICE1:
-            case CUPS_CSPACE_DEVICE2:
-            case CUPS_CSPACE_DEVICE3:
-            case CUPS_CSPACE_DEVICE4:
-            case CUPS_CSPACE_DEVICE5:
-            case CUPS_CSPACE_DEVICE6:
-            case CUPS_CSPACE_DEVICE7:
-            case CUPS_CSPACE_DEVICE8:
-            case CUPS_CSPACE_DEVICE9:
-            case CUPS_CSPACE_DEVICEA:
-            case CUPS_CSPACE_DEVICEB:
-            case CUPS_CSPACE_DEVICEC:
-            case CUPS_CSPACE_DEVICED:
-            case CUPS_CSPACE_DEVICEE:
-            case CUPS_CSPACE_DEVICEF:
-                // For right now, DeviceN will use /DeviceCMYK in the PDF
-                dict["/ColorSpace"]=QPDFObjectHandle::newName("/DeviceCMYK");
-                break;
-            case CUPS_CSPACE_K:
-                dict["/ColorSpace"]=QPDFObjectHandle::newName("/DeviceGray");
-                break;
-            case CUPS_CSPACE_SW:
-                if (use_blackpoint)
-                  dict["/ColorSpace"]=getCalGrayArray(cmWhitePointSGray(), cmGammaSGray(), 
-                                                      cmBlackPointDefault());
-                else
-                  dict["/ColorSpace"]=getCalGrayArray(cmWhitePointSGray(), cmGammaSGray(), 0);
-                break;
-            case CUPS_CSPACE_CMYK:
-                dict["/ColorSpace"]=QPDFObjectHandle::newName("/DeviceCMYK");
-                break;
-            case CUPS_CSPACE_RGB:
-                dict["/ColorSpace"]=QPDFObjectHandle::newName("/DeviceRGB");
-                break;
-            case CUPS_CSPACE_SRGB:
-                icc_ref = embedSrgbProfile(pdf);
-                if (!icc_ref.isNull())
-                  dict["/ColorSpace"]=icc_ref;
-                else 
-                  dict["/ColorSpace"]=QPDFObjectHandle::newName("/DeviceRGB");
-                break;
-            case CUPS_CSPACE_ADOBERGB:
-                if (use_blackpoint)
-                  dict["/ColorSpace"]=getCalRGBArray(cmWhitePointAdobeRgb(), cmGammaAdobeRgb(), 
-                                                         cmMatrixAdobeRgb(), cmBlackPointDefault());
-                else
-                  dict["/ColorSpace"]=getCalRGBArray(cmWhitePointAdobeRgb(), 
-                                                     cmGammaAdobeRgb(), cmMatrixAdobeRgb(), 0);
-                break;
-            default:
-                fputs("DEBUG: Color space not supported.\n", stderr); 
-                return QPDFObjectHandle();
-        }
-    } else if (cm_disabled) {
-        switch(cs) {
-          case CUPS_CSPACE_K:
-          case CUPS_CSPACE_SW:
-            dict["/ColorSpace"]=QPDFObjectHandle::newName("/DeviceGray");
-            break;
-          case CUPS_CSPACE_RGB:
-          case CUPS_CSPACE_SRGB:
-          case CUPS_CSPACE_ADOBERGB:
-            dict["/ColorSpace"]=QPDFObjectHandle::newName("/DeviceRGB");
-            break;
-          case CUPS_CSPACE_DEVICE1:
-          case CUPS_CSPACE_DEVICE2:
-          case CUPS_CSPACE_DEVICE3:
-          case CUPS_CSPACE_DEVICE4:
-          case CUPS_CSPACE_DEVICE5:
-          case CUPS_CSPACE_DEVICE6:
-          case CUPS_CSPACE_DEVICE7:
-          case CUPS_CSPACE_DEVICE8:
-          case CUPS_CSPACE_DEVICE9:
-          case CUPS_CSPACE_DEVICEA:
-          case CUPS_CSPACE_DEVICEB:
-          case CUPS_CSPACE_DEVICEC:
-          case CUPS_CSPACE_DEVICED:
-          case CUPS_CSPACE_DEVICEE:
-          case CUPS_CSPACE_DEVICEF:
-          case CUPS_CSPACE_CMYK:
-            dict["/ColorSpace"]=QPDFObjectHandle::newName("/DeviceCMYK");
-            break;
-          default:
-            fputs("DEBUG: Color space not supported.\n", stderr); 
-            return QPDFObjectHandle();
-        }
-    } else
-        return QPDFObjectHandle();
-
-    ret.replaceDict(QPDFObjectHandle::newDictionary(dict));
-
-#ifdef PRE_COMPRESS
-    // we deliver already compressed content (instead of letting QPDFWriter do it), to avoid using excessive memory
-    Pl_Buffer psink("psink");
-    Pl_Flate pflate("pflate",&psink,Pl_Flate::a_deflate);
-    
-    pflate.write(page_data->getBuffer(),page_data->getSize());
-    pflate.finish();
-
-    ret.replaceStreamData(PointerHolder<Buffer>(psink.getBuffer()),
-                          QPDFObjectHandle::newName("/FlateDecode"),QPDFObjectHandle::newNull());
-#else
-    ret.replaceStreamData(page_data,QPDFObjectHandle::newNull(),QPDFObjectHandle::newNull());
-#endif
-
-    return ret;
-}
-
-void finish_page(struct pdf_info * info)
-{
-    if (info->outformat == OUTPUT_FORMAT_PDF)
-    {
-      // Finish previous PDF Page
-      if(!info->page_data.getPointer())
-          return;
-
-      QPDFObjectHandle image = makeImage(info->pdf, info->page_data, info->width, info->height, info->render_intent, info->color_space, info->bpc);
-      if(!image.isInitialized()) die("Unable to load image data");
-
-      // add it
-      info->page.getKey("/Resources").getKey("/XObject").replaceKey("/I",image);
-    }
-#ifdef QPDF_HAVE_PCLM
-    else if (info->outformat == OUTPUT_FORMAT_PCLM)
-    {
-      // Finish previous PCLm page
-      if (info->pclm_num_strips == 0)
-        return;
-
-      for (size_t i = 0; i < info->pclm_strip_data.size(); i ++)
-        if(!info->pclm_strip_data[i].getPointer())
-          return;
-
-      std::vector<QPDFObjectHandle> strips = makePclmStrips(info->pdf, info->pclm_num_strips, info->pclm_strip_data, info->pclm_compression_method_preferred, info->width, info->pclm_strip_height, info->color_space, info->bpc);
-      for (size_t i = 0; i < info->pclm_num_strips; i ++)
-        if(!strips[i].isInitialized()) die("Unable to load strip data");
-
-      // add it
-      for (size_t i = 0; i < info->pclm_num_strips; i ++)
-        info->page.getKey("/Resources").getKey("/XObject")
-                  .replaceKey("/Image" +
-                              int_to_fwstring(i,num_digits(info->pclm_num_strips - 1)),
-                              strips[i]);
-    }
-#endif
-
-    // draw it
-    std::string content;
-    if (info->outformat == OUTPUT_FORMAT_PDF)
-    {
-      content.append(QUtil::double_to_string(info->page_width) + " 0 0 " +
-                     QUtil::double_to_string(info->page_height) + " 0 0 cm\n");
-      content.append("/I Do\n");
-    }
-#ifdef QPDF_HAVE_PCLM
-    else if (info->outformat == OUTPUT_FORMAT_PCLM)
-    {
-      std::string res = info->pclm_source_resolution_default;
-
-      // resolution is in dpi, so remove the last three characters from
-      // resolution string to get resolution integer
-      unsigned resolution_integer = std::stoi(res.substr(0, res.size() - 3));
-      double d = (double)DEFAULT_PDF_UNIT / resolution_integer;
-      content.append(QUtil::double_to_string(d) + " 0 0 " + QUtil::double_to_string(d) + " 0 0 cm\n");
-      unsigned yAnchor = info->height;
-      for (unsigned i = 0; i < info->pclm_num_strips; i ++)
-      {
-        yAnchor -= info->pclm_strip_height[i];
-        content.append("/P <</MCID 0>> BDC q\n");
-        content.append(QUtil::int_to_string(info->width) + " 0 0 " +
-                        QUtil::int_to_string(info->pclm_strip_height[i]) +
-                        " 0 " + QUtil::int_to_string(yAnchor) + " cm\n");
-        content.append("/Image" +
-                       int_to_fwstring(i, num_digits(info->pclm_num_strips - 1)) +
-                       " Do Q\n");
-      }
-    }
-#endif
-
-    QPDFObjectHandle page_contents = info->page.getKey("/Contents");
-    if (info->outformat == OUTPUT_FORMAT_PDF)
-      page_contents.replaceStreamData(content, QPDFObjectHandle::newNull(), QPDFObjectHandle::newNull());
-#ifdef QPDF_HAVE_PCLM
-    else if (info->outformat == OUTPUT_FORMAT_PCLM)
-      page_contents.getArrayItem(0).replaceStreamData(content, QPDFObjectHandle::newNull(), QPDFObjectHandle::newNull());
-#endif
-
-    // bookkeeping
-    info->page_data = PointerHolder<Buffer>();
-#ifdef QPDF_HAVE_PCLM
-    info->pclm_strip_data.clear();
-#endif
-}
-
-
-/* Perform modifications to PDF if color space conversions are needed */      
-int prepare_pdf_page(struct pdf_info * info, unsigned width, unsigned height, unsigned bpl, 
-                     unsigned bpp, unsigned bpc, std::string render_intent, cups_cspace_t color_space)
-{
-#define IMAGE_CMYK_8   (bpp == 32 && bpc == 8)
-#define IMAGE_CMYK_16  (bpp == 64 && bpc == 16)
-#define IMAGE_RGB_8    (bpp == 24 && bpc == 8)
-#define IMAGE_RGB_16   (bpp == 48 && bpc == 16)
-#define IMAGE_WHITE_1  (bpp == 1 && bpc == 1)
-#define IMAGE_WHITE_8  (bpp == 8 && bpc == 8)
-#define IMAGE_WHITE_16 (bpp == 16 && bpc == 16)    
-
-    int error = 0;
-    pdfConvertFunction fn = convertPdf_NoConversion;
-    cmsColorSpaceSignature css;
-
-    /* Register available raster information into the PDF */
-    info->width = width;
-    info->height = height;
-    info->line_bytes = bpl;
-    info->bpp = bpp;
-    info->bpc = bpc;
-    info->render_intent = render_intent;
-    info->color_space = color_space;
-    if (info->outformat == OUTPUT_FORMAT_PCLM)
-    {
-      info->pclm_num_strips = (height / info->pclm_strip_height_preferred) +
-                              (height % info->pclm_strip_height_preferred ? 1 : 0);
-      info->pclm_strip_height.resize(info->pclm_num_strips);
-      info->pclm_strip_data.resize(info->pclm_num_strips);
-      for (size_t i = 0; i < info->pclm_num_strips; i ++)
-      {
-        info->pclm_strip_height[i] = info->pclm_strip_height_preferred < height ?
-                                     info->pclm_strip_height_preferred : height;
-        height -= info->pclm_strip_height[i];
-      }
-    }
-
-    /* Invert grayscale by default */
-    if (color_space == CUPS_CSPACE_K)
-      fn = convertPdf_InvertColors;
-
-    if (colorProfile != NULL) {
-      css = cmsGetColorSpace(colorProfile);
-
-      // Convert image and PDF color space to an embedded ICC Profile color space
-      switch(css) {
-        // Convert PDF to Grayscale when using a gray profile
-        case cmsSigGrayData:
-          if (color_space == CUPS_CSPACE_CMYK)
-            fn = convertPdf_Cmyk8ToWhite8;
-          else if (color_space == CUPS_CSPACE_RGB) 
-            fn = convertPdf_Rgb8ToWhite8;
-          else              
-            fn = convertPdf_InvertColors;
-          info->color_space = CUPS_CSPACE_K;
-          break;
-        // Convert PDF to RGB when using an RGB profile
-        case cmsSigRgbData:
-          if (color_space == CUPS_CSPACE_CMYK) 
-            fn = convertPdf_Cmyk8ToRgb8;
-          else if (color_space == CUPS_CSPACE_K) 
-            fn = convertPdf_White8ToRgb8;
-          info->color_space = CUPS_CSPACE_RGB;
-          break;
-        // Convert PDF to CMYK when using an RGB profile
-        case cmsSigCmykData:
-          if (color_space == CUPS_CSPACE_RGB)
-            fn = convertPdf_Rgb8ToCmyk8;
-          else if (color_space == CUPS_CSPACE_K) 
-            fn = convertPdf_White8ToCmyk8;
-          info->color_space = CUPS_CSPACE_CMYK;
-          break;
-        default:
-          fputs("DEBUG: Unable to convert PDF from profile.\n", stderr);
-          colorProfile = NULL;
-          error = 1;
-      }
-      // Perform conversion of an image color space 
-    } else if (!cm_disabled) {       
-      switch (color_space) {
-         // Convert image to CMYK
-         case CUPS_CSPACE_CMYK:
-           if (IMAGE_RGB_8)
-             fn = convertPdf_Rgb8ToCmyk8;  
-           else if (IMAGE_RGB_16)
-             fn = convertPdf_NoConversion;
-           else if (IMAGE_WHITE_8)
-             fn = convertPdf_White8ToCmyk8;  
-           else if (IMAGE_WHITE_16) 
-             fn = convertPdf_NoConversion;
-           break;
-         // Convert image to RGB
-         case CUPS_CSPACE_ADOBERGB:
-         case CUPS_CSPACE_RGB:
-         case CUPS_CSPACE_SRGB:
-           if (IMAGE_CMYK_8)
-             fn = convertPdf_Cmyk8ToRgb8;
-           else if (IMAGE_CMYK_16)
-             fn = convertPdf_NoConversion;  
-           else if (IMAGE_WHITE_8)
-             fn = convertPdf_White8ToRgb8;
-           else if (IMAGE_WHITE_16) 
-             fn = convertPdf_NoConversion;       
-           break;
-         // Convert image to Grayscale
-         case CUPS_CSPACE_SW:
-         case CUPS_CSPACE_K:
-           if (IMAGE_CMYK_8)
-             fn = convertPdf_Cmyk8ToWhite8;
-           else if (IMAGE_CMYK_16)
-             fn = convertPdf_NoConversion;
-           else if (IMAGE_RGB_8) 
-             fn = convertPdf_Rgb8ToWhite8;
-           else if (IMAGE_RGB_16) 
-             fn = convertPdf_NoConversion;
-           break;    
-         case CUPS_CSPACE_DEVICE1:
-         case CUPS_CSPACE_DEVICE2:
-         case CUPS_CSPACE_DEVICE3:
-         case CUPS_CSPACE_DEVICE4:
-         case CUPS_CSPACE_DEVICE5:
-         case CUPS_CSPACE_DEVICE6:
-         case CUPS_CSPACE_DEVICE7:
-         case CUPS_CSPACE_DEVICE8:
-         case CUPS_CSPACE_DEVICE9:
-         case CUPS_CSPACE_DEVICEA:
-         case CUPS_CSPACE_DEVICEB:
-         case CUPS_CSPACE_DEVICEC:
-         case CUPS_CSPACE_DEVICED:
-         case CUPS_CSPACE_DEVICEE:
-         case CUPS_CSPACE_DEVICEF:
-             // No conversion for right now
-             fn = convertPdf_NoConversion;
-             break;
-         default:
-           fputs("DEBUG: Color space not supported.\n", stderr);
-           error = 1;
-           break;
-      }
-   } 
-
-   if (!error)
-     fn(info);
-
-   return error;
-}
-
-int add_pdf_page(struct pdf_info * info, int pagen, unsigned width,
-		 unsigned height, int bpp, int bpc, int bpl, std::string render_intent,
-		 cups_cspace_t color_space, unsigned xdpi, unsigned ydpi)
-{
-    try {
-        finish_page(info); // any active
-
-        prepare_pdf_page(info, width, height, bpl, bpp, 
-                         bpc, render_intent, color_space);
-
-        if (info->height > (std::numeric_limits<unsigned>::max() / info->line_bytes)) {
-            die("Page too big");
-        }
-        if (info->outformat == OUTPUT_FORMAT_PDF)
-          info->page_data = PointerHolder<Buffer>(new Buffer(info->line_bytes*info->height));
-        else if (info->outformat == OUTPUT_FORMAT_PCLM)
-        {
-          // reserve space for PCLm strips
-          for (size_t i = 0; i < info->pclm_num_strips; i ++)
-            info->pclm_strip_data[i] = PointerHolder<Buffer>(new Buffer(info->line_bytes*info->pclm_strip_height[i]));
-        }
-
-        QPDFObjectHandle page = QPDFObjectHandle::parse(
-            "<<"
-            "  /Type /Page"
-            "  /Resources <<"
-            "    /XObject << >> "
-            "  >>"
-            "  /MediaBox null "
-            "  /Contents null "
-            ">>");
-
-        // Convert to pdf units
-        info->page_width=((double)info->width/xdpi)*DEFAULT_PDF_UNIT;
-        info->page_height=((double)info->height/ydpi)*DEFAULT_PDF_UNIT;
-        if (info->outformat == OUTPUT_FORMAT_PDF)
-        {
-          page.replaceKey("/Contents",QPDFObjectHandle::newStream(&info->pdf)); // data will be provided later
-          page.replaceKey("/MediaBox",makeRealBox(0,0,info->page_width,info->page_height));
-        }
-        else if (info->outformat == OUTPUT_FORMAT_PCLM)
-        {
-          page.replaceKey("/Contents",
-            QPDFObjectHandle::newArray(std::vector<QPDFObjectHandle>(1, QPDFObjectHandle::newStream(&info->pdf))));
-
-          // box with dimensions rounded off to the nearest integer
-          page.replaceKey("/MediaBox",makeIntegerBox(0,0,info->page_width + 0.5,info->page_height + 0.5));
-        }
-    
-        info->page = info->pdf.makeIndirectObject(page); // we want to keep a reference
-        info->pdf.addPage(info->page, false);
-    } catch (std::bad_alloc &ex) {
-        die("Unable to allocate page data");
-    } catch (...) {
-        return 1;
-    }
-
-    return 0;
-}
-
-int close_pdf_file(struct pdf_info * info)
-{
-    try {
-        finish_page(info); // any active
-
-        QPDFWriter output(info->pdf,NULL);
-//        output.setMinimumPDFVersion("1.4");
-#ifdef QPDF_HAVE_PCLM
-        if (info->outformat == OUTPUT_FORMAT_PCLM)
-          output.setPCLm(true);
-#endif
-        output.write();
-    } catch (...) {
-        return 1;
-    }
-
-    return 0;
-}
-
-void pdf_set_line(struct pdf_info * info, unsigned line_n, unsigned char *line)
-{
-    //dprintf("pdf_set_line(%d)\n", line_n);
-
-    if(line_n > info->height)
-    {
-        dprintf("Bad line %d\n", line_n);
-        return;
-    }
-
-    switch(info->outformat)
-    {
-      case OUTPUT_FORMAT_PDF:
-        memcpy((info->page_data->getBuffer()+(line_n*info->line_bytes)), line, info->line_bytes);
-        break;
-      case OUTPUT_FORMAT_PCLM:
-        // copy line data into appropriate pclm strip
-        size_t strip_num = line_n / info->pclm_strip_height_preferred;
-        unsigned line_strip = line_n - strip_num*info->pclm_strip_height_preferred;
-        memcpy(((info->pclm_strip_data[strip_num])->getBuffer() + (line_strip*info->line_bytes)),
-               line, info->line_bytes);
-        break;
-    }
-}
-
-int convert_raster(cups_raster_t *ras, unsigned width, unsigned height,
-		   int bpp, int bpl, struct pdf_info * info)
-{
-    // We should be at raster start
-    int i;
-    unsigned cur_line = 0;
-    unsigned char *PixelBuffer, *ptr = NULL, *buff;
-
-    PixelBuffer = (unsigned char *)malloc(bpl);
-    buff = (unsigned char *)malloc(info->line_bytes);
-
-    do
-    {
-        // Read raster data...
-        cupsRasterReadPixels(ras, PixelBuffer, bpl);
-
-#if !ARCH_IS_BIG_ENDIAN
-
-	if (info->bpc == 16)
-	{
-	  // Swap byte pairs for endianess (cupsRasterReadPixels() switches
-	  // from Big Endian back to the system's Endian)
-	  for (i = bpl, ptr = PixelBuffer; i > 0; i -= 2, ptr += 2)
-	  {
-	    unsigned char swap = *ptr;
-	    *ptr = *(ptr + 1);
-	    *(ptr + 1) = swap;
-	  }
-	}
-#endif /* !ARCH_IS_BIG_ENDIAN */
-
-        // perform bit operations if necessary
-        bit_function(PixelBuffer, ptr,  bpl);
-
-        // write lines and color convert when necessary
- 	pdf_set_line(info, cur_line, conversion_function(PixelBuffer, buff, width));
-	++cur_line;
-    }
-    while(cur_line < height);
-
-    free(buff);
-    free(PixelBuffer);
-
-    return 0;
-}
-
-int setProfile(const char * path) 
-{
-    if (path != NULL) 
-      colorProfile = cmsOpenProfileFromFile(path,"r");
-
-    if (colorProfile != NULL) {
-      fputs("DEBUG: Load profile successful.\n", stderr); 
-      return 0;
-    }
-    else {
-      fputs("DEBUG: Unable to load profile.\n", stderr); 
-      return 1;
-    }
-}
-
-/* Obtain a source profile name using color qualifiers from raster file */
-const char * getIPPColorProfileName(const char * media_type, cups_cspace_t cs, unsigned dpi)
-{
-    std::string mediaType = "";
-    std::string resolution = "";
-    std::string colorModel = "";
-   
-    std::string iccProfile = "";
-
-    // ColorModel
-    switch (cs) {
-        case CUPS_CSPACE_RGB:
-            colorModel = "rgb";
-            break;
-        case CUPS_CSPACE_SRGB:
-            colorModel = "srgb";
-            break;
-        case CUPS_CSPACE_ADOBERGB:
-            colorModel = "adobergb";
-            break;
-        case CUPS_CSPACE_K:
-            colorModel = "gray";
-            break;
-        case CUPS_CSPACE_CMYK:
-            colorModel = "cmyk";
-            break;
-        default:
-            colorModel = "";
-            break;
-     }
- 
-    if (media_type != NULL)
-      mediaType = media_type;
-    if (dpi > 0)
-      resolution = dpi;
-
-    // Requires color space and media type qualifiers
-    if (resolution != "" || colorModel != "")
-      return 0;
-
-    // profile-uri reference: "http://www.server.com/colorModel-Resolution-mediaType.icc
-    if (mediaType != "")          
-      iccProfile = colorModel + "-" + resolution + ".icc";
-    else 
-      iccProfile = colorModel + "-" + resolution + "-" + mediaType + ".icc";
-
-    return strdup(iccProfile.c_str());
-}
-
-int main(int argc, char **argv)
-{
-    char *outformat_env = NULL;
-    OutFormatType outformat; /* Output format */
-    int fd, Page, empty = 1;
-    struct pdf_info pdf;
-    FILE * input = NULL;
-    cups_raster_t	*ras;		/* Raster stream for printing */
-    cups_page_header2_t	header;		/* Page header from file */
-    ppd_file_t		*ppd;		/* PPD file */
-    ppd_attr_t    *attr;  /* PPD attribute */
-    int			num_options;	/* Number of options */
-    const char*         profile_name;	/* IPP Profile Name */
-    cups_option_t	*options;	/* Options */
-
-    // Make sure status messages are not buffered...
-    setbuf(stderr, NULL);
-
-    cmsSetLogErrorHandler(lcmsErrorHandler);
-
-    if (argc < 6 || argc > 7)
-    {
-        fprintf(stderr, "Usage: %s <job> <user> <job name> <copies> <option> [file]\n", argv[0]);
-        return 1;
-    }
-
-    /* Determine the output format via an environment variable set by a wrapper
-        script */
-#ifdef QPDF_HAVE_PCLM
-    if ((outformat_env = getenv("OUTFORMAT")) == NULL || strcasestr(outformat_env, "pdf"))
-      outformat = OUTPUT_FORMAT_PDF;
-    else if (strcasestr(outformat_env, "pclm"))
-      outformat = OUTPUT_FORMAT_PCLM;
-    else {
-      fprintf(stderr, "ERROR: OUTFORMAT=\"%s\", cannot determine output format\n",
-	      outformat_env);
-      return 1;
-    }
-#else
-    outformat = OUTPUT_FORMAT_PDF;
-#endif
-    fprintf(stderr, "DEBUG: OUTFORMAT=\"%s\", output format will be %s\n",
-	    outformat_env, (outformat == OUTPUT_FORMAT_PDF ? "PDF" : "PCLM"));
-  
-    num_options = cupsParseOptions(argv[5], 0, &options);  
-
-    /* support the CUPS "cm-calibration" option */ 
-    cm_calibrate = cmGetCupsColorCalibrateMode(options, num_options);
-
-    if (outformat == OUTPUT_FORMAT_PCLM ||
-        cm_calibrate == CM_CALIBRATION_ENABLED)
-      cm_disabled = 1;
-    else
-      cm_disabled = cmIsPrinterCmDisabled(getenv("PRINTER"));
-
-    // Open the PPD file...
-    ppd = ppdOpenFile(getenv("PPD"));
-
-    if (ppd)
-    {
-      ppdMarkDefaults(ppd);
-      cupsMarkOptions(ppd, num_options, options);
-    }
-    else
-    {
-      ppd_status_t	status;		/* PPD error */
-      int		linenum;	/* Line number */
-
-      fputs("DEBUG: The PPD file could not be opened.\n", stderr);
-
-      status = ppdLastError(&linenum);
-      
-      fprintf(stderr, "DEBUG: %s on line %d.\n", ppdErrorString(status), linenum);
-#ifdef QPDF_HAVE_PCLM
-      if (outformat == OUTPUT_FORMAT_PCLM) {
-	fprintf(stderr, "ERROR: PCLm output only possible with PPD file.\n");
-	return 1;
-      }
-#endif
-    }
-
-    // Open the page stream...
-    if (argc == 7)
-    {
-        input = fopen(argv[6], "rb");
-        if (input == NULL) die("Unable to open PWG Raster file");
-    }
-    else
-        input = stdin;
-
-    // Get fd from file
-    fd = fileno(input);
-
-    // Transform
-    ras = cupsRasterOpen(fd, CUPS_RASTER_READ);
-
-    // Process pages as needed...
-    Page = 0;
-
-    /* Get PCLm attributes from PPD */
-    if (ppd && outformat == OUTPUT_FORMAT_PCLM)
-    {
-      char *attr_name = (char *)"cupsPclmStripHeightPreferred";
-      if ((attr = ppdFindAttr(ppd, attr_name, NULL)) != NULL)
-      {
-        fprintf(stderr, "DEBUG: PPD PCLm attribute \"%s\" with value \"%s\"\n",
-            attr_name, attr->value);
-        pdf.pclm_strip_height_preferred = atoi(attr->value);
-      }
-      else
-        pdf.pclm_strip_height_preferred = 16; /* default strip height */
-
-      attr_name = (char *)"cupsPclmStripHeightSupported";
-      if ((attr = ppdFindAttr(ppd, attr_name, NULL)) != NULL)
-      {
-        fprintf(stderr, "DEBUG: PPD PCLm attribute \"%s\" with value \"%s\"\n",
-            attr_name, attr->value);
-        pdf.pclm_strip_height_supported.clear();  // remove default value = 16
-        std::vector<std::string> vec = split_strings(attr->value, ",");
-        for (size_t i = 0; i < vec.size(); i ++)
-          pdf.pclm_strip_height_supported.push_back(atoi(vec[i].c_str()));
-        vec.clear();
-      }
-
-      attr_name = (char *)"cupsPclmRasterBackSide";
-      if ((attr = ppdFindAttr(ppd, attr_name, NULL)) != NULL)
-      {
-        fprintf(stderr, "DEBUG: PPD PCLm attribute \"%s\" with value \"%s\"\n",
-            attr_name, attr->value);
-        pdf.pclm_raster_back_side = attr->value;
-      }
-
-      attr_name = (char *)"cupsPclmSourceResolutionDefault";
-      if ((attr = ppdFindAttr(ppd, attr_name, NULL)) != NULL)
-      {
-        fprintf(stderr, "DEBUG: PPD PCLm attribute \"%s\" with value \"%s\"\n",
-            attr_name, attr->value);
-        pdf.pclm_source_resolution_default = attr->value;
-      }
-
-      attr_name = (char *)"cupsPclmSourceResolutionSupported";
-      if ((attr = ppdFindAttr(ppd, attr_name, NULL)) != NULL)
-      {
-        fprintf(stderr, "DEBUG: PPD PCLm attribute \"%s\" with value \"%s\"\n",
-            attr_name, attr->value);
-        pdf.pclm_source_resolution_supported = split_strings(attr->value, ",");
-      }
-
-      attr_name = (char *)"cupsPclmCompressionMethodPreferred";
-      if ((attr = ppdFindAttr(ppd, attr_name, NULL)) != NULL)
-      {
-        fprintf(stderr, "DEBUG: PPD PCLm attribute \"%s\" with value \"%s\"\n",
-            attr_name, attr->value);
-        std::vector<std::string> vec = split_strings(attr->value, ",");
-
-        // get all compression methods supported by the printer
-        for (std::vector<std::string>::iterator it = vec.begin();
-             it != vec.end(); ++it)
-        {
-          std::string compression_method = *it;
-          for (char& x: compression_method)
-            x = tolower(x);
-          if (compression_method == "flate")
-            pdf.pclm_compression_method_preferred.push_back(FLATE_DECODE);
-          else if (compression_method == "rle")
-            pdf.pclm_compression_method_preferred.push_back(RLE_DECODE);
-          else if (compression_method == "jpeg")
-            pdf.pclm_compression_method_preferred.push_back(DCT_DECODE);
-        }
-
-      }
-      // If the compression methods is none of the above or is erreneous
-      // use FLATE as compression method and show a warning.
-      if (pdf.pclm_compression_method_preferred.empty())
-      {
-        fprintf(stderr, "WARNING: (rastertopclm) Unable parse PPD attribute \"%s\". Using FLATE for encoding image streams.\n", attr_name);
-        pdf.pclm_compression_method_preferred.push_back(FLATE_DECODE);
-      }
-    }
-
-    while (cupsRasterReadHeader2(ras, &header))
-    {
-      if (empty)
-      {
-	empty = 0;
-	// We have a valid input page, so create PDF file
-	if (create_pdf_file(&pdf, outformat) != 0)
-	  die("Unable to create PDF file");
-      }
-
-      // Write a status message with the page number
-      Page ++;
-      fprintf(stderr, "INFO: Starting page %d.\n", Page);
-
-      // Use "profile=profile_name.icc" to embed 'profile_name.icc' into the PDF
-      // for testing. Forces color management to enable.
-      if (outformat == OUTPUT_FORMAT_PDF &&
-          (profile_name = cupsGetOption("profile", num_options, options)) != NULL) {
-        setProfile(profile_name);
-        cm_disabled = 0;
-      }
-      if (colorProfile != NULL)       
-        fprintf(stderr, "DEBUG: TEST ICC Profile specified (color management forced ON): \n[%s]\n", profile_name);
-
-      // Add a new page to PDF file
-      if (add_pdf_page(&pdf, Page, header.cupsWidth, header.cupsHeight,
-		       header.cupsBitsPerPixel, header.cupsBitsPerColor, 
-		       header.cupsBytesPerLine, header.cupsRenderingIntent, 
-                       header.cupsColorSpace, header.HWResolution[0],
-		       header.HWResolution[1]) != 0)
-	die("Unable to start new PDF page");
-
-      // Write the bit map into the PDF file
-      if (convert_raster(ras, header.cupsWidth, header.cupsHeight,
-			 header.cupsBitsPerPixel, header.cupsBytesPerLine, 
-			 &pdf) != 0)
-	die("Failed to convert page bitmap");
-    }
-
-    if (empty)
-    {
-      fprintf(stderr, "DEBUG: Input is empty, outputting empty file.\n");
-      cupsRasterClose(ras);
-      return 0;
-    }
-
-    close_pdf_file(&pdf); // will output to stdout
-
-    if (colorProfile != NULL) {
-      cmsCloseProfile(colorProfile);
-    }
-
-    cupsFreeOptions(num_options, options);
-
-    cupsRasterClose(ras);
-
-    if (fd != 0)
-      close(fd);
-
-    return (Page == 0);
-}
diff --git a/filter/test_pdf1.c b/filter/test_pdf1.c
deleted file mode 100644
index 0fadea4..0000000
--- a/filter/test_pdf1.c
+++ /dev/null
@@ -1,52 +0,0 @@
-#include "pdfutils.h"
-#include <assert.h>
-#include <string.h>
-
-int main()
-{
-  pdfOut *pdf;
-
-  pdf=pdfOut_new();
-  assert(pdf);
-
-  pdfOut_begin_pdf(pdf);
-
-  // bad font
-  int font_obj=pdfOut_add_xref(pdf);
-  pdfOut_printf(pdf,"%d 0 obj\n"
-                    "<</Type/Font\n"
-                    "  /Subtype /Type1\n" // /TrueType,/Type3
-                    "  /BaseFont /%s\n"
-                    ">>\n"
-                    "endobj\n"
-                    ,font_obj,"Courier");
-  // test
-  const int PageWidth=595,PageLength=842;
-  int cobj=pdfOut_add_xref(pdf);
-  const char buf[]="BT /a 10 Tf (abc) Tj ET";
-  pdfOut_printf(pdf,"%d 0 obj\n"
-                    "<</Length %d\n"
-                    ">>\n"
-                    "stream\n"
-                    "%s\n"
-                    "endstream\n"
-                    "endobj\n"
-                    ,cobj,strlen(buf),buf);
-
-  int obj=pdfOut_add_xref(pdf);
-  pdfOut_printf(pdf,"%d 0 obj\n"
-                    "<</Type/Page\n"
-                    "  /Parent 1 0 R\n"
-                    "  /MediaBox [0 0 %d %d]\n"
-                    "  /Contents %d 0 R\n"
-                    "  /Resources << /Font << /a %d 0 R >> >>\n"
-                    ">>\n"
-                    "endobj\n"
-                    ,obj,PageWidth,PageLength,cobj,font_obj); // TODO: into pdf->
-  pdfOut_add_page(pdf,obj);
-  pdfOut_finish_pdf(pdf);
-
-  pdfOut_free(pdf);
-
-  return 0;
-}
diff --git a/filter/test_pdf2.c b/filter/test_pdf2.c
deleted file mode 100644
index a0c1d8b..0000000
--- a/filter/test_pdf2.c
+++ /dev/null
@@ -1,102 +0,0 @@
-#include "pdfutils.h"
-#include "config.h"
-#include <assert.h>
-#include "fontembed/embed.h"
-#include "fontembed/sfnt.h"
-
-#include <stdio.h>
-
-static inline void write_string(pdfOut *pdf,EMB_PARAMS *emb,const char *str) // {{{
-{
-  assert(pdf);
-  assert(emb);
-  int iA;
-
-  if (emb->plan&EMB_A_MULTIBYTE) {
-    putc('<',stdout); 
-    for (iA=0;str[iA];iA++) {
-      const unsigned short gid=emb_get(emb,(unsigned char)str[iA]);
-      fprintf(stdout,"%04x",gid);
-    }
-    putc('>',stdout); 
-    pdf->filepos+=4*iA+2;
-  } else { 
-    for (iA=0;str[iA];iA++) {
-      emb_get(emb,(unsigned char)str[iA]);
-      // TODO: pdf: otf_from_pdf_default_encoding
-    }
-    pdfOut_putString(pdf,str,-1);
-  }
-}
-// }}}
-
-int main()
-{
-  pdfOut *pdf;
-
-  pdf=pdfOut_new();
-  assert(pdf);
-
-  pdfOut_begin_pdf(pdf);
-
-  // font, pt.1 
-  const char *fn=TESTFONT;
-/*
-  if (argc==2) {
-    fn=argv[1];
-  }
-*/
-  OTF_FILE *otf=otf_load(fn);
-  assert(otf);
-  FONTFILE *ff=fontfile_open_sfnt(otf);
-  EMB_PARAMS *emb=emb_new(ff,
-                          EMB_DEST_PDF16,
-                          EMB_C_FORCE_MULTIBYTE|
-                          EMB_C_TAKE_FONTFILE);
-
-  // test
-  const int PageWidth=595,PageLength=842;
-  const int cobj=pdfOut_add_xref(pdf);
-  pdfOut_printf(pdf,"%d 0 obj\n"
-                    "<</Length %d 0 R\n"
-                    ">>\n"
-                    "stream\n"
-                    ,cobj,cobj+1);
-  long streamlen=-pdf->filepos;
-  pdfOut_printf(pdf,"BT /a 10 Tf ");
-  write_string(pdf,emb,"Test");
-  pdfOut_printf(pdf," Tj ET");
-
-  streamlen+=pdf->filepos;
-  pdfOut_printf(pdf,"\nendstream\n"
-                    "endobj\n");
-  const int clobj=pdfOut_add_xref(pdf);
-  assert(clobj==cobj+1);
-  pdfOut_printf(pdf,"%d 0 obj\n"
-                    "%d\n"
-                    "endobj\n"
-                    ,clobj,streamlen);
-
-  // font
-  int font_obj=pdfOut_write_font(pdf,emb);
-  assert(font_obj);
-
-  int obj=pdfOut_add_xref(pdf);
-  pdfOut_printf(pdf,"%d 0 obj\n"
-                    "<</Type/Page\n"
-                    "  /Parent 1 0 R\n"
-                    "  /MediaBox [0 0 %d %d]\n"
-                    "  /Contents %d 0 R\n"
-                    "  /Resources << /Font << /a %d 0 R >> >>\n"
-                    ">>\n"
-                    "endobj\n"
-                    ,obj,PageWidth,PageLength,cobj,font_obj); // TODO: into pdf->
-  pdfOut_add_page(pdf,obj);
-  pdfOut_finish_pdf(pdf);
-
-  pdfOut_free(pdf);
-
-  emb_close(emb);
-
-  return 0;
-}
diff --git a/filter/texttopdf.c b/filter/texttopdf.c
deleted file mode 100644
index 50a0876..0000000
--- a/filter/texttopdf.c
+++ /dev/null
@@ -1,1212 +0,0 @@
-/*
- *   Text to PDF filter for the Common UNIX Printing System (CUPS).
- *
- *   Copyright 2008,2012 by Tobias Hoffmann.
- *   Copyright 2007 by Apple Inc.
- *   Copyright 1993-2007 by Easy Software Products.
- *
- *   These coded instructions, statements, and computer programs are the
- *   property of Apple Inc. and are protected by Federal copyright
- *   law.  Distribution and use rights are outlined in the file "COPYING"
- *   which should have been included with this file.
- *
- * Contents:
- *
- *   main()          - Main entry for text to PDF filter.
- *   WriteEpilogue() - Write the PDF file epilogue.
- *   WritePage()     - Write a page of text.
- *   WriteProlog()   - Write the PDF file prolog with options.
- *   write_line()    - Write a row of text.
- *   write_string()  - Write a string of text.
- */
-
-/*
- * Include necessary headers...
- */
-
-#include "textcommon.h"
-#include "pdfutils.h"
-#include "fontembed/embed.h"
-#include <assert.h>
-#include "fontembed/sfnt.h"
-#include <fontconfig/fontconfig.h>
-
-/*
- * Globals...
- */
-
-#ifdef CUPS_1_4 /* CUPS 1.4.x or newer: only UTF8 is supported */
-int     UTF8 = 1;               /* Use UTF-8 encoding? */
-#endif /* CUPS_1_4 */
-
-EMB_PARAMS *font_load(const char *font, int fontwidth);
-
-EMB_PARAMS *font_load(const char *font, int fontwidth)
-{
-  OTF_FILE *otf;
-
-  FcPattern *pattern;
-  FcFontSet *candidates;
-  FcChar8   *fontname = NULL;
-  FcResult   result;
-  int i;
-
-  if ( (font[0]=='/')||(font[0]=='.') ) {
-    candidates = NULL;
-    fontname=(FcChar8 *)strdup(font);
-  } else {
-    FcInit ();
-    pattern = FcNameParse ((const FcChar8 *)font);
-    FcPatternAddInteger (pattern, FC_SPACING, FC_MONO); // guide fc, in case substitution becomes necessary
-    FcConfigSubstitute (0, pattern, FcMatchPattern);
-    FcDefaultSubstitute (pattern);
-
-    /* Receive a sorted list of fonts matching our pattern */
-    candidates = FcFontSort (0, pattern, FcFalse, 0, &result);
-    FcPatternDestroy (pattern);
-
-    if (candidates) {
-      /* In the list of fonts returned by FcFontSort()
-	 find the first one that is both in TrueType format and monospaced */
-      for (i = 0; i < candidates->nfont; i++) {
-	FcChar8 *fontformat=NULL; // TODO? or just try?
-	int spacing=0; // sane default, as FC_MONO == 100
-	FcPatternGetString  (candidates->fonts[i], FC_FONTFORMAT, 0, &fontformat);
-	FcPatternGetInteger (candidates->fonts[i], FC_SPACING,    0, &spacing);
-
-	if ( (fontformat)&&((spacing == FC_MONO) || (fontwidth == 2)) ) {    // check for monospace or double width fonts
-	  if (strcmp((const char *)fontformat, "TrueType") == 0) {
-	    fontname = FcPatternFormat (candidates->fonts[i], (const FcChar8 *)"%{file|cescape}/%{index}");
-	    break;
-	  } else if (strcmp((const char *)fontformat, "CFF") == 0) {
-	    fontname = FcPatternFormat (candidates->fonts[i], (const FcChar8 *)"%{file|cescape}"); // TTC only possible with non-cff glyphs!
-	    break;
-	  }
-	}
-      }
-      FcFontSetDestroy (candidates);
-    }
-  }
-
-  if (!fontname) {
-    // TODO: try /usr/share/fonts/*/*/%s.ttf
-    fprintf(stderr,"No viable font found\n");
-    return NULL;
-  }
-
-  otf = otf_load((const char *)fontname);
-  free(fontname);
-  if (!otf) {
-    return NULL;
-  }
-
-  FONTFILE *ff=fontfile_open_sfnt(otf);
-  assert(ff);
-  EMB_PARAMS *emb=emb_new(ff,
-                          EMB_DEST_PDF16,
-                          EMB_C_FORCE_MULTIBYTE|
-                          EMB_C_TAKE_FONTFILE);
-  assert(emb);
-  assert(emb->plan&EMB_A_MULTIBYTE);
-  return emb;
-}
-
-EMB_PARAMS *font_std(const char *name)
-{
-  FONTFILE *ff=fontfile_open_std(name);
-  assert(ff);
-  EMB_PARAMS *emb=emb_new(ff,
-                          EMB_DEST_PDF16,
-                          EMB_C_TAKE_FONTFILE);
-  assert(emb);
-  return emb;
-}
-
-/*
- * Globals...
- */
-
-int		NumFonts;	/* Number of fonts to use */
-EMB_PARAMS	*Fonts[256][4];	/* Fonts to use */
-unsigned short	Chars[256];	/* Input char to unicode */
-unsigned char	Codes[65536];	/* Unicode glyph mapping to font */
-int		Widths[256];	/* Widths of each font */
-int		Directions[256];/* Text directions for each font */
-pdfOut *pdf;
-int    FontResource;   /* Object number of font resource dictionary */
-float  FontScaleX,FontScaleY;  /* The font matrix */
-lchar_t *Title,*Date;   /* The title and date strings */
-
-/*
- * Local functions...
- */
-
-static void	write_line(int row, lchar_t *line);
-static void	write_string(int col, int row, int len, lchar_t *s);
-static lchar_t *make_wide(const char *buf);
-static void     write_font_str(float x,float y,int fontid, lchar_t *str, int len);
-static void     write_pretty_header();
-
-
-/*
- * 'main()' - Main entry for text to PDF filter.
- */
-
-int			/* O - Exit status */
-main(int  argc,		/* I - Number of command-line arguments */
-     char *argv[])	/* I - Command-line arguments */
-{
-  return (TextMain("texttopdf", argc, argv));
-}
-
-
-/*
- * 'WriteEpilogue()' - Write the PDF file epilogue.
- */
-
-void
-WriteEpilogue(void)
-{
-  static char	*names[] =	/* Font names */
-		{ "FN","FB","FI","FBI" };
-  int i,j;
-
-  // embed fonts
-  for (i = PrettyPrint ? 3 : 1; i >= 0; i --) {
-    for (j = 0; j < NumFonts; j ++) 
-    {
-      EMB_PARAMS *emb=Fonts[j][i];
-      if (emb->font->fobj) { // already embedded
-        continue;
-      }
-      if ( (!emb->subset)||(bits_used(emb->subset,emb->font->sfnt->numGlyphs)) ) {
-        emb->font->fobj=pdfOut_write_font(pdf,emb);
-        assert(emb->font->fobj);
-      }
-    }
-  }
-
-  /*
-   * Create the global fontdict
-   */
-
-  // now fix FontResource
-  pdf->xref[FontResource-1]=pdf->filepos;
-  pdfOut_printf(pdf,"%d 0 obj\n"
-                    "<<\n",
-                    FontResource);
-
-  for (i = PrettyPrint ? 3 : 1; i >= 0; i --) {
-    for (j = 0; j < NumFonts; j ++) {
-      EMB_PARAMS *emb=Fonts[j][i];
-      if (emb->font->fobj) { // used
-        pdfOut_printf(pdf,"  /%s%02x %d 0 R\n",names[i],j,emb->font->fobj);
-      }
-    }
-  }
-
-  pdfOut_printf(pdf,">>\n"
-                    "endobj\n");
-
-  pdfOut_finish_pdf(pdf);
-
-  pdfOut_free(pdf);
-}
-
-/*
- * {{{ 'WritePage()' - Write a page of text.
- */
-
-void
-WritePage(void)
-{
-  int	line;			/* Current line */
-
-  int content=pdfOut_add_xref(pdf);
-  pdfOut_printf(pdf,"%d 0 obj\n"
-                    "<</Length %d 0 R\n"
-                    ">>\n"
-                    "stream\n"
-                    "q\n"
-                    ,content,content+1);
-  long size=-(pdf->filepos-2);
-
-  NumPages ++;
-  if (PrettyPrint)
-    write_pretty_header(pdf);
-
-  for (line = 0; line < SizeLines; line ++)
-    write_line(line, Page[line]);
-
-  size+=pdf->filepos+2;
-  pdfOut_printf(pdf,"Q\n"
-                    "endstream\n"
-                    "endobj\n");
-  
-  int len_obj=pdfOut_add_xref(pdf);
-  assert(len_obj==content+1);
-  pdfOut_printf(pdf,"%d 0 obj\n"
-                    "%ld\n"
-                    "endobj\n",
-                    len_obj,size);
-
-  int obj=pdfOut_add_xref(pdf);
-  pdfOut_printf(pdf,"%d 0 obj\n"
-                    "<</Type/Page\n"
-                    "  /Parent 1 0 R\n"
-                    "  /MediaBox [0 0 %.0f %.0f]\n"
-                    "  /Contents %d 0 R\n"
-                    "  /Resources << /Font %d 0 R >>\n"
-                    ">>\n"
-                    "endobj\n",
-                    obj,PageWidth,PageLength,content,FontResource);
-  pdfOut_add_page(pdf,obj);
-
-  memset(Page[0], 0, sizeof(lchar_t) * SizeColumns * SizeLines);
-}
-// }}}
-
-/* 
- * {{{'WriteProlog()' - Write the PDF file prolog with options.
- */
-
-void
-WriteProlog(const char *title,		/* I - Title of job */
-	    const char *user,		/* I - Username */
-            const char *classification,	/* I - Classification */
-	    const char *label,		/* I - Page label */
-            ppd_file_t *ppd)		/* I - PPD file info */
-{
-  int		i, j, k;	/* Looping vars */
-  char		*charset;	/* Character set string */
-  char		filename[1024];	/* Glyph filenames */
-  FILE		*fp;		/* Glyph files */
-  const char	*datadir;	/* CUPS_DATADIR environment variable */
-  char		line[1024],	/* Line from file */
-		*lineptr,	/* Pointer into line */
-		*valptr;	/* Pointer to value in line */
-#ifndef CUPS_1_4 /* CUPS 1.4.x or newer: support for non-utf8 removed */
-  int		ch, unicode;	/* Character values */
-#endif
-  int		start, end;	/* Start and end values for range */
-  time_t	curtime;	/* Current time */
-  struct tm	*curtm;		/* Current date */
-  char		curdate[255];	/* Current date (text format) */
-  int		num_fonts=0;	/* Number of unique fonts */
-  EMB_PARAMS	*fonts[1024];	/* Unique fonts */
-  char		*fontnames[1024];	/* Unique fonts */
-#if 0
-  static char	*names[] =	/* Font names */
-		{
-                  "FN","FB","FI"
-                /*
-		  "cupsNormal",
-		  "cupsBold",
-		  "cupsItalic"
-                */
-		};
-#endif
-
-
- /*
-  * Get the data directory...
-  */
-
-  if ((datadir = getenv("CUPS_DATADIR")) == NULL)
-    datadir = CUPS_DATADIR;
-
- /*
-  * Adjust margins as necessary...
-  */
-
-  if (classification || label)
-  {
-   /*
-    * Leave room for labels...
-    */
-
-    PageBottom += 36;
-    PageTop    -= 36;
-  }
-
-  if (PageColumns > 1)
-  {
-    ColumnGutter = CharsPerInch / 2;
-    ColumnWidth  = (SizeColumns - ColumnGutter * (PageColumns - 1)) /
-                   PageColumns;
-  }
-  else
-    ColumnWidth = SizeColumns;
-
- /*
-  * {{{ Output the PDF header...
-  */
-
-  assert(!pdf);
-  pdf=pdfOut_new();
-  assert(pdf);
-
-  pdfOut_begin_pdf(pdf);
-  pdfOut_printf(pdf,"%%cupsRotation: %d\n", (Orientation & 3) * 90); // TODO?
-
-  pdfOut_add_kv(pdf,"Creator","texttopdf/" PACKAGE_VERSION);
-
-  curtime = time(NULL);
-  curtm   = localtime(&curtime);
-  strftime(curdate, sizeof(curdate), "%c", curtm);
-
-  pdfOut_add_kv(pdf,"CreationDate",pdfOut_to_pdfdate(curtm));
-  pdfOut_add_kv(pdf,"Title",title);
-  pdfOut_add_kv(pdf,"Author",user); // was(PostScript): /For
-  // }}}
-
- /*
-  * {{{ Initialize globals...
-  */
-
-  NumFonts = 0;
-  memset(Fonts, 0, sizeof(Fonts));
-  memset(Chars, 0, sizeof(Chars));
-  memset(Codes, 0, sizeof(Codes));
-  // }}}
-
- /*
-  * Get the output character set...
-  */
-
-  charset = getenv("CHARSET");
-  if (charset != NULL && strcmp(charset, "us-ascii") != 0) // {{{
-  {
-    snprintf(filename, sizeof(filename), "%s/charsets/pdf.%s", datadir, charset);
-
-    if ((fp = fopen(filename, "r")) == NULL)
-    {
-     /*
-      * Can't open charset file!
-      */
-
-      fprintf(stderr, "ERROR: Unable to open %s: %s\n", filename,
-              strerror(errno));
-      exit(1);
-    }
-
-   /*
-    * Opened charset file; now see if this is really a charset file...
-    */
-
-    if (fgets(line, sizeof(line), fp) == NULL)
-    {
-     /*
-      * Bad/empty charset file!
-      */
-
-      fclose(fp);
-      fprintf(stderr, "ERROR: Bad charset file %s\n", filename);
-      exit(1);
-    }
-
-    if (strncmp(line, "charset", 7) != 0)
-    {
-     /*
-      * Bad format/not a charset file!
-      */
-
-      fclose(fp);
-      fprintf(stderr, "ERROR: Bad charset file %s\n", filename);
-      exit(1);
-    }
-
-   /*
-    * See if this is an 8-bit or UTF-8 character set file...
-    */
-
-    line[strlen(line) - 1] = '\0'; /* Drop \n */
-    for (lineptr = line + 7; isspace(*lineptr & 255); lineptr ++); /* Skip whitespace */
-
-#ifndef CUPS_1_4 /* CUPS 1.4.x or newer: support for non-utf8 removed */
-    if (strcmp(lineptr, "8bit") == 0) // {{{
-    {
-     /*
-      * 8-bit text...
-      */
-
-      UTF8     = 0;
-      NumFonts = 0;
-
-     /*
-      * Read the font description(s)...
-      */
-
-      while (fgets(line, sizeof(line), fp) != NULL)
-      {
-       /*
-        * Skip comment and blank lines...
-	*/
-
-        if (line[0] == '#' || line[0] == '\n')
-	  continue;
-
-       /*
-	* Read the font descriptions that should look like:
-	*
-	*   first last direction width normal [bold italic bold-italic]
-	*/
-
-	lineptr = line;
-
-        start = strtol(lineptr, &lineptr, 16);
-	end   = strtol(lineptr, &lineptr, 16);
-
-	while (isspace(*lineptr & 255))
-	  lineptr ++;
-
-        if (!*lineptr)
-	  break;	/* Must be a font mapping */
-
-	valptr = lineptr;
-
-	while (!isspace(*lineptr & 255) && *lineptr)
-	  lineptr ++;
-
-	if (!*lineptr)
-	{
-	 /*
-	  * Can't have a font without all required values...
-	  */
-
-	  fprintf(stderr, "ERROR: Bad font description line: %s\n", valptr);
-	  fclose(fp);
-	  exit(1);
-	}
-
-	*lineptr++ = '\0';
-
-	if (strcmp(valptr, "ltor") == 0)
-	  Directions[NumFonts] = 1;
-	else if (strcmp(valptr, "rtol") == 0)
-	  Directions[NumFonts] = -1;
-	else
-	{
-	  fprintf(stderr, "ERROR: Bad text direction %s\n", valptr);
-	  fclose(fp);
-	  exit(1);
-	}
-
-       /*
-	* Got the direction, now get the width...
-	*/
-
-	while (isspace(*lineptr & 255))
-	  lineptr ++;
-
-	valptr = lineptr;
-
-	while (!isspace(*lineptr & 255) && *lineptr)
-	  lineptr ++;
-
-	if (!*lineptr)
-	{
-	 /*
-	  * Can't have a font without all required values...
-	  */
-
-	  fprintf(stderr, "ERROR: Bad font description line: %s\n", valptr);
-	  fclose(fp);
-	  exit(1);
-	}
-
-	*lineptr++ = '\0';
-
-	if (strcmp(valptr, "single") == 0)
-          Widths[NumFonts] = 1;
-	else if (strcmp(valptr, "double") == 0)
-          Widths[NumFonts] = 2;
-	else 
-	{
-	  fprintf(stderr, "ERROR: Bad text width %s\n", valptr);
-	  fclose(fp);
-	  exit(1);
-	}
-
-       /*
-	* Get the fonts...
-	*/
-
-	for (i = 0; *lineptr && i < 4; i ++)
-	{
-	  while (isspace(*lineptr & 255))
-	    lineptr ++;
-
-	  valptr = lineptr;
-
-	  while (!isspace(*lineptr & 255) && *lineptr)
-	    lineptr ++;
-
-          if (*lineptr)
-	    *lineptr++ = '\0';
-
-          if (lineptr > valptr) {
-            // search for duplicates
-            for (k = 0; k < num_fonts; k ++)
-              if (strcmp(valptr, fontnames[k]) == 0) {
-	        Fonts[NumFonts][i] = fonts[k];
-                break;
-              }
-
-            if (k==num_fonts) {  // not found
-	      fonts[num_fonts] = Fonts[NumFonts][i] = font_load(valptr, Widths[NumFonts]);
-              if (!fonts[num_fonts]) { // font missing/corrupt, replace by first
-                fprintf(stderr,"WARNING: Ignored bad font \"%s\"\n",valptr);
-                break;
-              }
-              fontnames[num_fonts++] = strdup(valptr);
-            }
-          }
-	}
-
-        /* ignore complete range, when the first font is not available */
-        if (i==0) {
-          continue;
-        }
-
-       /*
-	* Fill in remaining fonts as needed...
-	*/
-
-	for (j = i; j < 4; j ++)
-	  Fonts[NumFonts][j] = Fonts[NumFonts][0];
-
-       /*
-        * Define the character mappings...
-	*/
-
-	for (i = start; i <= end; i ++)
-	  Codes[i] = NumFonts;
-
-        NumFonts ++;
-      }
-
-     /*
-      * Read encoding lines...
-      */
-
-      do
-      {
-       /*
-        * Skip comment and blank lines...
-	*/
-
-        if (line[0] == '#' || line[0] == '\n')
-	  continue;
-
-       /*
-        * Grab the character and unicode glyph number.
-	*/
-
-	if (sscanf(line, "%x%x", &ch, &unicode) == 2 && ch < 256)
-          Chars[ch] = unicode;
-      }
-      while (fgets(line, sizeof(line), fp) != NULL);
-
-      fclose(fp);
-    } else // }}}
-#endif
-    if (strcmp(lineptr, "utf8") == 0) { // {{{
-     /*
-      * UTF-8 (Unicode) text...
-      */
-
-      UTF8 = 1;
-
-     /*
-      * Read the font descriptions...
-      */
-
-      NumFonts = 0;
-
-      while (fgets(line, sizeof(line), fp) != NULL)
-      {
-       /*
-        * Skip comment and blank lines...
-	*/
-
-        if (line[0] == '#' || line[0] == '\n')
-	  continue;
-
-       /*
-	* Read the font descriptions that should look like:
-	*
-	*   start end direction width normal [bold italic bold-italic]
-	*/
-
-	lineptr = line;
-
-        start = strtol(lineptr, &lineptr, 16);
-	end   = strtol(lineptr, &lineptr, 16);
-
-	while (isspace(*lineptr & 255))
-	  lineptr ++;
-
-	valptr = lineptr;
-
-	while (!isspace(*lineptr & 255) && *lineptr)
-	  lineptr ++;
-
-	if (!*lineptr)
-	{
-	 /*
-	  * Can't have a font without all required values...
-	  */
-
-	  fprintf(stderr, "ERROR: Bad font description line: %s\n", valptr);
-	  fclose(fp);
-	  exit(1);
-	}
-
-	*lineptr++ = '\0';
-
-	if (strcmp(valptr, "ltor") == 0)
-	  Directions[NumFonts] = 1;
-	else if (strcmp(valptr, "rtol") == 0)
-	  Directions[NumFonts] = -1;
-	else
-	{
-	  fprintf(stderr, "ERROR: Bad text direction %s\n", valptr);
-	  fclose(fp);
-	  exit(1);
-	}
-
-       /*
-	* Got the direction, now get the width...
-	*/
-
-	while (isspace(*lineptr & 255))
-	  lineptr ++;
-
-	valptr = lineptr;
-
-	while (!isspace(*lineptr & 255) && *lineptr)
-	  lineptr ++;
-
-	if (!*lineptr)
-	{
-	 /*
-	  * Can't have a font without all required values...
-	  */
-
-	  fprintf(stderr, "ERROR: Bad font description line: %s\n", valptr);
-	  fclose(fp);
-	  exit(1);
-	}
-
-	*lineptr++ = '\0';
-
-	if (strcmp(valptr, "single") == 0)
-          Widths[NumFonts] = 1;
-	else if (strcmp(valptr, "double") == 0)
-          Widths[NumFonts] = 2;
-	else 
-	{
-	  fprintf(stderr, "ERROR: Bad text width %s\n", valptr);
-	  fclose(fp);
-	  exit(1);
-	}
-
-       /*
-	* Get the fonts...
-	*/
-
-	for (i = 0; *lineptr && i < 4; i ++)
-	{
-	  while (isspace(*lineptr & 255))
-	    lineptr ++;
-
-	  valptr = lineptr;
-
-	  while (!isspace(*lineptr & 255) && *lineptr)
-	    lineptr ++;
-
-          if (*lineptr)
-	    *lineptr++ = '\0';
-
-          if (lineptr > valptr) {
-            // search for duplicates
-            for (k = 0; k < num_fonts; k ++)
-              if (strcmp(valptr, fontnames[k]) == 0) {
-	        Fonts[NumFonts][i] = fonts[k];
-                break;
-              }
-
-            if (k==num_fonts) {  // not found
-	      fonts[num_fonts] = Fonts[NumFonts][i] = font_load(valptr, Widths[NumFonts]);
-              if (!fonts[num_fonts]) { // font missing/corrupt, replace by first
-                fprintf(stderr,"WARNING: Ignored bad font \"%s\"\n",valptr);
-                break;
-              }
-              fontnames[num_fonts++] = strdup(valptr);
-            }
-          }
-	}
-
-        /* ignore complete range, when the first font is not available */
-        if (i==0) {
-          continue;
-        }
-
-       /*
-	* Fill in remaining fonts as needed...
-	*/
-
-	for (j = i; j < 4; j ++)
-	  Fonts[NumFonts][j] = Fonts[NumFonts][0];
-
-       /*
-        * Define the character mappings...
-	*/
-
-	for (i = start; i <= end; i ++)
-	{
-          Codes[i] = NumFonts;
-	}
-
-       /*
-        * Move to the next font, stopping if needed...
-	*/
-
-        NumFonts ++;
-	if (NumFonts >= 256)
-	  break;
-      }
-
-      fclose(fp);
-    } // }}}
-    else // {{{
-    {
-      fprintf(stderr, "ERROR: Bad charset type %s\n", lineptr);
-      fclose(fp);
-      exit(1);
-    } // }}}
-  } // }}}
-  else // {{{ Standard ASCII
-  {
-   /*
-    * Standard ASCII output just uses Courier, Courier-Bold, and
-    * possibly Courier-Oblique.
-    */
-
-    NumFonts = 1;
-
-    Fonts[0][ATTR_NORMAL]     = font_std("Courier");
-    Fonts[0][ATTR_BOLD]       = font_std("Courier-Bold");
-    Fonts[0][ATTR_ITALIC]     = font_std("Courier-Oblique");
-    Fonts[0][ATTR_BOLDITALIC] = font_std("Courier-BoldOblique");
-
-    Widths[0]     = 1;
-    Directions[0] = 1;
-
-   /*
-    * Define US-ASCII characters...
-    */
-
-    for (i = 32; i < 127; i ++)
-    {
-      Chars[i] = i;
-      Codes[i] = NumFonts-1;
-    }
-  }
-  // }}}
-
-  if (NumFonts==0) {
-    fprintf(stderr, "ERROR: No usable font available\n");
-    exit(1);
-  }
-
-  FontScaleX=120.0 / CharsPerInch;
-  FontScaleY=68.0 / LinesPerInch;
-
-  // allocate now, for pages to use. will be fixed in epilogue
-  FontResource=pdfOut_add_xref(pdf);
-
-  if (PrettyPrint)
-  {
-    Date=make_wide(curdate);
-    Title=make_wide(title);
-  }
-}
-// }}}
-
-/*
- * {{{ 'write_line()' - Write a row of text.
- */
-
-static void
-write_line(int     row,		/* I - Row number (0 to N) */
-           lchar_t *line)	/* I - Line to print */
-{
-  int		i;		/* Looping var */
-  int		col,xcol,xwid;		/* Current column */
-  int		attr;		/* Current attribute */
-  int		font,		/* Font to use */
-		lastfont,	/* Last font */
-		mono;		/* Monospaced? */
-  lchar_t	*start;		/* First character in sequence */
-
-
-  xcol=0;
-  for (col = 0, start = line; col < SizeColumns;)
-  {
-    while (col < SizeColumns && (line->ch == ' ' || line->ch == 0))
-    {
-      col ++;
-      xcol ++;
-      line ++;
-    }
-
-    if (col >= SizeColumns)
-      break;
-
-    if (NumFonts == 1)
-    {
-     /*
-      * All characters in a single font - assume monospaced and single width...
-      */
-
-      attr  = line->attr;
-      start = line;
-
-      while (col < SizeColumns && line->ch != 0 && attr == line->attr)
-      {
-	col ++;
-	line ++;
-      }
-
-      write_string(col - (line - start), row, line - start, start);
-    }
-    else
-    {
-     /*
-      * Multiple fonts; break up based on the font...
-      */
-
-      attr     = line->attr;
-      start    = line;
-      xwid     = 0;
-      if (UTF8) {
-        lastfont = Codes[line->ch];
-      } else {
-        lastfont = Codes[Chars[line->ch]];
-      }
-//      mono     = strncmp(Fonts[lastfont][0], "Courier", 7) == 0;
-mono=1; // TODO
-
-      col ++;
-      xwid += Widths[lastfont];
-      line ++;
-
-      if (mono)
-      {
-	while (col < SizeColumns && line->ch != 0 && attr == line->attr)
-	{
-          if (UTF8) {
-            font = Codes[line->ch];
-          } else {
-            font = Codes[Chars[line->ch]];
-          }
-          if (/*strncmp(Fonts[font][0], "Courier", 7) != 0 ||*/ // TODO
-	      font != lastfont)
-	    break;
-
-	  col ++;
-          xwid += Widths[lastfont];
-	  line ++;
-	}
-      }
-
-      if (Directions[lastfont] > 0) {
-        write_string(xcol, row, line - start, start);
-        xcol += xwid;
-      }
-      else
-      {
-       /*
-        * Do right-to-left text... ; assume no font change without direction change
-	*/
-
-	while (col < SizeColumns && line->ch != 0 && attr == line->attr)
-	{
-          if (UTF8) {
-            font = Codes[line->ch];
-          } else {
-            font = Codes[Chars[line->ch]];
-          }
-          if (Directions[font] > 0 &&
-	      !ispunct(line->ch & 255) && !isspace(line->ch & 255))
-	    break;
-
-	  col ++;
-          xwid += Widths[lastfont];
-	  line ++;
-	}
-
-        for (i = 1; start < line; i ++, start ++)
-	  if (!isspace(start->ch & 255)) {
-            xwid-=Widths[lastfont];
-	    write_string(xcol + xwid, row, 1, start);
-          } else {
-            xwid--;
-          }
-      }
-    }
-  }
-}
-// }}}
-
-static lchar_t *make_wide(const char *buf)  // {{{ - convert to lchar_t
-{
-  const unsigned char	*utf8;	/* UTF8 text */
-  lchar_t *ret,*out;
-  
-  // this is enough, utf8 chars will only require less space
-  out=ret=malloc((strlen(buf)+1)*sizeof(lchar_t)); 
-
-  utf8 = (const unsigned char *)buf;
-  while (*utf8)
-  {
-    out->attr=0;
-
-    if (*utf8 < 0xc0 || !UTF8)
-      out->ch = *utf8 ++;
-    else if ((*utf8 & 0xe0) == 0xc0)
-    {
-     /*
-      * Two byte character...
-      */
-
-      out->ch = ((utf8[0] & 0x1f) << 6) | (utf8[1] & 0x3f);
-      utf8 += 2;
-    }
-    else
-    {
-     /*
-      * Three byte character...
-      */
-
-      out->ch = ((((utf8[0] & 0x1f) << 6) | (utf8[1] & 0x3f)) << 6) |
-                (utf8[2] & 0x3f);
-      utf8 += 3;
-    }
-
-    out++;
-  }
-  out->ch=out->attr=0;
-  return ret;
-}
-// }}}
-
-/*
- * {{{ 'write_string()' - Write a string of text.
- */
-
-static void
-write_string(int     col,	/* I - Start column */
-             int     row,	/* I - Row */
-             int     len,	/* I - Number of characters */
-             lchar_t *s)	/* I - String to print */
-{
-  float		x, y;		/* Position of text */
-  unsigned	attr;		/* Character attributes */
-
-
- /*
-  * Position the text and set the font...
-  */
-
-  if (Duplex && (NumPages & 1) == 0)
-  {
-    x = PageWidth - PageRight;
-    y = PageTop;
-  }
-  else
-  {
-    x = PageLeft;
-    y = PageTop;
-  }
-
-  x += (float)col * 72.0f / (float)CharsPerInch;
-  y -= (float)(row + 0.843) * 72.0f / (float)LinesPerInch;
-
-  attr = s->attr;
-
-  if (attr & ATTR_RAISED)
-    y += 36.0 / (float)LinesPerInch;
-  else if (attr & ATTR_LOWERED)
-    y -= 36.0 / (float)LinesPerInch;
-
-  if (attr & ATTR_UNDERLINE)
-    pdfOut_printf(pdf,"q 0.5 w 0 g %.3f %.3f m %.3f %.3f l S Q ",
-                      x, y - 6.8 / LinesPerInch,
-                      x + (float)len * 72.0 / (float)CharsPerInch,
-                      y - 6.8 / LinesPerInch);
-
-  if (PrettyPrint)
-  {
-    if (ColorDevice) {
-      if (attr & ATTR_RED)
-        pdfOut_printf(pdf,"0.5 0 0 rg\n");
-      else if (attr & ATTR_GREEN)
-        pdfOut_printf(pdf,"0 0.5 0 rg\n");
-      else if (attr & ATTR_BLUE)
-        pdfOut_printf(pdf,"0 0 0.5 rg\n");
-      else
-        pdfOut_printf(pdf,"0 g\n");
-    } else {
-      if ( (attr & ATTR_RED)||(attr & ATTR_GREEN)||(attr & ATTR_BLUE) )
-        pdfOut_printf(pdf,"0.2 g\n");
-      else
-        pdfOut_printf(pdf,"0 g\n");
-    }
-  }
-  else
-    pdfOut_printf(pdf,"0 g\n");
-  
-  write_font_str(x,y,attr & ATTR_FONT,s,len);
-}
-// }}}
-
-// {{{ show >len characters from >str, using the right font(s) at >x,>y
-static void write_font_str(float x,float y,int fontid, lchar_t *str, int len)
-{
-  unsigned short		ch;		/* Current character */
-  static char	*names[] =	/* Font names */
-		{ "FN","FB","FI","FBI" };
-
-  if (len==-1) {
-    for (len=0;str[len].ch;len++);
-  }
-  pdfOut_printf(pdf,"BT\n");
-
-  if (x == (int)x)
-    pdfOut_printf(pdf,"  %.0f ", x);
-  else
-    pdfOut_printf(pdf,"  %.3f ", x);
-
-  if (y == (int)y)
-    pdfOut_printf(pdf,"%.0f Td\n", y);
-  else
-    pdfOut_printf(pdf,"%.3f Td\n", y);
-
-  int lastfont,font;
-
-  // split on font boundary
-  while (len > 0) 
-  {
-   /*
-    * Write a hex string...
-    */
-    if (UTF8) {
-      lastfont=Codes[str->ch];
-    } else {
-      lastfont=Codes[Chars[str->ch]];
-    }
-    EMB_PARAMS *emb=Fonts[lastfont][fontid];
-    OTF_FILE *otf=emb->font->sfnt;
-
-    if (otf) { // TODO?
-      pdfOut_printf(pdf,"  %.3f Tz\n",
-                        FontScaleX*600.0/(otf_get_width(otf,4)*1000.0/otf->unitsPerEm)*100.0/FontScaleY); // TODO? 
-      // gid==4 is usually '!', the char after space. We just need "the" width for the monospaced font. gid==0 is bad, and space might also be bad.
-    } else {
-      pdfOut_printf(pdf,"  %.3f Tz\n",
-                        FontScaleX*100.0/FontScaleY); // TODO?
-    }
-
-    pdfOut_printf(pdf,"  /%s%02x %.3f Tf <",
-                      names[fontid],lastfont,FontScaleY);
-
-    while (len > 0)
-    {
-      if (UTF8) {
-        ch=str->ch;
-      } else {
-        ch=Chars[str->ch];
-      }
-
-      font = Codes[ch];
-      if (lastfont != font) { // only possible, when not used via write_string (e.g. utf-8filename.txt in prettyprint)
-        break;
-      }
-      if (otf) { // TODO 
-        const unsigned short gid=emb_get(emb,ch);
-        pdfOut_printf(pdf,"%04x", gid);
-      } else { // std 14 font with 7-bit us-ascii uses single byte encoding, TODO
-        pdfOut_printf(pdf,"%02x",ch);
-      }
-
-      len --;
-      str ++;
-    }
-
-    pdfOut_printf(pdf,"> Tj\n");
-  }
-  pdfOut_printf(pdf,"ET\n");
-}
-// }}}
-
-static float stringwidth_x(lchar_t *str)
-{
-  int len;
-
-  for (len=0;str[len].ch;len++);
-
-  return  (float)len * 72.0 / (float)CharsPerInch;
-}
-
-static void write_pretty_header() // {{{
-{
-  float x,y;
-  pdfOut_printf(pdf,"q\n"
-                    "0.9 g\n");
-
-  if (Duplex && (NumPages & 1) == 0) {
-    x = PageWidth - PageRight;
-    y = PageTop + 72.0f / LinesPerInch;
-  } else {
-    x = PageLeft;
-    y = PageTop + 72.0f / LinesPerInch;
-  }
-
-  pdfOut_printf(pdf,"1 0 0 1 %.3f %.3f cm\n",x,y); // translate
-  pdfOut_printf(pdf,"0 0 %.3f %.3f re f\n",
-                    PageRight - PageLeft, 144.0f / LinesPerInch);
-  pdfOut_printf(pdf,"0 g 0 G\n");
-
-  if (Duplex && (NumPages & 1) == 0) {
-      x = PageRight - PageLeft - 36.0f / LinesPerInch - stringwidth_x(Title);
-      y = (0.5f + 0.157f) * 72.0f / LinesPerInch;
-  } else {
-      x = 36.0f / LinesPerInch;
-      y = (0.5f + 0.157f) * 72.0f / LinesPerInch;
-  }
-  write_font_str(x,y,ATTR_BOLD,Title,-1);
-
-  x = (-stringwidth_x(Date) + PageRight - PageLeft) * 0.5;
-  write_font_str(x,y,ATTR_BOLD,Date,-1);
-
-  // convert pagenumber to string
-  char tmp[20];
-  tmp[19]=0;
-  snprintf(tmp,19,"%d",NumPages);
-  lchar_t *pagestr=make_wide(tmp);
-
-  if (Duplex && (NumPages & 1) == 0) {
-      x = 36.0f / LinesPerInch;
-  } else {
-      x = PageRight - PageLeft - 36.0f / LinesPerInch - stringwidth_x(pagestr);
-  }
-  write_font_str(x,y,ATTR_BOLD,pagestr,-1);
-  free(pagestr);
-
-  pdfOut_printf(pdf,"Q\n");
-}
-// }}}
-
diff --git a/filter/urftopdf.cpp b/filter/urftopdf.cpp
deleted file mode 100644
index 4e7f653..0000000
--- a/filter/urftopdf.cpp
+++ /dev/null
@@ -1,498 +0,0 @@
-/**
- * This program is free software: you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation, either version 3 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- * @brief Decode URF to a PDF file
- * @file urftopdf.cpp
- * @author Neil 'Superna' Armstrong <superna9999@gmail.com> (C) 2010
- * @author Tobias Hoffmann <smilingthax@gmail.com> (c) 2012
- */
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdint.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <string.h>
-#include <limits>
-#include <errno.h>
-
-#include <arpa/inet.h>   // ntohl
-
-#include <vector>
-#include <qpdf/QPDF.hh>
-#include <qpdf/QPDFWriter.hh>
-#include <qpdf/QUtil.hh>
-
-#include <qpdf/Pl_Flate.hh>
-#include <qpdf/Pl_Buffer.hh>
-
-#include "unirast.h"
-
-#define DEFAULT_PDF_UNIT 72   // 1/72 inch
-
-#define PROGRAM "urftopdf"
-
-#ifdef URF_DEBUG
-#define dprintf(format, ...) fprintf(stderr, "DEBUG: (" PROGRAM ") " format, __VA_ARGS__)
-#else
-#define dprintf(format, ...)
-#endif
-
-#define iprintf(format, ...) fprintf(stderr, "INFO: (" PROGRAM ") " format, __VA_ARGS__)
-
-void die(const char * str)
-{
-    fprintf(stderr, "CRIT: (" PROGRAM ") die(%s) [%s]\n", str, strerror(errno));
-    exit(1);
-}
-
-//------------- PDF ---------------
-
-struct pdf_info
-{
-    pdf_info() 
-      : pagecount(0),
-        width(0),height(0),
-        pixel_bytes(0),line_bytes(0),
-        bpp(0),
-        page_width(0),page_height(0)
-    {
-    }
-
-    QPDF pdf;
-    QPDFObjectHandle page;
-    unsigned pagecount;
-    unsigned width;
-    unsigned height;
-    unsigned pixel_bytes;
-    unsigned line_bytes;
-    unsigned bpp;
-    PointerHolder<Buffer> page_data;
-    double page_width,page_height;
-};
-
-int create_pdf_file(struct pdf_info * info, unsigned pagecount)
-{
-    try {
-        info->pdf.emptyPDF();
-    } catch (...) {
-        return 1;
-    }
-
-    info->pagecount = pagecount;
-
-    return 0;
-}
-
-QPDFObjectHandle makeBox(double x1, double y1, double x2, double y2)
-{
-    QPDFObjectHandle ret=QPDFObjectHandle::newArray();
-    ret.appendItem(QPDFObjectHandle::newReal(x1));
-    ret.appendItem(QPDFObjectHandle::newReal(y1));
-    ret.appendItem(QPDFObjectHandle::newReal(x2));
-    ret.appendItem(QPDFObjectHandle::newReal(y2));
-    return ret;
-}
-
-enum ColorSpace {
-    DEVICE_GRAY,
-    DEVICE_RGB,
-    DEVICE_CMYK
-};
-
-#define PRE_COMPRESS
-/* or temporarily store images?
-    if(cupsTempFile2(tempfile_name, 255) == NULL) die("Unable to create a temporary pdf file");
-    iprintf("Created temporary file '%s'\n", tempfile_name);
-*/
-
-QPDFObjectHandle makeImage(QPDF &pdf, PointerHolder<Buffer> page_data, unsigned width, unsigned height, ColorSpace cs, unsigned bpc)
-{
-    QPDFObjectHandle ret = QPDFObjectHandle::newStream(&pdf);
-
-    std::map<std::string,QPDFObjectHandle> dict;
-
-    dict["/Type"]=QPDFObjectHandle::newName("/XObject");
-    dict["/Subtype"]=QPDFObjectHandle::newName("/Image");
-    dict["/Width"]=QPDFObjectHandle::newInteger(width);
-    dict["/Height"]=QPDFObjectHandle::newInteger(height);
-    dict["/BitsPerComponent"]=QPDFObjectHandle::newInteger(bpc);
-
-    if (cs==DEVICE_GRAY) {
-        dict["/ColorSpace"]=QPDFObjectHandle::newName("/DeviceGray");
-    } else if (cs==DEVICE_RGB) {
-        dict["/ColorSpace"]=QPDFObjectHandle::newName("/DeviceRGB");
-    } else if (cs==DEVICE_CMYK) {
-        dict["/ColorSpace"]=QPDFObjectHandle::newName("/DeviceCMYK");
-    } else {
-        return QPDFObjectHandle();
-    }
-
-    ret.replaceDict(QPDFObjectHandle::newDictionary(dict));
-
-#ifdef PRE_COMPRESS
-    // we deliver already compressed content (instead of letting QPDFWriter do it), to avoid using excessive memory
-    Pl_Buffer psink("psink");
-    Pl_Flate pflate("pflate",&psink,Pl_Flate::a_deflate);
-    
-    pflate.write(page_data->getBuffer(),page_data->getSize());
-    pflate.finish();
-
-//    /Filter /FlateDecode
-//    /DecodeParms  [<</Predictor 1 /Colors 1[3] /BitsPerComponent $bits /Columns $x>>]  ??
-    ret.replaceStreamData(PointerHolder<Buffer>(psink.getBuffer()),
-                          QPDFObjectHandle::newName("/FlateDecode"),QPDFObjectHandle::newNull());
-#else
-    ret.replaceStreamData(page_data,QPDFObjectHandle::newNull(),QPDFObjectHandle::newNull());
-#endif
-
-    return ret;
-}
-
-void finish_page(struct pdf_info * info)
-{
-    //Finish previous Page
-    if(!info->page_data.getPointer())
-        return;
-
-    QPDFObjectHandle image = makeImage(info->pdf, info->page_data, info->width, info->height, DEVICE_RGB, 8);
-    if(!image.isInitialized()) die("Unable to load image data");
-
-    // add it
-    info->page.getKey("/Resources").getKey("/XObject").replaceKey("/I",image);
-
-    // draw it
-    std::string content;
-    content.append(QUtil::double_to_string(info->page_width) + " 0 0 " + 
-                   QUtil::double_to_string(info->page_height) + " 0 0 cm\n");
-    content.append("/I Do\n");
-    info->page.getKey("/Contents").replaceStreamData(content,QPDFObjectHandle::newNull(),QPDFObjectHandle::newNull());
-
-    // bookkeeping
-    info->page_data = PointerHolder<Buffer>();
-}
-
-int add_pdf_page(struct pdf_info * info, int pagen, unsigned width, unsigned height, int bpp, unsigned dpi)
-{
-    try {
-        finish_page(info); // any active
-
-        info->width = width;
-        info->height = height;
-        info->pixel_bytes = bpp/8;
-        info->line_bytes = (width*info->pixel_bytes);
-        info->bpp = bpp;
-    
-        if (info->height > (std::numeric_limits<unsigned>::max() / info->line_bytes)) {
-            die("Page too big");
-        }
-        info->page_data = PointerHolder<Buffer>(new Buffer(info->line_bytes*info->height));
-
-        QPDFObjectHandle page = QPDFObjectHandle::parse(
-            "<<"
-            "  /Type /Page"
-            "  /Resources <<"
-            "    /XObject << >> "
-            "  >>"
-            "  /MediaBox null "
-            "  /Contents null "
-            ">>");
-        page.replaceKey("/Contents",QPDFObjectHandle::newStream(&info->pdf)); // data will be provided later
-    
-        // Convert to pdf units
-        info->page_width=((double)info->width/dpi)*DEFAULT_PDF_UNIT;
-        info->page_height=((double)info->height/dpi)*DEFAULT_PDF_UNIT;
-        page.replaceKey("/MediaBox",makeBox(0,0,info->page_width,info->page_height));
-    
-        info->page = info->pdf.makeIndirectObject(page); // we want to keep a reference
-        info->pdf.addPage(info->page, false);
-    } catch (std::bad_alloc &ex) {
-        die("Unable to allocate page data");
-    } catch (...) {
-        return 1;
-    }
-
-    return 0;
-}
-
-int close_pdf_file(struct pdf_info * info)
-{
-    try {
-        finish_page(info); // any active
-
-        QPDFWriter output(info->pdf,NULL);
-        output.write();
-    } catch (...) {
-        return 1;
-    }
-
-    return 0;
-}
-
-void pdf_set_line(struct pdf_info * info, unsigned line_n, uint8_t line[])
-{
-    dprintf("pdf_set_line(%d)\n", line_n);
-
-    if(line_n > info->height)
-    {
-        dprintf("Bad line %d\n", line_n);
-        return;
-    }
-  
-    memcpy((info->page_data->getBuffer()+(line_n*info->line_bytes)), line, info->line_bytes);
-}
-
-// Data are in network endianness
-struct urf_file_header {
-    char unirast[8];
-    uint32_t page_count;
-} __attribute__((__packed__));
-
-struct urf_page_header {
-    uint8_t bpp;
-    uint8_t colorspace;
-    uint8_t duplex;
-    uint8_t quality;
-    uint32_t unknown0;
-    uint32_t unknown1;
-    uint32_t width;
-    uint32_t height;
-    uint32_t dot_per_inch;
-    uint32_t unknown2;
-    uint32_t unknown3;
-} __attribute__((__packed__));
-
-int decode_raster(int fd, unsigned width, unsigned height, int bpp, struct pdf_info * info)
-{
-    // We should be at raster start
-    int i, j;
-    unsigned cur_line = 0;
-    unsigned pos = 0;
-    uint8_t line_repeat_byte = 0;
-    unsigned line_repeat = 0;
-    int8_t packbit_code = 0;
-    int pixel_size = (bpp/8);
-    std::vector<uint8_t> pixel_container;
-    std::vector<uint8_t> line_container;
-
-    if (width > (std::numeric_limits<unsigned>::max() / pixel_size)) {
-        die("Line too big");
-    }
-    try {
-        pixel_container.resize(pixel_size);
-        line_container.resize(pixel_size*width);
-    } catch (...) {
-        die("Unable to allocate temporary storage");
-    }
-
-    do
-    {
-        if(read(fd, &line_repeat_byte, 1) < 1)
-        {
-            dprintf("l%06d : line_repeat EOF at %lu\n", cur_line, lseek(fd, 0, SEEK_CUR));
-            return 1;
-        }
-
-        line_repeat = (unsigned)line_repeat_byte + 1;
-
-        dprintf("l%06d : next actions for %d lines\n", cur_line, line_repeat);
-
-        // Start of line
-        pos = 0;
-
-        do
-        {
-            if(read(fd, &packbit_code, 1) < 1)
-            {
-                dprintf("p%06dl%06d : packbit_code EOF at %lu\n", pos, cur_line, lseek(fd, 0, SEEK_CUR));
-                return 1;
-            }
-
-            dprintf("p%06dl%06d: Raster code %02X='%d'.\n", pos, cur_line, (uint8_t)packbit_code, packbit_code);
-
-            if(packbit_code == -128)
-            {
-                dprintf("\tp%06dl%06d : blank rest of line.\n", pos, cur_line);
-                memset((&line_container[pos*pixel_size]), 0xFF, (pixel_size*(width-pos)));
-                pos = width;
-                break;
-            }
-            else if(packbit_code >= 0 && packbit_code <= 127)
-            {
-                int n = (packbit_code+1);
-
-                //Read pixel
-                if(read(fd, &pixel_container[0], pixel_size) < pixel_size)
-                {
-                    dprintf("p%06dl%06d : pixel repeat EOF at %lu\n", pos, cur_line, lseek(fd, 0, SEEK_CUR));
-                    return 1;
-                }
-
-                dprintf("\tp%06dl%06d : Repeat pixel '", pos, cur_line);
-                for(j = 0 ; j < pixel_size ; ++j)
-                    dprintf("%02X ", pixel_container[j]);
-                dprintf("' for %d times.\n", n);
-
-                for(i = 0 ; i < n ; ++i)
-                {
-                    //for(j = pixel_size-1 ; j >= 0 ; --j)
-                    for(j = 0 ; j < pixel_size ; ++j)
-                        line_container[pixel_size*pos + j] = pixel_container[j];
-                    ++pos;
-                    if(pos >= width)
-                        break;
-                }
-
-                if(i < n && pos >= width)
-                {
-                    dprintf("\tp%06dl%06d : Forced end of line for pixel repeat.\n", pos, cur_line);
-                }
-                
-                if(pos >= width)
-                    break;
-            }
-            else if(packbit_code > -128 && packbit_code < 0)
-            {
-                int n = (-(int)packbit_code)+1;
-
-                dprintf("\tp%06dl%06d : Copy %d verbatim pixels.\n", pos, cur_line, n);
-
-                for(i = 0 ; i < n ; ++i)
-                {
-                    if(read(fd, &pixel_container[0], pixel_size) < pixel_size)
-                    {
-                        dprintf("p%06dl%06d : literal_pixel EOF at %lu\n", pos, cur_line, lseek(fd, 0, SEEK_CUR));
-                        return 1;
-                    }
-                    //Invert pixels, should be programmable
-                    for(j = 0 ; j < pixel_size ; ++j)
-                        line_container[pixel_size*pos + j] = pixel_container[j];
-                    ++pos;
-                    if(pos >= width)
-                        break;
-                }
-
-                if(i < n && pos >= width)
-                {
-                    dprintf("\tp%06dl%06d : Forced end of line for pixel copy.\n", pos, cur_line);
-                }
-                
-                if(pos >= width)
-                    break;
-            }
-        }
-        while(pos < width);
-
-        dprintf("\tl%06d : End Of line, drawing %d times.\n", cur_line, line_repeat);
-
-        // write lines
-        for(i = 0 ; i < (int)line_repeat ; ++i)
-        {
-            pdf_set_line(info, cur_line, &line_container[0]);
-            ++cur_line;
-        }
-    }
-    while(cur_line < height);
-
-    return 0;
-}
-
-int main(int argc, char **argv)
-{
-    int fd, page;
-    struct urf_file_header head, head_orig;
-    struct urf_page_header page_header, page_header_orig;
-    struct pdf_info pdf;
-
-    FILE * input = NULL;
-
-    if(argc < 6)
-    {
-        fprintf(stderr, "Usage: %s <job> <user> <job name> <copies> <option> [file]\n", argv[0]);
-        return 1;
-    }
-
-    if(argc > 6)
-    {
-        input = fopen(argv[6], "rb");
-        if(input == NULL) die("Unable to open unirast file");
-    }
-    else
-        input = stdin;
-
-    // Get fd from file
-    fd = fileno(input);
-
-    if(read(fd, &head_orig, sizeof(head)) == -1) die("Unable to read file header");
-
-    //Transform
-    memcpy(head.unirast, head_orig.unirast, sizeof(head.unirast));
-    head.page_count = ntohl(head_orig.page_count);
-
-    if(head.unirast[7])
-        head.unirast[7] = 0;
-
-    if(strncmp(head.unirast, "UNIRAST", 7) != 0) die("Bad File Header");
-
-    iprintf("%s file, with %d page(s).\n", head.unirast, head.page_count);
-
-    if(create_pdf_file(&pdf, head.page_count) != 0) die("Unable to create PDF file");
-
-    for(page = 0 ; page < (int)head.page_count ; ++page)
-    {
-        if(read(fd, &page_header_orig, sizeof(page_header_orig)) == -1) die("Unable to read page header");
-
-        //Transform
-        page_header.bpp = page_header_orig.bpp;
-        page_header.colorspace = page_header_orig.colorspace;
-        page_header.duplex = page_header_orig.duplex;
-        page_header.quality = page_header_orig.quality;
-        page_header.unknown0 = 0;
-        page_header.unknown1 = 0;
-        page_header.width = ntohl(page_header_orig.width);
-        page_header.height = ntohl(page_header_orig.height);
-        page_header.dot_per_inch = ntohl(page_header_orig.dot_per_inch);
-        page_header.unknown2 = 0;
-        page_header.unknown3 = 0;
-
-        iprintf("Page %d :\n", page);
-        iprintf("Bits Per Pixel : %d\n", page_header.bpp);
-        iprintf("Colorspace : %d\n", page_header.colorspace);
-        iprintf("Duplex Mode : %d\n", page_header.duplex);
-        iprintf("Quality : %d\n", page_header.quality);
-        iprintf("Size : %dx%d pixels\n", page_header.width, page_header.height);
-        iprintf("Dots per Inches : %d\n", page_header.dot_per_inch);
-
-        if(page_header.colorspace != UNIRAST_COLOR_SPACE_SRGB_24BIT_1)
-        {
-            die("Invalid ColorSpace, only RGB 24BIT type 1 is supported");
-        }
-        
-        if(page_header.bpp != UNIRAST_BPP_24BIT)
-        {
-            die("Invalid Bit Per Pixel value, only 24bit is supported");
-        }
-
-        if(add_pdf_page(&pdf, page, page_header.width, page_header.height, page_header.bpp, page_header.dot_per_inch) != 0) die("Unable to create PDF file");
-
-        if(decode_raster(fd, page_header.width, page_header.height, page_header.bpp, &pdf) != 0)
-            die("Failed to decode Page");
-    }
-
-    close_pdf_file(&pdf); // will output to stdout
-
-    return 0;
-}
diff --git a/fontembed/README b/fontembed/README
deleted file mode 100644
index f84bd61..0000000
--- a/fontembed/README
+++ /dev/null
@@ -1,48 +0,0 @@
-libfontembed - font embedding and subsetting library
-----------------------------------------------------
-
-This library implements all the stuff required to
-embed and subset TrueType fonts, as for example 
-required in PDF files. It is completely self-contained,
-although a FreeType binding might come sometime in the future.
-
-Currently glyf-flavored TrueType is fully supported,
-for OTF, i.e. CFF-flavored TrueType/OpenType, subsetting is not
-done; but embedding does work.
-And single-byte mode does needs work/thought wrt. to encodings.
-Also reencoding and conversion of Type1 to CFF is planned.
-PostScript embedding is another goal of the project.
-
-The most important issue that needs fixing is support for
-text extraction in the PDF multibyte case (most common),
-which requires ToUnicode support; some preparation is already done.
-
-Usage
------
-(TODO)... see test_pdf.c ...
-
- * for direct sfnt access: use <sfnt.h>
- * for embedding: use <embed.h>  (which includes <fontfile.h>)
-
-License (MIT)
--------------
-Copyright (c) 2008,2012 by Tobias Hoffmann.
-
-Permission is hereby granted, free of charge, to any person obtaining
-a copy of this software and associated documentation files (the
-"Software"), to deal in the Software without restriction, including
-without limitation the rights to use, copy, modify, merge, publish,
-distribute, sublicense, and/or sell copies of the Software, and to
-permit persons to whom the Software is furnished to do so, subject to
-the following conditions:
-
-The above copyright notice and this permission notice shall be included
-in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
-CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/fontembed/aglfn13.c b/fontembed/aglfn13.c
deleted file mode 100644
index 0fa143c..0000000
--- a/fontembed/aglfn13.c
+++ /dev/null
@@ -1,214 +0,0 @@
-#include <stdlib.h>
-
-const char *aglfn13(unsigned short uni);
-
-#ifdef WITH_AGLFN
-static const char *agl_l207e[]={
-  "space","exclam","quotedbl","numbersign", "dollar","percent","ampersand","quotesingle",
-  "parenleft","parenright","asterisk","plus", "comma","hyphen","period","slash",
-  "zero","one","two","three", "four","five","six","seven",  "eight","nine","colon","semicolon", "less","equal","greater","question",
-  "at","A","B","C", "D","E","F","G",  "H","I","J","K", "L","M","N","O",
-  "P","Q","R","S", "T","U","V","W",  "X","Y","Z","bracketleft", "backslash","bracketright","asciicircum","underscore",
-  "grave","a","b","c", "d","e","f","g",  "h","i","j","k", "l","m","n","o",
-  "p","q","r","s", "t","u","v","w",  "x","y","z","braceleft", "bar","braceright","asciitilde"};
-
-static const char *agl_la1ff[]={
-  "exclamdown","cent","sterling","currency", "yen","brokenbar","section","dieresis",
-  "copyright","ordfeminine","guillemotleft","logicalnot", "registered","macron","degree","plusminus",
-  0,0,"acute",0, "paragraph","periodcentered","cedilla",0,
-  "ordmasculine","guillemotright","onequarter","onehalf", "threequarters","questiondown","Agrave","Aacute",
-  "Acircumflex","Atilde","Adieresis","Aring", "AE","Ccedilla","Egrave","Eacute",
-  "Ecircumflex","Edieresis","Igrave","Iacute", "Icircumflex","Idieresis","Eth","Ntilde",
-  "Ograve","Oacute","Ocircumflex","Otilde", "Odieresis","multiply","Oslash","Ugrave",
-  "Uacute","Ucircumflex","Udieresis","Yacute", "Thorn","germandbls","agrave","aacute",
-  "acircumflex","atilde","adieresis","aring", "ae","ccedilla","egrave","eacute",
-  "ecircumflex","edieresis","igrave","iacute", "icircumflex","idieresis","eth","ntilde",
-  "ograve","oacute","ocircumflex","otilde", "odieresis","divide","oslash","ugrave",
-  "uacute","ucircumflex","udieresis","yacute", "thorn","ydieresis"};
-
-static const char *agl_l1007f[]={
-  "Amacron","amacron","Abreve","abreve", "Aogonek","aogonek","Cacute","cacute",
-  "Ccircumflex","ccircumflex","Cdotaccent","cdotaccent", "Ccaron","ccaron","Dcaron","dcaron",
-  "Dcroat","dcroat","Emacron","emacron", "Ebreve","ebreve","Edotaccent","edotaccent",
-  "Eogonek","eogonek","Ecaron","ecaron", "Gcircumflex","gcircumflex","Gbreve","gbreve",
-  "Gdotaccent","gdotaccent","Gcommaaccent","gcommaaccent", "Hcircumflex","hcircumflex","Hbar","hbar",
-  "Itilde","itilde","Imacron","imacron", "Ibreve","ibreve","Iogonek","iogonek",
-  "Idotaccent","dotlessi","IJ","ij", "Jcircumflex","jcircumflex","Kcommaaccent","kcommaaccent",
-  "kgreenlandic","Lacute","lacute","Lcommaaccent", "lcommaaccent","Lcaron","lcaron","Ldot",
-  "ldot","Lslash","lslash","Nacute", "nacute","Ncommaaccent","ncommaaccent","Ncaron",
-  "ncaron","napostrophe","Eng","eng", "Omacron","omacron","Obreve","obreve",
-  "Ohungarumlaut","ohungarumlaut","OE","oe", "Racute","racute","Rcommaaccent","rcommaaccent",
-  "Rcaron","rcaron","Sacute","sacute", "Scircumflex","scircumflex","Scedilla","scedilla",
-  "Scaron","scaron","Tcommaaccent","tcommaaccent", "Tcaron","tcaron","Tbar","tbar",
-  "Utilde","utilde","Umacron","umacron", "Ubreve","ubreve","Uring","uring",
-  "Uhungarumlaut","uhungarumlaut","Uogonek","uogonek", "Wcircumflex","wcircumflex","Ycircumflex","ycircumflex",
-  "Ydieresis","Zacute","zacute","Zdotaccent", "zdotaccent","Zcaron","zcaron","longs"};
-
-struct agl_lt { unsigned short uid; const char *name; } agl_lxx[]={
-  {0x0192,"florin"},{0x01A0,"Ohorn"},{0x01A1,"ohorn"},{0x01AF,"Uhorn"},
-  {0x01B0,"uhorn"},{0x01E6,"Gcaron"},{0x01E7,"gcaron"},{0x01FA,"Aringacute"},
-  {0x01FB,"aringacute"},{0x01FC,"AEacute"},{0x01FD,"aeacute"},{0x01FE,"Oslashacute"},
-  {0x01FF,"oslashacute"},{0x0218,"Scommaaccent"},{0x0219,"scommaaccent"},{0x02BC,"afii57929"},
-  {0x02BD,"afii64937"},{0x02C6,"circumflex"},{0x02C7,"caron"},{0x02D8,"breve"},
-  {0x02D9,"dotaccent"},{0x02DA,"ring"},{0x02DB,"ogonek"},{0x02DC,"tilde"},
-  {0x02DD,"hungarumlaut"},{0x0300,"gravecomb"},{0x0301,"acutecomb"},{0x0303,"tildecomb"},
-  {0x0309,"hookabovecomb"},{0x0323,"dotbelowcomb"},{0x0384,"tonos"},{0x0385,"dieresistonos"},
-  {0x0386,"Alphatonos"},{0x0387,"anoteleia"},{0x0388,"Epsilontonos"},{0x0389,"Etatonos"},
-  {0x038A,"Iotatonos"},{0x038C,"Omicrontonos"},{0x038E,"Upsilontonos"},{0x038F,"Omegatonos"},
-  {0x0390,"iotadieresistonos"},{0x0391,"Alpha"},{0x0392,"Beta"},{0x0393,"Gamma"},
-  {0x0394,"Delta"},{0x0395,"Epsilon"},{0x0396,"Zeta"},{0x0397,"Eta"},
-  {0x0398,"Theta"},{0x0399,"Iota"},{0x039A,"Kappa"},{0x039B,"Lambda"},
-  {0x039C,"Mu"},{0x039D,"Nu"},{0x039E,"Xi"},{0x039F,"Omicron"},
-  {0x03A0,"Pi"},{0x03A1,"Rho"},{0x03A3,"Sigma"},{0x03A4,"Tau"},
-  {0x03A5,"Upsilon"},{0x03A6,"Phi"},{0x03A7,"Chi"},{0x03A8,"Psi"},
-  {0x03A9,"Omega"},{0x03AA,"Iotadieresis"},{0x03AB,"Upsilondieresis"},{0x03AC,"alphatonos"},
-  {0x03AD,"epsilontonos"},{0x03AE,"etatonos"},{0x03AF,"iotatonos"},{0x03B0,"upsilondieresistonos"},
-  {0x03B1,"alpha"},{0x03B2,"beta"},{0x03B3,"gamma"},{0x03B4,"delta"},
-  {0x03B5,"epsilon"},{0x03B6,"zeta"},{0x03B7,"eta"},{0x03B8,"theta"},
-  {0x03B9,"iota"},{0x03BA,"kappa"},{0x03BB,"lambda"},{0x03BC,"mu"},
-  {0x03BD,"nu"},{0x03BE,"xi"},{0x03BF,"omicron"},{0x03C0,"pi"},
-  {0x03C1,"rho"},{0x03C2,"sigma1"},{0x03C3,"sigma"},{0x03C4,"tau"},
-  {0x03C5,"upsilon"},{0x03C6,"phi"},{0x03C7,"chi"},{0x03C8,"psi"},
-  {0x03C9,"omega"},{0x03CA,"iotadieresis"},{0x03CB,"upsilondieresis"},
-  {0x03CC,"omicrontonos"},{0x03CD,"upsilontonos"},{0x03CE,"omegatonos"},
-  {0x03D1,"theta1"},{0x03D2,"Upsilon1"},{0x03D5,"phi1"},{0x03D6,"omega1"},
-  {0x0401,"afii10023"},{0x0402,"afii10051"},{0x0403,"afii10052"},{0x0404,"afii10053"},
-  {0x0405,"afii10054"},{0x0406,"afii10055"},{0x0407,"afii10056"},{0x0408,"afii10057"},
-  {0x0409,"afii10058"},{0x040A,"afii10059"},{0x040B,"afii10060"},{0x040C,"afii10061"},
-  {0x040E,"afii10062"},{0x040F,"afii10145"},{0x0410,"afii10017"},{0x0411,"afii10018"},
-  {0x0412,"afii10019"},{0x0413,"afii10020"},{0x0414,"afii10021"},{0x0415,"afii10022"},
-  {0x0416,"afii10024"},{0x0417,"afii10025"},{0x0418,"afii10026"},{0x0419,"afii10027"},
-  {0x041A,"afii10028"},{0x041B,"afii10029"},{0x041C,"afii10030"},{0x041D,"afii10031"},
-  {0x041E,"afii10032"},{0x041F,"afii10033"},{0x0420,"afii10034"},{0x0421,"afii10035"},
-  {0x0422,"afii10036"},{0x0423,"afii10037"},{0x0424,"afii10038"},{0x0425,"afii10039"},
-  {0x0426,"afii10040"},{0x0427,"afii10041"},{0x0428,"afii10042"},{0x0429,"afii10043"},
-  {0x042A,"afii10044"},{0x042B,"afii10045"},{0x042C,"afii10046"},{0x042D,"afii10047"},
-  {0x042E,"afii10048"},{0x042F,"afii10049"},{0x0430,"afii10065"},{0x0431,"afii10066"},
-  {0x0432,"afii10067"},{0x0433,"afii10068"},{0x0434,"afii10069"},{0x0435,"afii10070"},
-  {0x0436,"afii10072"},{0x0437,"afii10073"},{0x0438,"afii10074"},{0x0439,"afii10075"},
-  {0x043A,"afii10076"},{0x043B,"afii10077"},{0x043C,"afii10078"},{0x043D,"afii10079"},
-  {0x043E,"afii10080"},{0x043F,"afii10081"},{0x0440,"afii10082"},{0x0441,"afii10083"},
-  {0x0442,"afii10084"},{0x0443,"afii10085"},{0x0444,"afii10086"},{0x0445,"afii10087"},
-  {0x0446,"afii10088"},{0x0447,"afii10089"},{0x0448,"afii10090"},{0x0449,"afii10091"},
-  {0x044A,"afii10092"},{0x044B,"afii10093"},{0x044C,"afii10094"},{0x044D,"afii10095"},
-  {0x044E,"afii10096"},{0x044F,"afii10097"},{0x0451,"afii10071"},{0x0452,"afii10099"},
-  {0x0453,"afii10100"},{0x0454,"afii10101"},{0x0455,"afii10102"},{0x0456,"afii10103"},
-  {0x0457,"afii10104"},{0x0458,"afii10105"},{0x0459,"afii10106"},{0x045A,"afii10107"},
-  {0x045B,"afii10108"},{0x045C,"afii10109"},{0x045E,"afii10110"},{0x045F,"afii10193"},
-  {0x0462,"afii10146"},{0x0463,"afii10194"},{0x0472,"afii10147"},{0x0473,"afii10195"},
-  {0x0474,"afii10148"},{0x0475,"afii10196"},{0x0490,"afii10050"},{0x0491,"afii10098"},
-  {0x04D9,"afii10846"},{0x05B0,"afii57799"},{0x05B1,"afii57801"},{0x05B2,"afii57800"},
-  {0x05B3,"afii57802"},{0x05B4,"afii57793"},{0x05B5,"afii57794"},{0x05B6,"afii57795"},
-  {0x05B7,"afii57798"},{0x05B8,"afii57797"},{0x05B9,"afii57806"},{0x05BB,"afii57796"},
-  {0x05BC,"afii57807"},{0x05BD,"afii57839"},{0x05BE,"afii57645"},{0x05BF,"afii57841"},
-  {0x05C0,"afii57842"},{0x05C1,"afii57804"},{0x05C2,"afii57803"},{0x05C3,"afii57658"},
-  {0x05D0,"afii57664"},{0x05D1,"afii57665"},{0x05D2,"afii57666"},{0x05D3,"afii57667"},
-  {0x05D4,"afii57668"},{0x05D5,"afii57669"},{0x05D6,"afii57670"},{0x05D7,"afii57671"},
-  {0x05D8,"afii57672"},{0x05D9,"afii57673"},{0x05DA,"afii57674"},{0x05DB,"afii57675"},
-  {0x05DC,"afii57676"},{0x05DD,"afii57677"},{0x05DE,"afii57678"},{0x05DF,"afii57679"},
-  {0x05E0,"afii57680"},{0x05E1,"afii57681"},{0x05E2,"afii57682"},{0x05E3,"afii57683"},
-  {0x05E4,"afii57684"},{0x05E5,"afii57685"},{0x05E6,"afii57686"},{0x05E7,"afii57687"},
-  {0x05E8,"afii57688"},{0x05E9,"afii57689"},{0x05EA,"afii57690"},{0x05F0,"afii57716"},
-  {0x05F1,"afii57717"},{0x05F2,"afii57718"},{0x060C,"afii57388"},{0x061B,"afii57403"},
-  {0x061F,"afii57407"},{0x0621,"afii57409"},{0x0622,"afii57410"},{0x0623,"afii57411"},
-  {0x0624,"afii57412"},{0x0625,"afii57413"},{0x0626,"afii57414"},{0x0627,"afii57415"},
-  {0x0628,"afii57416"},{0x0629,"afii57417"},{0x062A,"afii57418"},{0x062B,"afii57419"},
-  {0x062C,"afii57420"},{0x062D,"afii57421"},{0x062E,"afii57422"},{0x062F,"afii57423"},
-  {0x0630,"afii57424"},{0x0631,"afii57425"},{0x0632,"afii57426"},{0x0633,"afii57427"},
-  {0x0634,"afii57428"},{0x0635,"afii57429"},{0x0636,"afii57430"},{0x0637,"afii57431"},
-  {0x0638,"afii57432"},{0x0639,"afii57433"},{0x063A,"afii57434"},{0x0640,"afii57440"},
-  {0x0641,"afii57441"},{0x0642,"afii57442"},{0x0643,"afii57443"},{0x0644,"afii57444"},
-  {0x0645,"afii57445"},{0x0646,"afii57446"},{0x0647,"afii57470"},{0x0648,"afii57448"},
-  {0x0649,"afii57449"},{0x064A,"afii57450"},{0x064B,"afii57451"},{0x064C,"afii57452"},
-  {0x064D,"afii57453"},{0x064E,"afii57454"},{0x064F,"afii57455"},{0x0650,"afii57456"},
-  {0x0651,"afii57457"},{0x0652,"afii57458"},{0x0660,"afii57392"},{0x0661,"afii57393"},
-  {0x0662,"afii57394"},{0x0663,"afii57395"},{0x0664,"afii57396"},{0x0665,"afii57397"},
-  {0x0666,"afii57398"},{0x0667,"afii57399"},{0x0668,"afii57400"},{0x0669,"afii57401"},
-  {0x066A,"afii57381"},{0x066D,"afii63167"},{0x0679,"afii57511"},{0x067E,"afii57506"},
-  {0x0686,"afii57507"},{0x0688,"afii57512"},{0x0691,"afii57513"},{0x0698,"afii57508"},
-  {0x06A4,"afii57505"},{0x06AF,"afii57509"},{0x06BA,"afii57514"},{0x06D2,"afii57519"},
-  {0x06D5,"afii57534"},{0x1E80,"Wgrave"},{0x1E81,"wgrave"},{0x1E82,"Wacute"},
-  {0x1E83,"wacute"},{0x1E84,"Wdieresis"},{0x1E85,"wdieresis"},{0x1EF2,"Ygrave"},
-  {0x1EF3,"ygrave"},{0x200C,"afii61664"},{0x200D,"afii301"},{0x200E,"afii299"},
-  {0x200F,"afii300"},{0x2012,"figuredash"},{0x2013,"endash"},{0x2014,"emdash"},
-  {0x2015,"afii00208"},{0x2017,"underscoredbl"},{0x2018,"quoteleft"},{0x2019,"quoteright"},
-  {0x201A,"quotesinglbase"},{0x201B,"quotereversed"},{0x201C,"quotedblleft"},{0x201D,"quotedblright"},
-  {0x201E,"quotedblbase"},{0x2020,"dagger"},{0x2021,"daggerdbl"},{0x2022,"bullet"},
-  {0x2024,"onedotenleader"},{0x2025,"twodotenleader"},{0x2026,"ellipsis"},{0x202C,"afii61573"},
-  {0x202D,"afii61574"},{0x202E,"afii61575"},{0x2030,"perthousand"},{0x2032,"minute"},
-  {0x2033,"second"},{0x2039,"guilsinglleft"},{0x203A,"guilsinglright"},{0x203C,"exclamdbl"},
-  {0x2044,"fraction"},{0x20A1,"colonmonetary"},{0x20A3,"franc"},{0x20A4,"lira"},
-  {0x20A7,"peseta"},{0x20AA,"afii57636"},{0x20AB,"dong"},{0x20AC,"Euro"},
-  {0x2105,"afii61248"},{0x2111,"Ifraktur"},{0x2113,"afii61289"},{0x2116,"afii61352"},
-  {0x2118,"weierstrass"},{0x211C,"Rfraktur"},{0x211E,"prescription"},{0x2122,"trademark"},
-  {0x212E,"estimated"},{0x2135,"aleph"},{0x2153,"onethird"},{0x2154,"twothirds"},
-  {0x215B,"oneeighth"},{0x215C,"threeeighths"},{0x215D,"fiveeighths"},{0x215E,"seveneighths"},
-  {0x2190,"arrowleft"},{0x2191,"arrowup"},{0x2192,"arrowright"},{0x2193,"arrowdown"},
-  {0x2194,"arrowboth"},{0x2195,"arrowupdn"},{0x21A8,"arrowupdnbse"},{0x21B5,"carriagereturn"},
-  {0x21D0,"arrowdblleft"},{0x21D1,"arrowdblup"},{0x21D2,"arrowdblright"},{0x21D3,"arrowdbldown"},
-  {0x21D4,"arrowdblboth"},{0x2200,"universal"},{0x2202,"partialdiff"},{0x2203,"existential"},
-  {0x2205,"emptyset"},{0x2207,"gradient"},{0x2208,"element"},{0x2209,"notelement"},
-  {0x220B,"suchthat"},{0x220F,"product"},{0x2211,"summation"},{0x2212,"minus"},
-  {0x2217,"asteriskmath"},{0x221A,"radical"},{0x221D,"proportional"},{0x221E,"infinity"},
-  {0x221F,"orthogonal"},{0x2220,"angle"},{0x2227,"logicaland"},{0x2228,"logicalor"},
-  {0x2229,"intersection"},{0x222A,"union"},{0x222B,"integral"},{0x2234,"therefore"},
-  {0x223C,"similar"},{0x2245,"congruent"},{0x2248,"approxequal"},{0x2260,"notequal"},
-  {0x2261,"equivalence"},{0x2264,"lessequal"},{0x2265,"greaterequal"},{0x2282,"propersubset"},
-  {0x2283,"propersuperset"},{0x2284,"notsubset"},{0x2286,"reflexsubset"},{0x2287,"reflexsuperset"},
-  {0x2295,"circleplus"},{0x2297,"circlemultiply"},{0x22A5,"perpendicular"},{0x22C5,"dotmath"},
-  {0x2302,"house"},{0x2310,"revlogicalnot"},{0x2320,"integraltp"},{0x2321,"integralbt"},
-  {0x2329,"angleleft"},{0x232A,"angleright"},{0x2500,"SF100000"},{0x2502,"SF110000"},
-  {0x250C,"SF010000"},{0x2510,"SF030000"},{0x2514,"SF020000"},{0x2518,"SF040000"},
-  {0x251C,"SF080000"},{0x2524,"SF090000"},{0x252C,"SF060000"},{0x2534,"SF070000"},
-  {0x253C,"SF050000"},{0x2550,"SF430000"},{0x2551,"SF240000"},{0x2552,"SF510000"},
-  {0x2553,"SF520000"},{0x2554,"SF390000"},{0x2555,"SF220000"},{0x2556,"SF210000"},
-  {0x2557,"SF250000"},{0x2558,"SF500000"},{0x2559,"SF490000"},{0x255A,"SF380000"},
-  {0x255B,"SF280000"},{0x255C,"SF270000"},{0x255D,"SF260000"},{0x255E,"SF360000"},
-  {0x255F,"SF370000"},{0x2560,"SF420000"},{0x2561,"SF190000"},{0x2562,"SF200000"},
-  {0x2563,"SF230000"},{0x2564,"SF470000"},{0x2565,"SF480000"},{0x2566,"SF410000"},
-  {0x2567,"SF450000"},{0x2568,"SF460000"},{0x2569,"SF400000"},{0x256A,"SF540000"},
-  {0x256B,"SF530000"},{0x256C,"SF440000"},{0x2580,"upblock"},{0x2584,"dnblock"},
-  {0x2588,"block"},{0x258C,"lfblock"},{0x2590,"rtblock"},{0x2591,"ltshade"},
-  {0x2592,"shade"},{0x2593,"dkshade"},{0x25A0,"filledbox"},{0x25A1,"H22073"},
-  {0x25AA,"H18543"},{0x25AB,"H18551"},{0x25AC,"filledrect"},{0x25B2,"triagup"},
-  {0x25BA,"triagrt"},{0x25BC,"triagdn"},{0x25C4,"triaglf"},{0x25CA,"lozenge"},
-  {0x25CB,"circle"},{0x25CF,"H18533"},{0x25D8,"invbullet"},{0x25D9,"invcircle"},
-  {0x25E6,"openbullet"},{0x263A,"smileface"},{0x263B,"invsmileface"},{0x263C,"sun"},
-  {0x2640,"female"},{0x2642,"male"},{0x2660,"spade"},{0x2663,"club"},
-  {0x2665,"heart"},{0x2666,"diamond"},{0x266A,"musicalnote"},{0x266B,"musicalnotedbl"}};
-
-static int agl_cmp(const void *a,const void *b)
-{
-  const unsigned short aa=((struct agl_lt *)a)->uid,bb=((struct agl_lt *)b)->uid;
-  if (aa<bb) {
-    return -1;
-  } else if (aa>bb) {
-    return 1;
-  }
-  return 0;
-}
-
-const char *aglfn13(unsigned short uni)
-{
-  if ( (uni>=0x0020)&&(uni<0x007f) ) {
-    return agl_l207e[uni-0x0020];
-  } else if ( (uni>=0x00a1)&&(uni<=0x00ff) ) {
-    return agl_la1ff[uni-0x00a1];
-  } else if ( (uni>=0x0100)&&(uni<=0x017f) ) {
-    return agl_l1007f[uni-0x0100];
-  } else if (uni>=0x0180) {
-    struct agl_lt key,*res;
-    key.uid=uni;
-    res=bsearch(&key,agl_lxx,(sizeof(agl_lxx)/sizeof(struct agl_lt)),sizeof(struct agl_lt),agl_cmp);
-    if (res) {
-      return res->name;
-    }
-  }
-  return NULL;
-}
-#else
-const char *aglfn13(unsigned short uni)
-{
-  return NULL;
-}
-#endif
diff --git a/fontembed/bitset.h b/fontembed/bitset.h
deleted file mode 100644
index 71d50ab..0000000
--- a/fontembed/bitset.h
+++ /dev/null
@@ -1,38 +0,0 @@
-#ifndef _BITSET_H
-#define _BITSET_H
-
-#include <stdlib.h>
-
-typedef int * BITSET;
-
-static inline void bit_set(BITSET bs,int num)
-{
-  bs[num/(8*sizeof(int))]|=1<<(num%(8*sizeof(int)));
-}
-
-static inline int bit_check(BITSET bs,int num)
-{
-  return bs[num/(8*sizeof(int))]&1<<(num%(8*sizeof(int)));
-}
-
-// use free() when done. returns NULL on bad_alloc
-static inline BITSET bitset_new(int size)
-{
-  return (BITSET)calloc(1,((size+8*sizeof(int)-1)&~(8*sizeof(int)-1))/8);
-}
-
-static inline int bits_used(BITSET bits,int size) // {{{  returns true if any bit is used
-{
-  size=(size+8*sizeof(int)-1)/(8*sizeof(int));
-  while (size>0) {
-    if (*bits) {
-      return 1;
-    }
-    bits++;
-    size--;
-  }
-  return 0;
-}
-// }}}
-
-#endif
diff --git a/fontembed/dynstring.c b/fontembed/dynstring.c
deleted file mode 100644
index 0bdad15..0000000
--- a/fontembed/dynstring.c
+++ /dev/null
@@ -1,105 +0,0 @@
-#include "dynstring.h"
-#include <errno.h>
-#include <stdarg.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <assert.h>
-
-int dyn_init(DYN_STRING *ds,int reserve_size) // {{{
-{
-  assert(ds);
-  assert(reserve_size>0);
-
-  ds->len=0;
-  ds->alloc=reserve_size;
-  ds->buf=malloc(ds->alloc+1);
-  if (!ds->buf) {
-    fprintf(stderr,"Bad alloc: %s\n", strerror(errno));
-    assert(0);
-    ds->len=-1;
-    return -1;
-  }
-  return 0;
-}
-// }}}
-
-void dyn_free(DYN_STRING *ds) // {{{
-{
-  assert(ds);
-
-  ds->len=-1;
-  ds->alloc=0;
-  free(ds->buf);
-  ds->buf=NULL;
-}
-// }}}
-
-int dyn_ensure(DYN_STRING *ds,int free_space) // {{{
-{
-  assert(ds);
-  assert(free_space);
-
-  if (ds->len<0) {
-    return -1;
-  }
-  if (ds->alloc - ds->len >= free_space) {
-    return 0; // done
-  }
-  ds->alloc+=free_space;
-  char *tmp=realloc(ds->buf,ds->alloc+1);
-  if (!tmp) {
-    ds->len=-1;
-    fprintf(stderr,"Bad alloc: %s\n", strerror(errno));
-    assert(0);
-    return -1;
-  }
-  ds->buf=tmp;
-  return 0;
-}
-// }}}
-
-int dyn_vprintf(DYN_STRING *ds,const char *fmt,va_list ap) // {{{
-{
-  assert(ds);
-
-  int need,len=strlen(fmt)+100;
-  va_list va;
-
-  if (dyn_ensure(ds,len)==-1) {
-    return -1;
-  }
-
-  while (1) {
-    va_copy(va,ap);
-    need=vsnprintf(ds->buf+ds->len,ds->alloc-ds->len+1,fmt,va);
-    va_end(va);
-    if (need==-1) {
-      len+=100;
-    } else if (need>=len) {
-      len=need;
-    } else {
-      ds->len+=need;
-      break;
-    }
-    if (dyn_ensure(ds,len)==-1) {
-      return -1;
-    }
-  }
-  return 0;
-}
-// }}}
-
-int dyn_printf(DYN_STRING *ds,const char *fmt,...) // {{{
-{
-  va_list va;
-  int ret;
-
-  va_start(va,fmt);
-  ret=dyn_vprintf(ds,fmt,va);
-  va_end(va);
-
-  return ret;
-}
-// }}}
-
diff --git a/fontembed/dynstring.h b/fontembed/dynstring.h
deleted file mode 100644
index a758f2c..0000000
--- a/fontembed/dynstring.h
+++ /dev/null
@@ -1,16 +0,0 @@
-#ifndef _DYNSTRING_H
-#define _DYNSTRING_H
-
-typedef struct {
-  int len,alloc;
-  char *buf;
-} DYN_STRING;
-
-int dyn_init(DYN_STRING *ds,int reserve_size); // -1 on error
-void dyn_free(DYN_STRING *ds);
-int dyn_ensure(DYN_STRING *ds,int free_space);
-int dyn_printf(DYN_STRING *ds,const char *fmt,...) // appends
-  __attribute__((format(printf, 2, 3)));
-
-#endif
-
diff --git a/fontembed/embed.c b/fontembed/embed.c
deleted file mode 100644
index cdf8054..0000000
--- a/fontembed/embed.c
+++ /dev/null
@@ -1,260 +0,0 @@
-#include "embed.h"
-#include "embed_sfnt_int.h"
-#include <assert.h>
-#include <errno.h>
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-
-static inline int copy_file(FILE *f,OUTPUT_FN output,void *context) // {{{
-{
-  assert(f);
-  assert(output);
-
-  char buf[4096];
-  int iA,ret=0;
-
-  ret=0;
-  rewind(f);
-  do {
-    iA=fread(buf,1,4096,f);
-    (*output)(buf,iA,context);
-    ret+=iA;
-  } while (iA>0);
-  return ret;
-}
-// }}}
-
-/* certain profiles: (=> constraints to be auto-applied in emb_new via >dest)
-  PSold: T1->T1, TTF->T1, OTF->CFF->T1, STD->STD   // output limit: T1  (maybe length, binary/text, ... limit)
-  PS1: T1->T1, TTF->T1, OTF->CFF, STD->STD    // output limit: T1,CFF [does this really exists?]
-  PS2: T1->T1, TTF->TTF, OTF->T1, STD->STD    // output limit: T1,TTF
-  PS3: T1->T1, TTF->TTF, OTF->CFF, STD->STD
-  PDF12/13?: OTF->CFF
-  PDF16: OTF->OTF (,T1->CFF?)
-    --- rename KEEP_T1 to NEED_T1?  NO_T42?
-
-  converters:
-  OTF->CFF, CFF->OTF (extract metrics, etc)
-  (T1->CFF, CFF->T1)
-  ((TTF->T1 ['good'; T1->TTF: not good]))
-  [subsetTTF,subsetCFF,subsetT1]
-
-  output modes:
-  subset,CID(multibyte),(PS:)text/binary,(PS:)incremental
-
-  TODO: remove dest from emb_new, replace with EMB_ACTIONS constraints:
-     - bitfield mask which ACTIONS are allowed.  (problem: we want to force certain ones, e.g. MULTIBYTE)
-     - e.g. currently EMB_C_PDF_OT has to functions
-     - the only (other) 'difference' to now is the subsetting spec
-     - another issue is, that emb_pdf_ might want some pdf version informatino (->extra flag?)
-   and funtion to determine appropriate mask for certain destination
-     EMB_ACTIONS emb_mask_for_dest(EMB_DESTINATION)
-  TODO? determine viability before trying emb_embed
-    (idea: use emb_embed(,NULL) -> will just return true/false  [same codepath!])
-
-  TODO?! "always subset CJK"
-*/
-
-EMB_PARAMS *emb_new(FONTFILE *font,EMB_DESTINATION dest,EMB_CONSTRAINTS mode) // {{{
-{
-  assert(font);
-
-  EMB_PARAMS *ret=calloc(1,sizeof(EMB_PARAMS));
-  if (!ret) {
-    fprintf(stderr,"Bad alloc: %s\n", strerror(errno));
-    if (mode&EMB_C_TAKE_FONTFILE) {
-      fontfile_close(font);
-    }
-    return NULL;
-  }
-  ret->dest=dest;
-  ret->font=font;
-  if (mode&EMB_C_TAKE_FONTFILE) {
-    ret->plan|=EMB_A_CLOSE_FONTFILE;
-  }
-
-  // check parameters
-  if ( (mode&EMB_C_KEEP_T1)&&(mode&EMB_C_FORCE_MULTIBYTE) ) {
-    fprintf(stderr,"Incompatible mode: KEEP_T1 and FORCE_MULTIBYTE\n");
-    emb_close(ret);
-    return NULL;
-  }
-  if ((mode&0x07)>5) {
-    fprintf(stderr,"Bad subset specification\n");
-    emb_close(ret);
-    return NULL;
-  }
-
-  // determine intype
-  int numGlyphs=0;
-  if (font->sfnt) {
-    if (font->sfnt->flags&OTF_F_FMT_CFF) {
-      ret->intype=EMB_FMT_OTF;
-    } else {
-      ret->intype=EMB_FMT_TTF;
-    }
-    ret->rights=emb_otf_get_rights(ret->font->sfnt);
-    numGlyphs=ret->font->sfnt->numGlyphs; // TODO
-  } else if (font->stdname) {
-    ret->intype=EMB_FMT_STDFONT;
-    ret->rights=EMB_RIGHT_NONE;
-  } else {
-    assert(0);
-  }
-/*
-  if ( (ret->intype==EMB_FMT_CFF)&&
-       (ret->cffFont.is_cid()) ) {
-     ?= || ( (ret->intype==EMB_FMT_OTF)&&(ret->sfnt->cffFont.is_cid()) ) // TODO?
-    ret->plan|=EMB_A_MULTIBYTE;
-  }
-*/
-
-  // determine outtype
-  if (ret->intype==EMB_FMT_STDFONT) {
-    ret->outtype=ret->intype;
-    if (mode&EMB_C_FORCE_MULTIBYTE) {
-      fprintf(stderr,"Multibyte stdfonts are not possible\n");
-      emb_close(ret);
-      return NULL;
-    }
-    return ret; // never subset, no multibyte
-  } else if (ret->intype==EMB_FMT_T1) {
-    if (mode&EMB_C_KEEP_T1) {
-      ret->outtype=EMB_FMT_T1;
-    } else {
-      ret->plan|=EMB_A_T1_TO_CFF;
-      ret->outtype=EMB_FMT_CFF;
-    }
-  } else {
-    ret->outtype=ret->intype;
-  }
-  if (ret->outtype==EMB_FMT_CFF) {
-    if (mode&EMB_C_PDF_OT) {
-      ret->outtype=EMB_FMT_OTF;
-      ret->plan|=EMB_A_CFF_TO_OTF;
-    }
-  } else if (ret->outtype==EMB_FMT_OTF) {
-    // TODO: no support yet;  but we want to get the FontDescriptor/Name right
-    mode|=EMB_C_NEVER_SUBSET;
-    if (!(mode&EMB_C_PDF_OT)) { // TODO!?!
-      ret->outtype=EMB_FMT_CFF;
-      ret->plan|=EMB_A_OTF_TO_CFF;
-    }
-  }
-
-  if (mode&EMB_C_FORCE_MULTIBYTE) {
-    ret->plan|=EMB_A_MULTIBYTE;
-  }
-
-  // check rights (for subsetting)
-  if (  (ret->rights&EMB_RIGHT_NONE)||
-        (ret->rights&EMB_RIGHT_BITMAPONLY)||
-        ( (ret->rights&EMB_RIGHT_READONLY)&&(mode&EMB_C_EDITABLE_SUBSET) )||
-        ( (ret->rights&EMB_RIGHT_NO_SUBSET)&&(mode&EMB_C_MUST_SUBSET) )  ) {
-    fprintf(stderr,"The font does not permit the requested embedding\n");
-    emb_close(ret);
-    return NULL;
-  } else if ( (!(ret->rights&EMB_RIGHT_NO_SUBSET))&&
-              (!(mode&EMB_C_NEVER_SUBSET)) ) {
-    ret->plan|=EMB_A_SUBSET;
-  }
-
-  // alloc subset
-  if (ret->plan&EMB_A_SUBSET) {
-    ret->subset=bitset_new(numGlyphs);
-    if (!ret->subset) {
-      fprintf(stderr,"Bad alloc: %s\n", strerror(errno));
-      emb_close(ret);
-      return NULL;
-    }
-  }
-
-  return ret;
-}
-// }}}
-
-int emb_embed(EMB_PARAMS *emb,OUTPUT_FN output,void *context) // {{{
-{
-  assert(emb);
-
-  if (emb->dest==EMB_DEST_NATIVE) {
-  } else if (emb->dest<=EMB_DEST_PS) {
-    int ret=-2;
-    const char *fontname=emb_otf_get_fontname(emb->font->sfnt); // TODO!!
-    (*output)("%%BeginFont: ",13,context);
-    (*output)(fontname,strlen(fontname),context);
-    (*output)("\n",1,context);
-    if (emb->outtype==EMB_FMT_T1) {
-    } else if (emb->outtype==EMB_FMT_TTF) { // emb->outtype==EMB_OUTPUT_OTF  is stupid (?)
-      // do Type42
-      ret=emb_otf_ps(emb->font->sfnt,NULL,256,NULL,output,context); // TODO?
-    } else if (emb->outtype==EMB_FMT_CFF) {
-    } else if (emb->outtype==EMB_FMT_STDFONT) {
-    }
-    if (ret!=-2) {
-      if (ret!=-1) {
-        (*output)("%%EndFont\n",10,context);
-      } else {
-        fprintf(stderr,"Failed\n");
-      }
-      return ret;
-    }
-  } else if (emb->dest<=EMB_DEST_PDF16) {
-    if (emb->outtype==EMB_FMT_TTF) {
-      assert(emb->font->sfnt);
-      if (emb->plan&EMB_A_SUBSET) {
-        return otf_subset(emb->font->sfnt,emb->subset,output,context);
-      } else if (emb->font->sfnt->numTTC) { //
-        return otf_ttc_extract(emb->font->sfnt,output,context);
-      } else { // copy verbatim
-        return copy_file(emb->font->sfnt->f,output,context);
-      }
-    } else if (emb->outtype==EMB_FMT_OTF) {
-      if (emb->plan&EMB_A_CFF_TO_OTF) {
-        if (emb->plan&EMB_A_T1_TO_CFF) {
-          // TODO
-        } else {
-          // assert(emb->font->cff);
-          // TODO
-        }
-      } else {
-        assert(emb->font->sfnt);
-        if (emb->plan&EMB_A_SUBSET) {
-          return otf_subset_cff(emb->font->sfnt,emb->subset,output,context);
-        } else {
-          return copy_file(emb->font->sfnt->f,output,context);
-        }
-      }
-    } else if (emb->outtype==EMB_FMT_CFF) {
-      if (emb->plan&EMB_A_OTF_TO_CFF) {
-        assert(emb->font->sfnt);
-        if (emb->plan&EMB_A_SUBSET) {
-          // TODO
-        } else {
-          return otf_cff_extract(emb->font->sfnt,output,context);
-        }
-      } else {
-        // TODO
-      }
-    }
-  }
-
-  fprintf(stderr,"NOT IMPLEMENTED\n");
-  assert(0);
-  return -1;
-}
-// }}}
-
-void emb_close(EMB_PARAMS *emb) // {{{
-{
-  if (emb) {
-    free(emb->subset);
-    if (emb->plan&EMB_A_CLOSE_FONTFILE) {
-      fontfile_close(emb->font);
-    }
-    free(emb);
-  }
-}
-// }}}
-
diff --git a/fontembed/embed.h b/fontembed/embed.h
deleted file mode 100644
index 682471f..0000000
--- a/fontembed/embed.h
+++ /dev/null
@@ -1,92 +0,0 @@
-#ifndef EMBED_H
-#define EMBED_H
-
-#include "bitset.h"
-#include "fontfile.h"
-#include "iofn.h"
-
-typedef enum { EMB_FMT_T1,       // type1, with AFM/PFM,PFA/PFB
-               EMB_FMT_TTF,      // sfnt, for TTF(glyf)
-               EMB_FMT_OTF,      // sfnt+cff, for OTF(cff)
-               EMB_FMT_CFF,      // cff, for raw CFF
-               EMB_FMT_STDFONT   // don't embed (already present)
-               } EMB_FORMAT;
-typedef enum { EMB_DEST_NATIVE,  // just subsetting/conversion
-               EMB_DEST_PS,
-//               EMB_DEST_PS2,
-//               EMB_DEST_PDF13,
-               EMB_DEST_PDF16
-               } EMB_DESTINATION;
-
-typedef enum { EMB_RIGHT_FULL=0, EMB_RIGHT_NONE=0x02,
-               EMB_RIGHT_READONLY=0x04,
-               EMB_RIGHT_NO_SUBSET=0x0100,
-               EMB_RIGHT_BITMAPONLY=0x0200 } EMB_RIGHT_TYPE;
-
-typedef enum { EMB_A_MULTIBYTE=0x01,    // embedd as multibyte font?
-               EMB_A_SUBSET=0x02,       // do subsetting?
-               EMB_A_T1_TO_CFF=0x04,    // convert Type1 to CFF?
-               EMB_A_CFF_TO_OTF=0x08,   // wrap CFF(from input or T1+CONVERT_CFF) in sfnt? (OTF)
-               EMB_A_OTF_TO_CFF=0x10,   // unwrap CFF
-
-               EMB_A_CLOSE_FONTFILE=0x8000
-               } EMB_ACTIONS;
-
-typedef enum { EMB_C_MUST_SUBSET=0x01,     // (fail, when not possible)
-               EMB_C_EDITABLE_SUBSET=0x02, // (...)
-               EMB_C_NEVER_SUBSET=0x04,    // (...)
-
-               EMB_C_FORCE_MULTIBYTE=0x08, // always use multibyte fonts
-
-               EMB_C_PDF_OT=0x10, // output TTF/OTF (esp. CFF to OTF)
-               EMB_C_KEEP_T1=0x20, // don't convert T1 to CFF
-
-               EMB_C_TAKE_FONTFILE=0x8000 // take ownership of fontfile
-               } EMB_CONSTRAINTS;
-
-typedef struct _EMB_PARAMS {
-  EMB_FORMAT intype;
-  EMB_FORMAT outtype;
-  EMB_DESTINATION dest;
-
-  EMB_ACTIONS plan;
-
-  // font infos
-  FONTFILE *font;
-  EMB_RIGHT_TYPE rights;
-// public:
-  BITSET subset;
-
-} EMB_PARAMS;
-
-EMB_PARAMS *emb_new(FONTFILE *font,EMB_DESTINATION dest,EMB_CONSTRAINTS mode);
-// emb_embedd does only the "binary" part
-int emb_embed(EMB_PARAMS *emb,OUTPUT_FN output,void *context); // returns number of bytes written
-void emb_close(EMB_PARAMS *emb);
-
-// TODO: encoding, TODO: ToUnicode
-static inline void emb_set(EMB_PARAMS *emb,int unicode,unsigned short gid) // {{{
-{
-  if (emb->subset) {
-    if (emb->plan&EMB_A_MULTIBYTE) {
-      bit_set(emb->subset,gid);
-      // ToUnicode.add(gid,unicode);
-    } else {
-      // TODO ... encoding
-    }
-  }
-}
-// }}}
-
-// TODO: encoding?, TODO: non-sfnt
-static inline unsigned short emb_get(EMB_PARAMS *emb,int unicode) // {{{ gid
-{
-  const unsigned short gid=otf_from_unicode(emb->font->sfnt,unicode);
-  emb_set(emb,unicode,gid);
-  return gid;
-}
-// }}}
-
-#include "embed_pdf.h"
-
-#endif
diff --git a/fontembed/embed_pdf.c b/fontembed/embed_pdf.c
deleted file mode 100644
index f3df1af..0000000
--- a/fontembed/embed_pdf.c
+++ /dev/null
@@ -1,597 +0,0 @@
-#include "embed.h"
-#include "embed_pdf.h" // already included fron embed.h ...
-#include "embed_pdf_int.h"
-#include "embed_sfnt_int.h"
-#include <assert.h>
-#include <errno.h>
-#include <string.h>
-#include <time.h>
-#include "frequent.h"
-
-// NOTE: these must be in sync with the EMB_FORMAT enum
-static const char *emb_pdf_font_subtype[][2]={ // {{{ (output_format,multibyte)
-        {"Type1",NULL},
-        {"TrueType","CIDFontType2"},
-        {"Type1","CIDFontType0"},
-        {"Type1","CIDFontType0"},
-        {"Type1",NULL}};
-// }}}
-
-static const char *emb_pdf_fontfile_key[]={ // {{{ (output_format)
-        "FontFile","FontFile2","FontFile3","FontFile3",NULL};
-// }}}
-
-// ... PDF1.6 here
-static const char *emb_pdf_fontfile_subtype[][2]={ // {{{ (output_format,multibyte)
-        {NULL,NULL},
-        {NULL,NULL},
-        {"OpenType","OpenType"},
-        {"Type1C","CIDFontType0C"},
-        {NULL,NULL}};
-// }}}
-
-static inline int emb_multibyte(EMB_PARAMS *emb) // {{{
-{
-  return (emb->plan&EMB_A_MULTIBYTE)?1:0;
-}
-// }}}
-
-static const char *emb_pdf_escape_name(const char *name,int len) // {{{ // - statically allocated buffer
-{
-  assert(name);
-  if (len==-1) {
-    len=strlen(name);
-  }
-  assert(len<=127); // pdf implementation limit
-
-  static char buf[128*3];
-  int iA,iB;
-  const char hex[]="0123456789abcdef";
-
-  for (iA=0,iB=0;iA<len;iA++,iB++) {
-    if ( ((unsigned char)name[iA]<33)||((unsigned char)name[iA]>126)||
-         (strchr("#()<>[]{}/%",name[iA])) ) {
-      buf[iB]='#';
-      buf[++iB]=hex[(name[iA]>>4)&0x0f];
-      buf[++iB]=hex[name[iA]&0xf];
-    } else {
-      buf[iB]=name[iA];
-    }
-  }
-  buf[iB]=0;
-  return buf;
-}
-// }}}
-
-// this is in the font dict
-const char *emb_pdf_get_font_subtype(EMB_PARAMS *emb) // {{{
-{
-  assert(emb);
-  return emb_pdf_font_subtype[emb->outtype][emb_multibyte(emb)];
-}
-// }}}
-
-// in font descriptor
-const char *emb_pdf_get_fontfile_key(EMB_PARAMS *emb) // {{{
-{
-  assert(emb);
-  return emb_pdf_fontfile_key[emb->outtype];
-}
-// }}}
-
-// this is what to put in the font-stream dict
-const char *emb_pdf_get_fontfile_subtype(EMB_PARAMS *emb) // {{{
-{
-  assert(emb);
-  return emb_pdf_fontfile_subtype[emb->outtype][emb_multibyte(emb)];
-}
-// }}}
-
-// {{{ static EMB_PDF_FONTDESCR *emb_pdf_fd_new(fontname,subset_tag,cid_registry,cid_ordering,cid_supplement,panose)
-static EMB_PDF_FONTDESCR *emb_pdf_fd_new(const char *fontname,
-                                  const char *subset_tag,
-                                  const char *cid_registry, // or supplement==-1
-                                  const char *cid_ordering, // or supplement==-1
-                                  int cid_supplement) // -1 for non-cid
-{
-  assert(fontname);
-  EMB_PDF_FONTDESCR *ret;
-
-  int len=sizeof(EMB_PDF_FONTDESCR);
-  if (subset_tag) {
-    assert(strlen(subset_tag)==6);
-    len+=7;
-  }
-  len+=strlen(fontname)+1;
-  if (cid_supplement>=0) { // cid font
-    len+=12; // space for panose
-    assert(cid_registry);
-    assert(cid_ordering);
-    len+=strlen(cid_registry)+1;
-    len+=strlen(cid_ordering)+1;
-  }
-  ret=calloc(1,len);
-  if (!ret) {
-    fprintf(stderr,"Bad alloc: %s\n", strerror(errno));
-    assert(0);
-    return NULL;
-  }
-
-  // now fill the struct
-  len=0;
-  if (cid_supplement>=0) { // free space for panose is at beginning
-    len+=12;
-  }
-  ret->fontname=ret->data+len;
-  len+=strlen(fontname)+1;
-  if (subset_tag) {
-    strncpy(ret->fontname,subset_tag,6);
-    ret->fontname[6]='+';
-    strcpy(ret->fontname+7,fontname);
-    len+=7;
-  } else {
-    strcpy(ret->fontname,fontname);
-  }
-  ret->italicAngle=90;
-  if (cid_supplement>=0) {
-    ret->registry=ret->data+len;
-    strcpy(ret->registry,cid_registry);
-    len+=strlen(cid_registry)+1;
-
-    ret->ordering=ret->data+len;
-    strcpy(ret->ordering,cid_ordering);
-    len+=strlen(cid_registry)+1;
-  }
-  ret->supplement=cid_supplement;
-
-  return ret;
-}
-// }}}
-
-EMB_PDF_FONTDESCR *emb_pdf_fontdescr(EMB_PARAMS *emb) // {{{ -  to be freed by user
-{
-  assert(emb);
-
-  const char *subset_tag=NULL;
-  // {{{ generate pdf subtag
-  static unsigned int rands=0;
-  if (!rands) {
-    rands=time(NULL);
-  }
-
-  char subtag[7];
-  subtag[6]=0;
-  if (emb->plan&EMB_A_SUBSET) {
-    int iA;
-    for (iA=0;iA<6;iA++) {
-      const int x=(int)(26.0*(rand_r(&rands)/(RAND_MAX+1.0)));
-      subtag[iA]='A'+x;
-    }
-    subset_tag=subtag;
-  }
-  // }}}
-
-  const char *fontname=NULL;
-  if ( (emb->intype==EMB_FMT_TTF)||(emb->intype==EMB_FMT_OTF) ) { // TODO? use fontinfo from CFF when outtype==CFT, etc.?
-    assert(emb->font->sfnt);
-    fontname=emb_otf_get_fontname(emb->font->sfnt);
-  } else if (emb->outtype==EMB_FMT_STDFONT) {
-    return NULL;
-  } else {
-    fprintf(stderr,"NOT IMPLEMENTED\n");
-    assert(0);
-    return NULL;
-  }
-
-  EMB_PDF_FONTDESCR *ret;
-  if (emb->plan&EMB_A_MULTIBYTE) { // multibyte
-    ret=emb_pdf_fd_new(fontname,subset_tag,"Adobe","Identity",0); // TODO other /ROS ?
-  } else {
-    ret=emb_pdf_fd_new(fontname,subset_tag,NULL,NULL,-1);
-  }
-  if (!ret) {
-    return NULL;
-  }
-
-  if ( (emb->intype==EMB_FMT_TTF)||(emb->intype==EMB_FMT_OTF) ) {
-    emb_otf_get_pdf_fontdescr(emb->font->sfnt,ret);
-  } else {
-    assert(0);
-  }
-  return ret;
-}
-// }}}
-
-EMB_PDF_FONTWIDTHS *emb_pdf_fw_new(int datasize) // {{{
-{
-  assert(datasize>=0);
-  EMB_PDF_FONTWIDTHS *ret=calloc(1,sizeof(EMB_PDF_FONTWIDTHS)+datasize*sizeof(int));
-  if (!ret) {
-    fprintf(stderr,"Bad alloc: %s\n", strerror(errno));
-    assert(0);
-    return NULL;
-  }
-  return ret;
-}
-// }}}
-
-// if default_width==-1: default_width will be estimated
-EMB_PDF_FONTWIDTHS *emb_pdf_fw_cidwidths(const BITSET glyphs,int len,int default_width,int (*getGlyphWidth)(void *context,int gid),void *context) // {{{ glyphs==NULL -> output all
-{
-  assert(getGlyphWidth);
-
-  FREQUENT *freq=NULL;
-  if (default_width<0) {
-    freq=frequent_new(3);
-  }
-
-  int iA,b,c;
-  int size=0,in_region=0; // current number of elements in after region start
-
-  // first pass: find continuous regions, calculate needed size, estimate dw
-  for (iA=0,b=0,c=1;iA<len;iA++,c<<=1) {
-    if (!c) {
-      b++;
-      c=1;
-    }
-    if ( (!glyphs)||(glyphs[b]&c) ) {
-      if (freq) {
-        const int w=(*getGlyphWidth)(context,iA);
-        frequent_add(freq,w);
-      }
-      if (in_region) {
-        in_region++;
-      } else { // start new region
-        size+=2; // len c
-        in_region=1;
-      }
-    } else { // region end
-      size+=in_region;
-      in_region=0;
-    }
-  }
-  size+=in_region;
-
-  if (freq) {
-    default_width=frequent_get(freq,0);
-    free(freq);
-  }
-  assert(default_width>0);
-
-  // now create the array
-  EMB_PDF_FONTWIDTHS *ret=emb_pdf_fw_new(size+1);
-  if (!ret) {
-    return NULL;
-  }
-  ret->default_width=default_width;
-  ret->warray=ret->data;
-
-  // second pass
-  in_region=0;
-  size=0;
-  int *rlen=0; // position of current len field  (only valid if in_region!=0)
-  for (iA=0,b=0,c=1;iA<len;iA++,c<<=1) {
-    if (!c) {
-      b++;
-      c=1;
-    }
-    if ( (!glyphs)||(glyphs[b]&c) ) {
-      const int w=(*getGlyphWidth)(context,iA);
-      if (in_region>0) { // in array region
-        if ( (w==default_width)&&(ret->warray[size-1]==default_width) ) { // omit this and prev entry
-          size--;
-          *rlen=in_region-1; // !=0, as it does not start with >default_width
-          in_region=0; // end region, immediate restart will take just the same amount of space
-        } else if ( (in_region>=4)&&
-                    (ret->warray[size-1]==w)&&(ret->warray[size-2]==w)&&
-                    (ret->warray[size-3]==w)&&(ret->warray[size-4]==w) ) {
-          // five in a row.  c1 c2 w [l c] is equally short and can be extended (-len c1 w)  [w/ cost of array-region restart]
-          if (in_region==4) { // completely replace
-            size-=6;
-          } else { // first end previous region
-            size-=4;
-            *rlen=in_region-4;
-          }
-          in_region=-4; // start range region instead
-          rlen=&ret->warray[size++];
-          ret->warray[size++]=iA-4;
-          ret->warray[size++]=w;
-        } else { // just add
-          in_region++;
-          ret->warray[size++]=w;
-        }
-        continue;
-      } else if (in_region<0) { // in range region
-        if (ret->warray[size-1]==w) {
-          in_region--; // just add
-          continue;
-        }
-        *rlen=in_region; // end
-        in_region=0;
-      }
-      if (w!=default_width) { // start new array region
-        in_region=1;
-        rlen=&ret->warray[size++];
-        ret->warray[size++]=iA; // c
-        ret->warray[size++]=w;
-      }
-    } else if (in_region) {
-      // TODO? no need to stop range region? } else if (in_region<0) { inregion--; }
-      *rlen=in_region;
-      in_region=0;
-    }
-  }
-  if (in_region) {
-    *rlen=in_region;
-  }
-  ret->warray[size]=0; // terminator
-  return ret;
-}
-// }}}
-
-// TODO: encoding into EMB_PARAMS  (emb_new_enc(...,encoding,len ,to_unicode));
-//   -> will then change interpretation of BITSET...(?really?); can we allow dynamic encoding map generation?
-//   -> encoding has a "len";  len<256
-EMB_PDF_FONTWIDTHS *emb_pdf_fontwidths(EMB_PARAMS *emb) // {{{
-{
-  assert(emb);
-
-  if ( (emb->intype==EMB_FMT_TTF)||(emb->intype==EMB_FMT_OTF) ) {
-    assert(emb->font->sfnt);
-    if (emb->plan&EMB_A_MULTIBYTE) {
-      return emb_otf_get_pdf_cidwidths(emb->font->sfnt,emb->subset);
-    } else {
-      return emb_otf_get_pdf_widths(emb->font->sfnt,/*encoding*/NULL,emb->font->sfnt->numGlyphs,emb->subset); // TODO: encoding
-    }
-  } else {
-    fprintf(stderr,"NOT IMPLEMENTED\n");
-    assert(0);
-    return NULL;
-  }
-}
-// }}}
-
-/*** PDF out stuff ***/
-#include "dynstring.h"
-
-#define NEXT /* {{{ */ \
-  if ( (len<0)||(len>=size) ) { \
-    assert(0); \
-    free(ret); \
-    return NULL; \
-  } \
-  pos+=len; \
-  size-=len; /* }}} */
-
-// TODO? /CIDSet    TODO... /FontFamily /FontStretch /FontWeight (PDF1.5?) would be nice...
-char *emb_pdf_simple_fontdescr(EMB_PARAMS *emb,EMB_PDF_FONTDESCR *fdes,int fontfile_obj_ref) // {{{ - to be freed by user
-{
-  assert(emb);
-  assert(fdes);
-
-  char *ret=NULL,*pos;
-  int len,size;
-
-  size=300;
-  pos=ret=malloc(size);
-  if (!ret) {
-    fprintf(stderr,"Bad alloc: %s\n", strerror(errno));
-    return NULL;
-  }
-
-  len=snprintf(pos,size,
-               "<</Type /FontDescriptor\n"
-               "  /FontName /%s\n" // TODO? handle quoting in struct?
-               "  /Flags %d\n"
-               "  /ItalicAngle %d\n",
-               emb_pdf_escape_name(fdes->fontname,-1),
-               fdes->flags,
-               fdes->italicAngle);
-  NEXT;
-
-  if (1) { // TODO type!=EMB_PDF_TYPE3
-    len=snprintf(pos,size,
-                 "  /FontBBox [%d %d %d %d]\n"
-                 "  /Ascent %d\n"
-                 "  /Descent %d\n"
-                 "  /CapHeight %d\n" // if font has Latin chars
-                 "  /StemV %d\n",
-                 fdes->bbxmin,fdes->bbymin,fdes->bbxmax,fdes->bbymax,
-                 fdes->ascent,
-                 fdes->descent,
-                 fdes->capHeight,
-                 fdes->stemV);
-    NEXT;
-  }
-  if (fdes->xHeight) {
-    len=snprintf(pos,size,"  /XHeight %d\n",fdes->xHeight);
-    NEXT;
-  }
-  if (fdes->avgWidth) {
-    len=snprintf(pos,size,"  /AvgWidth %d\n",fdes->avgWidth);
-    NEXT;
-  }
-  if (fdes->panose) {
-    int iA;
-    len=snprintf(pos,size,"  /Style << /Panose <");
-    NEXT;
-    if (size<30) {
-      assert(0);
-      free(ret);
-      return NULL;
-    }
-    for (iA=0;iA<12;iA++) {
-      snprintf(pos+iA*2,size-iA*2,"%02x",fdes->panose[iA]);
-    }
-    size-=24;
-    pos+=24;
-    len=snprintf(pos,size,"> >>\n");
-    NEXT;
-  }
-  // TODO (for Type0)? CIDSet  -> simply our glyphs BITSET  (ok. endianess?)
-  len=snprintf(pos,size,
-               "  /%s %d 0 R\n"
-               ">>\n",
-               emb_pdf_get_fontfile_key(emb),
-               fontfile_obj_ref);
-  NEXT;
-
-  return ret;
-}
-// }}}
-
-char *emb_pdf_simple_font(EMB_PARAMS *emb,EMB_PDF_FONTDESCR *fdes,EMB_PDF_FONTWIDTHS *fwid,int fontdescr_obj_ref) // {{{ - to be freed by user
-{
-  assert(emb);
-  assert(fdes);
-  assert(fwid);
-
-  int iA,iB;
-  DYN_STRING ret;
-
-  if (dyn_init(&ret,500)==-1) {
-    return NULL;
-  }
-
-  dyn_printf(&ret,"<</Type /Font\n"
-                  "  /Subtype /%s\n"
-                  "  /BaseFont /%s\n"
-                  "  /FontDescriptor %d 0 R\n",
-                  emb_pdf_get_font_subtype(emb),
-                  emb_pdf_escape_name(fdes->fontname,-1),
-                  fontdescr_obj_ref);
-
-  if (emb->plan&EMB_A_MULTIBYTE) { // multibyte
-    assert(fwid->warray);
-    dyn_printf(&ret,"  /CIDSystemInfo <<\n"
-                    "    /Registry (%s)\n"
-                    "    /Ordering (%s)\n"
-                    "    /Supplement %d\n"
-                    "  >>\n"
-                    "  /DW %d\n",
-//                    "  /CIDToGIDMap /Id...\n" // TrueType only, default /Identity  [optional?  which PDF version says what?]
-                    fdes->registry,
-                    fdes->ordering,
-                    fdes->supplement,
-                    fwid->default_width);
-
-    if (fwid->warray[0]) {
-      dyn_printf(&ret,"  /W [");
-      for (iA=0;fwid->warray[iA];) {
-        if (fwid->warray[iA]<0) { // c1 (c1-len) w
-          dyn_printf(&ret," %d %d %d",
-                          fwid->warray[iA+1],
-                          fwid->warray[iA+1]-fwid->warray[iA],
-                          fwid->warray[iA+2]);
-          iA+=3;
-        } else { // c [w ... w]
-          iB=fwid->warray[iA++]; // len
-          dyn_printf(&ret," %d [",fwid->warray[iA++]); // c
-          for (;iB>0;iB--) {
-            dyn_printf(&ret," %d",fwid->warray[iA++]);
-          }
-          dyn_printf(&ret,"]");
-        }
-      }
-      dyn_printf(&ret,"]\n");
-    }
-  } else { // "not std14"
-    assert(fwid->widths);
-    dyn_printf(&ret,
-                    "  /Encoding /MacRomanEncoding\n"  // optional; TODO!!!!!
-//                    "  /ToUnicode ?\n"  // optional
-                    "  /FirstChar %d\n"
-                    "  /LastChar %d\n"
-                    "  /Widths [",
-                    fwid->first,
-                    fwid->last);
-    for (iA=0,iB=fwid->first;iB<=fwid->last;iA++,iB++) {
-      dyn_printf(&ret," %d",fwid->widths[iA]);
-    }
-    dyn_printf(&ret,"]\n");
-  }
-  dyn_printf(&ret,">>\n");
-  if (ret.len==-1) {
-    dyn_free(&ret);
-    assert(0);
-    return NULL;
-  }
-
-  return ret.buf;
-}
-// }}}
-
-// TODO? + encoding as param?  TODO + ToUnicode cmap    => we need another struct EMB_PDF_FONTMAP
-// (TODO?? fontname here without subset-tag [_some_ pdfs out there seem to be that way])
-// TODO? don't do the CidType0 check here?
-// NOTE: this is _additionally_ to emb_pdf_simple_font()!
-char *emb_pdf_simple_cidfont(EMB_PARAMS *emb,const char *fontname,int descendant_obj_ref) // {{{ - to be freed by user
-{
-  assert(emb);
-  assert(fontname);
-
-  char *ret=NULL,*pos;
-  int len,size;
-
-  size=250;
-  pos=ret=malloc(size);
-  if (!ret) {
-    fprintf(stderr,"Bad alloc: %s\n", strerror(errno));
-    return NULL;
-  }
-     // for CFF: one of:
-     // UniGB-UCS2-H, UniCNS-UCS2-H, UniJIS-UCS2-H, UniKS-UCS2-H
-  const char *encoding="Identity-H",*addenc="-";
-  if (emb->outtype==EMB_FMT_TTF) { // !=CidType0
-    addenc="";
-  }
-
-  len=snprintf(pos,size,
-               "<</Type /Font\n"
-               "  /Subtype /Type0\n"
-               "  /BaseFont /%s%s%s\n"
-               "  /Encoding /%s\n"
-               "  /DescendantFonts [%d 0 R]\n",
-//               "  /ToUnicode ?\n" // TODO
-               emb_pdf_escape_name(fontname,-1),
-               addenc,((addenc[0])?encoding:""),
-               encoding,
-               descendant_obj_ref);
-  NEXT;
-
-  len=snprintf(pos,size,">>\n");
-  NEXT;
-
-  return ret;
-}
-// }}}
-
-char *emb_pdf_simple_stdfont(EMB_PARAMS *emb) // {{{ - to be freed by user
-{
-  assert(emb);
-  assert(emb->font->stdname);
-
-  char *ret=NULL,*pos;
-  int len,size;
-
-  size=300;
-  pos=ret=malloc(size);
-  if (!ret) {
-    fprintf(stderr,"Bad alloc: %s\n", strerror(errno));
-    return NULL;
-  }
-
-  len=snprintf(pos,size,
-               "<</Type/Font\n"
-               "  /Subtype /Type1\n"
-               "  /BaseFont /%s\n"
-               ">>\n",
-//               emb_pdf_get_font_subtype(emb),
-               emb->font->stdname);
-  NEXT;
-
-  return ret;
-}
-// }}}
-#undef NEXT
-
diff --git a/fontembed/embed_pdf.h b/fontembed/embed_pdf.h
deleted file mode 100644
index d837e4a..0000000
--- a/fontembed/embed_pdf.h
+++ /dev/null
@@ -1,53 +0,0 @@
-#ifndef EMBED_PDF_H
-#define EMBED_PDF_H
-
-// all the necessary information for pdf font embedding
-typedef struct {
-  char *fontname;
-  unsigned int flags;
-
-  // for the following: 0=not set/invalid
-  int bbxmin,bbymin,bbxmax,bbymax;
-  int italicAngle;    // >=90: not set/invalid
-  int ascent;
-  int descent;
-  int capHeight;
-  int stemV;
-  // optional, default=0:
-  int xHeight;
-  int avgWidth;
-
-  // CID-additions:
-  char *panose; // 12 bytes
-  char *registry,*ordering;
-  int supplement;
-
-  char data[1]; // used for storing e.g. >fontname
-} EMB_PDF_FONTDESCR;
-
-typedef struct {
-  // normal font
-  int first,last;
-  int *widths;
-
-  // multibyte font
-  int default_width;
-  int *warray; // format: (len c w ... w)*   if (len<0) { c1 (c2=c1+(-len)) w } else { c w[len] }, terminated by len==0
-
-  int data[1];
-} EMB_PDF_FONTWIDTHS;
-
-const char *emb_pdf_get_font_subtype(EMB_PARAMS *emb);
-const char *emb_pdf_get_fontfile_key(EMB_PARAMS *emb);
-const char *emb_pdf_get_fontfile_subtype(EMB_PARAMS *emb);
-
-EMB_PDF_FONTDESCR *emb_pdf_fontdescr(EMB_PARAMS *emb);
-EMB_PDF_FONTWIDTHS *emb_pdf_fontwidths(EMB_PARAMS *emb);
-
-/** TODO elsewhere **/
-char *emb_pdf_simple_fontdescr(EMB_PARAMS *emb,EMB_PDF_FONTDESCR *fdes,int fontfile_obj_ref);
-char *emb_pdf_simple_font(EMB_PARAMS *emb,EMB_PDF_FONTDESCR *fdes,EMB_PDF_FONTWIDTHS *fwid,int fontdescr_obj_ref);
-char *emb_pdf_simple_cidfont(EMB_PARAMS *emb,const char *fontname,int descendant_obj_ref);
-char *emb_pdf_simple_stdfont(EMB_PARAMS *emb);
-
-#endif
diff --git a/fontembed/embed_pdf_int.h b/fontembed/embed_pdf_int.h
deleted file mode 100644
index 81d8fac..0000000
--- a/fontembed/embed_pdf_int.h
+++ /dev/null
@@ -1,10 +0,0 @@
-#ifndef EMBED_PDF_INT_H
-#define EMBED_PDF_INT_H
-
-EMB_PDF_FONTWIDTHS *emb_pdf_fw_new(int datasize);
-
-// if default_width==-1: default_width will be estimated
-// glyphs==NULL -> output all
-EMB_PDF_FONTWIDTHS *emb_pdf_fw_cidwidths(const BITSET glyphs,int len,int default_width,int (*getGlyphWidth)(void *context,int gid),void *context);
-
-#endif
diff --git a/fontembed/embed_sfnt.c b/fontembed/embed_sfnt.c
deleted file mode 100644
index 3f1f4dc..0000000
--- a/fontembed/embed_sfnt.c
+++ /dev/null
@@ -1,677 +0,0 @@
-#include "embed.h"
-#include "embed_pdf_int.h"
-#include "embed_sfnt_int.h"
-#include "sfnt.h"
-#include "sfnt_int.h"
-#include <assert.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-EMB_RIGHT_TYPE emb_otf_get_rights(OTF_FILE *otf) // {{{
-{
-  EMB_RIGHT_TYPE ret=EMB_RIGHT_FULL;
-
-  int len;
-  char *os2=otf_get_table(otf,OTF_TAG('O','S','/','2'),&len);
-  if (os2) {
-    const unsigned short os2_version=get_USHORT(os2);
-    // check len
-    assert( (os2_version!=0x0000)||(len==78) );
-    assert( (os2_version!=0x0001)||(len==86) );
-    assert( (os2_version<0x0002)||(os2_version>0x0004)||(len==96) );
-    if (os2_version<=0x0004) {
-      // get rights
-      unsigned short fsType=get_USHORT(os2+8);
-      // from Adobe's Fontpolicies_v9.pdf, pg 13:
-      if (fsType==0x0002) {
-        ret=EMB_RIGHT_NONE;
-      } else {
-        ret=fsType&0x0300; // EMB_RIGHT_BITMAPONLY, EMB_RIGHT_NO_SUBSET
-        if ((fsType&0x000c)==0x0004) {
-          ret|=EMB_RIGHT_READONLY;
-        }
-      }
-    }
-    free(os2);
-  }
-  return ret;
-}
-// }}}
-
-// NOTE: statically allocated buffer
-const char *emb_otf_get_fontname(OTF_FILE *otf) // {{{
-{
-  static char fontname[64];
-
-  int len;
-  const char *fname=otf_get_name(otf,3,1,0x409,6,&len); // microsoft
-  if (fname) {
-    int iA,iB=0;
-    for (iA=0;(iA<63)&&(iA*2<len);iA++) {
-      if ( (fname[2*iA]==0)&&
-           (fname[2*iA+1]>=33)&&(fname[2*iA+1]<=126)&&
-           (!strchr("[](){}<>/%",fname[iA*2+1])) ) {
-        fontname[iB++]=fname[iA*2+1];
-      }
-    }
-    fontname[iB]=0;
-  } else if ((fname=otf_get_name(otf,1,0,0,6,&len))) { // mac
-    int iA,iB=0;
-    for (iA=0;(iA<63)&&(iA<len);iA++) {
-      if ( (fname[iA]>=33)&&(fname[iA]<=126)&&
-           (!strchr("[](){}<>/%",fname[iA])) ) {
-        fontname[iB++]=fname[iA];
-      }
-    }
-    fontname[iB]=0;
-  } else {
-    fontname[0]=0;
-  }
-  if (!*fontname) {
-    // TODO construct a fontname, eg from */*/*/4
-    fprintf(stderr,"WARNING: no fontName\n");
-  }
-  return fontname;
-}
-// }}}
-
-// TODO? monospaced by actual glyph width?
-// TODO? use PCLT table? (esp. CFF, as table dircouraged for glyf fonts)
-void emb_otf_get_pdf_fontdescr(OTF_FILE *otf,EMB_PDF_FONTDESCR *ret) // {{{
-{
-  int len;
-
-//  TODO
-//  ... fill in struct
-  char *head=otf_get_table(otf,OTF_TAG('h','e','a','d'),&len);
-  assert(head); // version is 1.0 from otf_load
-  ret->bbxmin=get_SHORT(head+36)*1000/otf->unitsPerEm;
-  ret->bbymin=get_SHORT(head+38)*1000/otf->unitsPerEm;
-  ret->bbxmax=get_SHORT(head+40)*1000/otf->unitsPerEm;
-  ret->bbymax=get_SHORT(head+42)*1000/otf->unitsPerEm;
-  const int macStyle=get_USHORT(head+44);
-  free(head);
-
-  char *post=otf_get_table(otf,OTF_TAG('p','o','s','t'),&len);
-  assert(post);
-  const unsigned int post_version=get_ULONG(post);
-  // check length
-  assert( (post_version!=0x00010000)||(len==32) );
-  assert( (post_version!=0x00020000)||(len>=34+2*otf->numGlyphs) );
-  assert( (post_version!=0x00025000)||(len==35+otf->numGlyphs) );
-  assert( (post_version!=0x00030000)||(len==32) );
-  assert( (post_version!=0x00020000)||(get_USHORT(post+32)==otf->numGlyphs) ); // v4?
-//  assert( (post_version==0x00030000)==(!!(otf->flags&OTF_F_FMT_CFF)) ); // ghostscript embedding does this..
-  // TODO: v4 (apple) :  uint16 reencoding[numGlyphs]
-  if ( (post_version==0x00010000)||
-       (post_version==0x00020000)||
-       (post_version==0x00025000)||
-       (post_version==0x00030000)||
-       (post_version==0x00040000) ) {
-    ret->italicAngle=get_LONG(post+4)>>16;
-    if (get_ULONG(post+12)>0) { // monospaced
-      ret->flags|=1;
-    }
-  } else {
-    fprintf(stderr,"WARNING: no italicAngle, no monospaced flag\n");
-  }
-  free(post);
-
-  char *os2=otf_get_table(otf,OTF_TAG('O','S','/','2'),&len);
-  if (os2) {
-    const unsigned short os2_version=get_USHORT(os2);
-    // check len
-    assert( (os2_version!=0x0000)||(len==78) );
-    assert( (os2_version!=0x0001)||(len==86) );
-    assert( (os2_version<0x0002)||(os2_version>0x0004)||(len==96) );
-    if (os2_version<=0x0004) {
-
-      // from PDF14Deltas.pdf, pg 113
-      const int weightClass=get_USHORT(os2+4);
-      ret->stemV=50+weightClass*weightClass/(65*65); // TODO, really bad
-//printf("a %d\n",weightClass);
-
-      if (ret->supplement>=0) { // cid
-        ret->panose=ret->data;
-        memcpy(ret->panose,os2+30,12); // sFamilyClass + panose
-      }
-      const unsigned short fsSelection=get_USHORT(os2+62);
-      if (fsSelection&0x01) { // italic
-        ret->flags|=0x0040;
-      }
-      if ( (fsSelection&0x10)&&(weightClass>600) ) { // force bold
-        ret->flags|=0x0400;
-      }
-      const unsigned char family_class=get_USHORT(os2+30)>>8;
-      if (family_class==10) { // script
-        ret->flags|=0x0008;
-      }
-      if (family_class!=8) { // not sans-serif
-        ret->flags|=0x0002;
-      }
-
-      ret->avgWidth=get_SHORT(os2+2)*1000/otf->unitsPerEm;
-      ret->ascent=get_SHORT(os2+68)*1000/otf->unitsPerEm;
-      ret->descent=get_SHORT(os2+70)*1000/otf->unitsPerEm;
-      if (os2_version>=0x0002) {
-        ret->xHeight=get_SHORT(os2+86)*1000/otf->unitsPerEm;
-        ret->capHeight=get_SHORT(os2+88)*1000/otf->unitsPerEm;
-      } // else capHeight fixed later
-    } else {
-      free(os2);
-      os2=NULL;
-    }
-  } else {
-    fprintf(stderr,"WARNING: no OS/2 table\n");
-    // e.g. subsetted font from ghostscript // e.g. CFF
-  }
-  if (os2) {
-    free(os2);
-  } else { // TODO (if(CFF))
-    fprintf(stderr,"WARNING: no ascent/descent, capHeight, stemV, flags\n");
-    if (macStyle&0x01) { // force bold - just do it on bold
-      ret->flags|=0x0400;
-    }
-    if (macStyle&0x02) { // italic
-      ret->flags|=0x0004;
-    }
-    //  ... flags TODO? (Serif, Script, Italic, AllCap,SmallCap, ForceBold)
-  }
-
-// ? maybe get ascent,descent,capHeight,xHeight,stemV directly from cff
-  // Fallbacks
-  if ( (!ret->ascent)||(!ret->descent) ) {
-    char *hhea=otf_get_table(otf,OTF_TAG('h','h','e','a'),&len);
-    if (hhea) {
-      ret->ascent=get_SHORT(hhea+4)*1000/otf->unitsPerEm;
-      ret->descent=get_SHORT(hhea+6)*1000/otf->unitsPerEm;
-    }
-    free(hhea);
-  }
-  if (!ret->stemV) { // TODO? use name
-    const unsigned short d_gid=otf_from_unicode(otf,'.');
-    if (d_gid) { // stemV=bbox['.'].width;
-      len=otf_get_glyph(otf,d_gid);
-      assert(len>=10);
-      ret->stemV=(get_SHORT(otf->gly+6)-get_SHORT(otf->gly+2))*1000/otf->unitsPerEm;
-    } else {
-      if (macStyle&1) { // bold
-        ret->stemV=165;
-      } else {
-        ret->stemV=109; // TODO... unserious values...
-      }
-    }
-  }
-  if (!ret->capHeight) { // TODO? only reqd. for fonts with latin...
-    ret->capHeight=ret->ascent;
-    // TODO: OTF spec says:  use metrics of 'H' (0 if not available)
-  }
-  if (0) { // TODO? uses only adobe latin standard? ?? e.g. Type1
-    ret->flags|=0x0020;
-  } else {
-    ret->flags|=0x0004;
-  }
-  // TODO SmallCap by font name(?)
-
-// TODO ;   ? cid ?
-}
-// }}}
-
-// TODO: split generic part and otf part
-// TODO: FIXME: gid vs. char   ... NOTE: not called in multi_byte mode...
-// Adobe does: char --MacRoman/WinAnsi--> name --AGL--> unicode --cmap(3,1) --> gid   only avoidable by setting 'symbol'+custom(1,0)/(3,0)
-// HINT: caller sets len == otf->numGlyphs   (only when not using encoding...)
-EMB_PDF_FONTWIDTHS *emb_otf_get_pdf_widths(OTF_FILE *otf,const unsigned short *encoding,int len,const BITSET glyphs) // {{{ glyphs==NULL -> all from 0 to len
-{
-  assert(otf);
-
-  int first=len,last=0;
-  int iA;
-
-  if (glyphs) {
-    for (iA=0;iA<len;iA++) { // iA is a "gid" when in multi_byte mode...
-      const int gid=(encoding)?encoding[iA]:otf_from_unicode(otf,iA); // TODO
-      if (bit_check(glyphs,gid)) {
-        if (first>iA) { // first is a character index
-          first=iA;
-        }
-        if (last<iA) {
-          last=iA;
-        }
-      }
-    }
-  } else {
-    first=0;
-    last=len;
-  }
-  if (last<first) {
-    // empty
-    fprintf(stderr,"WARNING: empty embedding range\n");
-    return NULL;
-  }
-
-  // ensure hmtx is there
-  if (!otf->hmtx) {
-    if (otf_load_more(otf)!=0) {
-      assert(0);
-      return NULL;
-    }
-  }
-
-  // now create the array
-  EMB_PDF_FONTWIDTHS *ret=emb_pdf_fw_new(last-first+1);
-  if (!ret) {
-    return NULL;
-  }
-  ret->first=first;
-  ret->last=last;
-  ret->widths=ret->data;
-  for (iA=0;first<=last;iA++,first++) {
-    const int gid=(encoding)?encoding[first]:otf_from_unicode(otf,first); // TODO
-    if (gid>=otf->numGlyphs) {
-      fprintf(stderr,"Bad glyphid\n");
-      assert(0);
-      free(ret);
-      return NULL;
-    }
-    if ( (!glyphs)||(bit_check(glyphs,gid)) ) {
-      ret->widths[iA]=get_width_fast(otf,gid)*1000/otf->unitsPerEm;
-    } // else 0 from calloc
-  }
-
-  return ret;
-}
-// }}}
-
-// otf->hmtx must be there
-static int emb_otf_pdf_glyphwidth(void *context,int gid) // {{{
-{
-  OTF_FILE *otf=(OTF_FILE *)context;
-  return get_width_fast(otf,gid)*1000/otf->unitsPerEm;
-}
-// }}}
-
-EMB_PDF_FONTWIDTHS *emb_otf_get_pdf_cidwidths(OTF_FILE *otf,const BITSET glyphs) // {{{ // glyphs==NULL -> output all
-{
-  assert(otf);
-
-  // ensure hmtx is there
-  if (!otf->hmtx) {
-    if (otf_load_more(otf)!=0) {
-      assert(0);
-      return NULL;
-    }
-  }
-//  int dw=emb_otf_pdf_glyphwidth(otf,0); // e.g.
-  int dw=-1; // let them estimate
-
-  return emb_pdf_fw_cidwidths(glyphs,otf->numGlyphs,dw,emb_otf_pdf_glyphwidth,otf);
-}
-// }}}
-
-/*** PS stuff ***/
-
-#include "dynstring.h"
-
-const char *aglfn13(unsigned short uni); // aglfn13.c
-#include "macroman.h"
-
-// TODO? optimize pascal string skipping? (create index)
-// NOTE: might return a statically allocated string
-static const char *emb_otf_get_post_name(const char *post,unsigned short gid) // {{{
-{
-  if (!post) {
-    return NULL;
-  }
-  const unsigned int post_version=get_ULONG(post);
-  if (post_version==0x00010000) { // font has only 258 chars... font cannot be used on windows
-    if (gid<sizeof(macRoman)/sizeof(macRoman[0])) {
-      return macRoman[gid];
-    }
-  } else if (post_version==0x00020000) {
-    const unsigned short num_glyphs=get_USHORT(post+32);
-    // assert(num_glyphs==otf->numGlyphs);
-    if (gid<num_glyphs) {
-      unsigned short idx=get_USHORT(post+34+2*gid);
-      if (idx<258) {
-        if (idx<sizeof(macRoman)/sizeof(macRoman[0])) {
-          return macRoman[idx];
-        }
-      } else if (idx<32768) {
-        const unsigned char *pos=(unsigned char *)post+34+2*num_glyphs;
-        for (idx-=258;idx>0;idx--) { // this sucks...
-          pos+=*pos+1; // skip this string
-        }
-        // convert pascal string to asciiz
-        static char ret[256];
-        const unsigned char len=*pos;
-        memcpy(ret,(const char *)pos+1,len);
-        ret[len]=0;
-        return ret;
-      }
-    }
-  } else if (post_version==0x00025000) { // similiar to 0x00010000, deprecated
-    const unsigned short num_glyphs=get_USHORT(post+32);
-    if (gid<num_glyphs) {
-      const unsigned short idx=post[34+gid]+gid; // post is signed char *
-      if (idx<sizeof(macRoman)/sizeof(macRoman[0])) {
-        return macRoman[idx];
-      }
-    }
-  } else if (post_version==0x00030000) {
-    // no glyph names, sorry
-//  } else if (post_version==0x00040000) { // apple AAT ?!
-  }
-  return NULL;
-}
-// }}}
-
-// TODO!? to_unicode should be able to represent more than one unicode character?
-// NOTE: statically allocated string
-static const char *get_glyphname(const char *post,unsigned short *to_unicode,int charcode,unsigned short gid) // {{{ if charcode==0 -> force gid to be used
-{
-  if (gid==0) {
-    return ".notdef";
-  }
-  const char *postName=emb_otf_get_post_name(post,gid);
-  if (postName) {
-    return postName;
-  }
-  static char ret[255];
-  if (charcode) {
-    if (to_unicode) { // i.e. encoding was there
-      charcode=to_unicode[charcode];
-      // TODO!? to_unicode should be able to represent more than one unicode character?
-      // TODO for additional credit: for ligatures, etc  create /f_f /uni12341234  or the like
-    }
-    const char *aglname=aglfn13(charcode); // TODO? special case ZapfDingbats?
-    if (aglname) {
-      return aglname;
-    }
-    snprintf(ret,250,"uni%04X",charcode); // allows extraction
-  } else {
-    snprintf(ret,250,"c%d",gid);  // last resort: only by gid
-  }
-  return ret;
-}
-// }}}
-
-struct OUTFILTER_PS {
-  OUTPUT_FN out;
-  void *ctx;
-  int len;
-};
-
-// TODO: for maximum compatiblity (PS<2013 interpreter)  split only on table or glyph boundary (needs lookup in loca table!)
-// Note: table boundaries are at each call!
-static void outfilter_ascii_ps(const char *buf,int len,void *context)  // {{{
-{
-  struct OUTFILTER_PS *of=context;
-  OUTPUT_FN out=of->out;
-  int iA;
-
-  (*out)("<",1,of->ctx);
-  of->len++;
-
-  const char *last=buf;
-  char tmp[256];
-  while (len>0) {
-    for (iA=0;(iA<76)&&(len>0);iA+=2,len--) {
-      const unsigned char ch=buf[iA>>1];
-      tmp[iA]="0123456789abcdef"[ch>>4];
-      tmp[iA+1]="0123456789abcdef"[ch&0x0f];
-    }
-    buf+=iA>>1;
-    if (buf<last+64000) {
-      if (len>0) {
-        tmp[iA++]='\n';
-      }
-      (*out)(tmp,iA,of->ctx);
-    } else {
-      last=buf;
-      strcpy(tmp+iA,"00>\n<");
-      iA+=5;
-      (*out)(tmp,iA,of->ctx);
-    }
-    of->len+=iA;
-  }
-
-  (*out)("00>\n",4,of->ctx);
-  of->len+=4;
-}
-// }}}
-
-static void outfilter_binary_ps(const char *buf,int len,void *context)  // {{{
-{
-  struct OUTFILTER_PS *of=context;
-  OUTPUT_FN out=of->out;
-
-  char tmp[100];
-  while (len>0) {
-    const int maxlen=(len>64000)?64000:len;
-    const int l=sprintf(tmp,"%d RD ",maxlen);
-    (*out)(tmp,l,of->ctx);
-    of->len+=l;
-
-    (*out)(buf,maxlen,of->ctx);
-    (*out)("\n",1,of->ctx);
-    of->len+=maxlen+1;
-    len-=maxlen;
-    buf+=maxlen;
-  }
-}
-// }}}
-
-/*
-  encoding:  character-code -> glyph id  ["required", NULL: identity, i.e. from_unicode()] // TODO: respect subsetting
-  to_unicode:  character-code -> unicode  [NULL: no char names]  // kind-of "reverse" of encoding (to_unicode does not make sense without >encoding)
-
-Status:
-  - we need a 0..255 encoding to be used in the PS file
-  - we want to allow the use of encoding[];  this should map from your desired PS-stream output character (0..255) directly to the gid
-  - if encoding[] is not used, MacRoman/WinAnsi/latin1 is expected (easiest: latin1, as it is a subset of unicode)
-    i.e. your want to output latin1 to the PS-stream
-  - len is the length of >encoding, or the "last used latin1 character"
-  - oh. in multibyte-mode no >encoding probably should mean identity(gid->gid) not (latin1->gid)
-  - non-multibyte PDF -> only 255 chars  ... not recommended (we can't just map to gids, but only to names, which acro will then cmap(3,1) to gids)
-
-  => problem with subsetting BITSET (keyed by gid); we want BITSET keyed by 0..255 (via encoding)
-
-  // TODO: a) multi font encoding
-  // TODO: b) cid/big font encoding (PS>=2015) [/CIDFontType 2]     : CMap does Charcode->CID, /CIDMap does CID->GID [e.g. Identity/delta value]
-  //          (also needed [or a)] for loca>64000 if split, etc)      e.g. /CIDMap 0  [requires PS>=3011?]
-  //          [Danger: do not split composites]
-  // TODO? incremental download [/GlyphDirectory array or dict]     : /GlyphDirectory does GID-><glyf entry> mapping
-  //       need 'fake' gdir table (size,offset=0) in sfnt; loca, glyf can be ommited; hmtx can be omitted for PS>=3011 [/MetricsCount 2]
-  //       idea is to fill initial null entries in the array/dict   [Beware of save/restore!]
-  // NOTE: even when subsetting the font has to come first in the PS file
-
-
-... special information: when multi-byte PDF encoding is used <gid> is output.
-    therefore /Encoding /Identity-H + /CIDSystemInfo Adobe-Identity-0 will yield 1-1 mapping for font.
-    problem is that text is not selectable. therefore there is the /ToUnicode CMap option
-*/
-int emb_otf_ps(OTF_FILE *otf,unsigned short *encoding,int len,unsigned short *to_unicode,OUTPUT_FN output,void *context) // {{{
-{
-  const int binary=0; // binary format? // TODO
-  if (len>256) {
-    fprintf(stderr,"Encoding too big(%d) for Type42\n",len);
-    return -1;
-  }
-  if (len<1) {
-    fprintf(stderr,"At least .notdef required in Type42\n");
-    return -1;
-  }
-  if (!encoding) {
-    to_unicode=NULL; // does not make sense
-  }
-  int iA,ret=0;
-
-  DYN_STRING ds;
-  if (dyn_init(&ds,1024)==-1) {
-    return -1;
-  }
-
-  int rlen=0;
-  char *head=otf_get_table(otf,OTF_TAG('h','e','a','d'),&rlen);
-  if (!head) {
-    free(ds.buf);
-    return -1;
-  }
-  dyn_printf(&ds,"%%!PS-TrueTypeFont-%d-%d\n",
-                 otf->version,get_ULONG(head+4));
-  const int bbxmin=get_SHORT(head+36)*1000/otf->unitsPerEm,
-            bbymin=get_SHORT(head+38)*1000/otf->unitsPerEm,
-            bbxmax=get_SHORT(head+40)*1000/otf->unitsPerEm,
-            bbymax=get_SHORT(head+42)*1000/otf->unitsPerEm;
-  free(head);
-
-  char *post=otf_get_table(otf,OTF_TAG('p','o','s','t'),&rlen);
-  if ( (!post)&&(rlen!=-1) ) { // other error than "not found"
-    free(ds.buf);
-    return -1;
-  }
-  if (post) {
-    const unsigned int minMem=get_ULONG(post+16),maxMem=get_ULONG(post+20);
-    if (minMem) {
-      dyn_printf(&ds,"%%VMusage: %d %d\n",minMem,maxMem);
-    }
-  }
-
-  // don't forget the coordinate scaling...
-  dyn_printf(&ds,"11 dict begin\n"
-                 "/FontName /%s def\n"
-                 "/FontType 42 def\n"
-                 "/FontMatrix [1 0 0 1 0 0] def\n"
-                 "/FontBBox [%f %f %f %f] def\n"
-                 "/PaintType 0 def\n",
-//                 "/XUID [42 16#%X 16#%X 16#%X 16#%X] def\n"  // TODO?!? (md5 of font data)  (16# means base16)
-                 emb_otf_get_fontname(otf),
-                 bbxmin/1000.0,bbymin/1000.0,bbxmax/1000.0,bbymax/1000.0);
-  if (post) {
-    dyn_printf(&ds,"/FontInfo 4 dict dup begin\n"
-// TODO? [even non-post]: /version|/Notice|/Copyright|/FullName|/FamilyName|/Weight  () readonly def\n   from name table: 5 7 0 4 1 2
-// using: otf_get_name(otf,3,1,0x409,?,&len) / otf_get_name(otf,1,0,0,?,&len)   + encoding
-                   "  /ItalicAngle %d def\n"
-                   "  /isFixedPitch %s def\n"
-                   "  /UnderlinePosition %f def\n"
-                   "  /UnderlineThickness %f def\n"
-                   "end readonly def\n",
-                   get_LONG(post+4)>>16,
-                   (get_ULONG(post+12)?"true":"false"),
-                   (get_SHORT(post+8)-get_SHORT(post+10)/2)/(float)otf->unitsPerEm,
-                   get_SHORT(post+10)/(float)otf->unitsPerEm);
-  }
-  dyn_printf(&ds,"/Encoding 256 array\n"
-                 "0 1 255 { 1 index exch /.notdef put } for\n");
-  for (iA=0;iA<len;iA++) { // encoding data: 0...255 -> /glyphname
-    const int gid=(encoding)?encoding[iA]:otf_from_unicode(otf,iA);
-    if (gid!=0) {
-      dyn_printf(&ds,"dup %d /%s put\n",
-                     iA,get_glyphname(post,to_unicode,iA,gid));
-    }
-  }
-  dyn_printf(&ds,"readonly def\n");
-
-  if (binary) {
-    dyn_printf(&ds,"/RD { string currentfile exch readstring pop } executeonly def\n");
-  }
-  dyn_printf(&ds,"/sfnts[\n");
-
-  if (ds.len<0) {
-    free(post);
-    free(ds.buf);
-    return -1;
-  }
-  (*output)(ds.buf,ds.len,context);
-  ret+=ds.len;
-  ds.len=0;
-
-// TODO: only tables as in otf_subset
-// TODO:  somehow communicate table boundaries:
-  //   otf_action_copy  does exactly one output call (per table)
-  //   only otf_action_replace might do two (padding)
-  // {{{ copy tables verbatim (does not affect ds .len)
-  struct _OTF_WRITE *otfree=NULL;
-#if 0
-  struct _OTF_WRITE *otw;
-  otwfree=otw=malloc(sizeof(struct _OTF_WRITE)*otf->numTables);
-  if (!otw) {
-    fprintf(stderr,"Bad alloc: %m\n");
-    free(post);
-    free(ds.buf);
-    return -1;
-  }
-  // just copy everything
-  for (iA=0;iA<otf->numTables;iA++) {
-    otw[iA].tag=otf->tables[iA].tag;
-    otw[iA].action=otf_action_copy;
-    otw[iA].param=otf;
-    otw[iA].length=iA;
-  }
-  int numTables=otf->numTables;
-#else
-  struct _OTF_WRITE otw[]={ // sorted
-      {OTF_TAG('c','m','a','p'),otf_action_copy,otf,},
-      {OTF_TAG('c','v','t',' '),otf_action_copy,otf,},
-      {OTF_TAG('f','p','g','m'),otf_action_copy,otf,},
-      {OTF_TAG('g','l','y','f'),otf_action_copy,otf,},
-      {OTF_TAG('h','e','a','d'),otf_action_copy,otf,},
-      {OTF_TAG('h','h','e','a'),otf_action_copy,otf,},
-      {OTF_TAG('h','m','t','x'),otf_action_copy,otf,},
-      {OTF_TAG('l','o','c','a'),otf_action_copy,otf,},
-      {OTF_TAG('m','a','x','p'),otf_action_copy,otf,},
-      {OTF_TAG('n','a','m','e'),otf_action_copy,otf,},
-      {OTF_TAG('p','r','e','p'),otf_action_copy,otf,},
-      // vhea vmtx (never used in PDF, but possible in PS>=3011)
-      {0,0,0,0}};
-  int numTables=otf_intersect_tables(otf,otw);
-#endif
-
-  struct OUTFILTER_PS of;
-  of.out=output;
-  of.ctx=context;
-  of.len=0;
-  if (binary) {
-    iA=otf_write_sfnt(otw,otf->version,numTables,outfilter_binary_ps,&of);
-  } else {
-    iA=otf_write_sfnt(otw,otf->version,numTables,outfilter_ascii_ps,&of);
-  }
-  free(otfree);
-  if (iA==-1) {
-    free(post);
-    free(ds.buf);
-    return -1;
-  }
-  ret+=of.len;
-  // }}} done copying
-
-  dyn_printf(&ds,"] def\n");
-
-  dyn_printf(&ds,"/CharStrings %d dict dup begin\n"
-                 "/.notdef 0 def\n",len);
-  for (iA=0;iA<len;iA++) { // charstrings data: /glyphname -> gid
-    const int gid=(encoding)?encoding[iA]:otf_from_unicode(otf,iA);
-    if (gid) {
-      dyn_printf(&ds,"/%s %d def\n",get_glyphname(post,to_unicode,iA,gid),gid);
-    }
-    // (respecting subsetting...)
-  }
-  dyn_printf(&ds,"end readonly def\n");
-  dyn_printf(&ds,"FontName currentdict end definefont pop\n");
-  free(post);
-
-  if (ds.len<0) {
-    free(ds.buf);
-    return -1;
-  }
-  (*output)(ds.buf,ds.len,context);
-  ret+=ds.len;
-  ds.len=0;
-
-  free(ds.buf);
-  return ret;
-}
-// }}}
-
diff --git a/fontembed/embed_sfnt_int.h b/fontembed/embed_sfnt_int.h
deleted file mode 100644
index 9edc3e5..0000000
--- a/fontembed/embed_sfnt_int.h
+++ /dev/null
@@ -1,18 +0,0 @@
-#ifndef EMBED_SFNT_INT_H
-#define EMBED_SFNT_INT_H
-
-#include "sfnt.h"
-#include "embed_pdf.h"
-
-EMB_RIGHT_TYPE emb_otf_get_rights(OTF_FILE *otf);
-
-// NOTE: statically allocated buffer
-const char *emb_otf_get_fontname(OTF_FILE *otf);
-
-void emb_otf_get_pdf_fontdescr(OTF_FILE *otf,EMB_PDF_FONTDESCR *ret);
-EMB_PDF_FONTWIDTHS *emb_otf_get_pdf_widths(OTF_FILE *otf,const unsigned short *encoding,int len,const BITSET glyphs);
-EMB_PDF_FONTWIDTHS *emb_otf_get_pdf_cidwidths(OTF_FILE *otf,const BITSET glyph);
-
-int emb_otf_ps(OTF_FILE *otf,unsigned short *encoding,int len,unsigned short *to_unicode,OUTPUT_FN output,void *context);
-
-#endif
diff --git a/fontembed/fontfile.c b/fontembed/fontfile.c
deleted file mode 100644
index 703126c..0000000
--- a/fontembed/fontfile.c
+++ /dev/null
@@ -1,50 +0,0 @@
-#include "fontfile.h"
-#include <assert.h>
-#include <string.h>
-
-//FONTFILE *fontfile_open(const char *filename);
-
-/*
-FONTFILE *fontfile_open(const char *filename)
-{
-  // TODO? check magic
-  if (...) {
-  }
-}
-*/
-
-FONTFILE *fontfile_open_sfnt(OTF_FILE *otf) // {{{
-{
-  if (!otf) {
-    assert(0);
-    return NULL;
-  }
-  FONTFILE *ret=calloc(1,sizeof(FONTFILE));
-
-  ret->sfnt=otf;
-
-  return ret;
-}
-// }}}
-
-FONTFILE *fontfile_open_std(const char *name) // {{{
-{
-  assert(name);
-  FONTFILE *ret=calloc(1,sizeof(FONTFILE));
-
-  ret->stdname=strdup(name);
-
-  return ret;
-}
-// }}}
-
-void fontfile_close(FONTFILE *ff) // {{{
-{
-  if (ff) {
-    otf_close(ff->sfnt);
-    // ??? cff_close(ff->cff);
-    free(ff->stdname);
-    free(ff);
-  }
-}
-// }}}
diff --git a/fontembed/fontfile.h b/fontembed/fontfile.h
deleted file mode 100644
index 7e7b108..0000000
--- a/fontembed/fontfile.h
+++ /dev/null
@@ -1,22 +0,0 @@
-#ifndef _FONTFILE_H
-#define _FONTFILE_H
-
-#include "sfnt.h"
-
-struct _FONTFILE {
-  OTF_FILE *sfnt;
-  // ??? *cff;
-  char *stdname;
-  union {
-    int fobj;
-    void *user;
-  };
-};
-
-typedef struct _FONTFILE FONTFILE;
-
-FONTFILE *fontfile_open_sfnt(OTF_FILE *otf);
-FONTFILE *fontfile_open_std(const char *name);
-void fontfile_close(FONTFILE *ff);
-
-#endif
diff --git a/fontembed/frequent.c b/fontembed/frequent.c
deleted file mode 100644
index eb8edbd..0000000
--- a/fontembed/frequent.c
+++ /dev/null
@@ -1,83 +0,0 @@
-#include "frequent.h"
-#include <assert.h>
-#include <stdlib.h>
-
-// misra-gries
-// http://www2.research.att.com/~marioh/papers/vldb08-2.pdf
-
-struct _FREQUENT {
-  int size,czero;
-  char sorted;
-  struct { intptr_t key; int count,zero; } pair[];
-};
-
-// size is the precision/return size: in sequence with n _add(), it will find at most >size elements with occurence > n/(size+1) times
-FREQUENT *frequent_new(int size) // {{{ - just free() it
-{
-  assert(size>0);
-  FREQUENT *ret=malloc(sizeof(ret[0])+sizeof(ret->pair[0])*size);
-  if (!ret) {
-    return NULL;
-  }
-  ret->size=size;
-  ret->czero=0;
-  ret->sorted=1;
-  int iA;
-  for (iA=0;iA<size;iA++) {
-    ret->pair[iA].key=INTPTR_MIN;
-    ret->pair[iA].count=0;
-    ret->pair[iA].zero=0;
-  }
-
-  return ret;
-}
-// }}}
-
-void frequent_add(FREQUENT *freq,intptr_t key) // {{{
-{
-  assert(freq);
-  int iA,zero=-1;
-  for (iA=freq->size-1;iA>=0;iA--) {
-    if (freq->pair[iA].key==key) {
-      freq->pair[iA].count++;
-      freq->sorted=0;
-      return;
-    } else if (freq->pair[iA].count==freq->czero) {
-      zero=iA;
-    }
-  }
-  if (zero>=0) { // insert into set
-    freq->pair[zero].key=key;
-    freq->pair[zero].count++; // i.e. czero+1
-    freq->pair[zero].zero=freq->czero;
-    // if it was sorted, the free entries are at the end. zero points to the first free entry, because of the loop direction
-  } else { // out-of-set count
-    freq->czero++;
-  }
-}
-// }}}
-
-static int frequent_cmp(const void *a,const void *b) // {{{
-{
-  const typeof(((FREQUENT *)0)->pair[0]) *aa=a;
-  const typeof(((FREQUENT *)0)->pair[0]) *bb=b;
-  return (bb->count-bb->zero)-(aa->count-aa->zero);
-}
-// }}}
-
-// true frequency is somewhere between (count-zero) and count
-intptr_t frequent_get(FREQUENT *freq,int pos) // {{{
-{
-  assert(freq);
-  if (!freq->sorted) {
-    // sort by (count-zero)
-    qsort(freq->pair,freq->size,sizeof(freq->pair[0]),frequent_cmp);
-    freq->sorted=1;
-  }
-  if ( (pos<0)||(pos>=freq->size) ) {
-    return INTPTR_MIN;
-  }
-  return freq->pair[pos].key;
-}
-// }}}
-
diff --git a/fontembed/frequent.h b/fontembed/frequent.h
deleted file mode 100644
index 838adcc..0000000
--- a/fontembed/frequent.h
+++ /dev/null
@@ -1,17 +0,0 @@
-#ifndef _FREQUENT_H
-#define _FREQUENT_H
-
-#include <stdint.h>
-
-typedef struct _FREQUENT FREQUENT;
-
-// size is the precision/return size: it will find at most >size elements (i.e. all, if there) with frequency > 1/(size+1)
-FREQUENT *frequent_new(int size); // - just free() it
-
-void frequent_add(FREQUENT *freq,intptr_t key);
-
-// might return INTPTR_MIN, if not populated
-// this is only an approximation!
-intptr_t frequent_get(FREQUENT *freq,int pos); // 0 is "most frequent"
-
-#endif
diff --git a/fontembed/iofn.h b/fontembed/iofn.h
deleted file mode 100644
index 737d2e0..0000000
--- a/fontembed/iofn.h
+++ /dev/null
@@ -1,6 +0,0 @@
-#ifndef _IOFN_H
-#define _IOFN_H
-
-typedef void (*OUTPUT_FN)(const char *buf,int len,void *context);
-
-#endif
diff --git a/fontembed/macroman.h b/fontembed/macroman.h
deleted file mode 100644
index 9822abd..0000000
--- a/fontembed/macroman.h
+++ /dev/null
@@ -1,32 +0,0 @@
-// data header only. for inclusion in only one file
-#ifdef WITH_MACROMAN
-static const char *macRoman[]=
-  {".notdef",".null","nonmarkingreturn","space","exclam", "quotedbl","numbersign","dollar","percent","ampersand",
-   "quotesingle","parenleft","parenright","asterisk","plus", "comma","hyphen","period","slash","zero",
-   "one","two","three","four","five", "six","seven","eight","nine","colon",
-   "semicolon","less","equal","greater","question", "at","A","B","C","D",
-   "E","F","G","H","I", "J","K","L","M","N",
-   "O","P","Q","R","S", "T","U","V","W","X",
-   "Y","Z","bracketleft","backslash","bracketright", "asciicircum","underscore","grave","a","b",
-   "c","d","e","f","g", "h","i","j","k","l",
-   "m","n","o","p","q", "r","s","t","u","v",
-   "w","x","y","z","braceleft", "bar","braceright","asciitilde","Adieresis","Aring",
-   "Ccedilla","Eacute","Ntilde","Odieresis","Udieresis", "aacute","agrave","acircumflex","adieresis","atilde",
-   "aring","ccedilla","eacute","egrave","ecircumflex", "edieresis","iacute","igrave","icircumflex","idieresis",
-   "ntilde","oacute","ograve","ocircumflex","odieresis", "otilde","uacute","ugrave","ucircumflex","udieresis",
-   "dagger","degree","cent","sterling","section", "bullet","paragraph","germandbls","registered","copyright",
-   "trademark","acute","dieresis","notequal","AE", "Oslash","infinity","plusminus","lessequal","greaterequal",
-   "yen","mu","partialdiff","summation","product", "pi","integral","ordfeminine","ordmasculine","Omega",
-   "ae","oslash","questiondown","exclamdown","logicalnot", "radical","florin","approxequal","Delta","guillemotleft",
-   "guillemotright","ellipsis","nonbreakingspace","Agrave","Atilde", "Otilde","OE","oe","endash","emdash",
-   "quotedblleft","quotedblright","quoteleft","quoteright","divide", "lozenge","ydieresis","Ydieresis","fraction","currency",
-   "guilsinglleft","guilsinglright","fi","fl","daggerdbl", "periodcentered","quotesinglbase","quotedblbase","perthousand","Acircumflex",
-   "Ecircumflex","Aacute","Edieresis","Egrave","Iacute", "Icircumflex","Idieresis","Igrave","Oacute","Ocircumflex",
-   "apple","Ograve","Uacute","Ucircumflex","Ugrave", "dotlessi","circumflex","tilde","macron","breve",
-   "dotaccent","ring","cedilla","hungarumlaut","ogonek", "caron","Lslash","lslash","Scaron","scaron",
-   "Zcaron","zcaron","brokenbar","Eth","eth", "Yacute","yacute","Thorn","thorn","minus","multiply",
-   "onesuperior","twosuperior","threesuperior","onehalf","onequarter", "threequarters","franc","Gbreve","gbreve","Idotaccent",
-   "Scedilla","scedilla","Cacute","cacute","Ccaron", "ccaron","dcroat"};
-#else
-static const char *macRoman[]={0};
-#endif
diff --git a/fontembed/main.c b/fontembed/main.c
deleted file mode 100644
index af77004..0000000
--- a/fontembed/main.c
+++ /dev/null
@@ -1,170 +0,0 @@
-#include "config.h"
-#include "sfnt.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <assert.h>
-#include <errno.h>
-
-#include "embed.h"
-
-#if 0
-enum { TTF_OTF, TYPE1 } inputFile;
-if (TTF_OTF) {
-  assert(!TTC);
-  if (CFF/OTF) {
-    // or EMB_PDF_FONTFILE3_OTF [unstripped]
-    if (CIDfont) {
-      asset(multiBYTE);
-      strip_sfnt() // "CIDFontType0"  EMB_PDF_FONTFILE3_CID0C
-    } else {
-      ... strip_sfnt();
-    }
-  } else {
-    ...
-  }
-} else if (TYPE1) {
-  assert(!MMType1);
-  assert(!OCF);
-  assert(!WrappedCID_CFF);
-  ... convert_to_cff()
-}
-// not supported: MMType1 Type3
-#endif
-
-#include <string.h>
-
-static void example_outfn(const char *buf,int len,void *context) // {{{
-{
-  FILE *f=(FILE *)context;
-  if (fwrite(buf,1,len,f)!=len) {
-    perror("Short write");
-    assert(0);
-    return;
-  }
-}
-// }}}
-
-void example_write_fontdescr(OTF_FILE *otf,const char *outfile) // {{{
-{
-  FONTFILE *ff=fontfile_open_sfnt(otf);
-  EMB_PARAMS *emb=emb_new(ff,
-                          EMB_DEST_PDF16,
-//                          EMB_C_KEEP_T1
-                          EMB_C_FORCE_MULTIBYTE
-
-                          );
-  EMB_PDF_FONTDESCR *fdes=emb_pdf_fontdescr(emb);
-  assert(fdes);
-
-  emb_get(emb,'a');
-  emb_get(emb,0x400);
-
-  EMB_PDF_FONTWIDTHS *fwid=emb_pdf_fontwidths(emb);
-  assert(fwid);
-
-  printf("0 0 obj\n");
-  char *res=emb_pdf_simple_fontdescr(emb,fdes,1);
-  assert(res);
-  fputs(res,stdout);
-  free(res);
-  printf("endobj\n");
-
-  printf("1 0 obj\n"
-         "<<\n");
-  if (emb_pdf_get_fontfile_subtype(emb)) {
-    printf("  /Subtype /%s\n",
-           emb_pdf_get_fontfile_subtype(emb));
-  }
-  if (emb->outtype==EMB_FMT_T1) {
-    printf("  /Length1 ?\n"
-           "  /Length2 ?\n"
-           "  /Length3 ?\n");
-  } else if (emb->outtype==EMB_FMT_TTF) {
-    printf("  /Length1 2 0 R\n");
-  }
-  printf("  /Length 2 0 R\n" // maybe compress it...
-         ">>\n"
-         "stream\n");
-  int outlen=0; // TODO
-// TODO
-  if (outfile) {
-    FILE *f=fopen(outfile,"w");
-    if (!f) {
-      fprintf(stderr,"Opening \"%s\" for writing failed: %s\n",outfile, strerror(errno));
-      assert(0);
-      emb_close(emb);
-      return;
-    }
-    outlen=emb_embed(emb,example_outfn,f);
-//    outlen=otf_ttc_extract(emb->font->sfnt,example_outfn,f);
-    fclose(f);
-  }
-puts("...");
-  printf("endstream\n"
-         "endobj\n");
-  printf("2 0 obj\n"
-         "%d\n"
-         "endobj\n",
-         outlen
-         );
-
-  printf("3 0 obj\n");
-  res=emb_pdf_simple_font(emb,fdes,fwid,0);
-  assert(res);
-  fputs(res,stdout);
-  free(res);
-  printf("endobj\n");
-
-  if (emb->plan&EMB_A_MULTIBYTE) {
-    printf("4 0 obj\n");
-    res=emb_pdf_simple_cidfont(emb,fdes->fontname,3);
-    assert(res);
-    fputs(res,stdout);
-    free(res);
-    printf("endobj\n");
-  }
-
-  free(fdes);
-  free(fwid);
-  emb_close(emb);
-#if 1
-  free(ff); // TODO
-#else
-  ff->sfnt=NULL; // TODO
-  fontfile_close(ff);
-#endif
-}
-// }}}
-
-// TODO? reencode?
-int main(int argc,char **argv)
-{
-  const char *fn=TESTFONT;
-  if (argc==2) {
-    fn=argv[1];
-  }
-  OTF_FILE *otf=otf_load(fn);
-  assert(otf);
-  printf("width(4): %d\n",otf_get_width(otf,4));
-
-
-  if (strcmp(fn,"test.ttf")!=0) {
-    example_write_fontdescr(otf,"test.ttf");
-  } else {
-    example_write_fontdescr(otf,NULL);
-  }
-
-  // show_post(otf);
-
-  // show_name(otf);
-
-  // show_cmap(otf);
-  // printf("%d %d\n",otf_from_unicode(otf,'A'),0);
-
-  // ... name 6 -> FontName  /20(cid)
-  // ? StemV Flags(?) from FontName
-
-  otf_close(otf);
-
-  return 0;
-}
diff --git a/fontembed/sfnt.c b/fontembed/sfnt.c
deleted file mode 100644
index 6fd1fec..0000000
--- a/fontembed/sfnt.c
+++ /dev/null
@@ -1,992 +0,0 @@
-#include "sfnt.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <errno.h>
-#include <assert.h>
-#include "sfnt_int.h"
-
-// TODO?
-// get_SHORT(head+48) // fontDirectionHint
-/* reqd. Tables: cmap, head, hhea, hmtx, maxp, name, OS/2, post
- OTF: glyf,loca [cvt,fpgm,prep]
- */
-
-static void otf_bsearch_params(int num, // {{{
-                               int recordSize,
-                               int *searchRange,
-                               int *entrySelector,
-                               int *rangeShift)
-{
-  assert(num>0);
-  assert(searchRange);
-  assert(entrySelector);
-  assert(rangeShift);
-
-  int iA,iB;
-  for (iA=1,iB=0;iA<=num;iA<<=1,iB++) {}
-
-  *searchRange=iA*recordSize/2;
-  *entrySelector=iB-1;
-  *rangeShift=num*recordSize-*searchRange;
-}
-// }}}
-
-static char *otf_bsearch(char *table, // {{{
-                         const char *target,int len,
-                         int searchRange,
-                         int entrySelector,
-                         int rangeShift,
-                         int lower_bound) // return lower_bound, if !=0
-{
-  char *ret=table+rangeShift;
-  if (memcmp(target,ret,len)<0) {
-    ret=table;
-  }
-
-  for (;entrySelector>0;entrySelector--) {
-    searchRange>>=1;
-    ret+=searchRange;
-    if (memcmp(target,ret,len)<0) {
-      ret-=searchRange;
-    }
-  }
-  const int result=memcmp(target,ret,len);
-  if (result==0) {
-    return ret;
-  } else if (lower_bound) {
-    if (result>0) {
-      return ret+searchRange;
-    }
-    return ret;
-  }
-  return NULL; // not found;
-}
-// }}}
-
-static OTF_FILE *otf_new(FILE *f) // {{{
-{
-  assert(f);
-
-  OTF_FILE *ret;
-  ret=calloc(1,sizeof(OTF_FILE));
-  if (ret) {
-    ret->f=f;
-    ret->version=0x00010000;
-  }
-
-  return ret;
-}
-// }}}
-
-// will alloc, if >buf ==NULL, returns >buf, or NULL on error
-// NOTE: you probably want otf_get_table()
-static char *otf_read(OTF_FILE *otf,char *buf,long pos,int length) // {{{
-{
-  char *ours=NULL;
-
-  if (length==0) {
-    return buf;
-  } else if (length<0) {
-    assert(0);
-    return NULL;
-  }
-
-  int res=fseek(otf->f,pos,SEEK_SET);
-  if (res==-1) {
-    fprintf(stderr,"Seek failed: %s\n", strerror(errno));
-    return NULL;
-  }
-
-  // (+3)&~3 for checksum...
-  const int pad_len=(length+3)&~3;
-  if (!buf) {
-    ours=buf=malloc(sizeof(char)*pad_len);
-    if (!buf) {
-      fprintf(stderr,"Bad alloc: %s\n", strerror(errno));
-      return NULL;
-    }
-  }
-
-  res=fread(buf,1,pad_len,otf->f);
-  if (res!=pad_len) {
-    if (res==length) { // file size not multiple of 4, pad with zero
-      memset(buf+res,0,pad_len-length);
-    } else {
-      fprintf(stderr,"Short read\n");
-      free(ours);
-      return NULL;
-    }
-  }
-
-  return buf;
-}
-// }}}
-
-
-static int otf_get_ttc_start(OTF_FILE *otf,int use_ttc) // {{{
-{
-  char buf[4];
-
-  if (!otf->numTTC) { // >0 if TTC...
-    return 0;
-  }
-
-  int pos=0;
-  if ( (use_ttc<0)||(use_ttc>=otf->numTTC)||
-       (!otf_read(otf,buf,pos+12+4*use_ttc,4)) ) {
-    fprintf(stderr,"Bad TTC subfont number\n");
-    return -1;
-  }
-  return get_ULONG(buf);
-}
-// }}}
-
-OTF_FILE *otf_do_load(OTF_FILE *otf,int pos) // {{{
-{
-  int iA;
-  char buf[16];
-
-  // {{{ read offset table
-  if (otf_read(otf,buf,pos,12)) {
-    otf->version=get_ULONG(buf);
-    if (otf->version==0x00010000) { // 1.0 truetype
-    } else if (otf->version==OTF_TAG('O','T','T','O')) { // OTF(CFF)
-      otf->flags|=OTF_F_FMT_CFF;
-    } else if (otf->version==OTF_TAG('t','r','u','e')) { // (old mac)
-    } else if (otf->version==OTF_TAG('t','y','p','1')) { // sfnt wrapped type1
-      // TODO: unsupported
-    } else {
-      otf_close(otf);
-      otf=NULL;
-    }
-    pos+=12;
-  } else {
-    otf_close(otf);
-    otf=NULL;
-  }
-  if (!otf) {
-    fprintf(stderr,"Not a ttf font\n");
-    return NULL;
-  }
-  otf->numTables=get_USHORT(buf+4);
-  // }}}
-
-  // {{{ read directory
-  otf->tables=malloc(sizeof(OTF_DIRENT)*otf->numTables);
-  if (!otf->tables) {
-    fprintf(stderr,"Bad alloc: %s\n", strerror(errno));
-    otf_close(otf);
-    return NULL;
-  }
-  for (iA=0;iA<otf->numTables;iA++) {
-    if (!otf_read(otf,buf,pos,16)) {
-      otf_close(otf);
-      return NULL;
-    }
-    otf->tables[iA].tag=get_ULONG(buf);
-    otf->tables[iA].checkSum=get_ULONG(buf+4);
-    otf->tables[iA].offset=get_ULONG(buf+8);
-    otf->tables[iA].length=get_ULONG(buf+12);
-    if ( (otf->tables[iA].tag==OTF_TAG('C','F','F',' '))&&
-         ((otf->flags&OTF_F_FMT_CFF)==0) ) {
-      fprintf(stderr,"Wrong magic\n");
-      otf_close(otf);
-      return NULL;
-    } else if ( (otf->tables[iA].tag==OTF_TAG('g','l','y','p'))&&
-                (otf->flags&OTF_F_FMT_CFF) ) {
-      fprintf(stderr,"Wrong magic\n");
-      otf_close(otf);
-      return NULL;
-    }
-    pos+=16;
-  }
-  // }}}
-
-//  otf->flags|=OTF_F_DO_CHECKSUM;
-  // {{{ check head table
-  int len=0;
-  char *head=otf_get_table(otf,OTF_TAG('h','e','a','d'),&len);
-  if ( (!head)||
-       (get_ULONG(head+0)!=0x00010000)||  // version
-       (len!=54)||
-       (get_ULONG(head+12)!=0x5F0F3CF5)|| // magic
-       (get_SHORT(head+52)!=0x0000) ) {   // glyphDataFormat
-    fprintf(stderr,"Unsupported OTF font / head table \n");
-    free(head);
-    otf_close(otf);
-    return NULL;
-  }
-  // }}}
-  otf->unitsPerEm=get_USHORT(head+18);
-  otf->indexToLocFormat=get_SHORT(head+50);
-
-  // {{{ checksum whole file
-  if (otf->flags&OTF_F_DO_CHECKSUM) {
-    unsigned int csum=0;
-    char tmp[1024];
-    rewind(otf->f);
-    while (!feof(otf->f)) {
-      len=fread(tmp,1,1024,otf->f);
-      if (len&3) { // zero padding reqd.
-        memset(tmp+len,0,4-(len&3));
-      }
-      csum+=otf_checksum(tmp,len);
-    }
-    if (csum!=0xb1b0afba) {
-      fprintf(stderr,"Wrong global checksum\n");
-      free(head);
-      otf_close(otf);
-      return NULL;
-    }
-  }
-  // }}}
-  free(head);
-
-  // {{{ read maxp table / numGlyphs
-  char *maxp=otf_get_table(otf,OTF_TAG('m','a','x','p'),&len);
-  if (maxp) {
-    const unsigned int maxp_version=get_ULONG(maxp);
-    if ( (maxp_version==0x00005000)&&(len==6) ) { // version 0.5
-      otf->numGlyphs=get_USHORT(maxp+4);
-      if ( (otf->flags&OTF_F_FMT_CFF)==0) { // only CFF
-        free(maxp);
-        maxp=NULL;
-      }
-    } else if ( (maxp_version==0x00010000)&&(len==32) ) { // version 1.0
-      otf->numGlyphs=get_USHORT(maxp+4);
-      if (otf->flags&OTF_F_FMT_CFF) { // only TTF
-        free(maxp);
-        maxp=NULL;
-      }
-    } else {
-      free(maxp);
-      maxp=NULL;
-    }
-  }
-  if (!maxp) {
-    fprintf(stderr,"Unsupported OTF font / maxp table \n");
-    free(maxp);
-    otf_close(otf);
-    return NULL;
-  }
-  free(maxp);
-  // }}}
-
-  return otf;
-}
-// }}}
-
-OTF_FILE *otf_load(const char *file) // {{{
-{
-  FILE *f;
-  OTF_FILE *otf;
-
-  int use_ttc=-1;
-  if ((f=fopen(file,"rb"))==NULL) {
-    // check for TTC
-    char *tmp=strrchr(file,'/'),*end;
-    if (tmp) {
-      use_ttc=strtoul(tmp+1,&end,10);
-      if (!*end) {
-        end=malloc((tmp-file+1)*sizeof(char));
-        if (!end) {
-          fprintf(stderr,"Bad alloc: %s\n", strerror(errno));
-          return NULL;
-        }
-        strncpy(end,file,tmp-file);
-        end[tmp-file]=0;
-        f=fopen(end,"rb");
-        free(end);
-      }
-    }
-    if (!f) {
-      fprintf(stderr,"Could not open \"%s\": %s\n", file, strerror(errno));
-      return NULL;
-    }
-  }
-  otf=otf_new(f);
-  if (!otf) {
-    fprintf(stderr,"Bad alloc: %s\n", strerror(errno));
-    fclose(f);
-    return NULL;
-  }
-
-  char buf[12];
-  int pos=0;
-  // {{{ check for TTC
-  if (otf_read(otf,buf,pos,12)) {
-    const unsigned int version=get_ULONG(buf);
-    if (version==OTF_TAG('t','t','c','f')) {
-      const unsigned int ttc_version=get_ULONG(buf+4);
-      if ( (ttc_version!=0x00010000)&&(ttc_version!=0x00020000) ) {
-        fprintf(stderr,"Unsupported TTC version\n");
-        otf_close(otf);
-        return NULL;
-      }
-      otf->numTTC=get_ULONG(buf+8);
-      otf->useTTC=use_ttc;
-      pos=otf_get_ttc_start(otf,use_ttc);
-      if (pos==-1) {
-        otf_close(otf);
-        return NULL;
-      }
-    }
-  } else {
-    fprintf(stderr,"Not a ttf font\n");
-    otf_close(otf);
-    return NULL;
-  }
-  // }}}
-
-  return otf_do_load(otf,pos);
-}
-// }}}
-
-void otf_close(OTF_FILE *otf) // {{{
-{
-  assert(otf);
-  if (otf) {
-    free(otf->gly);
-    free(otf->cmap);
-    free(otf->name);
-    free(otf->hmtx);
-    free(otf->glyphOffsets);
-    fclose(otf->f);
-    free(otf->tables);
-    free(otf);
-  }
-}
-// }}}
-
-static int otf_dirent_compare(const void *a,const void *b) // {{{
-{
-  const unsigned int aa=((const OTF_DIRENT *)a)->tag;
-  const unsigned int bb=((const OTF_DIRENT *)b)->tag;
-  if (aa<bb) {
-    return -1;
-  } else if (aa>bb) {
-    return 1;
-  }
-  return 0;
-}
-// }}}
-
-int otf_find_table(OTF_FILE *otf,unsigned int tag) // {{{  - table_index  or -1 on error
-{
-#if 0
-  // binary search would require raw table
-  int pos=0;
-  char buf[12];
-  if (!otf_read(otf,buf,pos,12)) {
-    return -1;
-  }
-  pos=12;
-  const unsigned int numTables=get_USHORT(buf+4);
-  char *tables=malloc(16*numTables);
-  if (!tables) {
-    return -1;
-  }
-  if (!otf_read(otf,tables,pos,16*numTables)) {
-    free(tables);
-    return -1;
-  }
-  char target[]={(tag>>24),(tag>>16),(tag>>8),tag};
-  //  assert(get_USHORT(buf+6)+get_USHORT(buf+10)==16*numTables);
-  char *result=otf_bsearch(tables,target,4,
-                           get_USHORT(buf+6),
-                           get_USHORT(buf+8),
-                           get_USHORT(buf+10),0);
-  free(tables);
-  if (result) {
-    return (result-tables)/16;
-  }
-#elif 1
-  OTF_DIRENT key={.tag=tag},*res;
-  res=bsearch(&key,otf->tables,otf->numTables,sizeof(otf->tables[0]),otf_dirent_compare);
-  if (res) {
-    return (res-otf->tables);
-  }
-#else
-  int iA;
-  for (iA=0;iA<otf->numTables;iA++) {
-    if (otf->tables[iA].tag==tag) {
-      return iA;
-    }
-  }
-#endif
-  return -1;
-}
-// }}}
-
-char *otf_get_table(OTF_FILE *otf,unsigned int tag,int *ret_len) // {{{
-{
-  assert(otf);
-  assert(ret_len);
-
-  const int idx=otf_find_table(otf,tag);
-  if (idx==-1) {
-    *ret_len=-1;
-    return NULL;
-  }
-  const OTF_DIRENT *table=otf->tables+idx;
-
-  char *ret=otf_read(otf,NULL,table->offset,table->length);
-  if (!ret) {
-    return NULL;
-  }
-  if (otf->flags&OTF_F_DO_CHECKSUM) {
-    unsigned int csum=otf_checksum(ret,table->length);
-    if (tag==OTF_TAG('h','e','a','d')) { // special case
-      csum-=get_ULONG(ret+8);
-    }
-    if (csum!=table->checkSum) {
-      fprintf(stderr,"Wrong checksum for %c%c%c%c\n",OTF_UNTAG(tag));
-      free(ret);
-      return NULL;
-    }
-  }
-  *ret_len=table->length;
-  return ret;
-}
-// }}}
-
-int otf_load_glyf(OTF_FILE *otf) // {{{  - 0 on success
-{
-  assert((otf->flags&OTF_F_FMT_CFF)==0); // not for CFF
-  int iA,len;
-  // {{{ find glyf table
-  iA=otf_find_table(otf,OTF_TAG('g','l','y','f'));
-  if (iA==-1) {
-    fprintf(stderr,"Unsupported OTF font / glyf table \n");
-    return -1;
-  }
-  otf->glyfTable=otf->tables+iA;
-  // }}}
-
-  // {{{ read loca table
-  char *loca=otf_get_table(otf,OTF_TAG('l','o','c','a'),&len);
-  if ( (!loca)||
-       (otf->indexToLocFormat>=2)||
-       (((len+3)&~3)!=((((otf->numGlyphs+1)*(otf->indexToLocFormat+1)*2)+3)&~3)) ) {
-    fprintf(stderr,"Unsupported OTF font / loca table \n");
-    return -1;
-  }
-  if (otf->glyphOffsets) {
-    free(otf->glyphOffsets);
-    assert(0);
-  }
-  otf->glyphOffsets=malloc((otf->numGlyphs+1)*sizeof(unsigned int));
-  if (!otf->glyphOffsets) {
-    fprintf(stderr,"Bad alloc: %s\n", strerror(errno));
-    return -1;
-  }
-  if (otf->indexToLocFormat==0) {
-    for (iA=0;iA<=otf->numGlyphs;iA++) {
-      otf->glyphOffsets[iA]=get_USHORT(loca+iA*2)*2;
-    }
-  } else { // indexToLocFormat==1
-    for (iA=0;iA<=otf->numGlyphs;iA++) {
-      otf->glyphOffsets[iA]=get_ULONG(loca+iA*4);
-    }
-  }
-  free(loca);
-  if (otf->glyphOffsets[otf->numGlyphs]>otf->glyfTable->length) {
-    fprintf(stderr,"Bad loca table \n");
-    return -1;
-  }
-  // }}}
-
-  // {{{ allocate otf->gly slot
-  int maxGlyfLen=0;  // no single glyf takes more space
-  for (iA=1;iA<=otf->numGlyphs;iA++) {
-    const int glyfLen=otf->glyphOffsets[iA]-otf->glyphOffsets[iA-1];
-    if (glyfLen<0) {
-      fprintf(stderr,"Bad loca table: glyph len %d\n",glyfLen);
-      return -1;
-    }
-    if (maxGlyfLen<glyfLen) {
-      maxGlyfLen=glyfLen;
-    }
-  }
-  if (otf->gly) {
-    free(otf->gly);
-    assert(0);
-  }
-  otf->gly=malloc(maxGlyfLen*sizeof(char));
-  if (!otf->gly) {
-    fprintf(stderr,"Bad alloc: %s\n", strerror(errno));
-    return -1;
-  }
-  // }}}
-
-  return 0;
-}
-// }}}
-
-int otf_load_more(OTF_FILE *otf) // {{{  - 0 on success   => hhea,hmtx,name,[glyf]
-{
-  int iA;
-
-  int len;
-  if ((otf->flags&OTF_F_FMT_CFF)==0) { // not for CFF
-    if (otf_load_glyf(otf)==-1) {
-      return -1;
-    }
-  }
-
-  // {{{ read hhea table
-  char *hhea=otf_get_table(otf,OTF_TAG('h','h','e','a'),&len);
-  if ( (!hhea)||
-       (get_ULONG(hhea)!=0x00010000)|| // version
-       (len!=36)||
-       (get_SHORT(hhea+32)!=0) ) { // metric format
-    fprintf(stderr,"Unsupported OTF font / hhea table \n");
-    return -1;
-  }
-  otf->numberOfHMetrics=get_USHORT(hhea+34);
-  free(hhea);
-  // }}}
-
-  // {{{ read hmtx table
-  char *hmtx=otf_get_table(otf,OTF_TAG('h','m','t','x'),&len);
-  if ( (!hmtx)||
-       (len!=otf->numberOfHMetrics*2+otf->numGlyphs*2) ) {
-    fprintf(stderr,"Unsupported OTF font / hmtx table \n");
-    return -1;
-  }
-  if (otf->hmtx) {
-    free(otf->hmtx);
-    assert(0);
-  }
-  otf->hmtx=hmtx;
-  // }}}
-
-  // {{{ read name table
-  char *name=otf_get_table(otf,OTF_TAG('n','a','m','e'),&len);
-  if ( (!name)||
-       (get_USHORT(name)!=0x0000)|| // version
-       (len<get_USHORT(name+2)*12+6)||
-       (len<=get_USHORT(name+4)) ) {
-    fprintf(stderr,"Unsupported OTF font / name table \n");
-    return -1;
-  }
-  // check bounds
-  int name_count=get_USHORT(name+2);
-  const char *nstore=name+get_USHORT(name+4);
-  for (iA=0;iA<name_count;iA++) {
-    const char *nrec=name+6+12*iA;
-    if (nstore-name+get_USHORT(nrec+10)+get_USHORT(nrec+8)>len) {
-      fprintf(stderr,"Bad name table \n");
-      free(name);
-      return -1;
-    }
-  }
-  if (otf->name) {
-    free(otf->name);
-    assert(0);
-  }
-  otf->name=name;
-  // }}}
-
-  return 0;
-}
-// }}}
-
-int otf_load_cmap(OTF_FILE *otf) // {{{  - 0 on success
-{
-  int iA;
-  int len;
-
-  char *cmap=otf_get_table(otf,OTF_TAG('c','m','a','p'),&len);
-  if ( (!cmap)||
-       (get_USHORT(cmap)!=0x0000)|| // version
-       (len<get_USHORT(cmap+2)*8+4) ) {
-    fprintf(stderr,"Unsupported OTF font / cmap table \n");
-    assert(0);
-    return -1;
-  }
-  // check bounds, find (3,0) or (3,1) [TODO?]
-  const int numTables=get_USHORT(cmap+2);
-  for (iA=0;iA<numTables;iA++) {
-    const char *nrec=cmap+4+8*iA;
-    const unsigned int offset=get_ULONG(nrec+4);
-    const char *ndata=cmap+offset;
-    if ( (ndata<cmap+4+8*numTables)||
-         (offset>=len)||
-         (offset+get_USHORT(ndata+2)>len) ) {
-      fprintf(stderr,"Bad cmap table \n");
-      free(cmap);
-      assert(0);
-      return -1;
-    }
-    if ( (get_USHORT(nrec)==3)&&
-         (get_USHORT(nrec+2)<=1)&&
-         (get_USHORT(ndata)==4)&&
-         (get_USHORT(ndata+4)==0) ) {
-      otf->unimap=ndata;
-    }
-  }
-  if (otf->cmap) {
-    free(otf->cmap);
-    assert(0);
-  }
-  otf->cmap=cmap;
-
-  return 0;
-}
-// }}}
-
-int otf_get_width(OTF_FILE *otf,unsigned short gid) // {{{  -1 on error
-{
-  assert(otf);
-
-  if (gid>=otf->numGlyphs) {
-    return -1;
-  }
-
-  // ensure hmtx is there
-  if (!otf->hmtx) {
-    if (otf_load_more(otf)!=0) {
-      assert(0);
-      return -1;
-    }
-  }
-
-  return get_width_fast(otf,gid);
-#if 0
-  if (gid>=otf->numberOfHMetrics) {
-    return get_USHORT(otf->hmtx+(otf->numberOfHMetrics-1)*2);
-    // TODO? lsb=get_SHORT(otf->hmtx+otf->numberOfHMetrics*2+gid*2);  // lsb: left_side_bearing (also in table)
-  }
-  return get_USHORT(otf->hmtx+gid*4);
-  // TODO? lsb=get_SHORT(otf->hmtx+gid*4+2);
-#endif
-}
-// }}}
-
-static int otf_name_compare(const void *a,const void *b) // {{{
-{
-  return memcmp(a,b,8);
-}
-// }}}
-
-const char *otf_get_name(OTF_FILE *otf,int platformID,int encodingID,int languageID,int nameID,int *ret_len) // {{{
-{
-  assert(otf);
-  assert(ret_len);
-
-  // ensure name is there
-  if (!otf->name) {
-    if (otf_load_more(otf)!=0) {
-      *ret_len=-1;
-      assert(0);
-      return NULL;
-    }
-  }
-
-  char key[8];
-  set_USHORT(key,platformID);
-  set_USHORT(key+2,encodingID);
-  set_USHORT(key+4,languageID);
-  set_USHORT(key+6,nameID);
-
-  char *res=bsearch(key,otf->name+6,get_USHORT(otf->name+2),12,otf_name_compare);
-  if (res) {
-    *ret_len=get_USHORT(res+8);
-    int npos=get_USHORT(res+10);
-    const char *nstore=otf->name+get_USHORT(otf->name+4);
-    return nstore+npos;
-  }
-  *ret_len=0;
-  return NULL;
-}
-// }}}
-
-int otf_get_glyph(OTF_FILE *otf,unsigned short gid) // {{{ result in >otf->gly, returns length, -1 on error
-{
-  assert(otf);
-  assert((otf->flags&OTF_F_FMT_CFF)==0); // not for CFF
-
-  if (gid>=otf->numGlyphs) {
-    return -1;
-  }
-
-  // ensure >glyphOffsets and >gly is there
-  if ( (!otf->gly)||(!otf->glyphOffsets) ) {
-    if (otf_load_more(otf)!=0) {
-      assert(0);
-      return -1;
-    }
-  }
-
-  const int len=otf->glyphOffsets[gid+1]-otf->glyphOffsets[gid];
-  if (len==0) {
-    return 0;
-  }
-
-  assert(otf->glyfTable->length>=otf->glyphOffsets[gid+1]);
-  if (!otf_read(otf,otf->gly,
-                otf->glyfTable->offset+otf->glyphOffsets[gid],len)) {
-    return -1;
-  }
-
-  return len;
-}
-// }}}
-
-unsigned short otf_from_unicode(OTF_FILE *otf,int unicode) // {{{ 0 = missing
-{
-  assert(otf);
-  assert( (unicode>=0)&&(unicode<65536) );
-//  assert((otf->flags&OTF_F_FMT_CFF)==0); // not for CFF, other method!
-
-  // ensure >cmap and >unimap is there
-  if (!otf->cmap) {
-    if (otf_load_cmap(otf)!=0) {
-      assert(0);
-      return 0; // TODO?
-    }
-  }
-  if (!otf->unimap) {
-    fprintf(stderr,"Unicode (3,1) cmap in format 4 not found\n");
-    return 0;
-  }
-
-#if 0
-  // linear search is cache friendly and should be quite fast
-#else
-  const unsigned short segCountX2=get_USHORT(otf->unimap+6);
-  char target[]={unicode>>8,unicode}; // set_USHORT(target,unicode);
-  char *result=otf_bsearch((char *)otf->unimap+14,target,2,
-                           get_USHORT(otf->unimap+8),
-                           get_USHORT(otf->unimap+10),
-                           get_USHORT(otf->unimap+12),1);
-  if (result>=otf->unimap+14+segCountX2) { // outside of endCode[segCount]
-    assert(0); // bad font, no 0xffff sentinel
-    return 0;
-  }
-
-  result+=2+segCountX2; // jump over padding into startCode[segCount]
-  const unsigned short startCode=get_USHORT(result);
-  if (startCode>unicode) {
-    return 0;
-  }
-  result+=2*segCountX2;
-  const unsigned short rangeOffset=get_USHORT(result);
-  if (rangeOffset) {
-    return get_USHORT(result+rangeOffset+2*(unicode-startCode)); // the so called "obscure indexing trick" into glyphIdArray[]
-    // NOTE: this is according to apple spec; microsoft says we must add delta (probably incorrect; fonts probably have delta==0)
-  } else {
-    const short delta=get_SHORT(result-segCountX2);
-    return (delta+unicode)&0xffff;
-  }
-#endif
-}
-// }}}
-
-/** output stuff **/
-int otf_action_copy(void *param,int table_no,OUTPUT_FN output,void *context) // {{{
-{
-  OTF_FILE *otf=param;
-  const OTF_DIRENT *table=otf->tables+table_no;
-
-  if (!output) { // get checksum and unpadded length
-    *(unsigned int *)context=table->checkSum;
-    return table->length;
-  }
-
-// TODO? copy_block(otf->f,table->offset,(table->length+3)&~3,output,context);
-// problem: PS currently depends on single-output.  also checksum not possible
-  char *data=otf_read(otf,NULL,table->offset,table->length);
-  if (!data) {
-    return -1;
-  }
-  int ret=(table->length+3)&~3;
-  (*output)(data,ret,context);
-  free(data);
-  return ret; // padded length
-}
-// }}}
-
-// TODO? >modified time-stamp?
-// Note: don't use this directly. otf_write_sfnt will internally replace otf_action_copy for head with this
-int otf_action_copy_head(void *param,int csum,OUTPUT_FN output,void *context) // {{{
-{
-  OTF_FILE *otf=param;
-  const int table_no=otf_find_table(otf,OTF_TAG('h','e','a','d')); // we can't have csum AND table_no ... never mind!
-  assert(table_no!=-1);
-  const OTF_DIRENT *table=otf->tables+table_no;
-
-  if (!output) { // get checksum and unpadded length
-    *(unsigned int *)context=table->checkSum;
-    return table->length;
-  }
-
-  char *data=otf_read(otf,NULL,table->offset,table->length);
-  if (!data) {
-    return -1;
-  }
-  set_ULONG(data+8,0xb1b0afba-csum); // head. fix global checksum
-  int ret=(table->length+3)&~3;
-  (*output)(data,ret,context);
-  free(data);
-  return ret; // padded length
-}
-// }}}
-
-int otf_action_replace(void *param,int length,OUTPUT_FN output,void *context) // {{{
-{
-  char *data=param;
-  char pad[4]={0,0,0,0};
-
-  int ret=(length+3)&~3;
-  if (!output) { // get checksum and unpadded length
-    if (ret!=length) {
-      unsigned int csum=otf_checksum(data,ret-4);
-      memcpy(pad,data+ret-4,ret-length);
-      csum+=get_ULONG(pad);
-      *(unsigned int *)context=csum;
-    } else {
-      *(unsigned int *)context=otf_checksum(data,length);
-    }
-    return length;
-  }
-
-  (*output)(data,length,context);
-  if (ret!=length) {
-    (*output)(pad,ret-length,context);
-  }
-
-  return ret; // padded length
-}
-// }}}
-
-/* windows "works best" with the following ordering:
-  head, hhea, maxp, OS/2, hmtx, LTSH, VDMX, hdmx, cmap, fpgm, prep, cvt, loca, glyf, kern, name, post, gasp, PCLT, DSIG
-or for CFF:
-  head, hhea, maxp, OS/2, name, cmap, post, CFF, (other tables, as convenient)
-*/
-#define NUM_PRIO 20
-static const struct { int prio; unsigned int tag; } otf_tagorder_win[]={ // {{{
-  {19,OTF_TAG('D','S','I','G')},
-  { 5,OTF_TAG('L','T','S','H')},
-  { 3,OTF_TAG('O','S','/','2')},
-  {18,OTF_TAG('P','C','L','T')},
-  { 6,OTF_TAG('V','D','M','X')},
-  { 8,OTF_TAG('c','m','a','p')},
-  {11,OTF_TAG('c','v','t',' ')},
-  { 9,OTF_TAG('f','p','g','m')},
-  {17,OTF_TAG('g','a','s','p')},
-  {13,OTF_TAG('g','l','y','f')},
-  { 7,OTF_TAG('h','d','m','x')},
-  { 0,OTF_TAG('h','e','a','d')},
-  { 1,OTF_TAG('h','h','e','a')},
-  { 4,OTF_TAG('h','m','t','x')},
-  {14,OTF_TAG('k','e','r','n')},
-  {12,OTF_TAG('l','o','c','a')},
-  { 2,OTF_TAG('m','a','x','p')},
-  {15,OTF_TAG('n','a','m','e')},
-  {16,OTF_TAG('p','o','s','t')},
-  {10,OTF_TAG('p','r','e','p')}};
-// }}}
-
-int otf_write_sfnt(struct _OTF_WRITE *otw,unsigned int version,int numTables,OUTPUT_FN output,void *context) // {{{
-{
-  int iA;
-  int ret;
-
-  int *order=malloc(sizeof(int)*numTables); // temporary
-  char *start=malloc(12+16*numTables);
-  if ( (!order)||(!start) ) {
-    fprintf(stderr,"Bad alloc: %s\n", strerror(errno));
-    free(order);
-    free(start);
-    return -1;
-  }
-
-  if (1) { // sort tables
-    int priolist[NUM_PRIO]={0,};
-
-    // reverse intersection of both sorted arrays
-    int iA=numTables-1,iB=sizeof(otf_tagorder_win)/sizeof(otf_tagorder_win[0])-1;
-    int ret=numTables-1;
-    while ( (iA>=0)&&(iB>=0) ) {
-      if (otw[iA].tag==otf_tagorder_win[iB].tag) {
-        priolist[otf_tagorder_win[iB--].prio]=1+iA--;
-      } else if (otw[iA].tag>otf_tagorder_win[iB].tag) { // no order known: put unchanged at end of result
-        order[ret--]=iA--;
-      } else { // <
-        iB--;
-      }
-    }
-    for (iA=NUM_PRIO-1;iA>=0;iA--) { // pick the matched tables up in sorted order (bucketsort principle)
-      if (priolist[iA]) {
-        order[ret--]=priolist[iA]-1;
-      }
-    }
-  } else {
-    for (iA=0;iA<numTables;iA++) {
-      order[iA]=iA;
-    }
-  }
-
-  // the header
-  set_ULONG(start,version);
-  set_USHORT(start+4,numTables);
-  int a,b,c;
-  otf_bsearch_params(numTables,16,&a,&b,&c);
-  set_USHORT(start+6,a);
-  set_USHORT(start+8,b);
-  set_USHORT(start+10,c);
-
-  // first pass: calculate table directory / offsets and checksums
-  unsigned int globalSum=0,csum;
-  int offset=12+16*numTables;
-  int headAt=-1;
-  for (iA=0;iA<numTables;iA++) {
-    char *entry=start+12+16*order[iA];
-    const int res=(*otw[order[iA]].action)(otw[order[iA]].param,otw[order[iA]].length,NULL,&csum);
-    assert(res>=0);
-    if (otw[order[iA]].tag==OTF_TAG('h','e','a','d')) {
-      headAt=order[iA];
-    }
-    set_ULONG(entry,otw[order[iA]].tag);
-    set_ULONG(entry+4,csum);
-    set_ULONG(entry+8,offset);
-    set_ULONG(entry+12,res);
-    offset+=(res+3)&~3; // padding
-    globalSum+=csum;
-  }
-
-  // second pass: write actual data
-  // write header + directory
-  ret=12+16*numTables;
-  (*output)(start,ret,context);
-  globalSum+=otf_checksum(start,ret);
-
-  // change head
-  if ( (headAt!=-1)&&(otw[headAt].action==otf_action_copy) ) { // more needed?
-    otw[headAt].action=otf_action_copy_head;
-    otw[headAt].length=globalSum;
-  }
-
-  // write tables
-  for (iA=0;iA<numTables;iA++) {
-    const int res=(*otw[order[iA]].action)(otw[order[iA]].param,otw[order[iA]].length,output,context);
-    if (res<0) {
-      free(order);
-      free(start);
-      return -1;
-    }
-    assert(((res+3)&~3)==res); // correctly padded? (i.e. next line is just ret+=res;)
-    ret+=(res+3)&~3;
-  }
-  assert(offset==ret);
-  free(order);
-  free(start);
-
-  return ret;
-}
-// }}}
-
diff --git a/fontembed/sfnt.h b/fontembed/sfnt.h
deleted file mode 100644
index 1783098..0000000
--- a/fontembed/sfnt.h
+++ /dev/null
@@ -1,64 +0,0 @@
-#ifndef _SFNT_H
-#define _SFNT_H
-
-#include <stdio.h>
-
-typedef struct {
-  unsigned int tag;
-  unsigned int checkSum;
-  unsigned int offset;
-  unsigned int length;
-} OTF_DIRENT;
-
-typedef struct {
-  FILE *f;
-  unsigned int numTTC,useTTC;
-  unsigned int version;
-
-  unsigned short numTables;
-  OTF_DIRENT *tables;
-
-  int flags;
-  unsigned short unitsPerEm;
-  unsigned short indexToLocFormat; // 0=short, 1=long
-  unsigned short numGlyphs;
-
-  // optionally loaded data
-  unsigned int *glyphOffsets;
-  unsigned short numberOfHMetrics;
-  char *hmtx,*name,*cmap;
-  const char *unimap; // ptr to (3,1) or (3,0) cmap start
-
-  // single glyf buffer, allocated large enough by otf_load_more()
-  char *gly;
-  OTF_DIRENT *glyfTable;
-
-} OTF_FILE;
-#define OTF_F_FMT_CFF      0x10000
-#define OTF_F_DO_CHECKSUM  0x40000
-
-// to load TTC collections: append e.g. "/3" for the third font in the file.
-OTF_FILE *otf_load(const char *file);
-void otf_close(OTF_FILE *otf);
-
-#define OTF_TAG(a,b,c,d)  (unsigned int)( ((a)<<24)|((b)<<16)|((c)<<8)|(d) )
-#define OTF_UNTAG(a)  (((unsigned int)(a)>>24)&0xff),(((unsigned int)(a)>>16)&0xff),\
-                      (((unsigned int)(a)>>8)&0xff),(((unsigned int)(a))&0xff)
-
-char *otf_get_table(OTF_FILE *otf,unsigned int tag,int *ret_len);
-
-int otf_get_width(OTF_FILE *otf,unsigned short gid);
-const char *otf_get_name(OTF_FILE *otf,int platformID,int encodingID,int languageID,int nameID,int *ret_len);
-int otf_get_glyph(OTF_FILE *otf,unsigned short gid);
-unsigned short otf_from_unicode(OTF_FILE *otf,int unicode);
-
-#include "bitset.h"
-#include "iofn.h"
-
-// TODO?! allow glyphs==NULL for non-subsetting table reduction?
-int otf_subset(OTF_FILE *otf,BITSET glyphs,OUTPUT_FN output,void *context);
-int otf_ttc_extract(OTF_FILE *otf,OUTPUT_FN output,void *context);
-int otf_subset_cff(OTF_FILE *otf,BITSET glyphs,OUTPUT_FN output,void *context);
-int otf_cff_extract(OTF_FILE *otf,OUTPUT_FN output,void *context);
-
-#endif
diff --git a/fontembed/sfnt_int.h b/fontembed/sfnt_int.h
deleted file mode 100644
index 777ead6..0000000
--- a/fontembed/sfnt_int.h
+++ /dev/null
@@ -1,97 +0,0 @@
-#ifndef _SFNT_INT_H
-#define _SFNT_INT_H
-
-static inline unsigned short get_USHORT(const char *buf) // {{{
-{
-  return ((unsigned char)buf[0]<<8)|((unsigned char)buf[1]);
-}
-// }}}
-static inline short get_SHORT(const char *buf) // {{{
-{
-  return (buf[0]<<8)|((unsigned char)buf[1]);
-}
-// }}}
-static inline unsigned int get_UINT24(const char *buf) // {{{
-{
-  return ((unsigned char)buf[0]<<16)|
-         ((unsigned char)buf[1]<<8)|
-         ((unsigned char)buf[2]);
-}
-// }}}
-static inline unsigned int get_ULONG(const char *buf) // {{{
-{
-  return ((unsigned char)buf[0]<<24)|
-         ((unsigned char)buf[1]<<16)|
-         ((unsigned char)buf[2]<<8)|
-         ((unsigned char)buf[3]);
-}
-// }}}
-static inline int get_LONG(const char *buf) // {{{
-{
-  return (buf[0]<<24)|
-         ((unsigned char)buf[1]<<16)|
-         ((unsigned char)buf[2]<<8)|
-         ((unsigned char)buf[3]);
-}
-// }}}
-
-static inline void set_USHORT(char *buf,unsigned short val) // {{{
-{
-  buf[0]=val>>8;
-  buf[1]=val&0xff;
-}
-// }}}
-static inline void set_ULONG(char *buf,unsigned int val) // {{{
-{
-  buf[0]=val>>24;
-  buf[1]=(val>>16)&0xff;
-  buf[2]=(val>>8)&0xff;
-  buf[3]=val&0xff;
-}
-// }}}
-
-static inline unsigned int otf_checksum(const char *buf, unsigned int len) // {{{
-{
-  unsigned int ret=0;
-  for (len=(len+3)/4;len>0;len--,buf+=4) {
-    ret+=get_ULONG(buf);
-  }
-  return ret;
-}
-// }}}
-static inline int get_width_fast(OTF_FILE *otf,int gid) // {{{
-{
-  if (gid>=otf->numberOfHMetrics) {
-    return get_USHORT(otf->hmtx+(otf->numberOfHMetrics-1)*4);
-  } else {
-    return get_USHORT(otf->hmtx+gid*4);
-  }
-}
-// }}}
-
-int otf_load_glyf(OTF_FILE *otf); //  - 0 on success
-int otf_load_more(OTF_FILE *otf); //  - 0 on success
-
-int otf_find_table(OTF_FILE *otf,unsigned int tag); // - table_index  or -1 on error
-
-int otf_action_copy(void *param,int csum,OUTPUT_FN output,void *context);
-int otf_action_replace(void *param,int csum,OUTPUT_FN output,void *context);
-
-// Note: don't use this directly. otf_write_sfnt will internally replace otf_action_copy for head with this
-int otf_action_copy_head(void *param,int csum,OUTPUT_FN output,void *context);
-
-struct _OTF_WRITE {
-  unsigned long tag;
-  int (*action)(void *param,int length,OUTPUT_FN output,void *context); // -1 on error, num_bytes_written on success; if >output==NULL return checksum in (unsigned int *)context  instead.
-  void *param;
-  int length;
-};
-
-int otf_write_sfnt(struct _OTF_WRITE *otw,unsigned int version,int numTables,OUTPUT_FN output,void *context);
-
-/** from sfnt_subset.c: **/
-
-// otw {0,}-terminated, will be modified; returns numTables for otf_write_sfnt
-int otf_intersect_tables(OTF_FILE *otf,struct _OTF_WRITE *otw);
-
-#endif
diff --git a/fontembed/sfnt_subset.c b/fontembed/sfnt_subset.c
deleted file mode 100644
index dee34c5..0000000
--- a/fontembed/sfnt_subset.c
+++ /dev/null
@@ -1,343 +0,0 @@
-#include "sfnt.h"
-#include "sfnt_int.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <errno.h>
-#include <assert.h>
-#include "bitset.h"
-
-int otf_ttc_extract(OTF_FILE *otf,OUTPUT_FN output,void *context) // {{{
-{
-  assert(otf);
-  assert(output);
-  assert(otf->numTTC);
-  int iA;
-
-  struct _OTF_WRITE *otw;
-  otw=malloc(sizeof(struct _OTF_WRITE)*otf->numTables);
-  if (!otw) {
-    fprintf(stderr,"Bad alloc: %s\n", strerror(errno));
-    return -1;
-  }
-
-  // just copy everything
-  for (iA=0;iA<otf->numTables;iA++) {
-    otw[iA].tag=otf->tables[iA].tag;
-    otw[iA].action=otf_action_copy;
-    otw[iA].param=otf;
-    otw[iA].length=iA;
-  }
-  iA=otf_write_sfnt(otw,otf->version,otf->numTables,output,context);
-  free(otw);
-
-  return iA;
-}
-// }}}
-
-// otw {0,}-terminated, will be modified; returns numTables for otf_write_sfnt
-int otf_intersect_tables(OTF_FILE *otf,struct _OTF_WRITE *otw) // {{{
-{
-  int iA,iB,numTables=0;
-  for (iA=0,iB=0;(iA<otf->numTables)&&(otw[iB].tag);) {
-    if (otf->tables[iA].tag==otw[iB].tag) {
-      if (otw[iB].action==otf_action_copy) {
-        otw[iB].length=iA; // original table location found.
-      }
-      if (iB!=numTables) { // >, actually
-        memmove(otw+numTables,otw+iB,sizeof(struct _OTF_WRITE));
-      }
-      iA++;
-      iB++;
-      numTables++;
-    } else if (otf->tables[iA].tag<otw[iB].tag) {
-      iA++;
-    } else { // not in otf->tables
-      if (otw[iB].action!=otf_action_copy) { // keep
-        if (iB!=numTables) { // >, actually
-          memmove(otw+numTables,otw+iB,sizeof(struct _OTF_WRITE));
-        }
-        numTables++;
-      } // else delete
-      iB++;
-    }
-  }
-  return numTables;
-}
-// }}}
-
-
-// include components (set bit in >glyphs) of currently loaded compound glyph (with >curgid)
-// returns additional space requirements (when bits below >donegid are touched)
-static int otf_subset_glyf(OTF_FILE *otf,int curgid,int donegid,BITSET glyphs) // {{{
-{
-  int ret=0;
-  if (get_SHORT(otf->gly)>=0) { // not composite
-    return ret; // done
-  }
-
-  char *cur=otf->gly+10;
-
-  unsigned short flags;
-  do {
-    flags=get_USHORT(cur);
-    const unsigned short sub_gid=get_USHORT(cur+2);
-    assert(sub_gid<otf->numGlyphs);
-    if (!bit_check(glyphs,sub_gid)) {
-      // bad: temporarily load sub glyph
-      const int len=otf_get_glyph(otf,sub_gid);
-      assert(len>0);
-      bit_set(glyphs,sub_gid);
-      if (sub_gid<donegid) {
-        ret+=len;
-        ret+=otf_subset_glyf(otf,sub_gid,donegid,glyphs); // composite of composites?, e.g. in DejaVu
-      }
-      const int res=otf_get_glyph(otf,curgid); // reload current glyph
-      assert(res);
-    }
-
-    // skip parameters
-    cur+=6;
-    if (flags&0x01) {
-      cur+=2;
-    }
-    if (flags&0x08) {
-      cur+=2;
-    } else if (flags&0x40) {
-      cur+=4;
-    } else if (flags&0x80) {
-      cur+=8;
-    }
-  } while (flags&0x20); // more components
-
-  return ret;
-}
-// }}}
-
-// TODO: cmap only required in non-CID context
-int otf_subset(OTF_FILE *otf,BITSET glyphs,OUTPUT_FN output,void *context) // {{{ - returns number of bytes written
-{
-  assert(otf);
-  assert(glyphs);
-  assert(output);
-
-  int iA,b,c;
-
-  // first pass: include all required glyphs
-  bit_set(glyphs,0); // .notdef always required
-  int glyfSize=0;
-  for (iA=0,b=0,c=1;iA<otf->numGlyphs;iA++,c<<=1) {
-    if (!c) {
-      b++;
-      c=1;
-    }
-    if (glyphs[b]&c) {
-      int len=otf_get_glyph(otf,iA);
-      if (len<0) {
-        assert(0);
-        return -1;
-      } else if (len>0) {
-        glyfSize+=len;
-        len=otf_subset_glyf(otf,iA,iA,glyphs);
-        if (len<0) {
-          assert(0);
-          return -1;
-        }
-        glyfSize+=len;
-      }
-    }
-  }
-
-  // second pass: calculate new glyf and loca
-  int locaSize=(otf->numGlyphs+1)*(otf->indexToLocFormat+1)*2;
-
-  char *new_loca=malloc(locaSize);
-  char *new_glyf=malloc(glyfSize);
-  if ( (!new_loca)||(!new_glyf) ) {
-    fprintf(stderr,"Bad alloc: %s\n", strerror(errno));
-    assert(0);
-    free(new_loca);
-    free(new_glyf);
-    return -1;
-  }
-
-  int offset=0;
-  for (iA=0,b=0,c=1;iA<otf->numGlyphs;iA++,c<<=1) {
-    if (!c) {
-      b++;
-      c=1;
-    }
-
-    assert(offset%2==0);
-    // TODO? change format? if glyfSize<0x20000
-    if (otf->indexToLocFormat==0) {
-      set_USHORT(new_loca+iA*2,offset/2);
-    } else { // ==1
-      set_ULONG(new_loca+iA*4,offset);
-    }
-
-    if (glyphs[b]&c) {
-      const int len=otf_get_glyph(otf,iA);
-      assert(len>=0);
-      memcpy(new_glyf+offset,otf->gly,len);
-      offset+=len;
-    }
-  }
-  // last entry
-  if (otf->indexToLocFormat==0) {
-    set_USHORT(new_loca+otf->numGlyphs*2,offset/2);
-  } else { // ==1
-    set_ULONG(new_loca+otf->numGlyphs*4,offset);
-  }
-  assert(offset==glyfSize);
-
-  // determine new tables.
-  struct _OTF_WRITE otw[]={ // sorted
-    // TODO: cmap only required in non-CID context   or always in CFF
-      {OTF_TAG('c','m','a','p'),otf_action_copy,otf,},
-      {OTF_TAG('c','v','t',' '),otf_action_copy,otf,},
-      {OTF_TAG('f','p','g','m'),otf_action_copy,otf,},
-      {OTF_TAG('g','l','y','f'),otf_action_replace,new_glyf,glyfSize},
-      {OTF_TAG('h','e','a','d'),otf_action_copy,otf,}, // _copy_head
-      {OTF_TAG('h','h','e','a'),otf_action_copy,otf,},
-      {OTF_TAG('h','m','t','x'),otf_action_copy,otf,},
-      {OTF_TAG('l','o','c','a'),otf_action_replace,new_loca,locaSize},
-      {OTF_TAG('m','a','x','p'),otf_action_copy,otf,},
-      {OTF_TAG('n','a','m','e'),otf_action_copy,otf,},
-      {OTF_TAG('p','r','e','p'),otf_action_copy,otf,},
-      // vhea vmtx (never used in PDF, but possible in PS>=3011)
-      {0,0,0,0}};
-
-  // and write them
-  int numTables=otf_intersect_tables(otf,otw);
-  int ret=otf_write_sfnt(otw,otf->version,numTables,output,context);
-
-  free(new_loca);
-  free(new_glyf);
-  return ret;
-
-  //TODO ? reduce cmap [to (1,0) ;-)]
-  //TODO (cmap for non-cid)
-}
-// }}}
-
-// TODO no subsetting actually done (for now)
-int otf_subset_cff(OTF_FILE *otf,BITSET glyphs,OUTPUT_FN output,void *context) // {{{ - returns number of bytes written
-{
-  assert(otf);
-  assert(output);
-
-// TODO char *new_cff=cff_subset(...);
-
-  // determine new tables.
-  struct _OTF_WRITE otw[]={
-      {OTF_TAG('C','F','F',' '),otf_action_copy,otf,},
-//      {OTF_TAG('C','F','F',' '),otf_action_replace,new_glyf,glyfSize},
-      {OTF_TAG('c','m','a','p'),otf_action_copy,otf,},
-#if 0 // not actually needed!
-      {OTF_TAG('c','v','t',' '),otf_action_copy,otf,},
-      {OTF_TAG('f','p','g','m'),otf_action_copy,otf,},
-      {OTF_TAG('h','e','a','d'),otf_action_copy,otf,}, // _copy_head
-      {OTF_TAG('h','h','e','a'),otf_action_copy,otf,},
-      {OTF_TAG('h','m','t','x'),otf_action_copy,otf,},
-      {OTF_TAG('m','a','x','p'),otf_action_copy,otf,},
-      {OTF_TAG('n','a','m','e'),otf_action_copy,otf,},
-      {OTF_TAG('p','r','e','p'),otf_action_copy,otf,},
-#endif
-      {0,0,0,0}};
-
-  // and write them
-  int numTables=otf_intersect_tables(otf,otw);
-  int ret=otf_write_sfnt(otw,otf->version,numTables,output,context);
-
-//  free(new_cff);
-  return ret;
-}
-// }}}
-
-//int copy_block(FILE *f,long pos,int length,OUTPUT_FN output,void *context);  // copied bytes or -1 (also on premature EOF)
-
-static int copy_block(FILE *f,long pos,int length,OUTPUT_FN output,void *context) // {{{
-{
-  assert(f);
-  assert(output);
-
-  char buf[4096];
-  int iA,ret;
-
-  ret=fseek(f,pos,SEEK_SET);
-  if (ret==-1) {
-    fprintf(stderr,"Seek failed: %s\n", strerror(errno));
-    return -1;
-  }
-  ret=0;
-  while (length>4096) {
-    iA=fread(buf,1,4096,f);
-    if (iA<4096) {
-      return -1;
-    }
-    (*output)(buf,iA,context);
-    ret+=iA;
-    length-=iA;
-  };
-  iA=fread(buf,1,length,f);
-  if (iA<length) {
-    return -1;
-  }
-  (*output)(buf,iA,context);
-  ret+=iA;
-
-  return ret;
-}
-// }}}
-
-int otf_cff_extract(OTF_FILE *otf,OUTPUT_FN output,void *context) // {{{ - returns number of bytes written
-{
-  assert(otf);
-  assert(output);
-
-  int idx=otf_find_table(otf,OTF_TAG('C','F','F',' '));
-  if (idx==-1) {
-    return -1;
-  }
-  const OTF_DIRENT *table=otf->tables+idx;
-
-  return copy_block(otf->f,table->offset,table->length,output,context);
-}
-// }}}
-
-// CFF *otf_get_cff(); // not load, but create by "substream"-in ctor
-#if 0 // TODO elsewhere : char *cff_subset(...);
-  // first pass: include all required glyphs
-  bit_set(glyphs,0); // .notdef always required
-  int glyfSize=0;
-  for (iA=0,b=0,c=1;iA<otf->numGlyphs;iA++,c<<=1) {
-    if (!c) {
-      b++;
-      c=1;
-    }
-    if (glyphs[b]&c) {
-// TODO: cff_glyph
-    }
-  }
-
-  // second pass: calculate new glyf and loca
-  char *new_cff=malloc(cffSize);
-  if (!new_cff) {
-    fprintf(stderr,"Bad alloc: %s\n", strerror(errno));
-    assert(0);
-    return -1;
-  }
-
-  int offset=0;
-  for (iA=0,b=0,c=1;iA<otf->numGlyphs;iA++,c<<=1) {
-    if (!c) {
-      b++;
-      c=1;
-    }
-    if (glyphs[b]&c) {
-//...
-    }
-  }
-  return new_cff;
-#endif
diff --git a/fontembed/test_analyze.c b/fontembed/test_analyze.c
deleted file mode 100644
index 3f42573..0000000
--- a/fontembed/test_analyze.c
+++ /dev/null
@@ -1,234 +0,0 @@
-#include "sfnt.h"
-#include "sfnt_int.h"
-#include "embed.h"
-#include "config.h"
-#include "embed_sfnt_int.h"
-#include <assert.h>
-#include <stdio.h>
-#include <stdlib.h>
-
-enum { WEIGHT_THIN=100,
-       WEIGHT_EXTRALIGHT=200, WEIGHT_ULTRALIGHT=200,
-       WEIGHT_LIGHT=300,
-       WEIGHT_NORMAL=400, WEIGHT_REGULAR=400,
-       WEIGHT_MEDIUM=500,
-       WEIGHT_SEMIBOLD=600, // DEMI
-       WEIGHT_BOLD=700,
-       WEIGHT_EXTRABOLD=800, WEIGHT_ULTRABOLD=800,
-       WEIGHT_BLACK=900, WEIGHT_HEAVY=900 };
-
-void show_post(OTF_FILE *otf) // {{{
-{
-  assert(otf);
-  int len=0;
-  char *buf;
-
-  buf=otf_get_table(otf,OTF_TAG('p','o','s','t'),&len);
-  if (!buf) {
-    assert(len==-1);
-    printf("No post table\n");
-    return;
-  }
-  // TODO: check len
-  printf("POST: (%d bytes)\n"
-         "  version: %08x\n"
-         "  italicAngle: %d.%d\n"
-         "  underlinePosition: %d\n"
-         "  underlineThickness: %d\n"
-         "  isFixedPitch: %d\n"
-         "  vmType42: %d %d\n"
-         "  vmType1: %d %d\n",len,
-         get_ULONG(buf),
-         get_LONG(buf+4)>>16,get_ULONG(buf+4)&0xffff,
-         get_SHORT(buf+8),
-         get_SHORT(buf+10),
-         get_ULONG(buf+12),
-         get_ULONG(buf+16),get_ULONG(buf+20),
-         get_ULONG(buf+24),get_ULONG(buf+38));
-  free(buf);
-}
-// }}}
-
-void show_name(OTF_FILE *otf) // {{{
-{
-  assert(otf);
-  int iA,len=0;
-  char *buf;
-
-  buf=otf_get_table(otf,OTF_TAG('n','a','m','e'),&len);
-  if (!buf) {
-    assert(len==-1);
-    printf("No name table\n");
-    return;
-  }
-  printf("NAME:\n");
-  int name_count=get_USHORT(buf+2);
-  const char *nstore=buf+get_USHORT(buf+4);
-  for (iA=0;iA<name_count;iA++) {
-    const char *nrec=buf+6+12*iA;
-    printf("  { platformID/encodingID/languageID/nameID: %d/%d/%d/%d\n"
-           "    length: %d, offset: %d, data                       :",
-           get_USHORT(nrec),
-           get_USHORT(nrec+2),
-           get_USHORT(nrec+4),
-           get_USHORT(nrec+6),
-           get_USHORT(nrec+8),
-           get_USHORT(nrec+10));
-    if (  (get_USHORT(nrec)==0)||
-          ( (get_USHORT(nrec)==3) )  ) { // WCHAR
-      int nlen=get_USHORT(nrec+8);
-      int npos=get_USHORT(nrec+10);
-      for (;nlen>0;nlen-=2,npos+=2) {
-        if (nstore[npos]!=0x00) {
-          printf("?");
-        } else {
-          printf("%c",nstore[npos+1]);
-        }
-      }
-      printf(" }\n");
-    } else {
-      printf("%.*s }\n",
-             get_USHORT(nrec+8),nstore+get_USHORT(nrec+10));
-    }
-  }
-  free(buf);
-}
-// }}}
-
-void show_cmap(OTF_FILE *otf) // {{{
-{
-  assert(otf);
-  int iA,len=0;
-
-  char *cmap=otf_get_table(otf,OTF_TAG('c','m','a','p'),&len);
-  if (!cmap) {
-    assert(len==-1);
-    printf("No cmap table\n");
-    return;
-  }
-  printf("cmap:\n");
-  assert(get_USHORT(cmap)==0x0000); // version
-  const int numTables=get_USHORT(cmap+2);
-  printf("  numTables: %d\n",numTables);
-  for (iA=0;iA<numTables;iA++) {
-    const char *nrec=cmap+4+8*iA;
-    const char *ndata=cmap+get_ULONG(nrec+4);
-    assert(ndata>=cmap+4+8*numTables);
-    printf("  platformID/encodingID: %d/%d\n"
-           "  offset: %d  data (format: %d, length: %d, language: %d);\n",
-           get_USHORT(nrec),get_USHORT(nrec+2),
-           get_ULONG(nrec+4),
-           get_USHORT(ndata),get_USHORT(ndata+2),get_USHORT(ndata+4));
-  }
-  free(cmap);
-}
-// }}}
-
-void show_glyf(OTF_FILE *otf,int full) // {{{
-{
-  assert(otf);
-
-  // ensure >glyphOffsets and >gly is there
-  if ( (!otf->gly)||(!otf->glyphOffsets) ) {
-    if (otf_load_glyf(otf)!=0) {
-      assert(0);
-      return;
-    }
-  }
-
-  int iA;
-  int compGlyf=0,zeroGlyf=0;
-
-  // {{{ glyf
-  assert(otf->gly);
-  for (iA=0;iA<otf->numGlyphs;iA++) {
-    int len=otf_get_glyph(otf,iA);
-    if (len==0) {
-      zeroGlyf++;
-    } else if (get_SHORT(otf->gly)==-1) {
-      compGlyf++;
-    }
-    if (full) {
-      printf("%d(%d) ",get_SHORT(otf->gly),len);
-    }
-  }
-  if (full) {
-    printf("\n");
-  }
-  printf("numGlyf(nonnull): %d(%d), composites: %d\n",otf->numGlyphs,otf->numGlyphs-zeroGlyf,compGlyf);
-  // }}}
-}
-// }}}
-
-void show_hmtx(OTF_FILE *otf) // {{{
-{
-  assert(otf);
-  int iA;
-
-  otf_get_width(otf,0); // load table.
-  if (!otf->hmtx) {
-    printf("NOTE: no hmtx table!\n");
-    return;
-  }
-  printf("hmtx (%d):\n",otf->numberOfHMetrics);
-  for (iA=0;iA<otf->numberOfHMetrics;iA++) {
-    printf("(%d,%d) ",
-           get_USHORT(otf->hmtx+iA*4),
-           get_SHORT(otf->hmtx+iA*4+2));
-  }
-  printf(" (last is repeated for the remaining %d glyphs)\n",otf->numGlyphs-otf->numberOfHMetrics);
-}
-// }}}
-
-int main(int argc,char **argv)
-{
-  const char *fn=TESTFONT;
-  if (argc==2) {
-    fn=argv[1];
-  }
-  OTF_FILE *otf=otf_load(fn);
-  assert(otf);
-  if (otf->numTTC) {
-    printf("TTC has %d fonts, using %d\n",otf->numTTC,otf->useTTC);
-  }
-  if (otf->version==0x00010000) {
-    printf("Got TTF 1.0\n");
-  } else if (otf->version==OTF_TAG('O','T','T','O')) {
-    printf("Got OTF(CFF)\n");
-  } else if (otf->version==OTF_TAG('t','r','u','e')) {
-    printf("Got TTF (true)\n");
-  } else if (otf->version==OTF_TAG('t','y','p','1')) {
-    printf("Got SFNT(Type1)\n");
-  }
-
-  printf("Has %d tables\n",otf->numTables);
-
-  int iA;
-  for (iA=0;iA<otf->numTables;iA++) {
-    printf("%c%c%c%c %d @%d\n",OTF_UNTAG(otf->tables[iA].tag),otf->tables[iA].length,otf->tables[iA].offset);
-  }
-  printf("unitsPerEm: %d, indexToLocFormat: %d\n",
-         otf->unitsPerEm,otf->indexToLocFormat);
-  printf("num glyphs: %d\n",otf->numGlyphs);
-  otf_get_width(otf,0); // load table.
-  printf("numberOfHMetrics: %d\n",otf->numberOfHMetrics);
-
-  printf("Embedding rights: %x\n",emb_otf_get_rights(otf));
-
-  show_post(otf);
-
-  show_name(otf);
-
-  show_cmap(otf);
-  // printf("%d %d\n",otf_from_unicode(otf,'A'),0);
-
-  if (!(otf->flags&OTF_F_FMT_CFF)) {
-    show_glyf(otf,1);
-  }
-
-  show_hmtx(otf);
-
-  otf_close(otf);
-
-  return 0;
-}
diff --git a/fontembed/test_pdf.c b/fontembed/test_pdf.c
deleted file mode 100644
index 565fd59..0000000
--- a/fontembed/test_pdf.c
+++ /dev/null
@@ -1,215 +0,0 @@
-#include "embed.h"
-#include "config.h"
-#include "sfnt.h"
-#include <assert.h>
-#include <stdio.h>
-#include <stdlib.h>
-
-static void example_outfn(const char *buf,int len,void *context) // {{{
-{
-  FILE *f=(FILE *)context;
-  if (fwrite(buf,1,len,f)!=len) {
-    fprintf(stderr,"Short write: %m\n");
-    assert(0);
-    return;
-  }
-}
-// }}}
-
-#define OBJ \
-    xref[xrefpos++]=ftell(f); \
-    fprintf(f,"%d 0 obj\n",xrefpos);
-
-#define ENDOBJ \
-    fprintf(f,"endobj\n");
-
-#define STREAMDICT \
-    OBJ; \
-    fprintf(f,"<<\n" \
-              "  /Length %d 0 R\n",xrefpos+1);
-
-#define STREAMDATA \
-    fprintf(f,">>\n" \
-              "stream\n"); \
-  stream_len=-ftell(f);
-
-#define STREAM \
-  STREAMDICT \
-  STREAMDATA
-
-#define ENDSTREAM \
-  stream_len+=ftell(f); \
-  fprintf(f,"endstream\n" \
-            "endobj\n"); \
-  OBJ; \
-  fprintf(f,"%d\n",stream_len); \
-  ENDOBJ;
-
-static inline void write_string(FILE *f,EMB_PARAMS *emb,const char *str) // {{{
-{
-  assert(f);
-  assert(emb);
-  int iA;
-
-  if (emb->plan&EMB_A_MULTIBYTE) {
-    putc('<',f);
-    for (iA=0;str[iA];iA++) {
-      const unsigned short gid=emb_get(emb,(unsigned char)str[iA]);
-      fprintf(f,"%04x",gid);
-    }
-    putc('>',f);
-  } else {
-    putc('(',f);
-    for (iA=0;str[iA];iA++) {
-      emb_get(emb,(unsigned char)str[iA]);
-    }
-    fprintf(f,"%s",str); // TODO
-    putc(')',f);
-  }
-}
-// }}}
-
-int main(int argc,char **argv)
-{
-  const char *fn=TESTFONT;
-  if (argc==2) {
-    fn=argv[1];
-  }
-  OTF_FILE *otf=otf_load(fn);
-  assert(otf);
-  FONTFILE *ff=fontfile_open_sfnt(otf);
-  EMB_PARAMS *emb=emb_new(ff,
-                          EMB_DEST_PDF16,
-                          EMB_C_FORCE_MULTIBYTE|
-                          EMB_C_TAKE_FONTFILE);
-
-  FILE *f=fopen("test.pdf","w");
-  assert(f);
-  int xref[100],xrefpos=3;
-  int stream_len;
-
-  fprintf(f,"%%PDF-1.3\n");
-  // content
-  STREAM;
-  fprintf(f,"BT\n" // content
-            "  100 100 Td\n"
-            "  /F1 10 Tf\n");
-  write_string(f,emb,"Hallo");
-  fprintf(f," Tj\n"
-            "ET\n");
-  ENDSTREAM;
-
-  emb_get(emb,'a');
-
-  // {{{ do font
-  EMB_PDF_FONTDESCR *fdes=emb_pdf_fontdescr(emb);
-  assert(fdes);
-  EMB_PDF_FONTWIDTHS *fwid=emb_pdf_fontwidths(emb);
-  assert(fwid);
-
-  STREAMDICT;
-  int ff_ref=xrefpos;
-  if (emb_pdf_get_fontfile_subtype(emb)) {
-    fprintf(f,"  /Subtype /%s\n",
-              emb_pdf_get_fontfile_subtype(emb));
-  }
-  if (emb->outtype==EMB_FMT_T1) {
-    fprintf(f,"  /Length1 ?\n"
-              "  /Length2 ?\n"
-              "  /Length3 ?\n");
-  } else if (emb->outtype==EMB_FMT_TTF) {
-    fprintf(f,"  /Length1 %d 0 R\n",xrefpos+2);
-  }
-  STREAMDATA;
-  const int outlen=emb_embed(emb,example_outfn,f);
-  ENDSTREAM;
-  if (emb->outtype==EMB_FMT_TTF) {
-    OBJ;
-    fprintf(f,"%d\n",outlen);
-    ENDOBJ;
-  }
-
-  OBJ;
-  const int fd_ref=xrefpos;
-  char *res=emb_pdf_simple_fontdescr(emb,fdes,ff_ref);
-  assert(res);
-  fputs(res,f);
-  free(res);
-  ENDOBJ;
-
-  OBJ;
-  int f_ref=xrefpos;
-  res=emb_pdf_simple_font(emb,fdes,fwid,fd_ref);
-  assert(res);
-  fputs(res,f);
-  free(res);
-  ENDOBJ;
-
-  if (emb->plan&EMB_A_MULTIBYTE) {
-    OBJ;
-    res=emb_pdf_simple_cidfont(emb,fdes->fontname,f_ref);
-    f_ref=xrefpos;
-    assert(res);
-    fputs(res,f);
-    free(res);
-    ENDOBJ;
-  }
-
-  free(fdes);
-  free(fwid);
-  // }}}
-
-  int iA;
-
-  xref[2]=ftell(f);
-  fprintf(f,"3 0 obj\n"
-            "<</Type/Page\n"
-            "  /Parent 2 0 R\n"
-            "  /MediaBox [0 0 595 842]\n"
-            "  /Contents 4 0 R\n"
-            "  /Resources <<\n"
-            "    /Font <<\n"
-            "      /F1 %d 0 R\n"
-            "    >>\n"
-            "  >>\n"
-            ">>\n"
-            "endobj\n",
-            f_ref);
-  xref[1]=ftell(f);
-  fprintf(f,"2 0 obj\n"
-            "<</Type/Pages\n"
-            "  /Count 1\n"
-            "  /Kids [3 0 R]"
-            ">>\n"
-            "endobj\n");
-  xref[0]=ftell(f);
-  fprintf(f,"1 0 obj\n"
-            "<</Type/Catalog\n"
-            "  /Pages 2 0 R\n"
-            ">>\n"
-            "endobj\n");
-  // {{{ pdf trailer
-  int xref_start=ftell(f);
-  fprintf(f,"xref\n"
-            "0 %d\n"
-            "%010d 65535 f \n",
-            xrefpos+1,0);
-  for (iA=0;iA<xrefpos;iA++) {
-    fprintf(f,"%010d 00000 n \n",xref[iA]);
-  }
-  fprintf(f,"trailer\n"
-          "<<\n"
-          "  /Size %d\n"
-          "  /Root 1 0 R\n"
-          ">>\n"
-          "startxref\n"
-          "%d\n"
-          "%%%%EOF\n",
-          xrefpos+1,xref_start);
-  // }}}
-  fclose(f);
-
-  emb_close(emb);
-
-  return 0;
-}
diff --git a/fontembed/test_ps.c b/fontembed/test_ps.c
deleted file mode 100644
index 1f8c2bb..0000000
--- a/fontembed/test_ps.c
+++ /dev/null
@@ -1,89 +0,0 @@
-#include "embed.h"
-#include "config.h"
-#include "sfnt.h"
-#include <assert.h>
-#include <stdio.h>
-#include <stdlib.h>
-
-const char *emb_otf_get_fontname(OTF_FILE *otf); // TODO
-
-static void example_outfn(const char *buf,int len,void *context) // {{{
-{
-  FILE *f=(FILE *)context;
-  if (fwrite(buf,1,len,f)!=len) {
-    fprintf(stderr,"Short write: %m\n");
-    assert(0);
-    return;
-  }
-}
-// }}}
-
-static inline void write_string(FILE *f,EMB_PARAMS *emb,const char *str) // {{{
-{
-  assert(f);
-  assert(emb);
-  int iA;
-
-  if (emb->plan&EMB_A_MULTIBYTE) {
-    putc('<',f);
-    for (iA=0;str[iA];iA++) {
-      const unsigned short gid=emb_get(emb,(unsigned char)str[iA]);
-      fprintf(f,"%04x",gid);
-    }
-    putc('>',f);
-  } else {
-    putc('(',f);
-    for (iA=0;str[iA];iA++) {
-      emb_get(emb,(unsigned char)str[iA]);
-    }
-    fprintf(f,"%s",str); // TODO
-    putc(')',f);
-  }
-}
-// }}}
-
-int main(int argc,char **argv)
-{
-  const char *fn=TESTFONT;
-  if (argc==2) {
-    fn=argv[1];
-  }
-  OTF_FILE *otf=otf_load(fn);
-  assert(otf);
-  FONTFILE *ff=fontfile_open_sfnt(otf);
-  EMB_PARAMS *emb=emb_new(ff,
-                          EMB_DEST_PS,
-//                          EMB_C_FORCE_MULTIBYTE| // not yet...
-                          EMB_C_TAKE_FONTFILE);
-
-  FILE *f=fopen("test.ps","w");
-  assert(f);
-
-  fprintf(f,"%%!PS-Adobe-2.0\n");
-
-  char *str="Hallo";
-
-  emb_get(emb,'a');
-
-  int iA;
-  for (iA=0;str[iA];iA++) {
-    emb_get(emb,(unsigned char)str[iA]);
-  }
-
-  emb_embed(emb,example_outfn,f);
-
-  // content
-  fprintf(f,"  100 100 moveto\n" // content
-            "  /%s findfont 10 scalefont setfont\n",emb_otf_get_fontname(emb->font->sfnt));
-  write_string(f,emb,"Hallo");
-// Note that write_string sets subset bits, but it's too late
-  fprintf(f," show\n"
-            "showpage\n");
-
-  fprintf(f,"%%%%EOF\n");
-  fclose(f);
-
-  emb_close(emb);
-
-  return 0;
-}
diff --git a/mime/cupsfilters-mupdf.convs b/mime/cupsfilters-mupdf.convs
deleted file mode 100644
index 20a68be..0000000
--- a/mime/cupsfilters-mupdf.convs
+++ /dev/null
@@ -1,19 +0,0 @@
-#
-#   MIME conversions file for OpenPrinting CUPS Filters.
-#
-#   Copyright 2007-2011 by Apple Inc.
-#   Copyright 1997-2007 by Easy Software Products.
-#   Copyright 2012-2016 by Till Kamppeter.
-#
-#   These coded instructions, statements, and computer programs are the
-#   property of Apple Inc. and are protected by Federal copyright
-#   law.  Distribution and use rights are outlined in the file "COPYING"
-#   which should have been included with this file.
-#
-
-#
-# MuPDF-based filters...
-#
-
-application/vnd.cups-pdf	application/vnd.cups-raster	101	mupdftoraster
-application/vnd.cups-pdf	image/pwg-raster		101	mupdftoraster
-- 
2.25.1

