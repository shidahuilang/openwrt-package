From 0fc0e0e0b89de3becd5f099eae725f13eeecc0d1 Mon Sep 17 00:00:00 2001
From: Wim Taymans <wtaymans@redhat.com>
Date: Tue, 25 Jun 2019 11:43:16 +0200
Subject: Remove USAC

---
 Makefile.am                         |    9 +-
 Makefile.vc                         |    9 +-
 libAACdec/src/aacdecoder.cpp        |   34 +-
 libAACdec/src/block.cpp             |  163 ---
 libAACdec/src/channel.cpp           |   70 +-
 libAACdec/src/channelinfo.h         |   91 --
 libAACdec/src/usacdec_ace_d4t64.cpp |  439 --------
 libAACdec/src/usacdec_ace_d4t64.h   |  117 --
 libAACdec/src/usacdec_ace_ltp.cpp   |  229 ----
 libAACdec/src/usacdec_ace_ltp.h     |  128 ---
 libAACdec/src/usacdec_acelp.cpp     | 1296 ----------------------
 libAACdec/src/usacdec_acelp.h       |  281 -----
 libAACdec/src/usacdec_const.h       |  203 ----
 libAACdec/src/usacdec_fac.cpp       |  745 -------------
 libAACdec/src/usacdec_fac.h         |  191 ----
 libAACdec/src/usacdec_lpc.cpp       | 1194 ---------------------
 libAACdec/src/usacdec_lpc.h         |  190 ----
 libAACdec/src/usacdec_lpd.cpp       | 2017 -----------------------------------
 libAACdec/src/usacdec_lpd.h         |  198 ----
 libAACdec/src/usacdec_rom.cpp       | 1504 --------------------------
 libAACdec/src/usacdec_rom.h         |  154 ---
 22 files changed, 6 insertions(+), 9258 deletions(-)
 delete mode 100644 libAACdec/src/usacdec_ace_d4t64.cpp
 delete mode 100644 libAACdec/src/usacdec_ace_d4t64.h
 delete mode 100644 libAACdec/src/usacdec_ace_ltp.cpp
 delete mode 100644 libAACdec/src/usacdec_ace_ltp.h
 delete mode 100644 libAACdec/src/usacdec_acelp.cpp
 delete mode 100644 libAACdec/src/usacdec_acelp.h
 delete mode 100644 libAACdec/src/usacdec_const.h
 delete mode 100644 libAACdec/src/usacdec_fac.cpp
 delete mode 100644 libAACdec/src/usacdec_fac.h
 delete mode 100644 libAACdec/src/usacdec_lpc.cpp
 delete mode 100644 libAACdec/src/usacdec_lpc.h
 delete mode 100644 libAACdec/src/usacdec_lpd.cpp
 delete mode 100644 libAACdec/src/usacdec_lpd.h
 delete mode 100644 libAACdec/src/usacdec_rom.cpp
 delete mode 100644 libAACdec/src/usacdec_rom.h

--- a/Makefile.am
+++ b/Makefile.am
@@ -57,14 +57,7 @@ AACDEC_SRC = \
     libAACdec/src/channelinfo.cpp \
     libAACdec/src/ldfiltbank.cpp \
     libAACdec/src/pulsedata.cpp \
-    libAACdec/src/stereo.cpp \
-    libAACdec/src/usacdec_ace_d4t64.cpp \
-    libAACdec/src/usacdec_ace_ltp.cpp \
-    libAACdec/src/usacdec_acelp.cpp \
-    libAACdec/src/usacdec_fac.cpp \
-    libAACdec/src/usacdec_lpc.cpp \
-    libAACdec/src/usacdec_lpd.cpp \
-    libAACdec/src/usacdec_rom.cpp
+    libAACdec/src/stereo.cpp
 
 AACENC_SRC = \
     libAACenc/src/aacEnc_ram.cpp \
--- a/Makefile.vc
+++ b/Makefile.vc
@@ -41,14 +41,7 @@ AACDEC_SRC = \
     libAACdec/src/channelinfo.cpp \
     libAACdec/src/ldfiltbank.cpp \
     libAACdec/src/pulsedata.cpp \
-    libAACdec/src/stereo.cpp \
-    libAACdec/src/usacdec_ace_d4t64.cpp \
-    libAACdec/src/usacdec_ace_ltp.cpp \
-    libAACdec/src/usacdec_acelp.cpp \
-    libAACdec/src/usacdec_fac.cpp \
-    libAACdec/src/usacdec_lpc.cpp \
-    libAACdec/src/usacdec_lpd.cpp \
-    libAACdec/src/usacdec_rom.cpp
+    libAACdec/src/stereo.cpp
 
 AACENC_SRC = \
     libAACenc/src/aacEnc_ram.cpp \
--- a/libAACdec/src/aacdecoder.cpp
+++ b/libAACdec/src/aacdecoder.cpp
@@ -161,8 +161,6 @@ amm-info@iis.fraunhofer.de
 
 #include "aacdec_pns.h"
 
-#include "usacdec_lpd.h"
-
 #include "ac_arith_coder.h"
 
 #include "tpdec_lib.h"
@@ -1942,17 +1940,6 @@ CAacDecoder_Init(HANDLE_AACDECODER self,
               goto bail;
             }
           }
-          if (elCh > 0) {
-            self->pAacDecoderStaticChannelInfo[ch - elCh]->nfRandomSeed =
-                (ULONG)0x3039;
-            if (self->elements[el2] == ID_USAC_CPE) {
-              if (asc->m_sc.m_usacConfig.element[el2].m_stereoConfigIndex !=
-                  1) {
-                self->pAacDecoderStaticChannelInfo[ch - elCh + 1]
-                    ->nfRandomSeed = (ULONG)0x10932;
-              }
-            }
-          }
         } /* for each element */
       }
 
@@ -2010,11 +1997,6 @@ CAacDecoder_Init(HANDLE_AACDECODER self,
                 self->pAacDecoderStaticChannelInfo[ch]->pOverlapBuffer,
                 OverlapBufferSize);
 
-      self->pAacDecoderStaticChannelInfo[ch]->last_core_mode = FD_LONG;
-      self->pAacDecoderStaticChannelInfo[ch]->last_lpd_mode = 255;
-
-      self->pAacDecoderStaticChannelInfo[ch]->last_tcx_pitch = L_DIV;
-
       /* Reset DRC control data for this channel */
       aacDecoder_drcInitChannelData(
           &self->pAacDecoderStaticChannelInfo[ch]->drcData);
@@ -2893,10 +2875,7 @@ LINKSPEC_CPP AAC_DECODER_ERROR CAacDecod
               (self->frameOK && !(flags & AACDEC_CONCEAL));
           const int icsIsInvalid = (GetScaleFactorBandsTransmitted(pIcsInfo) >
                                     GetScaleFactorBandsTotal(pIcsInfo));
-          const int icsInfoUsedinFadeOut =
-              !(pAacDecoderChannelInfo->renderMode == AACDEC_RENDER_LPD &&
-                pAacDecoderStaticChannelInfo->last_lpd_mode == 0);
-          if (icsInfoUsedinFadeOut && icsIsInvalid && !mute_release_active) {
+          if (icsIsInvalid && !mute_release_active) {
             self->frameOK = 0;
           }
         }
@@ -2956,16 +2935,7 @@ LINKSPEC_CPP AAC_DECODER_ERROR CAacDecod
                   2;
             } break;
             case AACDEC_RENDER_LPD:
-
-              CLpd_RenderTimeSignal(
-                  pAacDecoderStaticChannelInfo, pAacDecoderChannelInfo,
-                  pTimeData + offset, self->streamInfo.aacSamplesPerFrame,
-                  &self->samplingRateInfo[streamIndex],
-                  (self->frameOK && !(flags & AACDEC_CONCEAL) &&
-                   !frameOk_butConceal),
-                  flags, self->flags[streamIndex]);
-
-              self->extGainDelay = self->streamInfo.aacSamplesPerFrame;
+              ErrorStatus = AAC_DEC_UNKNOWN;
               break;
             default:
               ErrorStatus = AAC_DEC_UNKNOWN;
--- a/libAACdec/src/block.cpp
+++ b/libAACdec/src/block.cpp
@@ -107,9 +107,6 @@ amm-info@iis.fraunhofer.de
 #include "scale.h"
 #include "FDK_tools_rom.h"
 
-#include "usacdec_fac.h"
-#include "usacdec_lpd.h"
-#include "usacdec_lpc.h"
 #include "FDK_trigFcts.h"
 
 #include "ac_arith_coder.h"
@@ -1010,162 +1007,7 @@ void CBlock_FrequencyToTime(
       nSpec = 8;
       break;
   }
-
   {
-    int last_frame_lost = pAacDecoderStaticChannelInfo->last_lpc_lost;
-
-    if (pAacDecoderStaticChannelInfo->last_core_mode == LPD) {
-      INT fac_FB = 1;
-      if (elFlags & AC_EL_FULLBANDLPD) {
-        fac_FB = 2;
-      }
-
-      FIXP_DBL *synth;
-
-      /* Keep some free space at the beginning of the buffer. To be used for
-       * past data */
-      if (!(elFlags & AC_EL_LPDSTEREOIDX)) {
-        synth = pWorkBuffer1 + ((PIT_MAX_MAX - (1 * L_SUBFR)) * fac_FB);
-      } else {
-        synth = pWorkBuffer1 + PIT_MAX_MAX * fac_FB;
-      }
-
-      int fac_length =
-          (pAacDecoderChannelInfo->icsInfo.WindowSequence == BLOCK_SHORT)
-              ? (frameLen >> 4)
-              : (frameLen >> 3);
-
-      INT pitch[NB_SUBFR_SUPERFR + SYN_SFD];
-      FIXP_DBL pit_gain[NB_SUBFR_SUPERFR + SYN_SFD];
-
-      int nbDiv = (elFlags & AC_EL_FULLBANDLPD) ? 2 : 4;
-      int lFrame = (elFlags & AC_EL_FULLBANDLPD) ? frameLen / 2 : frameLen;
-      int nbSubfr =
-          lFrame / (nbDiv * L_SUBFR); /* number of subframes per division */
-      int LpdSfd = (nbDiv * nbSubfr) >> 1;
-      int SynSfd = LpdSfd - BPF_SFD;
-
-      FDKmemclear(
-          pitch,
-          sizeof(
-              pitch));  // added to prevent ferret errors in bass_pf_1sf_delay
-      FDKmemclear(pit_gain, sizeof(pit_gain));
-
-      /* FAC case */
-      if (pAacDecoderStaticChannelInfo->last_lpd_mode == 0 ||
-          pAacDecoderStaticChannelInfo->last_lpd_mode == 4) {
-        FIXP_DBL fac_buf[LFAC];
-        FIXP_LPC *A = pAacDecoderChannelInfo->data.usac.lp_coeff[0];
-
-        if (!frameOk || last_frame_lost ||
-            (pAacDecoderChannelInfo->data.usac.fac_data[0] == NULL)) {
-          FDKmemclear(fac_buf,
-                      pAacDecoderChannelInfo->granuleLength * sizeof(FIXP_DBL));
-          pAacDecoderChannelInfo->data.usac.fac_data[0] = fac_buf;
-          pAacDecoderChannelInfo->data.usac.fac_data_e[0] = 0;
-        }
-
-        INT A_exp; /* linear prediction coefficients exponent */
-        {
-          for (int i = 0; i < M_LP_FILTER_ORDER; i++) {
-            A[i] = FX_DBL2FX_LPC(fixp_cos(
-                fMult(pAacDecoderStaticChannelInfo->lpc4_lsf[i],
-                      FL2FXCONST_SGL((1 << LSPARG_SCALE) * M_PI / 6400.0)),
-                LSF_SCALE - LSPARG_SCALE));
-          }
-
-          E_LPC_f_lsp_a_conversion(A, A, &A_exp);
-        }
-
-#if defined(FDK_ASSERT_ENABLE)
-        nSamples =
-#endif
-            CLpd_FAC_Acelp2Mdct(
-                &pAacDecoderStaticChannelInfo->IMdct, synth,
-                SPEC_LONG(pAacDecoderChannelInfo->pSpectralCoefficient),
-                pAacDecoderChannelInfo->specScale, nSpec,
-                pAacDecoderChannelInfo->data.usac.fac_data[0],
-                pAacDecoderChannelInfo->data.usac.fac_data_e[0], fac_length,
-                frameLen, tl,
-                FDKgetWindowSlope(
-                    fr, GetWindowShape(&pAacDecoderChannelInfo->icsInfo)),
-                fr, A, A_exp, &pAacDecoderStaticChannelInfo->acelp,
-                (FIXP_DBL)0, /* FAC gain has already been applied. */
-                (last_frame_lost || !frameOk), 1,
-                pAacDecoderStaticChannelInfo->last_lpd_mode, 0,
-                pAacDecoderChannelInfo->currAliasingSymmetry);
-
-      } else {
-#if defined(FDK_ASSERT_ENABLE)
-        nSamples =
-#endif
-            imlt_block(
-                &pAacDecoderStaticChannelInfo->IMdct, synth,
-                SPEC_LONG(pAacDecoderChannelInfo->pSpectralCoefficient),
-                pAacDecoderChannelInfo->specScale, nSpec, frameLen, tl,
-                FDKgetWindowSlope(
-                    fl, GetWindowShape(&pAacDecoderChannelInfo->icsInfo)),
-                fl,
-                FDKgetWindowSlope(
-                    fr, GetWindowShape(&pAacDecoderChannelInfo->icsInfo)),
-                fr, (FIXP_DBL)0,
-                pAacDecoderChannelInfo->currAliasingSymmetry
-                    ? MLT_FLAG_CURR_ALIAS_SYMMETRY
-                    : 0);
-      }
-      FDK_ASSERT(nSamples == frameLen);
-
-      /* The "if" clause is entered both for fullbandLpd mono and
-       * non-fullbandLpd*. The "else"-> just for fullbandLpd stereo*/
-      if (!(elFlags & AC_EL_LPDSTEREOIDX)) {
-        FDKmemcpy(pitch, pAacDecoderStaticChannelInfo->old_T_pf,
-                  SynSfd * sizeof(INT));
-        FDKmemcpy(pit_gain, pAacDecoderStaticChannelInfo->old_gain_pf,
-                  SynSfd * sizeof(FIXP_DBL));
-
-        for (int i = SynSfd; i < LpdSfd + 3; i++) {
-          pitch[i] = L_SUBFR;
-          pit_gain[i] = (FIXP_DBL)0;
-        }
-
-        if (pAacDecoderStaticChannelInfo->last_lpd_mode == 0) {
-          pitch[SynSfd] = pitch[SynSfd - 1];
-          pit_gain[SynSfd] = pit_gain[SynSfd - 1];
-          if (IsLongBlock(&pAacDecoderChannelInfo->icsInfo)) {
-            pitch[SynSfd + 1] = pitch[SynSfd];
-            pit_gain[SynSfd + 1] = pit_gain[SynSfd];
-          }
-        }
-
-        /* Copy old data to the beginning of the buffer */
-        {
-          FDKmemcpy(
-              pWorkBuffer1, pAacDecoderStaticChannelInfo->old_synth,
-              ((PIT_MAX_MAX - (1 * L_SUBFR)) * fac_FB) * sizeof(FIXP_DBL));
-        }
-
-        FIXP_DBL *p2_synth = pWorkBuffer1 + (PIT_MAX_MAX * fac_FB);
-
-        /* recalculate pitch gain to allow postfilering on FAC area */
-        for (int i = 0; i < SynSfd + 2; i++) {
-          int T = pitch[i];
-          FIXP_DBL gain = pit_gain[i];
-
-          if (gain > (FIXP_DBL)0) {
-            gain = get_gain(&p2_synth[i * L_SUBFR * fac_FB],
-                            &p2_synth[(i * L_SUBFR * fac_FB) - fac_FB * T],
-                            L_SUBFR * fac_FB);
-            pit_gain[i] = gain;
-          }
-        }
-
-        bass_pf_1sf_delay(p2_synth, pitch, pit_gain, frameLen,
-                          (LpdSfd + 2) * L_SUBFR + BPF_SFD * L_SUBFR,
-                          frameLen - (LpdSfd + 4) * L_SUBFR, outSamples,
-                          pAacDecoderStaticChannelInfo->mem_bpf);
-      }
-
-    } else /* last_core_mode was not LPD */
     {
       FIXP_DBL *tmp =
           pAacDecoderChannelInfo->pComStaticData->pWorkBufferCore1->mdctOutTemp;
@@ -1190,11 +1032,6 @@ void CBlock_FrequencyToTime(
   }
 
   FDK_ASSERT(nSamples == frameLen);
-
-  pAacDecoderStaticChannelInfo->last_core_mode =
-      (pAacDecoderChannelInfo->icsInfo.WindowSequence == BLOCK_SHORT) ? FD_SHORT
-                                                                      : FD_LONG;
-  pAacDecoderStaticChannelInfo->last_lpd_mode = 255;
 }
 
 #include "ldfiltbank.h"
--- a/libAACdec/src/channel.cpp
+++ b/libAACdec/src/channel.cpp
@@ -106,9 +106,6 @@ amm-info@iis.fraunhofer.de
 #include "aacdec_tns.h"
 #include "FDK_bitstream.h"
 
-#include "usacdec_lpd.h"
-#include "usacdec_fac.h"
-
 static void MapMidSideMaskToPnsCorrelation(
     CAacDecoderChannelInfo *pAacDecoderChannelInfo[2]) {
   int group;
@@ -164,13 +161,6 @@ void CChannelElement_Decode(
   int maxSfBandsL = 0, maxSfBandsR = 0;
   int maybe_jstereo = (el_channels > 1);
 
-  if (flags & (AC_USAC | AC_RSVD50 | AC_RSV603DA) && el_channels == 2) {
-    if (pAacDecoderChannelInfo[L]->data.usac.core_mode ||
-        pAacDecoderChannelInfo[R]->data.usac.core_mode) {
-      maybe_jstereo = 0;
-    }
-  }
-
   if (maybe_jstereo) {
     maxSfBandsL =
         GetScaleFactorBandsTransmitted(&pAacDecoderChannelInfo[L]->icsInfo);
@@ -236,9 +226,6 @@ void CChannelElement_Decode(
 
   for (ch = 0; ch < el_channels; ch++) {
     if (pAacDecoderChannelInfo[ch]->renderMode == AACDEC_RENDER_LPD) {
-      /* Decode LPD data */
-      CLpdChannelStream_Decode(pAacDecoderChannelInfo[ch],
-                               pAacDecoderStaticChannelInfo[ch], flags);
     } else {
       UCHAR noSfbs =
           GetScaleFactorBandsTransmitted(&pAacDecoderChannelInfo[ch]->icsInfo);
@@ -651,13 +638,6 @@ AAC_DECODER_ERROR CChannelElement_Read(
         break;
       case core_mode:
         decision_bit = FDKreadBits(hBs, 1);
-        pAacDecoderChannelInfo[ch]->data.usac.core_mode = decision_bit;
-        if ((ch == 1) && (pAacDecoderChannelInfo[0]->data.usac.core_mode !=
-                          pAacDecoderChannelInfo[1]->data.usac.core_mode)) {
-          /* StereoCoreToolInfo(core_mode[ch] ) */
-          pAacDecoderChannelInfo[0]->pDynData->RawDataInfo.CommonWindow = 0;
-          pAacDecoderChannelInfo[1]->pDynData->RawDataInfo.CommonWindow = 0;
-        }
         break;
       case tns_active:
         pAacDecoderChannelInfo[0]->pDynData->specificTo.usac.tns_active =
@@ -671,53 +651,12 @@ AAC_DECODER_ERROR CChannelElement_Read(
         }
         break;
       case lpd_channel_stream:
-
-      {
-        error = CLpdChannelStream_Read(/* = lpd_channel_stream() */
-                                       hBs, pAacDecoderChannelInfo[ch],
-                                       pAacDecoderStaticChannelInfo[ch],
-                                       pSamplingRateInfo, flags);
-      }
-
         pAacDecoderChannelInfo[ch]->renderMode = AACDEC_RENDER_LPD;
         break;
       case fac_data: {
         int fFacDatPresent = FDKreadBit(hBs);
 
-        /* Wee need a valid fac_data[0] even if no FAC data is present (as
-         * temporal buffer) */
-        pAacDecoderChannelInfo[ch]->data.usac.fac_data[0] =
-            pAacDecoderChannelInfo[ch]->data.usac.fac_data0;
-
-        if (fFacDatPresent) {
-          if (elFlags & AC_EL_LFE) {
-            error = AAC_DEC_PARSE_ERROR;
-            break;
-          }
-          /* FAC data present, this frame is FD, so the last mode had to be
-           * ACELP. */
-          if (pAacDecoderStaticChannelInfo[ch]->last_core_mode != LPD ||
-              pAacDecoderStaticChannelInfo[ch]->last_lpd_mode != 0) {
-            pAacDecoderChannelInfo[ch]->data.usac.core_mode_last = LPD;
-            pAacDecoderChannelInfo[ch]->data.usac.lpd_mode_last = 0;
-            /* We can't change the past! So look to the future and go ahead! */
-          }
-          CLpd_FAC_Read(hBs, pAacDecoderChannelInfo[ch]->data.usac.fac_data[0],
-                        pAacDecoderChannelInfo[ch]->data.usac.fac_data_e,
-                        CLpd_FAC_getLength(
-                            IsLongBlock(&pAacDecoderChannelInfo[ch]->icsInfo),
-                            pAacDecoderChannelInfo[ch]->granuleLength),
-                        1, 0);
-        } else {
-          if (pAacDecoderStaticChannelInfo[ch]->last_core_mode == LPD &&
-              pAacDecoderStaticChannelInfo[ch]->last_lpd_mode == 0) {
-            /* ACELP to FD transitons without FAC are possible. That is why we
-            zero it out (i.e FAC will not be considered in the subsequent
-            calculations */
-            FDKmemclear(pAacDecoderChannelInfo[ch]->data.usac.fac_data0,
-                        LFAC * sizeof(FIXP_DBL));
-          }
-        }
+        error = AAC_DEC_PARSE_ERROR;
       } break;
       case esc2_rvlc:
         if (flags & AC_ER_RVLC) {
@@ -887,13 +826,6 @@ AAC_DECODER_ERROR CChannelElement_Read(
       if (error != AAC_DEC_OK) {
         return error;
       }
-
-      if (elFlags & AC_EL_USAC_NOISE) {
-        CBlock_ApplyNoise(pAacDecoderChannelInfo[ch], pSamplingRateInfo,
-                          &pAacDecoderStaticChannelInfo[ch]->nfRandomSeed,
-                          band_is_noise);
-
-      } /* if (elFlags & AC_EL_USAC_NOISE) */
     }
   }
 
--- a/libAACdec/src/channelinfo.h
+++ b/libAACdec/src/channelinfo.h
@@ -117,10 +117,6 @@ amm-info@iis.fraunhofer.de
 
 #include "aacdec_pns.h"
 
-#include "usacdec_acelp.h"
-#include "usacdec_const.h"
-#include "usacdec_rom.h"
-
 #include "ac_arith_coder.h"
 
 #include "aacdec_drc_types.h"
@@ -202,55 +198,6 @@ typedef struct {
 
   INT pnsCurrentSeed;
 
-  /* LPD memory */
-  FIXP_DBL old_synth[PIT_MAX_MAX - L_SUBFR];
-  INT old_T_pf[SYN_SFD];
-  FIXP_DBL old_gain_pf[SYN_SFD];
-  FIXP_DBL mem_bpf[L_FILT + L_SUBFR];
-  UCHAR
-  old_bpf_control_info; /* (1: enable, 0: disable) bpf for past superframe
-                         */
-
-  USAC_COREMODE last_core_mode; /* core mode used by the decoder in previous
-                                   frame. (not signalled by the bitstream, see
-                                   CAacDecoderChannelInfo::core_mode_last !! )
-                                 */
-  UCHAR last_lpd_mode;      /* LPD mode used by the decoder in last LPD subframe
-                                (not signalled by the bitstream, see
-                               CAacDecoderChannelInfo::lpd_mode_last !! ) */
-  UCHAR last_last_lpd_mode; /* LPD mode used in second last LPD subframe
-                                (not signalled by the bitstream) */
-  UCHAR last_lpc_lost;      /* Flag indicating that the previous LPC is lost */
-
-  FIXP_LPC
-  lpc4_lsf[M_LP_FILTER_ORDER]; /* Last LPC4 coefficients in LSF domain. */
-  FIXP_LPC lsf_adaptive_mean[M_LP_FILTER_ORDER]; /* Adaptive mean of LPC
-                                                    coefficients in LSF domain
-                                                    for concealment. */
-  FIXP_LPC lp_coeff_old[2][M_LP_FILTER_ORDER];   /* Last LPC coefficients in LP
-                                    domain. lp_coeff_old[0] is lpc4 (coeffs for
-                                    right folding point of last tcx frame),
-                                    lp_coeff_old[1] are coeffs for left folding
-                                    point of last tcx frame */
-  INT lp_coeff_old_exp[2];
-
-  FIXP_SGL
-  oldStability; /* LPC coeff stability value from last frame (required for
-                   TCX concealment). */
-  UINT numLostLpdFrames; /* Number of consecutive lost subframes. */
-
-  /* TCX memory */
-  FIXP_DBL last_tcx_gain;
-  INT last_tcx_gain_e;
-  FIXP_DBL last_alfd_gains[32]; /* Scaled by one bit. */
-  SHORT last_tcx_pitch;
-  UCHAR last_tcx_noise_factor;
-
-  /* ACELP memory */
-  CAcelpStaticMem acelp;
-
-  ULONG nfRandomSeed; /* seed value for USAC noise filling random generator */
-
   CDrcChannelData drcData;
 
   CpePersistentData *pCpeStaticData;
@@ -299,8 +246,6 @@ typedef shouldBeUnion {
    * used anymore. */
   FIXP_DBL mdctOutTemp[1024];
 
-  FIXP_DBL synth_buf[(PIT_MAX_MAX + SYN_DELAY + L_FRAME_PLUS)];
-
   FIXP_DBL workBuffer[WB_SECTION_SIZE];
 }
 CWorkBufferCore1;
@@ -335,42 +280,6 @@ typedef struct {
  */
 typedef struct {
   shouldBeUnion {
-    struct {
-      FIXP_DBL fac_data0[LFAC];
-      SCHAR fac_data_e[4];
-      FIXP_DBL
-      *fac_data[4]; /* Pointers to unused parts of pSpectralCoefficient */
-
-      UCHAR core_mode; /* current core mode */
-      USAC_COREMODE
-      core_mode_last;      /* previous core mode, signalled in the bitstream
-                              (not done by the decoder, see
-                              CAacDecoderStaticChannelInfo::last_core_mode !!)*/
-      UCHAR lpd_mode_last; /* previous LPD mode, signalled in the bitstream
-                              (not done by the decoder, see
-                              CAacDecoderStaticChannelInfo::last_core_mode !!)*/
-      UCHAR mod[4];
-      UCHAR bpf_control_info; /* (1: enable, 0: disable) bpf for current
-                                 superframe */
-
-      FIXP_LPC lsp_coeff[5][M_LP_FILTER_ORDER]; /* linear prediction
-                                                   coefficients in LSP domain */
-      FIXP_LPC
-      lp_coeff[5][M_LP_FILTER_ORDER]; /* linear prediction coefficients in
-                                         LP domain */
-      INT lp_coeff_exp[5];
-      FIXP_LPC lsf_adaptive_mean_cand
-          [M_LP_FILTER_ORDER]; /* concealment: is copied to
-                  CAacDecoderStaticChannelInfo->lsf_adaptive_mean once frame is
-                  assumed to be correct*/
-      FIXP_SGL aStability[4];  /* LPC coeff stability values required for ACELP
-                                  and TCX (concealment) */
-
-      CAcelpChannelData acelp[4];
-
-      FIXP_DBL tcx_gain[4];
-      SCHAR tcx_gain_e[4];
-    } usac;
 
     struct {
       CPnsData PnsData; /* Not required for USAC */
--- a/libAACdec/src/usacdec_ace_d4t64.cpp
+++ /dev/null
@@ -1,439 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/**************************** AAC decoder library ******************************
-
-   Author(s):
-
-   Description: ACELP
-
-*******************************************************************************/
-
-#include "usacdec_ace_d4t64.h"
-
-#define L_SUBFR 64 /* Subframe size              */
-
-/*
- * D_ACELP_add_pulse
- *
- * Parameters:
- *    pos         I: position of pulse
- *    nb_pulse    I: number of pulses
- *    track       I: track
- *    code        O: fixed codebook
- *
- * Function:
- *    Add pulses to fixed codebook
- *
- * Returns:
- *    void
- */
-static void D_ACELP_add_pulse(SHORT pos[], SHORT nb_pulse, SHORT track,
-                              FIXP_COD code[]) {
-  SHORT i, k;
-  for (k = 0; k < nb_pulse; k++) {
-    /* i = ((pos[k] & (16-1))*NB_TRACK) + track; */
-    i = ((pos[k] & (16 - 1)) << 2) + track;
-    if ((pos[k] & 16) == 0) {
-      code[i] = code[i] + (FIXP_COD)(512 << (COD_BITS - FRACT_BITS));
-    } else {
-      code[i] = code[i] - (FIXP_COD)(512 << (COD_BITS - FRACT_BITS));
-    }
-  }
-  return;
-}
-/*
- * D_ACELP_decode_1p_N1
- *
- * Parameters:
- *    index    I: pulse index
- *    N        I: number of bits for position
- *    offset   I: offset
- *    pos      O: position of the pulse
- *
- * Function:
- *    Decode 1 pulse with N+1 bits
- *
- * Returns:
- *    void
- */
-static void D_ACELP_decode_1p_N1(LONG index, SHORT N, SHORT offset,
-                                 SHORT pos[]) {
-  SHORT pos1;
-  LONG i, mask;
-
-  mask = ((1 << N) - 1);
-  /*
-   * Decode 1 pulse with N+1 bits
-   */
-  pos1 = (SHORT)((index & mask) + offset);
-  i = ((index >> N) & 1);
-  if (i == 1) {
-    pos1 += 16;
-  }
-  pos[0] = pos1;
-  return;
-}
-/*
- * D_ACELP_decode_2p_2N1
- *
- * Parameters:
- *    index    I: pulse index
- *    N        I: number of bits for position
- *    offset   I: offset
- *    pos      O: position of the pulse
- *
- * Function:
- *    Decode 2 pulses with 2*N+1 bits
- *
- * Returns:
- *    void
- */
-static void D_ACELP_decode_2p_2N1(LONG index, SHORT N, SHORT offset,
-                                  SHORT pos[]) {
-  SHORT pos1, pos2;
-  LONG mask, i;
-  mask = ((1 << N) - 1);
-  /*
-   * Decode 2 pulses with 2*N+1 bits
-   */
-  pos1 = (SHORT)(((index >> N) & mask) + offset);
-  i = (index >> (2 * N)) & 1;
-  pos2 = (SHORT)((index & mask) + offset);
-  if ((pos2 - pos1) < 0) {
-    if (i == 1) {
-      pos1 += 16;
-    } else {
-      pos2 += 16;
-    }
-  } else {
-    if (i == 1) {
-      pos1 += 16;
-      pos2 += 16;
-    }
-  }
-  pos[0] = pos1;
-  pos[1] = pos2;
-  return;
-}
-/*
- * D_ACELP_decode_3p_3N1
- *
- * Parameters:
- *    index    I: pulse index
- *    N        I: number of bits for position
- *    offset   I: offset
- *    pos      O: position of the pulse
- *
- * Function:
- *    Decode 3 pulses with 3*N+1 bits
- *
- * Returns:
- *    void
- */
-static void D_ACELP_decode_3p_3N1(LONG index, SHORT N, SHORT offset,
-                                  SHORT pos[]) {
-  SHORT j;
-  LONG mask, idx;
-
-  /*
-   * Decode 3 pulses with 3*N+1 bits
-   */
-  mask = ((1 << ((2 * N) - 1)) - 1);
-  idx = index & mask;
-  j = offset;
-  if (((index >> ((2 * N) - 1)) & 1) == 1) {
-    j += (1 << (N - 1));
-  }
-  D_ACELP_decode_2p_2N1(idx, N - 1, j, pos);
-  mask = ((1 << (N + 1)) - 1);
-  idx = (index >> (2 * N)) & mask;
-  D_ACELP_decode_1p_N1(idx, N, offset, pos + 2);
-  return;
-}
-/*
- * D_ACELP_decode_4p_4N1
- *
- * Parameters:
- *    index    I: pulse index
- *    N        I: number of bits for position
- *    offset   I: offset
- *    pos      O: position of the pulse
- *
- * Function:
- *    Decode 4 pulses with 4*N+1 bits
- *
- * Returns:
- *    void
- */
-static void D_ACELP_decode_4p_4N1(LONG index, SHORT N, SHORT offset,
-                                  SHORT pos[]) {
-  SHORT j;
-  LONG mask, idx;
-  /*
-   * Decode 4 pulses with 4*N+1 bits
-   */
-  mask = ((1 << ((2 * N) - 1)) - 1);
-  idx = index & mask;
-  j = offset;
-  if (((index >> ((2 * N) - 1)) & 1) == 1) {
-    j += (1 << (N - 1));
-  }
-  D_ACELP_decode_2p_2N1(idx, N - 1, j, pos);
-  mask = ((1 << ((2 * N) + 1)) - 1);
-  idx = (index >> (2 * N)) & mask;
-  D_ACELP_decode_2p_2N1(idx, N, offset, pos + 2);
-  return;
-}
-/*
- * D_ACELP_decode_4p_4N
- *
- * Parameters:
- *    index    I: pulse index
- *    N        I: number of bits for position
- *    offset   I: offset
- *    pos      O: position of the pulse
- *
- * Function:
- *    Decode 4 pulses with 4*N bits
- *
- * Returns:
- *    void
- */
-static void D_ACELP_decode_4p_4N(LONG index, SHORT N, SHORT offset,
-                                 SHORT pos[]) {
-  SHORT j, n_1;
-  /*
-   * Decode 4 pulses with 4*N bits
-   */
-  n_1 = N - 1;
-  j = offset + (1 << n_1);
-  switch ((index >> ((4 * N) - 2)) & 3) {
-    case 0:
-      if (((index >> ((4 * n_1) + 1)) & 1) == 0) {
-        D_ACELP_decode_4p_4N1(index, n_1, offset, pos);
-      } else {
-        D_ACELP_decode_4p_4N1(index, n_1, j, pos);
-      }
-      break;
-    case 1:
-      D_ACELP_decode_1p_N1((index >> ((3 * n_1) + 1)), n_1, offset, pos);
-      D_ACELP_decode_3p_3N1(index, n_1, j, pos + 1);
-      break;
-    case 2:
-      D_ACELP_decode_2p_2N1((index >> ((2 * n_1) + 1)), n_1, offset, pos);
-      D_ACELP_decode_2p_2N1(index, n_1, j, pos + 2);
-      break;
-    case 3:
-      D_ACELP_decode_3p_3N1((index >> (n_1 + 1)), n_1, offset, pos);
-      D_ACELP_decode_1p_N1(index, n_1, j, pos + 3);
-      break;
-  }
-  return;
-}
-
-/*
- * D_ACELP_decode_4t
- *
- * Parameters:
- *    index          I: index
- *    mode           I: speech mode
- *    code           I: (Q9) algebraic (fixed) codebook excitation
- *
- * Function:
- *    20, 36, 44, 52, 64, 72, 88 bits algebraic codebook.
- *    4 tracks x 16 positions per track = 64 samples.
- *
- *    20 bits 5+5+5+5 --> 4 pulses in a frame of 64 samples.
- *    36 bits 9+9+9+9 --> 8 pulses in a frame of 64 samples.
- *    44 bits 13+9+13+9 --> 10 pulses in a frame of 64 samples.
- *    52 bits 13+13+13+13 --> 12 pulses in a frame of 64 samples.
- *    64 bits 2+2+2+2+14+14+14+14 --> 16 pulses in a frame of 64 samples.
- *    72 bits 10+2+10+2+10+14+10+14 --> 18 pulses in a frame of 64 samples.
- *    88 bits 11+11+11+11+11+11+11+11 --> 24 pulses in a frame of 64 samples.
- *
- *    All pulses can have two (2) possible amplitudes: +1 or -1.
- *    Each pulse can sixteen (16) possible positions.
- *
- *    codevector length    64
- *    number of track      4
- *    number of position   16
- *
- * Returns:
- *    void
- */
-void D_ACELP_decode_4t64(SHORT index[], int nbits, FIXP_COD code[]) {
-  LONG L_index;
-  SHORT k, pos[6];
-
-  FDKmemclear(code, L_SUBFR * sizeof(FIXP_COD));
-
-  /* decode the positions and signs of pulses and build the codeword */
-  switch (nbits) {
-    case 12:
-      for (k = 0; k < 4; k += 2) {
-        L_index = index[2 * (k / 2) + 1];
-        D_ACELP_decode_1p_N1(L_index, 4, 0, pos);
-        D_ACELP_add_pulse(pos, 1, 2 * (index[2 * (k / 2)]) + k / 2, code);
-      }
-      break;
-    case 16: {
-      int i = 0;
-      int offset = index[i++];
-      offset = (offset == 0) ? 1 : 3;
-      for (k = 0; k < 4; k++) {
-        if (k != offset) {
-          L_index = index[i++];
-          D_ACELP_decode_1p_N1(L_index, 4, 0, pos);
-          D_ACELP_add_pulse(pos, 1, k, code);
-        }
-      }
-    } break;
-    case 20:
-      for (k = 0; k < 4; k++) {
-        L_index = (LONG)index[k];
-        D_ACELP_decode_1p_N1(L_index, 4, 0, pos);
-        D_ACELP_add_pulse(pos, 1, k, code);
-      }
-      break;
-    case 28:
-      for (k = 0; k < 4 - 2; k++) {
-        L_index = (LONG)index[k];
-        D_ACELP_decode_2p_2N1(L_index, 4, 0, pos);
-        D_ACELP_add_pulse(pos, 2, k, code);
-      }
-      for (k = 2; k < 4; k++) {
-        L_index = (LONG)index[k];
-        D_ACELP_decode_1p_N1(L_index, 4, 0, pos);
-        D_ACELP_add_pulse(pos, 1, k, code);
-      }
-      break;
-    case 36:
-      for (k = 0; k < 4; k++) {
-        L_index = (LONG)index[k];
-        D_ACELP_decode_2p_2N1(L_index, 4, 0, pos);
-        D_ACELP_add_pulse(pos, 2, k, code);
-      }
-      break;
-    case 44:
-      for (k = 0; k < 4 - 2; k++) {
-        L_index = (LONG)index[k];
-        D_ACELP_decode_3p_3N1(L_index, 4, 0, pos);
-        D_ACELP_add_pulse(pos, 3, k, code);
-      }
-      for (k = 2; k < 4; k++) {
-        L_index = (LONG)index[k];
-        D_ACELP_decode_2p_2N1(L_index, 4, 0, pos);
-        D_ACELP_add_pulse(pos, 2, k, code);
-      }
-      break;
-    case 52:
-      for (k = 0; k < 4; k++) {
-        L_index = (LONG)index[k];
-        D_ACELP_decode_3p_3N1(L_index, 4, 0, pos);
-        D_ACELP_add_pulse(pos, 3, k, code);
-      }
-      break;
-    case 64:
-      for (k = 0; k < 4; k++) {
-        L_index = (((LONG)index[k] << 14) + (LONG)index[k + 4]);
-        D_ACELP_decode_4p_4N(L_index, 4, 0, pos);
-        D_ACELP_add_pulse(pos, 4, k, code);
-      }
-      break;
-    default:
-      FDK_ASSERT(0);
-  }
-  return;
-}
--- a/libAACdec/src/usacdec_ace_d4t64.h
+++ /dev/null
@@ -1,117 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/**************************** AAC decoder library ******************************
-
-   Author(s):
-
-   Description: ACELP
-
-*******************************************************************************/
-
-#ifndef USACDEC_ACE_D4T64_H
-#define USACDEC_ACE_D4T64_H
-
-#include "common_fix.h"
-
-/* Data type definition for the fixed codebook vector */
-#define FIXP_COD FIXP_SGL
-#define FX_COD2FX_DBL(x) (FX_SGL2FX_DBL(x))
-#define FX_DBL2FX_COD(x) FX_DBL2FX_SGL((x) + (FIXP_DBL)0x8000)
-#define FX_SGL2FX_COD(x) (x)
-#define COD_BITS FRACT_BITS
-
-void D_ACELP_decode_4t64(SHORT index[], int nbits, FIXP_COD code[]);
-
-#endif /* USACDEC_ACE_D4T64_H */
--- a/libAACdec/src/usacdec_ace_ltp.cpp
+++ /dev/null
@@ -1,229 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/**************************** AAC decoder library ******************************
-
-   Author(s):   Matthias Hildenbrand
-
-   Description: USAC ACELP LTP filter
-
-*******************************************************************************/
-
-#include "usacdec_ace_ltp.h"
-
-#include "genericStds.h"
-#include "common_fix.h"
-
-#define UP_SAMP 4
-#define L_INTERPOL2 16
-#define L_SUBFR 64
-
-#define A2 FL2FX_SGL(2 * 0.18f)
-#define B FL2FX_SGL(0.64f)
-
-static const LONG Pred_lt4_inter4_2[UP_SAMP][L_INTERPOL2] = {
-    {(LONG)0x0000FFFC, (LONG)0x0008FFFC, (LONG)0xFFEB004C, (LONG)0xFF50014A,
-     (LONG)0xFDD90351, (LONG)0xFB2A06CD, (LONG)0xF6920D46, (LONG)0xEBB42B35,
-     (LONG)0x6D9EEF39, (LONG)0x0618FE0F, (LONG)0xFFE00131, (LONG)0xFE5501C5,
-     (LONG)0xFE5E015D, (LONG)0xFEF700B6, (LONG)0xFF920037, (LONG)0xFFEC0003},
-    {(LONG)0x0002FFF2, (LONG)0x0026FFBD, (LONG)0x005DFF98, (LONG)0x0055FFEF,
-     (LONG)0xFF89015F, (LONG)0xFD3A04E5, (LONG)0xF7D90DAA, (LONG)0xE67A50EE,
-     (LONG)0x50EEE67A, (LONG)0x0DAAF7D9, (LONG)0x04E5FD3A, (LONG)0x015FFF89,
-     (LONG)0xFFEF0055, (LONG)0xFF98005D, (LONG)0xFFBD0026, (LONG)0xFFF20002},
-    {(LONG)0x0003FFEC, (LONG)0x0037FF92, (LONG)0x00B6FEF7, (LONG)0x015DFE5E,
-     (LONG)0x01C5FE55, (LONG)0x0131FFE0, (LONG)0xFE0F0618, (LONG)0xEF396D9E,
-     (LONG)0x2B35EBB4, (LONG)0x0D46F692, (LONG)0x06CDFB2A, (LONG)0x0351FDD9,
-     (LONG)0x014AFF50, (LONG)0x004CFFEB, (LONG)0xFFFC0008, (LONG)0xFFFC0000},
-    {(LONG)0x0002FFF2, (LONG)0x002BFF9E, (LONG)0x00B9FECE, (LONG)0x01CFFD75,
-     (LONG)0x035EFBC1, (LONG)0x0521FA0C, (LONG)0x06AAF8C9, (LONG)0x07907852,
-     (LONG)0x0790F8C9, (LONG)0x06AAFA0C, (LONG)0x0521FBC1, (LONG)0x035EFD75,
-     (LONG)0x01CFFECE, (LONG)0x00B9FF9E, (LONG)0x002BFFF2, (LONG)0x00020000}};
-
-void Pred_lt4(FIXP_DBL exc[], /* in/out: excitation buffer              */
-              int T0,         /* input : integer pitch lag              */
-              int frac        /* input : fraction of lag in range 0..3  */
-) {
-  int j;
-  FIXP_DBL *x;
-  const LONG *interpol;
-  FIXP_DBL L_sumb, L_sumt;
-
-  x = &exc[-T0 - L_INTERPOL2 + 1];
-
-  /* remap frac and x:
-           0 -> 3   x (unchanged)
-           1 -> 0   x--
-           2 -> 1   x--
-           3 -> 2   x--
-  */
-
-  if (--frac < 0)
-    frac += UP_SAMP;
-  else
-    x--;
-
-  j = L_SUBFR + 1;
-  do {
-    LONG filt;
-    FIXP_DBL x0, x1;
-    FIXP_DBL *xi = x++;
-    interpol = Pred_lt4_inter4_2[frac];
-    int i = 3;
-
-    filt = *interpol++;
-    x0 = *xi++;
-    x1 = *xi++;
-    L_sumt = fMultDiv2(x0, (FIXP_SGL)((SHORT)(filt >> 16)));
-    L_sumb = fMultDiv2(x1, (FIXP_SGL)((SHORT)filt));
-    do {
-      filt = *interpol++;
-      x0 = *xi++;
-      x1 = *xi++;
-      L_sumt = fMultAddDiv2(L_sumt, x0, (FIXP_SGL)((SHORT)(filt >> 16)));
-      L_sumb = fMultAddDiv2(L_sumb, x1, (FIXP_SGL)((SHORT)filt));
-
-      filt = *interpol++;
-      x0 = *xi++;
-      x1 = *xi++;
-      L_sumt = fMultAddDiv2(L_sumt, x0, (FIXP_SGL)((SHORT)(filt >> 16)));
-      L_sumb = fMultAddDiv2(L_sumb, x1, (FIXP_SGL)((SHORT)filt));
-
-      filt = *interpol++;
-      x0 = *xi++;
-      x1 = *xi++;
-      L_sumt = fMultAddDiv2(L_sumt, x0, (FIXP_SGL)((SHORT)(filt >> 16)));
-      L_sumb = fMultAddDiv2(L_sumb, x1, (FIXP_SGL)((SHORT)filt));
-
-      filt = *interpol++;
-      x0 = *xi++;
-      x1 = *xi++;
-      L_sumt = fMultAddDiv2(L_sumt, x0, (FIXP_SGL)((SHORT)(filt >> 16)));
-      L_sumb = fMultAddDiv2(L_sumb, x1, (FIXP_SGL)((SHORT)filt));
-
-      filt = *interpol++;
-      x0 = *xi++;
-      x1 = *xi++;
-      L_sumt = fMultAddDiv2(L_sumt, x0, (FIXP_SGL)((SHORT)(filt >> 16)));
-      L_sumb = fMultAddDiv2(L_sumb, x1, (FIXP_SGL)((SHORT)filt));
-    } while (--i != 0);
-
-    L_sumb <<= 1;
-    L_sumb = fAddSaturate(L_sumt << 1, L_sumb);
-    *exc++ = L_sumb;
-  } while (--j != 0);
-  return;
-}
-
-void Pred_lt4_postfilter(FIXP_DBL exc[] /* in/out: excitation buffer */
-) {
-  /*
-  exc[i]   = A*exc[i-1] + B*exc[i] + A*exc[i+1]
-  exc[i+1] =              A*exc[i] + B*exc[i+1] + A*exc[i+2] ; i = 0:2:62
-  */
-  int i;
-  FIXP_DBL sum0, sum1, a_exc0, a_exc1;
-  a_exc0 = fMultDiv2(A2, exc[-1]);
-  a_exc1 = fMultDiv2(A2, exc[0]);
-
-  /* ARM926: 22 cycles/iteration */
-  for (i = 0; i < L_SUBFR; i += 2) {
-    sum0 = a_exc0 + fMult(B, exc[i]);
-    sum1 = a_exc1 + fMult(B, exc[i + 1]);
-    a_exc0 = fMultDiv2(A2, exc[i + 1]);
-    a_exc1 = fMultDiv2(A2, exc[i + 2]);
-    exc[i] = sum0 + a_exc0;
-    exc[i + 1] = sum1 + a_exc1;
-  }
-  return;
-}
--- a/libAACdec/src/usacdec_ace_ltp.h
+++ /dev/null
@@ -1,128 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/**************************** AAC decoder library ******************************
-
-   Author(s):   Matthias Hildenbrand
-
-   Description: USAC ACELP LTP filter
-
-*******************************************************************************/
-
-#ifndef USACDEC_ACE_LTP_H
-#define USACDEC_ACE_LTP_H
-
-#include "common_fix.h"
-
-/**
- * \brief Compute the initial adaptive codebook excitation v'(n) by
- * interpolating the past excitation vector u'(n).
- * \param exc points to adaptive codebook of current subframe (input/output)
- * \param T0 integer part of decoded pitch lag (input)
- * \param frac fractional part of decoded pitch lag (0..3) (input)
- */
-void Pred_lt4(FIXP_DBL exc[], /* in/out: excitation buffer */
-              int T0,         /* input : integer pitch lag */
-              int frac        /* input : fraction of lag   */
-);
-
-/**
- * \brief Compute the adaptive codebook excitation v(n) in case of
- * ltp_filtering_flag == 0.
- * \param exc points to adaptive codebook of current subframe (input/output)
- */
-void Pred_lt4_postfilter(FIXP_DBL exc[] /* in/out: excitation buffer */
-);
-
-#endif /* USACDEC_ACE_LTP_H */
--- a/libAACdec/src/usacdec_acelp.cpp
+++ /dev/null
@@ -1,1296 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/**************************** AAC decoder library ******************************
-
-   Author(s):   Matthias Hildenbrand
-
-   Description: USAC ACELP frame decoder
-
-*******************************************************************************/
-
-#include "usacdec_acelp.h"
-
-#include "usacdec_ace_d4t64.h"
-#include "usacdec_ace_ltp.h"
-#include "usacdec_rom.h"
-#include "usacdec_lpc.h"
-#include "genericStds.h"
-
-#define PIT_FR2_12k8 128 /* Minimum pitch lag with resolution 1/2      */
-#define PIT_FR1_12k8 160 /* Minimum pitch lag with resolution 1        */
-#define TILT_CODE2 \
-  FL2FXCONST_SGL(0.3f * 2.0f) /* ACELP code pre-emphasis factor ( *2 )      */
-#define PIT_SHARP \
-  FL2FXCONST_SGL(0.85f) /* pitch sharpening factor                    */
-#define PREEMPH_FAC \
-  FL2FXCONST_SGL(0.68f) /* ACELP synth pre-emphasis factor            */
-
-#define ACELP_HEADROOM 1
-#define ACELP_OUTSCALE (MDCT_OUT_HEADROOM - ACELP_HEADROOM)
-
-/**
- * \brief Calculate pre-emphasis (1 - mu z^-1) on input signal.
- * \param[in] in pointer to input signal; in[-1] is also needed.
- * \param[out] out pointer to output signal.
- * \param[in] L length of filtering.
- */
-/* static */
-void E_UTIL_preemph(const FIXP_DBL *in, FIXP_DBL *out, INT L) {
-  int i;
-
-  for (i = 0; i < L; i++) {
-    out[i] = in[i] - fMult(PREEMPH_FAC, in[i - 1]);
-  }
-
-  return;
-}
-
-/**
- * \brief Calculate de-emphasis 1/(1 - TILT_CODE z^-1) on innovative codebook
- * vector.
- * \param[in,out] x innovative codebook vector.
- */
-static void Preemph_code(
-    FIXP_COD x[] /* (i/o)   : input signal overwritten by the output */
-) {
-  int i;
-  FIXP_DBL L_tmp;
-
-  /* ARM926: 12 cycles per sample */
-  for (i = L_SUBFR - 1; i > 0; i--) {
-    L_tmp = FX_COD2FX_DBL(x[i]);
-    L_tmp -= fMultDiv2(x[i - 1], TILT_CODE2);
-    x[i] = FX_DBL2FX_COD(L_tmp);
-  }
-}
-
-/**
- * \brief Apply pitch sharpener to the innovative codebook vector.
- * \param[in,out] x innovative codebook vector.
- * \param[in] pit_lag decoded pitch lag.
- */
-static void Pit_shrp(
-    FIXP_COD x[], /* in/out: impulse response (or algebraic code) */
-    int pit_lag   /* input : pitch lag                            */
-) {
-  int i;
-  FIXP_DBL L_tmp;
-
-  for (i = pit_lag; i < L_SUBFR; i++) {
-    L_tmp = FX_COD2FX_DBL(x[i]);
-    L_tmp += fMult(x[i - pit_lag], PIT_SHARP);
-    x[i] = FX_DBL2FX_COD(L_tmp);
-  }
-
-  return;
-}
-
-  /**
-   * \brief Calculate Quantized codebook gain, Quantized pitch gain and unbiased
-   *        Innovative code vector energy.
-   * \param[in] index index of quantizer.
-   * \param[in] code innovative code vector with exponent = SF_CODE.
-   * \param[out] gain_pit Quantized pitch gain g_p with exponent = SF_GAIN_P.
-   * \param[out] gain_code Quantized codebook gain g_c.
-   * \param[in] mean_ener mean_ener defined in open-loop (2 bits), exponent = 7.
-   * \param[out] E_code unbiased innovative code vector energy.
-   * \param[out] E_code_e exponent of unbiased innovative code vector energy.
-   */
-
-#define SF_MEAN_ENER_LG10 9
-
-/* pow(10.0, {18, 30, 42, 54}/20.0) /(float)(1<<SF_MEAN_ENER_LG10) */
-static const FIXP_DBL pow_10_mean_energy[4] = {0x01fc5ebd, 0x07e7db92,
-                                               0x1f791f65, 0x7d4bfba3};
-
-static void D_gain2_plus(int index, FIXP_COD code[], FIXP_SGL *gain_pit,
-                         FIXP_DBL *gain_code, int mean_ener_bits, int bfi,
-                         FIXP_SGL *past_gpit, FIXP_DBL *past_gcode,
-                         FIXP_DBL *pEner_code, int *pEner_code_e) {
-  FIXP_DBL Ltmp;
-  FIXP_DBL gcode0, gcode_inov;
-  INT gcode0_e, gcode_inov_e;
-  int i;
-
-  FIXP_DBL ener_code;
-  INT ener_code_e;
-
-  /* ener_code = sum(code[]^2) */
-  ener_code = FIXP_DBL(0);
-  for (i = 0; i < L_SUBFR; i++) {
-    ener_code += fPow2Div2(code[i]);
-  }
-
-  ener_code_e = fMax(fNorm(ener_code) - 1, 0);
-  ener_code <<= ener_code_e;
-  ener_code_e = 2 * SF_CODE + 1 - ener_code_e;
-
-  /* export energy of code for calc_period_factor() */
-  *pEner_code = ener_code;
-  *pEner_code_e = ener_code_e;
-
-  ener_code += scaleValue(FL2FXCONST_DBL(0.01f), -ener_code_e);
-
-  /* ener_code *= 1/L_SUBFR, and make exponent even (because of square root
-   * below). */
-  if (ener_code_e & 1) {
-    ener_code_e -= 5;
-    ener_code >>= 1;
-  } else {
-    ener_code_e -= 6;
-  }
-  gcode_inov = invSqrtNorm2(ener_code, &gcode0_e);
-  gcode_inov_e = gcode0_e - (ener_code_e >> 1);
-
-  if (bfi) {
-    FIXP_DBL tgcode;
-    FIXP_SGL tgpit;
-
-    tgpit = *past_gpit;
-
-    if (tgpit > FL2FXCONST_SGL(0.95f / (1 << SF_GAIN_P))) {
-      tgpit = FL2FXCONST_SGL(0.95f / (1 << SF_GAIN_P));
-    } else if (tgpit < FL2FXCONST_SGL(0.5f / (1 << SF_GAIN_P))) {
-      tgpit = FL2FXCONST_SGL(0.5f / (1 << SF_GAIN_P));
-    }
-    *gain_pit = tgpit;
-    tgpit = FX_DBL2FX_SGL(fMult(tgpit, FL2FXCONST_DBL(0.95f)));
-    *past_gpit = tgpit;
-
-    tgpit = FL2FXCONST_SGL(1.4f / (1 << SF_GAIN_P)) - tgpit;
-    tgcode = fMult(*past_gcode, tgpit) << SF_GAIN_P;
-    *gain_code = scaleValue(fMult(tgcode, gcode_inov), gcode_inov_e);
-    *past_gcode = tgcode;
-
-    return;
-  }
-
-  /*-------------- Decode gains ---------------*/
-  /*
-   gcode0 = pow(10.0, (float)mean_ener/20.0);
-   gcode0 = gcode0 / sqrt(ener_code/L_SUBFR);
-   */
-  gcode0 = pow_10_mean_energy[mean_ener_bits];
-  gcode0 = fMultDiv2(gcode0, gcode_inov);
-  gcode0_e = gcode0_e + SF_MEAN_ENER_LG10 - (ener_code_e >> 1) + 1;
-
-  i = index << 1;
-  *gain_pit = fdk_t_qua_gain7b[i]; /* adaptive codebook gain */
-  /* t_qua_gain[ind2p1] : fixed codebook gain correction factor */
-  Ltmp = fMult(fdk_t_qua_gain7b[i + 1], gcode0);
-  *gain_code = scaleValue(Ltmp, gcode0_e - SF_GAIN_C + SF_QUA_GAIN7B);
-
-  /* update bad frame handler */
-  *past_gpit = *gain_pit;
-
-  /*--------------------------------------------------------
-    past_gcode  = gain_code/gcode_inov
-   --------------------------------------------------------*/
-  {
-    FIXP_DBL gcode_m;
-    INT gcode_e;
-
-    gcode_m = fDivNormHighPrec(Ltmp, gcode_inov, &gcode_e);
-    gcode_e += (gcode0_e - SF_GAIN_C + SF_QUA_GAIN7B) - (gcode_inov_e);
-    *past_gcode = scaleValue(gcode_m, gcode_e);
-  }
-}
-
-/**
- * \brief Calculate period/voicing factor r_v
- * \param[in] exc pitch excitation.
- * \param[in] gain_pit gain of pitch g_p.
- * \param[in] gain_code gain of code g_c.
- * \param[in] gain_code_e exponent of gain of code.
- * \param[in] ener_code unbiased innovative code vector energy.
- * \param[in] ener_code_e exponent of unbiased innovative code vector energy.
- * \return period/voice factor r_v (-1=unvoiced to 1=voiced), exponent SF_PFAC.
- */
-static FIXP_DBL calc_period_factor(FIXP_DBL exc[], FIXP_SGL gain_pit,
-                                   FIXP_DBL gain_code, FIXP_DBL ener_code,
-                                   int ener_code_e) {
-  int ener_exc_e, L_tmp_e, s = 0;
-  FIXP_DBL ener_exc, L_tmp;
-  FIXP_DBL period_fac;
-
-  /* energy of pitch excitation */
-  ener_exc = (FIXP_DBL)0;
-  for (int i = 0; i < L_SUBFR; i++) {
-    ener_exc += fPow2Div2(exc[i]) >> s;
-    if (ener_exc >= FL2FXCONST_DBL(0.5f)) {
-      ener_exc >>= 1;
-      s++;
-    }
-  }
-
-  ener_exc_e = fNorm(ener_exc);
-  ener_exc = fMult(ener_exc << ener_exc_e, fPow2(gain_pit));
-  if (ener_exc != (FIXP_DBL)0) {
-    ener_exc_e = 2 * SF_EXC + 1 + 2 * SF_GAIN_P - ener_exc_e + s;
-  } else {
-    ener_exc_e = 0;
-  }
-
-  /* energy of innovative code excitation */
-  /* L_tmp = ener_code * gain_code*gain_code; */
-  L_tmp_e = fNorm(gain_code);
-  L_tmp = fPow2(gain_code << L_tmp_e);
-  L_tmp = fMult(ener_code, L_tmp);
-  L_tmp_e = 2 * SF_GAIN_C + ener_code_e - 2 * L_tmp_e;
-
-  /* Find common exponent */
-  {
-    FIXP_DBL num, den;
-    int exp_diff;
-
-    exp_diff = ener_exc_e - L_tmp_e;
-    if (exp_diff >= 0) {
-      ener_exc >>= 1;
-      if (exp_diff <= DFRACT_BITS - 2) {
-        L_tmp >>= exp_diff + 1;
-      } else {
-        L_tmp = (FIXP_DBL)0;
-      }
-      den = ener_exc + L_tmp;
-      if (ener_exc_e < DFRACT_BITS - 1) {
-        den += scaleValue(FL2FXCONST_DBL(0.01f), -ener_exc_e - 1);
-      }
-    } else {
-      if (exp_diff >= -(DFRACT_BITS - 2)) {
-        ener_exc >>= 1 - exp_diff;
-      } else {
-        ener_exc = (FIXP_DBL)0;
-      }
-      L_tmp >>= 1;
-      den = ener_exc + L_tmp;
-      if (L_tmp_e < DFRACT_BITS - 1) {
-        den += scaleValue(FL2FXCONST_DBL(0.01f), -L_tmp_e - 1);
-      }
-    }
-    num = (ener_exc - L_tmp);
-    num >>= SF_PFAC;
-
-    if (den > (FIXP_DBL)0) {
-      if (ener_exc > L_tmp) {
-        period_fac = schur_div(num, den, 16);
-      } else {
-        period_fac = -schur_div(-num, den, 16);
-      }
-    } else {
-      period_fac = (FIXP_DBL)MAXVAL_DBL;
-    }
-  }
-
-  /* exponent = SF_PFAC */
-  return period_fac;
-}
-
-/*------------------------------------------------------------*
- * noise enhancer                                             *
- * ~~~~~~~~~~~~~~                                             *
- * - Enhance excitation on noise. (modify gain of code)       *
- *   If signal is noisy and LPC filter is stable, move gain   *
- *   of code 1.5 dB toward gain of code threshold.            *
- *   This decrease by 3 dB noise energy variation.            *
- *------------------------------------------------------------*/
-/**
- * \brief Enhance excitation on noise. (modify gain of code)
- * \param[in] gain_code Quantized codebook gain g_c, exponent = SF_GAIN_C.
- * \param[in] period_fac periodicity factor, exponent = SF_PFAC.
- * \param[in] stab_fac stability factor, exponent = SF_STAB.
- * \param[in,out] p_gc_threshold modified gain of previous subframe.
- * \return gain_code smoothed gain of code g_sc, exponent = SF_GAIN_C.
- */
-static FIXP_DBL
-noise_enhancer(/* (o) : smoothed gain g_sc                     SF_GAIN_C */
-               FIXP_DBL gain_code, /* (i) : Quantized codebook gain SF_GAIN_C */
-               FIXP_DBL period_fac, /* (i) : periodicity factor (-1=unvoiced to
-                                       1=voiced), SF_PFAC */
-               FIXP_SGL stab_fac,   /* (i) : stability factor (0 <= ... < 1.0)
-                                       SF_STAB   */
-               FIXP_DBL
-                   *p_gc_threshold) /* (io): gain of code threshold SF_GAIN_C */
-{
-  FIXP_DBL fac, L_tmp, gc_thres;
-
-  gc_thres = *p_gc_threshold;
-
-  L_tmp = gain_code;
-  if (L_tmp < gc_thres) {
-    L_tmp += fMultDiv2(gain_code,
-                       FL2FXCONST_SGL(2.0 * 0.19f)); /* +1.5dB => *(1.0+0.19) */
-    if (L_tmp > gc_thres) {
-      L_tmp = gc_thres;
-    }
-  } else {
-    L_tmp = fMult(gain_code,
-                  FL2FXCONST_SGL(1.0f / 1.19f)); /* -1.5dB => *10^(-1.5/20) */
-    if (L_tmp < gc_thres) {
-      L_tmp = gc_thres;
-    }
-  }
-  *p_gc_threshold = L_tmp;
-
-  /* voicing factor     lambda = 0.5*(1-period_fac) */
-  /* gain smoothing factor S_m = lambda*stab_fac  (=fac)
-                               = 0.5(stab_fac - stab_fac * period_fac) */
-  fac = (FX_SGL2FX_DBL(stab_fac) >> (SF_PFAC + 1)) -
-        fMultDiv2(stab_fac, period_fac);
-  /* fac_e = SF_PFAC + SF_STAB */
-  FDK_ASSERT(fac >= (FIXP_DBL)0);
-
-  /* gain_code = (float)((fac*tmp) + ((1.0-fac)*gain_code)); */
-  gain_code = fMult(fac, L_tmp) -
-              fMult(FL2FXCONST_DBL(-1.0f / (1 << (SF_PFAC + SF_STAB))) + fac,
-                    gain_code);
-  gain_code <<= (SF_PFAC + SF_STAB);
-
-  return gain_code;
-}
-
-/**
- * \brief Update adaptive codebook u'(n) (exc)
- *        Enhance pitch of c(n) and build post-processed excitation u(n) (exc2)
- * \param[in] code innovative codevector c(n), exponent = SF_CODE.
- * \param[in,out] exc filtered adaptive codebook v(n), exponent = SF_EXC.
- * \param[in] gain_pit adaptive codebook gain, exponent = SF_GAIN_P.
- * \param[in] gain_code innovative codebook gain g_c, exponent = SF_GAIN_C.
- * \param[in] gain_code_smoothed smoothed innov. codebook gain g_sc, exponent =
- * SF_GAIN_C.
- * \param[in] period_fac periodicity factor r_v, exponent = SF_PFAC.
- * \param[out] exc2 post-processed excitation u(n), exponent = SF_EXC.
- */
-void BuildAdaptiveExcitation(
-    FIXP_COD code[],    /* (i) : algebraic codevector c(n)             Q9  */
-    FIXP_DBL exc[],     /* (io): filtered adaptive codebook v(n)       Q15 */
-    FIXP_SGL gain_pit,  /* (i) : adaptive codebook gain g_p            Q14 */
-    FIXP_DBL gain_code, /* (i) : innovative codebook gain g_c          Q16 */
-    FIXP_DBL gain_code_smoothed, /* (i) : smoothed innov. codebook gain g_sc
-                                    Q16 */
-    FIXP_DBL period_fac, /* (i) : periodicity factor r_v                Q15 */
-    FIXP_DBL exc2[]      /* (o) : post-processed excitation u(n)        Q15 */
-) {
-/* Note: code[L_SUBFR] and exc2[L_SUBFR] share the same memory!
-         If exc2[i] is written, code[i] will be destroyed!
-*/
-#define SF (SF_CODE + SF_GAIN_C + 1 - SF_EXC)
-
-  int i;
-  FIXP_DBL tmp, cpe, code_smooth_prev, code_smooth;
-
-  FIXP_COD code_i;
-  FIXP_DBL cpe_code_smooth, cpe_code_smooth_prev;
-
-  /* cpe = (1+r_v)/8 * 2 ; ( SF = -1) */
-  cpe = (period_fac >> (2 - SF_PFAC)) + FL2FXCONST_DBL(0.25f);
-
-  /* u'(n) */
-  tmp = fMultDiv2(*exc, gain_pit) << (SF_GAIN_P + 1); /* v(0)*g_p */
-  *exc++ = tmp + (fMultDiv2(code[0], gain_code) << SF);
-
-  /* u(n) */
-  code_smooth_prev = fMultDiv2(*code++, gain_code_smoothed)
-                     << SF; /* c(0) * g_sc */
-  code_i = *code++;
-  code_smooth = fMultDiv2(code_i, gain_code_smoothed) << SF; /* c(1) * g_sc */
-  tmp += code_smooth_prev; /* tmp = v(0)*g_p + c(0)*g_sc */
-  cpe_code_smooth = fMultDiv2(cpe, code_smooth);
-  *exc2++ = tmp - cpe_code_smooth;
-  cpe_code_smooth_prev = fMultDiv2(cpe, code_smooth_prev);
-
-  i = L_SUBFR - 2;
-  do /* ARM926: 22 cycles per iteration */
-  {
-    /* u'(n) */
-    tmp = fMultDiv2(*exc, gain_pit) << (SF_GAIN_P + 1);
-    *exc++ = tmp + (fMultDiv2(code_i, gain_code) << SF);
-    /* u(n) */
-    tmp += code_smooth; /* += g_sc * c(i) */
-    tmp -= cpe_code_smooth_prev;
-    cpe_code_smooth_prev = cpe_code_smooth;
-    code_i = *code++;
-    code_smooth = fMultDiv2(code_i, gain_code_smoothed) << SF;
-    cpe_code_smooth = fMultDiv2(cpe, code_smooth);
-    *exc2++ = tmp - cpe_code_smooth; /* tmp - c_pe * g_sc * c(i+1) */
-  } while (--i != 0);
-
-  /* u'(n) */
-  tmp = fMultDiv2(*exc, gain_pit) << (SF_GAIN_P + 1);
-  *exc = tmp + (fMultDiv2(code_i, gain_code) << SF);
-  /* u(n) */
-  tmp += code_smooth;
-  tmp -= cpe_code_smooth_prev;
-  *exc2++ = tmp;
-
-  return;
-}
-
-/**
- * \brief Interpolate LPC vector in LSP domain for current subframe and convert
- * to LP domain
- * \param[in] lsp_old LPC vector (LSP domain) corresponding to the beginning of
- * current ACELP frame.
- * \param[in] lsp_new LPC vector (LSP domain) corresponding to the end of
- * current ACELP frame.
- * \param[in] subfr_nr number of current ACELP subframe 0..3.
- * \param[in] nb_subfr total number of ACELP subframes in this frame.
- * \param[out] A LP filter coefficients for current ACELP subframe, exponent =
- * SF_A_COEFFS.
- */
-/* static */
-void int_lpc_acelp(
-    const FIXP_LPC lsp_old[], /* input : LSPs from past frame              */
-    const FIXP_LPC lsp_new[], /* input : LSPs from present frame           */
-    int subfr_nr, int nb_subfr,
-    FIXP_LPC
-        A[], /* output: interpolated LP coefficients for current subframe */
-    INT *A_exp) {
-  int i;
-  FIXP_LPC lsp_interpol[M_LP_FILTER_ORDER];
-  FIXP_SGL fac_old, fac_new;
-
-  FDK_ASSERT((nb_subfr == 3) || (nb_subfr == 4));
-
-  fac_old = lsp_interpol_factor[nb_subfr & 0x1][(nb_subfr - 1) - subfr_nr];
-  fac_new = lsp_interpol_factor[nb_subfr & 0x1][subfr_nr];
-  for (i = 0; i < M_LP_FILTER_ORDER; i++) {
-    lsp_interpol[i] = FX_DBL2FX_LPC(
-        (fMultDiv2(lsp_old[i], fac_old) + fMultDiv2(lsp_new[i], fac_new)) << 1);
-  }
-
-  E_LPC_f_lsp_a_conversion(lsp_interpol, A, A_exp);
-
-  return;
-}
-
-/**
- * \brief Perform LP synthesis by filtering the post-processed excitation u(n)
- *        through the LP synthesis filter 1/A(z)
- * \param[in] a LP filter coefficients, exponent = SF_A_COEFFS.
- * \param[in] length length of input/output signal.
- * \param[in] x post-processed excitation u(n).
- * \param[in,out] y LP synthesis signal and filter memory
- * y[-M_LP_FILTER_ORDER..-1].
- */
-
-/* static */
-void Syn_filt(const FIXP_LPC a[], /* (i) : a[m] prediction coefficients Q12 */
-              const INT a_exp,
-              INT length,   /* (i) : length of input/output signal (64|128)   */
-              FIXP_DBL x[], /* (i) : input signal Qx  */
-              FIXP_DBL y[]  /* (i/o) : filter states / output signal  Qx-s*/
-) {
-  int i, j;
-  FIXP_DBL L_tmp;
-
-  for (i = 0; i < length; i++) {
-    L_tmp = (FIXP_DBL)0;
-
-    for (j = 0; j < M_LP_FILTER_ORDER; j++) {
-      L_tmp -= fMultDiv2(a[j], y[i - (j + 1)]) >> (LP_FILTER_SCALE - 1);
-    }
-
-    L_tmp = scaleValue(L_tmp, a_exp + LP_FILTER_SCALE);
-    y[i] = fAddSaturate(L_tmp, x[i]);
-  }
-
-  return;
-}
-
-/**
- * \brief Calculate de-emphasis 1/(1 - mu z^-1) on input signal.
- * \param[in] x input signal.
- * \param[out] y output signal.
- * \param[in] L length of signal.
- * \param[in,out] mem memory (signal[-1]).
- */
-/* static */
-void Deemph(FIXP_DBL *x, FIXP_DBL *y, int L, FIXP_DBL *mem) {
-  int i;
-  FIXP_DBL yi = *mem;
-
-  for (i = 0; i < L; i++) {
-    FIXP_DBL xi = x[i] >> 1;
-    xi = fMultAddDiv2(xi, PREEMPH_FAC, yi);
-    yi = SATURATE_LEFT_SHIFT(xi, 1, 32);
-    y[i] = yi;
-  }
-  *mem = yi;
-  return;
-}
-
-/**
- * \brief Compute the LP residual by filtering the input speech through the
- * analysis filter A(z).
- * \param[in] a LP filter coefficients, exponent = SF_A_COEFFS
- * \param[in] x input signal (note that values x[-m..-1] are needed), exponent =
- * SF_SYNTH
- * \param[out] y output signal (residual), exponent = SF_EXC
- * \param[in] l length of filtering
- */
-/* static */
-void E_UTIL_residu(const FIXP_LPC *a, const INT a_exp, FIXP_DBL *x, FIXP_DBL *y,
-                   INT l) {
-  FIXP_DBL s;
-  INT i, j;
-
-  /* (note that values x[-m..-1] are needed) */
-  for (i = 0; i < l; i++) {
-    s = (FIXP_DBL)0;
-
-    for (j = 0; j < M_LP_FILTER_ORDER; j++) {
-      s += fMultDiv2(a[j], x[i - j - 1]) >> (LP_FILTER_SCALE - 1);
-    }
-
-    s = scaleValue(s, a_exp + LP_FILTER_SCALE);
-    y[i] = fAddSaturate(s, x[i]);
-  }
-
-  return;
-}
-
-/* use to map subfr number to number of bits used for acb_index */
-static const UCHAR num_acb_idx_bits_table[2][NB_SUBFR] = {
-    {9, 6, 9, 6}, /* coreCoderFrameLength == 1024 */
-    {9, 6, 6, 0}  /* coreCoderFrameLength == 768  */
-};
-
-static int DecodePitchLag(HANDLE_FDK_BITSTREAM hBs,
-                          const UCHAR num_acb_idx_bits,
-                          const int PIT_MIN, /* TMIN */
-                          const int PIT_FR2, /* TFR2 */
-                          const int PIT_FR1, /* TFR1 */
-                          const int PIT_MAX, /* TMAX */
-                          int *pT0, int *pT0_frac, int *pT0_min, int *pT0_max) {
-  int acb_idx;
-  int error = 0;
-  int T0, T0_frac;
-
-  FDK_ASSERT((num_acb_idx_bits == 9) || (num_acb_idx_bits == 6));
-
-  acb_idx = FDKreadBits(hBs, num_acb_idx_bits);
-
-  if (num_acb_idx_bits == 6) {
-    /* When the pitch value is encoded on 6 bits, a pitch resolution of 1/4 is
-       always used in the range [T1-8, T1+7.75], where T1 is nearest integer to
-       the fractional pitch lag of the previous subframe.
-    */
-    T0 = *pT0_min + acb_idx / 4;
-    T0_frac = acb_idx & 0x3;
-  } else { /* num_acb_idx_bits == 9 */
-    /* When the pitch value is encoded on 9 bits, a fractional pitch delay is
-       used with resolutions 0.25 in the range [TMIN, TFR2-0.25], resolutions
-       0.5 in the range [TFR2, TFR1-0.5], and integers only in the range [TFR1,
-       TMAX]. NOTE: for small sampling rates TMAX can get smaller than TFR1.
-    */
-    int T0_min, T0_max;
-
-    if (acb_idx < (PIT_FR2 - PIT_MIN) * 4) {
-      /* first interval with 0.25 pitch resolution */
-      T0 = PIT_MIN + (acb_idx / 4);
-      T0_frac = acb_idx & 0x3;
-    } else if (acb_idx < ((PIT_FR2 - PIT_MIN) * 4 + (PIT_FR1 - PIT_FR2) * 2)) {
-      /* second interval with 0.5 pitch resolution */
-      acb_idx -= (PIT_FR2 - PIT_MIN) * 4;
-      T0 = PIT_FR2 + (acb_idx / 2);
-      T0_frac = (acb_idx & 0x1) * 2;
-    } else {
-      /* third interval with 1.0 pitch resolution */
-      T0 = acb_idx + PIT_FR1 - ((PIT_FR2 - PIT_MIN) * 4) -
-           ((PIT_FR1 - PIT_FR2) * 2);
-      T0_frac = 0;
-    }
-    /* find T0_min and T0_max for subframe 1 or 3 */
-    T0_min = T0 - 8;
-    if (T0_min < PIT_MIN) {
-      T0_min = PIT_MIN;
-    }
-    T0_max = T0_min + 15;
-    if (T0_max > PIT_MAX) {
-      T0_max = PIT_MAX;
-      T0_min = T0_max - 15;
-    }
-    *pT0_min = T0_min;
-    *pT0_max = T0_max;
-  }
-  *pT0 = T0;
-  *pT0_frac = T0_frac;
-
-  return error;
-}
-static void ConcealPitchLag(CAcelpStaticMem *acelp_mem, const int PIT_MAX,
-                            int *pT0, int *pT0_frac) {
-  USHORT *pold_T0 = &acelp_mem->old_T0;
-  UCHAR *pold_T0_frac = &acelp_mem->old_T0_frac;
-
-  if ((int)*pold_T0 >= PIT_MAX) {
-    *pold_T0 = (UCHAR)(PIT_MAX - 5);
-  }
-  *pT0 = (int)*pold_T0;
-  *pT0_frac = (int)*pold_T0_frac;
-}
-
-static UCHAR tab_coremode2nbits[8] = {20, 28, 36, 44, 52, 64, 12, 16};
-
-static int MapCoreMode2NBits(int core_mode) {
-  return (int)tab_coremode2nbits[core_mode];
-}
-
-void CLpd_AcelpDecode(CAcelpStaticMem *acelp_mem, INT i_offset,
-                      const FIXP_LPC lsp_old[M_LP_FILTER_ORDER],
-                      const FIXP_LPC lsp_new[M_LP_FILTER_ORDER],
-                      FIXP_SGL stab_fac, CAcelpChannelData *pAcelpData,
-                      INT numLostSubframes, int lastLpcLost, int frameCnt,
-                      FIXP_DBL synth[], int pT[], FIXP_DBL *pit_gain,
-                      INT coreCoderFrameLength) {
-  int i_subfr, subfr_nr, l_div, T;
-  int T0 = -1, T0_frac = -1; /* mark invalid */
-
-  int pit_gain_index = 0;
-
-  const int PIT_MAX = PIT_MAX_12k8 + (6 * i_offset); /* maximum pitch lag */
-
-  FIXP_COD *code;
-  FIXP_DBL *exc2;
-  FIXP_DBL *syn;
-  FIXP_DBL *exc;
-  FIXP_LPC A[M_LP_FILTER_ORDER];
-  INT A_exp;
-
-  FIXP_DBL period_fac;
-  FIXP_SGL gain_pit;
-  FIXP_DBL gain_code, gain_code_smooth, Ener_code;
-  int Ener_code_e;
-  int n;
-  int bfi = (numLostSubframes > 0) ? 1 : 0;
-
-  C_ALLOC_SCRATCH_START(
-      exc_buf, FIXP_DBL,
-      PIT_MAX_MAX + L_INTERPOL + L_DIV + 1); /* 411 + 17 + 256 + 1 = 685 */
-  C_ALLOC_SCRATCH_START(syn_buf, FIXP_DBL,
-                        M_LP_FILTER_ORDER + L_DIV); /* 16 + 256 = 272 */
-  /* use same memory for code[L_SUBFR] and exc2[L_SUBFR] */
-  C_ALLOC_SCRATCH_START(tmp_buf, FIXP_DBL, L_SUBFR); /* 64 */
-  /* make sure they don't overlap if they are accessed alternatingly in
-   * BuildAdaptiveExcitation() */
-#if (COD_BITS == FRACT_BITS)
-  code = (FIXP_COD *)(tmp_buf + L_SUBFR / 2);
-#elif (COD_BITS == DFRACT_BITS)
-  code = (FIXP_COD *)tmp_buf;
-#endif
-  exc2 = (FIXP_DBL *)tmp_buf;
-
-  syn = syn_buf + M_LP_FILTER_ORDER;
-  exc = exc_buf + PIT_MAX_MAX + L_INTERPOL;
-
-  FDKmemcpy(syn_buf, acelp_mem->old_syn_mem,
-            M_LP_FILTER_ORDER * sizeof(FIXP_DBL));
-  FDKmemcpy(exc_buf, acelp_mem->old_exc_mem,
-            (PIT_MAX_MAX + L_INTERPOL) * sizeof(FIXP_DBL));
-
-  FDKmemclear(exc_buf + (PIT_MAX_MAX + L_INTERPOL),
-              (L_DIV + 1) * sizeof(FIXP_DBL));
-
-  l_div = coreCoderFrameLength / NB_DIV;
-
-  for (i_subfr = 0, subfr_nr = 0; i_subfr < l_div;
-       i_subfr += L_SUBFR, subfr_nr++) {
-    /*-------------------------------------------------*
-     * - Decode pitch lag (T0 and T0_frac)             *
-     *-------------------------------------------------*/
-    if (bfi) {
-      ConcealPitchLag(acelp_mem, PIT_MAX, &T0, &T0_frac);
-    } else {
-      T0 = (int)pAcelpData->T0[subfr_nr];
-      T0_frac = (int)pAcelpData->T0_frac[subfr_nr];
-    }
-
-    /*-------------------------------------------------*
-     * - Find the pitch gain, the interpolation filter *
-     *   and the adaptive codebook vector.             *
-     *-------------------------------------------------*/
-    Pred_lt4(&exc[i_subfr], T0, T0_frac);
-
-    if ((!bfi && pAcelpData->ltp_filtering_flag[subfr_nr] == 0) ||
-        (bfi && numLostSubframes == 1 && stab_fac < FL2FXCONST_SGL(0.25f))) {
-      /* find pitch excitation with lp filter: v'(n) => v(n) */
-      Pred_lt4_postfilter(&exc[i_subfr]);
-    }
-
-    /*-------------------------------------------------------*
-     * - Decode innovative codebook.                         *
-     * - Add the fixed-gain pitch contribution to code[].    *
-     *-------------------------------------------------------*/
-    if (bfi) {
-      for (n = 0; n < L_SUBFR; n++) {
-        code[n] =
-            FX_SGL2FX_COD((FIXP_SGL)E_UTIL_random(&acelp_mem->seed_ace)) >> 4;
-      }
-    } else {
-      int nbits = MapCoreMode2NBits((int)pAcelpData->acelp_core_mode);
-      D_ACELP_decode_4t64(pAcelpData->icb_index[subfr_nr], nbits, &code[0]);
-    }
-
-    T = T0;
-    if (T0_frac > 2) {
-      T += 1;
-    }
-
-    Preemph_code(code);
-    Pit_shrp(code, T);
-
-    /* Output pitch lag for bass post-filter */
-    if (T > PIT_MAX) {
-      pT[subfr_nr] = PIT_MAX;
-    } else {
-      pT[subfr_nr] = T;
-    }
-    D_gain2_plus(
-        pAcelpData->gains[subfr_nr],
-        code,       /* (i)  : Innovative code vector, exponent = SF_CODE */
-        &gain_pit,  /* (o)  : Quantized pitch gain, exponent = SF_GAIN_P */
-        &gain_code, /* (o)  : Quantized codebook gain                    */
-        pAcelpData
-            ->mean_energy, /* (i)  : mean_ener defined in open-loop (2 bits) */
-        bfi, &acelp_mem->past_gpit, &acelp_mem->past_gcode,
-        &Ener_code,    /* (o)  : Innovative code vector energy              */
-        &Ener_code_e); /* (o)  : Innovative code vector energy exponent     */
-
-    pit_gain[pit_gain_index++] = FX_SGL2FX_DBL(gain_pit);
-
-    /* calc periodicity factor r_v */
-    period_fac =
-        calc_period_factor(/* (o) : factor (-1=unvoiced to 1=voiced)    */
-                           &exc[i_subfr], /* (i) : pitch excitation, exponent =
-                                             SF_EXC */
-                           gain_pit,      /* (i) : gain of pitch, exponent =
-                                             SF_GAIN_P */
-                           gain_code,     /* (i) : gain of code     */
-                           Ener_code,     /* (i) : Energy of code[]     */
-                           Ener_code_e);  /* (i) : Exponent of energy of code[]
-                                           */
-
-    if (lastLpcLost && frameCnt == 0) {
-      if (gain_pit > FL2FXCONST_SGL(1.0f / (1 << SF_GAIN_P))) {
-        gain_pit = FL2FXCONST_SGL(1.0f / (1 << SF_GAIN_P));
-      }
-    }
-
-    gain_code_smooth =
-        noise_enhancer(/* (o) : smoothed gain g_sc exponent = SF_GAIN_C */
-                       gain_code,  /* (i) : Quantized codebook gain  */
-                       period_fac, /* (i) : periodicity factor (-1=unvoiced to
-                                      1=voiced)  */
-                       stab_fac,   /* (i) : stability factor (0 <= ... < 1),
-                                      exponent = 1 */
-                       &acelp_mem->gc_threshold);
-
-    /* Compute adaptive codebook update u'(n), pitch enhancement c'(n) and
-     * post-processed excitation u(n). */
-    BuildAdaptiveExcitation(code, exc + i_subfr, gain_pit, gain_code,
-                            gain_code_smooth, period_fac, exc2);
-
-    /* Interpolate filter coeffs for current subframe in lsp domain and convert
-     * to LP domain */
-    int_lpc_acelp(lsp_old,  /* input : LSPs from past frame              */
-                  lsp_new,  /* input : LSPs from present frame           */
-                  subfr_nr, /* input : ACELP subframe index              */
-                  coreCoderFrameLength / L_DIV,
-                  A, /* output: LP coefficients of this subframe  */
-                  &A_exp);
-
-    Syn_filt(A, /* (i) : a[m] prediction coefficients               */
-             A_exp, L_SUBFR, /* (i) : length */
-             exc2, /* (i) : input signal                               */
-             &syn[i_subfr] /* (i/o) : filter states / output signal */
-    );
-
-  } /* end of subframe loop */
-
-  /* update pitch value for bfi procedure */
-  acelp_mem->old_T0_frac = T0_frac;
-  acelp_mem->old_T0 = T0;
-
-  /* save old excitation and old synthesis memory for next ACELP frame */
-  FDKmemcpy(acelp_mem->old_exc_mem, exc + l_div - (PIT_MAX_MAX + L_INTERPOL),
-            sizeof(FIXP_DBL) * (PIT_MAX_MAX + L_INTERPOL));
-  FDKmemcpy(acelp_mem->old_syn_mem, syn_buf + l_div,
-            sizeof(FIXP_DBL) * M_LP_FILTER_ORDER);
-
-  Deemph(syn, synth, l_div,
-         &acelp_mem->de_emph_mem); /* ref soft: mem = synth[-1] */
-
-  scaleValues(synth, l_div, -ACELP_OUTSCALE);
-  acelp_mem->deemph_mem_wsyn = acelp_mem->de_emph_mem;
-
-  C_ALLOC_SCRATCH_END(tmp_buf, FIXP_DBL, L_SUBFR);
-  C_ALLOC_SCRATCH_END(syn_buf, FIXP_DBL, M_LP_FILTER_ORDER + L_DIV);
-  C_ALLOC_SCRATCH_END(exc_buf, FIXP_DBL, PIT_MAX_MAX + L_INTERPOL + L_DIV + 1);
-  return;
-}
-
-void CLpd_AcelpReset(CAcelpStaticMem *acelp) {
-  acelp->gc_threshold = (FIXP_DBL)0;
-
-  acelp->past_gpit = (FIXP_SGL)0;
-  acelp->past_gcode = (FIXP_DBL)0;
-  acelp->old_T0 = 64;
-  acelp->old_T0_frac = 0;
-  acelp->deemph_mem_wsyn = (FIXP_DBL)0;
-  acelp->wsyn_rms = (FIXP_DBL)0;
-  acelp->seed_ace = 0;
-}
-
-/* TCX time domain concealment */
-/*   Compare to figure 13a on page 54 in 3GPP TS 26.290 */
-void CLpd_TcxTDConceal(CAcelpStaticMem *acelp_mem, SHORT *pitch,
-                       const FIXP_LPC lsp_old[M_LP_FILTER_ORDER],
-                       const FIXP_LPC lsp_new[M_LP_FILTER_ORDER],
-                       const FIXP_SGL stab_fac, INT nLostSf, FIXP_DBL synth[],
-                       INT coreCoderFrameLength, UCHAR last_tcx_noise_factor) {
-  /* repeat past excitation with pitch from previous decoded TCX frame */
-  C_ALLOC_SCRATCH_START(
-      exc_buf, FIXP_DBL,
-      PIT_MAX_MAX + L_INTERPOL + L_DIV); /* 411 +  17 + 256 + 1 =  */
-  C_ALLOC_SCRATCH_START(syn_buf, FIXP_DBL,
-                        M_LP_FILTER_ORDER + L_DIV); /* 256 +  16           =  */
-                                                    /*                    +=  */
-  FIXP_DBL ns_buf[L_DIV + 1];
-  FIXP_DBL *syn = syn_buf + M_LP_FILTER_ORDER;
-  FIXP_DBL *exc = exc_buf + PIT_MAX_MAX + L_INTERPOL;
-  FIXP_DBL *ns = ns_buf + 1;
-  FIXP_DBL tmp, fact_exc;
-  INT T = fMin(*pitch, (SHORT)PIT_MAX_MAX);
-  int i, i_subfr, subfr_nr;
-  int lDiv = coreCoderFrameLength / NB_DIV;
-
-  FDKmemcpy(syn_buf, acelp_mem->old_syn_mem,
-            M_LP_FILTER_ORDER * sizeof(FIXP_DBL));
-  FDKmemcpy(exc_buf, acelp_mem->old_exc_mem,
-            (PIT_MAX_MAX + L_INTERPOL) * sizeof(FIXP_DBL));
-
-  /* if we lost all packets (i.e. 1 packet of TCX-20 ms, 2 packets of
-     the TCX-40 ms or 4 packets of the TCX-80ms), we lost the whole
-     coded frame extrapolation strategy: repeat lost excitation and
-     use extrapolated LSFs */
-
-  /* AMR-WB+ like TCX TD concealment */
-
-  /* number of lost frame cmpt */
-  if (nLostSf < 2) {
-    fact_exc = FL2FXCONST_DBL(0.8f);
-  } else {
-    fact_exc = FL2FXCONST_DBL(0.4f);
-  }
-
-  /* repeat past excitation */
-  for (i = 0; i < lDiv; i++) {
-    exc[i] = fMult(fact_exc, exc[i - T]);
-  }
-
-  tmp = fMult(fact_exc, acelp_mem->wsyn_rms);
-  acelp_mem->wsyn_rms = tmp;
-
-  /* init deemph_mem_wsyn */
-  acelp_mem->deemph_mem_wsyn = exc[-1];
-
-  ns[-1] = acelp_mem->deemph_mem_wsyn;
-
-  for (i_subfr = 0, subfr_nr = 0; i_subfr < lDiv;
-       i_subfr += L_SUBFR, subfr_nr++) {
-    FIXP_DBL tRes[L_SUBFR];
-    FIXP_LPC A[M_LP_FILTER_ORDER];
-    INT A_exp;
-
-    /* interpolate LPC coefficients */
-    int_lpc_acelp(lsp_old, lsp_new, subfr_nr, lDiv / L_SUBFR, A, &A_exp);
-
-    Syn_filt(A,              /* (i) : a[m] prediction coefficients         */
-             A_exp, L_SUBFR, /* (i) : length                               */
-             &exc[i_subfr],  /* (i) : input signal                         */
-             &syn[i_subfr]   /* (i/o) : filter states / output signal      */
-    );
-
-    E_LPC_a_weight(
-        A, A,
-        M_LP_FILTER_ORDER); /* overwrite A as it is not needed any longer */
-
-    E_UTIL_residu(A, A_exp, &syn[i_subfr], tRes, L_SUBFR);
-
-    Deemph(tRes, &ns[i_subfr], L_SUBFR, &acelp_mem->deemph_mem_wsyn);
-
-    /* Amplitude limiter (saturate at wsyn_rms) */
-    for (i = i_subfr; i < i_subfr + L_SUBFR; i++) {
-      if (ns[i] > tmp) {
-        ns[i] = tmp;
-      } else {
-        if (ns[i] < -tmp) {
-          ns[i] = -tmp;
-        }
-      }
-    }
-
-    E_UTIL_preemph(&ns[i_subfr], tRes, L_SUBFR);
-
-    Syn_filt(A,              /* (i) : a[m] prediction coefficients         */
-             A_exp, L_SUBFR, /* (i) : length                               */
-             tRes,           /* (i) : input signal                         */
-             &syn[i_subfr]   /* (i/o) : filter states / output signal      */
-    );
-
-    FDKmemmove(&synth[i_subfr], &syn[i_subfr], L_SUBFR * sizeof(FIXP_DBL));
-  }
-
-  /* save old excitation and old synthesis memory for next ACELP frame */
-  FDKmemcpy(acelp_mem->old_exc_mem, exc + lDiv - (PIT_MAX_MAX + L_INTERPOL),
-            sizeof(FIXP_DBL) * (PIT_MAX_MAX + L_INTERPOL));
-  FDKmemcpy(acelp_mem->old_syn_mem, syn_buf + lDiv,
-            sizeof(FIXP_DBL) * M_LP_FILTER_ORDER);
-  acelp_mem->de_emph_mem = acelp_mem->deemph_mem_wsyn;
-
-  C_ALLOC_SCRATCH_END(syn_buf, FIXP_DBL, M_LP_FILTER_ORDER + L_DIV);
-  C_ALLOC_SCRATCH_END(exc_buf, FIXP_DBL, PIT_MAX_MAX + L_INTERPOL + L_DIV);
-}
-
-void Acelp_PreProcessing(FIXP_DBL *synth_buf, FIXP_DBL *old_synth, INT *pitch,
-                         INT *old_T_pf, FIXP_DBL *pit_gain,
-                         FIXP_DBL *old_gain_pf, INT samplingRate, INT *i_offset,
-                         INT coreCoderFrameLength, INT synSfd,
-                         INT nbSubfrSuperfr) {
-  int n;
-
-  /* init beginning of synth_buf with old synthesis from previous frame */
-  FDKmemcpy(synth_buf, old_synth, sizeof(FIXP_DBL) * (PIT_MAX_MAX - BPF_DELAY));
-
-  /* calculate pitch lag offset for ACELP decoder */
-  *i_offset =
-      (samplingRate * PIT_MIN_12k8 + (FSCALE_DENOM / 2)) / FSCALE_DENOM -
-      PIT_MIN_12k8;
-
-  /* for bass postfilter */
-  for (n = 0; n < synSfd; n++) {
-    pitch[n] = old_T_pf[n];
-    pit_gain[n] = old_gain_pf[n];
-  }
-  for (n = 0; n < nbSubfrSuperfr; n++) {
-    pitch[n + synSfd] = L_SUBFR;
-    pit_gain[n + synSfd] = (FIXP_DBL)0;
-  }
-}
-
-void Acelp_PostProcessing(FIXP_DBL *synth_buf, FIXP_DBL *old_synth, INT *pitch,
-                          INT *old_T_pf, INT coreCoderFrameLength, INT synSfd,
-                          INT nbSubfrSuperfr) {
-  int n;
-
-  /* store last part of synth_buf (which is not handled by the IMDCT overlap)
-   * for next frame */
-  FDKmemcpy(old_synth, synth_buf + coreCoderFrameLength,
-            sizeof(FIXP_DBL) * (PIT_MAX_MAX - BPF_DELAY));
-
-  /* for bass postfilter */
-  for (n = 0; n < synSfd; n++) {
-    old_T_pf[n] = pitch[nbSubfrSuperfr + n];
-  }
-}
-
-#define L_FAC_ZIR (LFAC)
-
-void CLpd_Acelp_Zir(const FIXP_LPC A[], const INT A_exp,
-                    CAcelpStaticMem *acelp_mem, const INT length,
-                    FIXP_DBL zir[], int doDeemph) {
-  C_ALLOC_SCRATCH_START(tmp_buf, FIXP_DBL, L_FAC_ZIR + M_LP_FILTER_ORDER);
-  FDK_ASSERT(length <= L_FAC_ZIR);
-
-  FDKmemcpy(tmp_buf, acelp_mem->old_syn_mem,
-            M_LP_FILTER_ORDER * sizeof(FIXP_DBL));
-  FDKmemset(tmp_buf + M_LP_FILTER_ORDER, 0, L_FAC_ZIR * sizeof(FIXP_DBL));
-
-  Syn_filt(A, A_exp, length, &tmp_buf[M_LP_FILTER_ORDER],
-           &tmp_buf[M_LP_FILTER_ORDER]);
-  if (!doDeemph) {
-    /* if last lpd mode was TD concealment, then bypass deemph */
-    FDKmemcpy(zir, tmp_buf, length * sizeof(*zir));
-  } else {
-    Deemph(&tmp_buf[M_LP_FILTER_ORDER], &zir[0], length,
-           &acelp_mem->de_emph_mem);
-    scaleValues(zir, length, -ACELP_OUTSCALE);
-  }
-  C_ALLOC_SCRATCH_END(tmp_buf, FIXP_DBL, L_FAC_ZIR + M_LP_FILTER_ORDER);
-}
-
-void CLpd_AcelpPrepareInternalMem(const FIXP_DBL *synth, UCHAR last_lpd_mode,
-                                  UCHAR last_last_lpd_mode,
-                                  const FIXP_LPC *A_new, const INT A_new_exp,
-                                  const FIXP_LPC *A_old, const INT A_old_exp,
-                                  CAcelpStaticMem *acelp_mem,
-                                  INT coreCoderFrameLength, INT clearOldExc,
-                                  UCHAR lpd_mode) {
-  int l_div =
-      coreCoderFrameLength / NB_DIV; /* length of one ACELP/TCX20 frame */
-  int l_div_partial;
-  FIXP_DBL *syn, *old_exc_mem;
-
-  C_ALLOC_SCRATCH_START(synth_buf, FIXP_DBL,
-                        PIT_MAX_MAX + L_INTERPOL + M_LP_FILTER_ORDER);
-  syn = &synth_buf[M_LP_FILTER_ORDER];
-
-  l_div_partial = PIT_MAX_MAX + L_INTERPOL - l_div;
-  old_exc_mem = acelp_mem->old_exc_mem;
-
-  if (lpd_mode == 4) {
-    /* Bypass Domain conversion. TCXTD Concealment does no deemphasis in the
-     * end. */
-    FDKmemcpy(
-        synth_buf, &synth[-(PIT_MAX_MAX + L_INTERPOL + M_LP_FILTER_ORDER)],
-        (PIT_MAX_MAX + L_INTERPOL + M_LP_FILTER_ORDER) * sizeof(FIXP_DBL));
-    /* Set deemphasis memory state for TD concealment */
-    acelp_mem->deemph_mem_wsyn = scaleValueSaturate(synth[-1], ACELP_OUTSCALE);
-  } else {
-    /* convert past [PIT_MAX_MAX+L_INTERPOL+M_LP_FILTER_ORDER] synthesis to
-     * preemph domain */
-    E_UTIL_preemph(&synth[-(PIT_MAX_MAX + L_INTERPOL + M_LP_FILTER_ORDER)],
-                   synth_buf, PIT_MAX_MAX + L_INTERPOL + M_LP_FILTER_ORDER);
-    scaleValuesSaturate(synth_buf, PIT_MAX_MAX + L_INTERPOL + M_LP_FILTER_ORDER,
-                        ACELP_OUTSCALE);
-  }
-
-  /* Set deemphasis memory state */
-  acelp_mem->de_emph_mem = scaleValueSaturate(synth[-1], ACELP_OUTSCALE);
-
-  /* update acelp synth filter memory */
-  FDKmemcpy(acelp_mem->old_syn_mem,
-            &syn[PIT_MAX_MAX + L_INTERPOL - M_LP_FILTER_ORDER],
-            M_LP_FILTER_ORDER * sizeof(FIXP_DBL));
-
-  if (clearOldExc) {
-    FDKmemclear(old_exc_mem, (PIT_MAX_MAX + L_INTERPOL) * sizeof(FIXP_DBL));
-    C_ALLOC_SCRATCH_END(synth_buf, FIXP_DBL,
-                        PIT_MAX_MAX + L_INTERPOL + M_LP_FILTER_ORDER);
-    return;
-  }
-
-  /* update past [PIT_MAX_MAX+L_INTERPOL] samples of exc memory */
-  if (last_lpd_mode == 1) {        /* last frame was TCX20 */
-    if (last_last_lpd_mode == 0) { /* ACELP -> TCX20 -> ACELP transition */
-      /* Delay valid part of excitation buffer (from previous ACELP frame) by
-       * l_div samples */
-      FDKmemmove(old_exc_mem, old_exc_mem + l_div,
-                 sizeof(FIXP_DBL) * l_div_partial);
-    } else if (last_last_lpd_mode > 0) { /* TCX -> TCX20 -> ACELP transition */
-      E_UTIL_residu(A_old, A_old_exp, syn, old_exc_mem, l_div_partial);
-    }
-    E_UTIL_residu(A_new, A_new_exp, syn + l_div_partial,
-                  old_exc_mem + l_div_partial, l_div);
-  } else { /* prev frame was FD, TCX40 or TCX80 */
-    int exc_A_new_length = (coreCoderFrameLength / 2 > PIT_MAX_MAX + L_INTERPOL)
-                               ? PIT_MAX_MAX + L_INTERPOL
-                               : coreCoderFrameLength / 2;
-    int exc_A_old_length = PIT_MAX_MAX + L_INTERPOL - exc_A_new_length;
-    E_UTIL_residu(A_old, A_old_exp, syn, old_exc_mem, exc_A_old_length);
-    E_UTIL_residu(A_new, A_new_exp, &syn[exc_A_old_length],
-                  &old_exc_mem[exc_A_old_length], exc_A_new_length);
-  }
-  C_ALLOC_SCRATCH_END(synth_buf, FIXP_DBL,
-                      PIT_MAX_MAX + L_INTERPOL + M_LP_FILTER_ORDER);
-
-  return;
-}
-
-FIXP_DBL *CLpd_ACELP_GetFreeExcMem(CAcelpStaticMem *acelp_mem, INT length) {
-  FDK_ASSERT(length <= PIT_MAX_MAX + L_INTERPOL);
-  return acelp_mem->old_exc_mem;
-}
-
-INT CLpd_AcelpRead(HANDLE_FDK_BITSTREAM hBs, CAcelpChannelData *acelp,
-                   INT acelp_core_mode, INT coreCoderFrameLength,
-                   INT i_offset) {
-  int nb_subfr = coreCoderFrameLength / L_DIV;
-  const UCHAR *num_acb_index_bits =
-      (nb_subfr == 4) ? num_acb_idx_bits_table[0] : num_acb_idx_bits_table[1];
-  int nbits;
-  int error = 0;
-
-  const int PIT_MIN = PIT_MIN_12k8 + i_offset;
-  const int PIT_FR2 = PIT_FR2_12k8 - i_offset;
-  const int PIT_FR1 = PIT_FR1_12k8;
-  const int PIT_MAX = PIT_MAX_12k8 + (6 * i_offset);
-  int T0, T0_frac, T0_min = 0, T0_max;
-
-  if (PIT_MAX > PIT_MAX_MAX) {
-    error = AAC_DEC_DECODE_FRAME_ERROR;
-    goto bail;
-  }
-
-  acelp->acelp_core_mode = acelp_core_mode;
-
-  nbits = MapCoreMode2NBits(acelp_core_mode);
-
-  /* decode mean energy with 2 bits : 18, 30, 42 or 54 dB */
-  acelp->mean_energy = FDKreadBits(hBs, 2);
-
-  for (int sfr = 0; sfr < nb_subfr; sfr++) {
-    /* read ACB index and store T0 and T0_frac for each ACELP subframe. */
-    error = DecodePitchLag(hBs, num_acb_index_bits[sfr], PIT_MIN, PIT_FR2,
-                           PIT_FR1, PIT_MAX, &T0, &T0_frac, &T0_min, &T0_max);
-    if (error) {
-      goto bail;
-    }
-    acelp->T0[sfr] = (USHORT)T0;
-    acelp->T0_frac[sfr] = (UCHAR)T0_frac;
-    acelp->ltp_filtering_flag[sfr] = FDKreadBits(hBs, 1);
-    switch (nbits) {
-      case 12: /* 12 bits AMR-WB codebook is used */
-        acelp->icb_index[sfr][0] = FDKreadBits(hBs, 1);
-        acelp->icb_index[sfr][1] = FDKreadBits(hBs, 5);
-        acelp->icb_index[sfr][2] = FDKreadBits(hBs, 1);
-        acelp->icb_index[sfr][3] = FDKreadBits(hBs, 5);
-        break;
-      case 16: /* 16 bits AMR-WB codebook is used */
-        acelp->icb_index[sfr][0] = FDKreadBits(hBs, 1);
-        acelp->icb_index[sfr][1] = FDKreadBits(hBs, 5);
-        acelp->icb_index[sfr][2] = FDKreadBits(hBs, 5);
-        acelp->icb_index[sfr][3] = FDKreadBits(hBs, 5);
-        break;
-      case 20: /* 20 bits AMR-WB codebook is used */
-        acelp->icb_index[sfr][0] = FDKreadBits(hBs, 5);
-        acelp->icb_index[sfr][1] = FDKreadBits(hBs, 5);
-        acelp->icb_index[sfr][2] = FDKreadBits(hBs, 5);
-        acelp->icb_index[sfr][3] = FDKreadBits(hBs, 5);
-        break;
-      case 28: /* 28 bits AMR-WB codebook is used */
-        acelp->icb_index[sfr][0] = FDKreadBits(hBs, 9);
-        acelp->icb_index[sfr][1] = FDKreadBits(hBs, 9);
-        acelp->icb_index[sfr][2] = FDKreadBits(hBs, 5);
-        acelp->icb_index[sfr][3] = FDKreadBits(hBs, 5);
-        break;
-      case 36: /* 36 bits AMR-WB codebook is used */
-        acelp->icb_index[sfr][0] = FDKreadBits(hBs, 9);
-        acelp->icb_index[sfr][1] = FDKreadBits(hBs, 9);
-        acelp->icb_index[sfr][2] = FDKreadBits(hBs, 9);
-        acelp->icb_index[sfr][3] = FDKreadBits(hBs, 9);
-        break;
-      case 44: /* 44 bits AMR-WB codebook is used */
-        acelp->icb_index[sfr][0] = FDKreadBits(hBs, 13);
-        acelp->icb_index[sfr][1] = FDKreadBits(hBs, 13);
-        acelp->icb_index[sfr][2] = FDKreadBits(hBs, 9);
-        acelp->icb_index[sfr][3] = FDKreadBits(hBs, 9);
-        break;
-      case 52: /* 52 bits AMR-WB codebook is used */
-        acelp->icb_index[sfr][0] = FDKreadBits(hBs, 13);
-        acelp->icb_index[sfr][1] = FDKreadBits(hBs, 13);
-        acelp->icb_index[sfr][2] = FDKreadBits(hBs, 13);
-        acelp->icb_index[sfr][3] = FDKreadBits(hBs, 13);
-        break;
-      case 64: /* 64 bits AMR-WB codebook is used */
-        acelp->icb_index[sfr][0] = FDKreadBits(hBs, 2);
-        acelp->icb_index[sfr][1] = FDKreadBits(hBs, 2);
-        acelp->icb_index[sfr][2] = FDKreadBits(hBs, 2);
-        acelp->icb_index[sfr][3] = FDKreadBits(hBs, 2);
-        acelp->icb_index[sfr][4] = FDKreadBits(hBs, 14);
-        acelp->icb_index[sfr][5] = FDKreadBits(hBs, 14);
-        acelp->icb_index[sfr][6] = FDKreadBits(hBs, 14);
-        acelp->icb_index[sfr][7] = FDKreadBits(hBs, 14);
-        break;
-      default:
-        FDK_ASSERT(0);
-        break;
-    }
-    acelp->gains[sfr] = FDKreadBits(hBs, 7);
-  }
-
-bail:
-  return error;
-}
--- a/libAACdec/src/usacdec_acelp.h
+++ /dev/null
@@ -1,281 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/**************************** AAC decoder library ******************************
-
-   Author(s):   Matthias Hildenbrand
-
-   Description: USAC ACELP frame decoder
-
-*******************************************************************************/
-
-#ifndef USACDEC_ACELP_H
-#define USACDEC_ACELP_H
-
-#include "common_fix.h"
-#include "FDK_bitstream.h"
-#include "usacdec_const.h"
-#include "usacdec_rom.h"
-
-//#define ENHANCED_TCX_TD_CONCEAL_ENABLE
-
-/** Structure which holds the ACELP internal persistent memory */
-typedef struct {
-  FIXP_DBL old_exc_mem[PIT_MAX_MAX + L_INTERPOL];
-  FIXP_DBL old_syn_mem[M_LP_FILTER_ORDER]; /* synthesis filter states */
-  FIXP_SGL A[M_LP_FILTER_ORDER];
-  INT A_exp;
-  FIXP_DBL gc_threshold;
-  FIXP_DBL de_emph_mem;
-  FIXP_SGL past_gpit;
-  FIXP_DBL past_gcode;
-  USHORT old_T0;
-  UCHAR old_T0_frac;
-  FIXP_DBL deemph_mem_wsyn;
-  FIXP_DBL wsyn_rms;
-  SHORT seed_ace;
-} CAcelpStaticMem;
-
-/** Structure which holds the parameter data needed to decode one ACELP frame.
- */
-typedef struct {
-  UCHAR
-  acelp_core_mode;   /**< mean excitation energy index for whole ACELP frame
-                      */
-  UCHAR mean_energy; /**< acelp core mode for whole ACELP frame */
-  USHORT T0[NB_SUBFR];
-  UCHAR T0_frac[NB_SUBFR];
-  UCHAR ltp_filtering_flag[NB_SUBFR]; /**< controlls whether LTP postfilter is
-                                         active for each ACELP subframe */
-  SHORT icb_index[NB_SUBFR]
-                 [8]; /**< innovative codebook index for each ACELP subframe */
-  UCHAR gains[NB_SUBFR]; /**< gain index for each ACELP subframe */
-} CAcelpChannelData;
-
-/**
- * \brief Read the acelp_coding() bitstream part.
- * \param[in] hBs bitstream handle to read data from.
- * \param[out] acelpData pointer to structure to store the parsed data of one
- * ACELP frame.
- * \param[in] acelp_core_mode the ACELP core mode index.
- * \param[in] coreCoderFrameLength length of core coder frame (1024|768)
- */
-INT CLpd_AcelpRead(HANDLE_FDK_BITSTREAM hBs, CAcelpChannelData *acelpData,
-                   INT acelp_core_mode, INT i_offset, INT coreCoderFrameLength);
-/**
- * \brief Initialization of memory before one LPD frame is decoded
- * \param[out] synth_buf synthesis buffer to be initialized, exponent = SF_SYNTH
- * \param[in] old_synth past synthesis of previous LPD frame, exponent =
- * SF_SYNTH
- * \param[out] synth_buf_fb fullband synthesis buffer to be initialized,
- * exponent = SF_SYNTH
- * \param[in] old_synth_fb past fullband synthesis of previous LPD frame,
- * exponent = SF_SYNTH
- * \param[out] pitch vector where decoded pitch lag values are stored
- * \param[in] old_T_pf past pitch lag values of previous LPD frame
- * \param[in] samplingRate sampling rate for pitch lag offset calculation
- * \param[out] i_offset pitch lag offset for the decoding of the pitch lag
- * \param[in] coreCoderFrameLength length of core coder frame (1024|768)
- */
-void Acelp_PreProcessing(FIXP_DBL *synth_buf, FIXP_DBL *old_synth, INT *pitch,
-                         INT *old_T_pf, FIXP_DBL *pit_gain,
-                         FIXP_DBL *old_gain_pf, INT samplingRate, INT *i_offset,
-                         INT coreCoderFrameLength, INT synSfd,
-                         INT nbSubfrSuperfr);
-
-/**
- * \brief Save tail of buffers for the initialization of the next LPD frame
- * \param[in] synth_buf synthesis of current LPD frame, exponent = SF_SYNTH
- * \param[out] old_synth memory where tail of fullband synth_buf is stored,
- * exponent = SF_SYNTH
- * \param[in] synth_buf_fb fullband synthesis of current LPD frame, exponent =
- * SF_SYNTH
- * \param[out] old_synth_fb memory where tail of fullband synth_buf is stored,
- * exponent = SF_SYNTH
- * \param[in] pitch decoded pitch lag values of current LPD frame
- * \param[out] old_T_pf memory where last SYN_SFD pitch lag values are stored
- */
-void Acelp_PostProcessing(FIXP_DBL *synth_buf, FIXP_DBL *old_synth, INT *pitch,
-                          INT *old_T_pf, INT coreCoderFrameLength, INT synSfd,
-                          INT nbSubfrSuperfr);
-
-/**
- * \brief Decode one ACELP frame (three or four ACELP subframes with 64 samples
- * each)
- * \param[in,out] acelp_mem pointer to ACELP memory structure
- * \param[in] i_offset pitch lag offset
- * \param[in] lsp_old LPC filter in LSP domain corresponding to previous frame
- * \param[in] lsp_new LPC filter in LSP domain corresponding to current frame
- * \param[in] stab_fac stability factor constrained by 0<=stab_fac<=1.0,
- * exponent = SF_STAB
- * \param[in] acelpData pointer to struct with data which is needed for decoding
- * one ACELP frame
- * \param[out] synth ACELP output signal
- * \param[out] pT four decoded pitch lag values
- * \param[in] coreCoderFrameLength length of core coder frame (1024|768)
- */
-void CLpd_AcelpDecode(CAcelpStaticMem *acelp_mem, INT i_offset,
-                      const FIXP_LPC lsp_old[M_LP_FILTER_ORDER],
-                      const FIXP_LPC lsp_new[M_LP_FILTER_ORDER],
-                      FIXP_SGL stab_fac, CAcelpChannelData *acelpData,
-                      INT numLostSubframes, int lastLpcLost, int frameCnt,
-                      FIXP_DBL synth[], int pT[], FIXP_DBL *pit_gain,
-                      INT coreCoderFrameLength);
-
-/**
- * \brief Reset ACELP internal memory.
- * \param[out] acelp_mem pointer to ACELP memory structure
- */
-void CLpd_AcelpReset(CAcelpStaticMem *acelp_mem);
-
-/**
- * \brief Initialize ACELP internal memory in case of FAC before ACELP decoder
- * is called
- * \param[in] synth points to end+1 of past valid synthesis signal, exponent =
- * SF_SYNTH
- * \param[in] last_lpd_mode last lpd mode
- * \param[in] last_last_lpd_mode lpd mode before last_lpd_mode
- * \param[in] A_new LP synthesis filter coeffs corresponding to last frame,
- * exponent = SF_A_COEFFS
- * \param[in] A_old LP synthesis filter coeffs corresponding to the frame before
- * last frame, exponent = SF_A_COEFFS
- * \param[in,out] acelp_mem pointer to ACELP memory structure
- * \param[in] coreCoderFrameLength length of core coder frame (1024|768)
- */
-void CLpd_AcelpPrepareInternalMem(const FIXP_DBL *synth, UCHAR last_lpd_mode,
-                                  UCHAR last_last_lpd_mode,
-                                  const FIXP_LPC *A_new, const INT A_new_exp,
-                                  const FIXP_LPC *A_old, const INT A_old_exp,
-                                  CAcelpStaticMem *acelp_mem,
-                                  INT coreCoderFrameLength, INT clearOldExc,
-                                  UCHAR lpd_mode);
-
-/**
- * \brief Calculate zero input response (zir) of the acelp synthesis filter
- * \param[in] A LP synthesis filter coefficients, exponent = SF_A_COEFFS
- * \param[in,out] acelp_mem pointer to ACELP memory structure
- * \param[in] length length of zir
- * \param[out] zir pointer to zir output buffer, exponent = SF_SYNTH
- */
-void CLpd_Acelp_Zir(const FIXP_LPC A[], const INT A_exp,
-                    CAcelpStaticMem *acelp_mem, const INT length,
-                    FIXP_DBL zir[], int doDeemph);
-
-/**
- * \brief Borrow static excitation memory from ACELP decoder
- * \param[in] acelp_mem pointer to ACELP memory structure
- * \param[in] length number of requested FIXP_DBL values
- * \return pointer to requested memory
- *
- * The caller has to take care not to overwrite valid memory areas.
- * During TCX/FAC calculations and before CLpd_AcelpPrepareInternalMem() is
- * called, the following memory size is available:
- * - 256 samples in case of ACELP -> TCX20 -> ACELP transition
- * - PIT_MAX_MAX+L_INTERPOL samples in all other cases
- */
-FIXP_DBL *CLpd_ACELP_GetFreeExcMem(CAcelpStaticMem *acelp_mem, INT length);
-
-void CLpd_TcxTDConceal(CAcelpStaticMem *acelp_mem, SHORT *pitch,
-                       const FIXP_LPC lsp_old[M_LP_FILTER_ORDER],
-                       const FIXP_LPC lsp_new[M_LP_FILTER_ORDER],
-                       const FIXP_SGL stab_fac, INT numLostSubframes,
-                       FIXP_DBL synth[], INT coreCoderFrameLength,
-                       UCHAR last_tcx_noise_factor);
-
-inline SHORT E_UTIL_random(SHORT *seed) {
-  *seed = (SHORT)((((LONG)*seed * (LONG)31821) >> 1) + (LONG)13849);
-  return (*seed);
-}
-
-#endif /* USACDEC_ACELP_H */
--- a/libAACdec/src/usacdec_const.h
+++ /dev/null
@@ -1,203 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/**************************** AAC decoder library ******************************
-
-   Author(s):   Manuel Jander
-
-   Description: USAC related constants
-
-*******************************************************************************/
-
-#ifndef USACDEC_CONST_H
-#define USACDEC_CONST_H
-
-/* scale factors */
-#define SF_CODE 6       /* exponent of code[], fixed codebook vector */
-#define SF_GAIN_C 16    /* exponent of gain code and smoothed gain code */
-#define SF_EXC 16       /* exponent of exc[] and exc2[], excitation buffer */
-#define SF_GAIN_P 1     /* exponent of gain_pit */
-#define SF_PFAC 0       /* exponent of period/voicing factor */
-#define SF_SYNTH SF_EXC /* exponent of synthesis buffer */
-#define SF_A_COEFFS 3   /* exponent of LP domain synthesis filter coefficient */
-#define SF_STAB 1       /* exponent of stability factor */
-
-/* definitions which are independent of coreCoderFrameLength */
-#define M_LP_FILTER_ORDER 16 /* LP filter order */
-#define LP_FILTER_SCALE 4    /* LP filter scale */
-
-#define PIT_MIN_12k8 34    /* Minimum pitch lag with resolution 1/4 */
-#define PIT_MAX_12k8 231   /* Maximum pitch lag for fs=12.8kHz */
-#define FSCALE_DENOM 12800 /* Frequency scale denominator */
-#define FAC_FSCALE_MIN \
-  6000 /* Minimum allowed frequency scale for acelp decoder */
-
-#if !defined(LPD_MAX_CORE_SR)
-#define LPD_MAX_CORE_SR 24000 /* Default value from ref soft */
-#endif
-#define FAC_FSCALE_MAX \
-  LPD_MAX_CORE_SR /* Maximum allowed frequency scale for acelp decoder */
-
-/* Maximum pitch lag (= 411 for fs_max = 24000) */
-#define PIT_MAX_TMP                                                            \
-  (PIT_MAX_12k8 +                                                              \
-   (6 *                                                                        \
-    ((((FAC_FSCALE_MAX * PIT_MIN_12k8) + (FSCALE_DENOM / 2)) / FSCALE_DENOM) - \
-     PIT_MIN_12k8)))
-#if (PIT_MAX_TMP < \
-     256) /* cannot be smaller because of tcx time domain concealment */
-#define PIT_MAX_MAX 256
-#else
-#define PIT_MAX_MAX PIT_MAX_TMP
-#endif
-
-#define NB_DIV 4   /* number of division (20ms) per 80ms frame */
-#define L_SUBFR 64 /* subframe size (5ms) */
-#define BPF_SFD 1  /* bass postfilter delay (subframe) */
-#define BPF_DELAY (BPF_SFD * L_SUBFR) /* bass postfilter delay (samples) */
-
-#define L_FILT 12  /* Delay of up-sampling filter (bass post-filter) */
-#define L_EXTRA 96 /* for bass post-filter */
-#define L_INTERPOL \
-  (16 + 1) /* Length of filter for interpolation (acelp decoder) */
-
-/* definitions for coreCoderFrameLength = 1024 */
-#define L_FRAME_PLUS_1024 1024 /* length of one 80ms superframe */
-#define L_DIV_1024 \
-  (L_FRAME_PLUS_1024 / NB_DIV) /* length of one acelp or tcx20 frame */
-#define NB_SUBFR_1024 \
-  (L_DIV_1024 / L_SUBFR) /* number of 5ms subframe per division */
-#define NB_SUBFR_SUPERFR_1024 \
-  (L_FRAME_PLUS_1024 / L_SUBFR) /* number of 5ms subframe per 80ms frame */
-#define AAC_SFD_1024 (NB_SUBFR_SUPERFR_1024 / 2) /* AAC delay (subframe) */
-#define AAC_DELAY_1024 (AAC_SFD_1024 * L_SUBFR)  /* AAC delay (samples) */
-#define SYN_SFD_1024 (AAC_SFD_1024 - BPF_SFD) /* synthesis delay (subframe) */
-#define SYN_DELAY_1024                                          \
-  (SYN_SFD_1024 * L_SUBFR)         /* synthesis delay (samples) \
-                                    */
-#define LFAC_1024 (L_DIV_1024 / 2) /* FAC frame length */
-#define LFAC_SHORT_1024 \
-  (L_DIV_1024 / 4)        /* for transitions EIGHT_SHORT FD->LPD and vv. */
-#define FDNS_NPTS_1024 64 /* FD noise shaping resolution (64=100Hz/point) */
-
-/* definitions for coreCoderFrameLength = 768 */
-#define L_FRAME_PLUS_768 768
-#define L_DIV_768 \
-  (L_FRAME_PLUS_768 / NB_DIV) /* length of one acelp or tcx20 frame */
-#define NB_SUBFR_768 \
-  (L_DIV_768 / L_SUBFR) /* number of 5ms subframe per division */
-#define NB_SUBFR_SUPERFR_768 \
-  (L_FRAME_PLUS_768 / L_SUBFR) /* number of 5ms subframe per 80ms frame */
-#define AAC_SFD_768 (NB_SUBFR_SUPERFR_768 / 2) /* AAC delay (subframe) */
-#define AAC_DELAY_768 (AAC_SFD_768 * L_SUBFR)  /* AAC delay (samples) */
-#define SYN_SFD_768 (AAC_SFD_768 - BPF_SFD)    /* synthesis delay (subframe) */
-#define SYN_DELAY_768 (SYN_SFD_768 * L_SUBFR)  /* synthesis delay (samples) */
-#define LFAC_768 (L_DIV_768 / 2)               /* FAC frame length */
-#define LFAC_SHORT_768 \
-  (L_DIV_768 / 4) /* for transitions EIGHT_SHORT FD->LPD and vv. */
-
-/* maximum (used for memory allocation) */
-#define L_FRAME_PLUS L_FRAME_PLUS_1024
-#define L_DIV L_DIV_1024
-#define NB_SUBFR NB_SUBFR_1024
-#define NB_SUBFR_SUPERFR NB_SUBFR_SUPERFR_1024
-#define AAC_SFD AAC_SFD_1024
-#define AAC_DELAY AAC_DELAY_1024
-#define SYN_SFD SYN_SFD_1024
-#define SYN_DELAY SYN_DELAY_1024
-#define LFAC LFAC_1024
-#define LFAC_SHORT LFAC_SHORT_1024
-#define FDNS_NPTS FDNS_NPTS_1024
-
-#endif /* USACDEC_CONST_H */
--- a/libAACdec/src/usacdec_fac.cpp
+++ /dev/null
@@ -1,745 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/**************************** AAC decoder library ******************************
-
-   Author(s):   Manuel Jander
-
-   Description: USAC FAC
-
-*******************************************************************************/
-
-#include "usacdec_fac.h"
-
-#include "usacdec_const.h"
-#include "usacdec_lpc.h"
-#include "usacdec_acelp.h"
-#include "usacdec_rom.h"
-#include "dct.h"
-#include "FDK_tools_rom.h"
-#include "mdct.h"
-
-#define SPEC_FAC(ptr, i, gl) ((ptr) + ((i) * (gl)))
-
-FIXP_DBL *CLpd_FAC_GetMemory(CAacDecoderChannelInfo *pAacDecoderChannelInfo,
-                             UCHAR mod[NB_DIV], int *pState) {
-  FIXP_DBL *ptr;
-  int i;
-  int k = 0;
-  int max_windows = 8;
-
-  FDK_ASSERT(*pState >= 0 && *pState < max_windows);
-
-  /* Look for free space to store FAC data. 2 FAC data blocks fit into each TCX
-   * spectral data block. */
-  for (i = *pState; i < max_windows; i++) {
-    if (mod[i >> 1] == 0) {
-      break;
-    }
-  }
-
-  *pState = i + 1;
-
-  if (i == max_windows) {
-    ptr = pAacDecoderChannelInfo->data.usac.fac_data0;
-  } else {
-    FDK_ASSERT(mod[(i >> 1)] == 0);
-    ptr = SPEC_FAC(pAacDecoderChannelInfo->pSpectralCoefficient, i,
-                   pAacDecoderChannelInfo->granuleLength << k);
-  }
-
-  return ptr;
-}
-
-int CLpd_FAC_Read(HANDLE_FDK_BITSTREAM hBs, FIXP_DBL *pFac, SCHAR *pFacScale,
-                  int length, int use_gain, int frame) {
-  FIXP_DBL fac_gain;
-  int fac_gain_e = 0;
-
-  if (use_gain) {
-    CLpd_DecodeGain(&fac_gain, &fac_gain_e, FDKreadBits(hBs, 7));
-  }
-
-  if (CLpc_DecodeAVQ(hBs, pFac, 1, 1, length) != 0) {
-    return -1;
-  }
-
-  {
-    int scale;
-
-    scale = getScalefactor(pFac, length);
-    scaleValues(pFac, length, scale);
-    pFacScale[frame] = DFRACT_BITS - 1 - scale;
-  }
-
-  if (use_gain) {
-    int i;
-
-    pFacScale[frame] += fac_gain_e;
-
-    for (i = 0; i < length; i++) {
-      pFac[i] = fMult(pFac[i], fac_gain);
-    }
-  }
-  return 0;
-}
-
-/**
- * \brief Apply synthesis filter with zero input to x. The overall filter gain
- * is 1.0.
- * \param a LPC filter coefficients.
- * \param length length of the input/output data vector x.
- * \param x input/output vector, where the synthesis filter is applied in place.
- */
-static void Syn_filt_zero(const FIXP_LPC a[], const INT a_exp, INT length,
-                          FIXP_DBL x[]) {
-  int i, j;
-  FIXP_DBL L_tmp;
-
-  for (i = 0; i < length; i++) {
-    L_tmp = (FIXP_DBL)0;
-
-    for (j = 0; j < fMin(i, M_LP_FILTER_ORDER); j++) {
-      L_tmp -= fMultDiv2(a[j], x[i - (j + 1)]) >> (LP_FILTER_SCALE - 1);
-    }
-
-    L_tmp = scaleValue(L_tmp, a_exp + LP_FILTER_SCALE);
-    x[i] = fAddSaturate(x[i], L_tmp);
-  }
-}
-
-/* Table is also correct for coreCoderFrameLength = 768. Factor 3/4 is canceled
-   out: gainFac = 0.5 * sqrt(fac_length/lFrame)
-*/
-static const FIXP_DBL gainFac[4] = {0x40000000, 0x2d413ccd, 0x20000000,
-                                    0x16a09e66};
-
-void CFac_ApplyGains(FIXP_DBL fac_data[LFAC], const INT fac_length,
-                     const FIXP_DBL tcx_gain, const FIXP_DBL alfd_gains[],
-                     const INT mod) {
-  FIXP_DBL facFactor;
-  int i;
-
-  FDK_ASSERT((fac_length == 128) || (fac_length == 96));
-
-  /* 2) Apply gain factor to FAC data */
-  facFactor = fMult(gainFac[mod], tcx_gain);
-  for (i = 0; i < fac_length; i++) {
-    fac_data[i] = fMult(fac_data[i], facFactor);
-  }
-
-  /* 3) Apply spectrum deshaping using alfd_gains */
-  for (i = 0; i < fac_length / 4; i++) {
-    int k;
-
-    k = i >> (3 - mod);
-    fac_data[i] = fMult(fac_data[i], alfd_gains[k])
-                  << 1; /* alfd_gains is scaled by one bit. */
-  }
-}
-
-static void CFac_CalcFacSignal(FIXP_DBL *pOut, FIXP_DBL *pFac,
-                               const int fac_scale, const int fac_length,
-                               const FIXP_LPC A[M_LP_FILTER_ORDER],
-                               const INT A_exp, const int fAddZir,
-                               const int isFdFac) {
-  FIXP_LPC wA[M_LP_FILTER_ORDER];
-  FIXP_DBL tf_gain = (FIXP_DBL)0;
-  int wlength;
-  int scale = fac_scale;
-
-  /* obtain tranform gain. */
-  imdct_gain(&tf_gain, &scale, isFdFac ? 0 : fac_length);
-
-  /* 4) Compute inverse DCT-IV of FAC data. Output scale of DCT IV is 16 bits.
-   */
-  dct_IV(pFac, fac_length, &scale);
-  /* dct_IV scale = log2(fac_length). "- 7" is a factor of 2/128 */
-  if (tf_gain != (FIXP_DBL)0) { /* non-radix 2 transform gain */
-    int i;
-
-    for (i = 0; i < fac_length; i++) {
-      pFac[i] = fMult(tf_gain, pFac[i]);
-    }
-  }
-  scaleValuesSaturate(pOut, pFac, fac_length,
-                      scale); /* Avoid overflow issues and saturate. */
-
-  E_LPC_a_weight(wA, A, M_LP_FILTER_ORDER);
-
-  /* We need the output of the IIR filter to be longer than "fac_length".
-  For this reason we run it with zero input appended to the end of the input
-  sequence, i.e. we generate its ZIR and extend the output signal.*/
-  FDKmemclear(pOut + fac_length, fac_length * sizeof(FIXP_DBL));
-  wlength = 2 * fac_length;
-
-  /* 5) Apply weighted synthesis filter to FAC data, including optional Zir (5.
-   * item 4). */
-  Syn_filt_zero(wA, A_exp, wlength, pOut);
-}
-
-INT CLpd_FAC_Mdct2Acelp(H_MDCT hMdct, FIXP_DBL *output, FIXP_DBL *pFac,
-                        const int fac_scale, FIXP_LPC *A, INT A_exp,
-                        INT nrOutSamples, const INT fac_length,
-                        const INT isFdFac, UCHAR prevWindowShape) {
-  FIXP_DBL *pOvl;
-  FIXP_DBL *pOut0;
-  const FIXP_WTP *pWindow;
-  int i, fl, nrSamples = 0;
-
-  FDK_ASSERT(fac_length <= 1024 / (4 * 2));
-
-  fl = fac_length * 2;
-
-  pWindow = FDKgetWindowSlope(fl, prevWindowShape);
-
-  /* Adapt window slope length in case of frame loss. */
-  if (hMdct->prev_fr != fl) {
-    int nl = 0;
-    imdct_adapt_parameters(hMdct, &fl, &nl, fac_length, pWindow, nrOutSamples);
-    FDK_ASSERT(nl == 0);
-  }
-
-  if (nrSamples < nrOutSamples) {
-    pOut0 = output;
-    nrSamples += hMdct->ov_offset;
-    /* Purge buffered output. */
-    FDKmemcpy(pOut0, hMdct->overlap.time, hMdct->ov_offset * sizeof(pOut0[0]));
-    hMdct->ov_offset = 0;
-  }
-
-  pOvl = hMdct->overlap.freq + hMdct->ov_size - 1;
-
-  if (nrSamples >= nrOutSamples) {
-    pOut0 = hMdct->overlap.time + hMdct->ov_offset;
-    hMdct->ov_offset += hMdct->prev_nr + fl / 2;
-  } else {
-    pOut0 = output + nrSamples;
-    nrSamples += hMdct->prev_nr + fl / 2;
-  }
-  if (hMdct->prevPrevAliasSymmetry == 0) {
-    for (i = 0; i < hMdct->prev_nr; i++) {
-      FIXP_DBL x = -(*pOvl--);
-      *pOut0 = IMDCT_SCALE_DBL(x);
-      pOut0++;
-    }
-  } else {
-    for (i = 0; i < hMdct->prev_nr; i++) {
-      FIXP_DBL x = (*pOvl--);
-      *pOut0 = IMDCT_SCALE_DBL(x);
-      pOut0++;
-    }
-  }
-  hMdct->prev_nr = 0;
-
-  {
-    if (pFac != NULL) {
-      /* Note: The FAC gain might have been applied directly after bit stream
-       * parse in this case. */
-      CFac_CalcFacSignal(pOut0, pFac, fac_scale, fac_length, A, A_exp, 0,
-                         isFdFac);
-    } else {
-      /* Clear buffer because of the overlap and ADD! */
-      FDKmemclear(pOut0, fac_length * sizeof(FIXP_DBL));
-    }
-  }
-
-  i = 0;
-
-  if (hMdct->prevPrevAliasSymmetry == 0) {
-    for (; i < fl / 2; i++) {
-      FIXP_DBL x0;
-
-      /* Overlap Add */
-      x0 = -fMult(*pOvl--, pWindow[i].v.re);
-
-      *pOut0 += IMDCT_SCALE_DBL(x0);
-      pOut0++;
-    }
-  } else {
-    for (; i < fl / 2; i++) {
-      FIXP_DBL x0;
-
-      /* Overlap Add */
-      x0 = fMult(*pOvl--, pWindow[i].v.re);
-
-      *pOut0 += IMDCT_SCALE_DBL(x0);
-      pOut0++;
-    }
-  }
-  if (hMdct->pFacZir !=
-      0) { /* this should only happen for ACELP -> TCX20 -> ACELP transition */
-    FIXP_DBL *pOut = pOut0 - fl / 2; /* fl/2 == fac_length */
-    for (i = 0; i < fl / 2; i++) {
-      pOut[i] += IMDCT_SCALE_DBL(hMdct->pFacZir[i]);
-    }
-    hMdct->pFacZir = NULL;
-  }
-
-  hMdct->prev_fr = 0;
-  hMdct->prev_nr = 0;
-  hMdct->prev_tl = 0;
-  hMdct->prevPrevAliasSymmetry = hMdct->prevAliasSymmetry;
-
-  return nrSamples;
-}
-
-INT CLpd_FAC_Acelp2Mdct(H_MDCT hMdct, FIXP_DBL *output, FIXP_DBL *_pSpec,
-                        const SHORT spec_scale[], const int nSpec,
-                        FIXP_DBL *pFac, const int fac_scale,
-                        const INT fac_length, INT noOutSamples, const INT tl,
-                        const FIXP_WTP *wrs, const INT fr, FIXP_LPC A[16],
-                        INT A_exp, CAcelpStaticMem *acelp_mem,
-                        const FIXP_DBL gain, const int last_frame_lost,
-                        const int isFdFac, const UCHAR last_lpd_mode,
-                        const int k, int currAliasingSymmetry) {
-  FIXP_DBL *pCurr, *pOvl, *pSpec;
-  const FIXP_WTP *pWindow;
-  const FIXP_WTB *FacWindowZir_conceal;
-  UCHAR doFacZirConceal = 0;
-  int doDeemph = 1;
-  const FIXP_WTB *FacWindowZir, *FacWindowSynth;
-  FIXP_DBL *pOut0 = output, *pOut1;
-  int w, i, fl, nl, nr, f_len, nrSamples = 0, s = 0, scale, total_gain_e;
-  FIXP_DBL *pF, *pFAC_and_FAC_ZIR = NULL;
-  FIXP_DBL total_gain = gain;
-
-  FDK_ASSERT(fac_length <= 1024 / (4 * 2));
-  switch (fac_length) {
-    /* coreCoderFrameLength = 1024 */
-    case 128:
-      pWindow = SineWindow256;
-      FacWindowZir = FacWindowZir128;
-      FacWindowSynth = FacWindowSynth128;
-      break;
-    case 64:
-      pWindow = SineWindow128;
-      FacWindowZir = FacWindowZir64;
-      FacWindowSynth = FacWindowSynth64;
-      break;
-    case 32:
-      pWindow = SineWindow64;
-      FacWindowZir = FacWindowZir32;
-      FacWindowSynth = FacWindowSynth32;
-      break;
-    /* coreCoderFrameLength = 768 */
-    case 96:
-      pWindow = SineWindow192;
-      FacWindowZir = FacWindowZir96;
-      FacWindowSynth = FacWindowSynth96;
-      break;
-    case 48:
-      pWindow = SineWindow96;
-      FacWindowZir = FacWindowZir48;
-      FacWindowSynth = FacWindowSynth48;
-      break;
-    default:
-      FDK_ASSERT(0);
-      return 0;
-  }
-
-  FacWindowZir_conceal = FacWindowSynth;
-  /* Derive NR and NL */
-  fl = fac_length * 2;
-  nl = (tl - fl) >> 1;
-  nr = (tl - fr) >> 1;
-
-  if (noOutSamples > nrSamples) {
-    /* Purge buffered output. */
-    FDKmemcpy(pOut0, hMdct->overlap.time, hMdct->ov_offset * sizeof(pOut0[0]));
-    nrSamples = hMdct->ov_offset;
-    hMdct->ov_offset = 0;
-  }
-
-  if (nrSamples >= noOutSamples) {
-    pOut1 = hMdct->overlap.time + hMdct->ov_offset;
-    if (hMdct->ov_offset < fac_length) {
-      pOut0 = output + nrSamples;
-    } else {
-      pOut0 = pOut1;
-    }
-    hMdct->ov_offset += fac_length + nl;
-  } else {
-    pOut1 = output + nrSamples;
-    pOut0 = output + nrSamples;
-  }
-
-  {
-    pFAC_and_FAC_ZIR = CLpd_ACELP_GetFreeExcMem(acelp_mem, 2 * fac_length);
-    {
-      const FIXP_DBL *pTmp1, *pTmp2;
-
-      doFacZirConceal |= ((last_frame_lost != 0) && (k == 0));
-      doDeemph &= (last_lpd_mode != 4);
-      if (doFacZirConceal) {
-        /* ACELP contribution in concealment case:
-           Use ZIR with a modified ZIR window to preserve some more energy.
-           Dont use FAC, which contains wrong information for concealed frame
-           Dont use last ACELP samples, but double ZIR, instead (afterwards) */
-        FDKmemclear(pFAC_and_FAC_ZIR, 2 * fac_length * sizeof(FIXP_DBL));
-        FacWindowSynth = (FIXP_WTB *)pFAC_and_FAC_ZIR;
-        FacWindowZir = FacWindowZir_conceal;
-      } else {
-        CFac_CalcFacSignal(pFAC_and_FAC_ZIR, pFac, fac_scale + s, fac_length, A,
-                           A_exp, 1, isFdFac);
-      }
-      /* 6) Get windowed past ACELP samples and ACELP ZIR signal */
-
-      /*
-       * Get ACELP ZIR (pFac[]) and ACELP past samples (pOut0[]) and add them
-       * to the FAC synth signal contribution on pOut1[].
-       */
-      {
-        {
-          CLpd_Acelp_Zir(A, A_exp, acelp_mem, fac_length, pFac, doDeemph);
-
-          pTmp1 = pOut0;
-          pTmp2 = pFac;
-        }
-
-        for (i = 0, w = 0; i < fac_length; i++) {
-          FIXP_DBL x;
-          /* Div2 is compensated by table scaling */
-          x = fMultDiv2(pTmp2[i], FacWindowZir[w]);
-          x += fMultDiv2(pTmp1[-i - 1], FacWindowSynth[w]);
-          x += pFAC_and_FAC_ZIR[i];
-          pOut1[i] = x;
-
-          w++;
-        }
-      }
-
-      if (doFacZirConceal) {
-        /* ZIR is the only ACELP contribution, so double it */
-        scaleValues(pOut1, fac_length, 1);
-      }
-    }
-  }
-
-  if (nrSamples < noOutSamples) {
-    nrSamples += fac_length + nl;
-  }
-
-  /* Obtain transform gain */
-  total_gain = gain;
-  total_gain_e = 0;
-  imdct_gain(&total_gain, &total_gain_e, tl);
-
-  /* IMDCT overlap add */
-  scale = total_gain_e;
-  pSpec = _pSpec;
-
-  /* Note:when comming from an LPD frame (TCX/ACELP) the previous alisaing
-   * symmetry must always be 0 */
-  if (currAliasingSymmetry == 0) {
-    dct_IV(pSpec, tl, &scale);
-  } else {
-    FIXP_DBL _tmp[1024 + ALIGNMENT_DEFAULT / sizeof(FIXP_DBL)];
-    FIXP_DBL *tmp = (FIXP_DBL *)ALIGN_PTR(_tmp);
-    C_ALLOC_ALIGNED_REGISTER(tmp, sizeof(_tmp));
-    dst_III(pSpec, tmp, tl, &scale);
-    C_ALLOC_ALIGNED_UNREGISTER(tmp);
-  }
-
-  /* Optional scaling of time domain - no yet windowed - of current spectrum */
-  if (total_gain != (FIXP_DBL)0) {
-    for (i = 0; i < tl; i++) {
-      pSpec[i] = fMult(pSpec[i], total_gain);
-    }
-  }
-  int loc_scale = fixmin_I(spec_scale[0] + scale, (INT)DFRACT_BITS - 1);
-  scaleValuesSaturate(pSpec, tl, loc_scale);
-
-  pOut1 += fl / 2 - 1;
-  pCurr = pSpec + tl - fl / 2;
-
-  for (i = 0; i < fl / 2; i++) {
-    FIXP_DBL x1;
-
-    /* FAC signal is already on pOut1, because of that the += operator. */
-    x1 = fMult(*pCurr++, pWindow[i].v.re);
-    FDK_ASSERT((pOut1 >= hMdct->overlap.time &&
-                pOut1 < hMdct->overlap.time + hMdct->ov_size) ||
-               (pOut1 >= output && pOut1 < output + 1024));
-    *pOut1 += IMDCT_SCALE_DBL(-x1);
-    pOut1--;
-  }
-
-  /* NL output samples TL/2+FL/2..TL. - current[FL/2..0] */
-  pOut1 += (fl / 2) + 1;
-
-  pFAC_and_FAC_ZIR += fac_length; /* set pointer to beginning of FAC ZIR */
-
-  if (nl == 0) {
-    /* save pointer to write FAC ZIR data later */
-    hMdct->pFacZir = pFAC_and_FAC_ZIR;
-  } else {
-    FDK_ASSERT(nl >= fac_length);
-    /* FAC ZIR will be added now ... */
-    hMdct->pFacZir = NULL;
-  }
-
-  pF = pFAC_and_FAC_ZIR;
-  f_len = fac_length;
-
-  pCurr = pSpec + tl - fl / 2 - 1;
-  for (i = 0; i < nl; i++) {
-    FIXP_DBL x = -(*pCurr--);
-    /* 5) (item 4) Synthesis filter Zir component, FAC ZIR (another one). */
-    if (i < f_len) {
-      x += *pF++;
-    }
-
-    FDK_ASSERT((pOut1 >= hMdct->overlap.time &&
-                pOut1 < hMdct->overlap.time + hMdct->ov_size) ||
-               (pOut1 >= output && pOut1 < output + 1024));
-    *pOut1 = IMDCT_SCALE_DBL(x);
-    pOut1++;
-  }
-
-  hMdct->prev_nr = nr;
-  hMdct->prev_fr = fr;
-  hMdct->prev_wrs = wrs;
-  hMdct->prev_tl = tl;
-  hMdct->prevPrevAliasSymmetry = hMdct->prevAliasSymmetry;
-  hMdct->prevAliasSymmetry = currAliasingSymmetry;
-  fl = fr;
-  nl = nr;
-
-  pOvl = pSpec + tl / 2 - 1;
-  pOut0 = pOut1;
-
-  for (w = 1; w < nSpec; w++) /* for ACELP -> FD short */
-  {
-    const FIXP_WTP *pWindow_prev;
-
-    /* Setup window pointers */
-    pWindow_prev = hMdct->prev_wrs;
-
-    /* Current spectrum */
-    pSpec = _pSpec + w * tl;
-
-    scale = total_gain_e;
-
-    /* For the second, third, etc. short frames the alisaing symmetry is equal,
-     * either (0,0) or (1,1) */
-    if (currAliasingSymmetry == 0) {
-      /* DCT IV of current spectrum */
-      dct_IV(pSpec, tl, &scale);
-    } else {
-      dst_IV(pSpec, tl, &scale);
-    }
-
-    /* Optional scaling of time domain - no yet windowed - of current spectrum
-     */
-    /* and de-scale current spectrum signal (time domain, no yet windowed) */
-    if (total_gain != (FIXP_DBL)0) {
-      for (i = 0; i < tl; i++) {
-        pSpec[i] = fMult(pSpec[i], total_gain);
-      }
-    }
-    loc_scale = fixmin_I(spec_scale[w] + scale, (INT)DFRACT_BITS - 1);
-    scaleValuesSaturate(pSpec, tl, loc_scale);
-
-    if (noOutSamples <= nrSamples) {
-      /* Divert output first half to overlap buffer if we already got enough
-       * output samples. */
-      pOut0 = hMdct->overlap.time + hMdct->ov_offset;
-      hMdct->ov_offset += hMdct->prev_nr + fl / 2;
-    } else {
-      /* Account output samples */
-      nrSamples += hMdct->prev_nr + fl / 2;
-    }
-
-    /* NR output samples 0 .. NR. -overlap[TL/2..TL/2-NR] */
-    for (i = 0; i < hMdct->prev_nr; i++) {
-      FIXP_DBL x = -(*pOvl--);
-      *pOut0 = IMDCT_SCALE_DBL(x);
-      pOut0++;
-    }
-
-    if (noOutSamples <= nrSamples) {
-      /* Divert output second half to overlap buffer if we already got enough
-       * output samples. */
-      pOut1 = hMdct->overlap.time + hMdct->ov_offset + fl / 2 - 1;
-      hMdct->ov_offset += fl / 2 + nl;
-    } else {
-      pOut1 = pOut0 + (fl - 1);
-      nrSamples += fl / 2 + nl;
-    }
-
-    /* output samples before window crossing point NR .. TL/2.
-     * -overlap[TL/2-NR..TL/2-NR-FL/2] + current[NR..TL/2] */
-    /* output samples after window crossing point TL/2 .. TL/2+FL/2.
-     * -overlap[0..FL/2] - current[TL/2..FL/2] */
-    pCurr = pSpec + tl - fl / 2;
-    if (currAliasingSymmetry == 0) {
-      for (i = 0; i < fl / 2; i++) {
-        FIXP_DBL x0, x1;
-
-        cplxMult(&x1, &x0, *pCurr++, -*pOvl--, pWindow_prev[i]);
-        *pOut0 = IMDCT_SCALE_DBL(x0);
-        *pOut1 = IMDCT_SCALE_DBL(-x1);
-        pOut0++;
-        pOut1--;
-      }
-    } else {
-      if (hMdct->prevPrevAliasSymmetry == 0) {
-        /* Jump DST II -> DST IV for the second window */
-        for (i = 0; i < fl / 2; i++) {
-          FIXP_DBL x0, x1;
-
-          cplxMult(&x1, &x0, *pCurr++, -*pOvl--, pWindow_prev[i]);
-          *pOut0 = IMDCT_SCALE_DBL(x0);
-          *pOut1 = IMDCT_SCALE_DBL(x1);
-          pOut0++;
-          pOut1--;
-        }
-      } else {
-        /* Jump DST IV -> DST IV from the second window on */
-        for (i = 0; i < fl / 2; i++) {
-          FIXP_DBL x0, x1;
-
-          cplxMult(&x1, &x0, *pCurr++, *pOvl--, pWindow_prev[i]);
-          *pOut0 = IMDCT_SCALE_DBL(x0);
-          *pOut1 = IMDCT_SCALE_DBL(x1);
-          pOut0++;
-          pOut1--;
-        }
-      }
-    }
-
-    if (hMdct->pFacZir != 0) {
-      /* add FAC ZIR of previous ACELP -> mdct transition */
-      FIXP_DBL *pOut = pOut0 - fl / 2;
-      FDK_ASSERT(fl / 2 <= 128);
-      for (i = 0; i < fl / 2; i++) {
-        pOut[i] += IMDCT_SCALE_DBL(hMdct->pFacZir[i]);
-      }
-      hMdct->pFacZir = NULL;
-    }
-    pOut0 += (fl / 2);
-
-    /* NL output samples TL/2+FL/2..TL. - current[FL/2..0] */
-    pOut1 += (fl / 2) + 1;
-    pCurr = pSpec + tl - fl / 2 - 1;
-    for (i = 0; i < nl; i++) {
-      FIXP_DBL x = -(*pCurr--);
-      *pOut1 = IMDCT_SCALE_DBL(x);
-      pOut1++;
-    }
-
-    /* Set overlap source pointer for next window pOvl = pSpec + tl/2 - 1; */
-    pOvl = pSpec + tl / 2 - 1;
-
-    /* Previous window values. */
-    hMdct->prev_nr = nr;
-    hMdct->prev_fr = fr;
-    hMdct->prev_tl = tl;
-    hMdct->prev_wrs = pWindow_prev;
-    hMdct->prevPrevAliasSymmetry = hMdct->prevAliasSymmetry;
-    hMdct->prevAliasSymmetry = currAliasingSymmetry;
-  }
-
-  /* Save overlap */
-
-  pOvl = hMdct->overlap.freq + hMdct->ov_size - tl / 2;
-  FDK_ASSERT(pOvl >= hMdct->overlap.time + hMdct->ov_offset);
-  FDK_ASSERT(tl / 2 <= hMdct->ov_size);
-  for (i = 0; i < tl / 2; i++) {
-    pOvl[i] = _pSpec[i + (w - 1) * tl];
-  }
-
-  return nrSamples;
-}
--- a/libAACdec/src/usacdec_fac.h
+++ /dev/null
@@ -1,191 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/**************************** AAC decoder library ******************************
-
-   Author(s):   Manuel Jander
-
-   Description: USAC FAC
-
-*******************************************************************************/
-
-#ifndef USACDEC_FAC_H
-#define USACDEC_FAC_H
-
-#include "channelinfo.h"
-#include "FDK_bitstream.h"
-
-/**
- * \brief Get the address of a memory area of the spectral data memory were the
- * FAC data can be stored into.
- * \param spec SPECTRAL_PTR pointing to the current spectral data.
- * \param mod the current LPD mod array.
- * \param pState pointer to a private state variable which must be 0 for the
- * first call and not changed externally.
- * \param isFullbandLPD is 1 if fullband LPD mode is on, otherwise it is 0.
- */
-FIXP_DBL *CLpd_FAC_GetMemory(CAacDecoderChannelInfo *pAacDecoderChannelInfo,
-                             UCHAR mod[NB_SUBFR], int *pState);
-
-/**
- * \brief read a fac bitstream data block.
- * \param hBs a bit stream handle, where the fac bitstream data is located.
- * \param pFac pointer to were the FAC data will be stored into.
- * \param pFacScale pointer to were the FAC data scale value will be stored
- * into.
- * \param tcx_gain value to be used as FAC gain. If zero, read fac_gain from
- * bitstream.
- * \param tcx_gain_e exponen value of tcx_gain.
- * \param frame the subframe to be considered from the current superframe.
- * Always 0 for FD case.
- * \return 0 on success, -1 on error.
- */
-int CLpd_FAC_Read(HANDLE_FDK_BITSTREAM hBs, FIXP_DBL *pFac, SCHAR *pFacScale,
-                  int length, int use_gain, int frame);
-
-/**
- * \brief Apply TCX and ALFD gains to FAC data.
- * \param fac_data pointer to FAC data.
- * \param fac_length FAC length (128 or 96).
- * \param tcx_gain TCX gain
- * \param alfd_gains pointer to alfd gains.
- * \param mod mod value (1,2,3) of TCX frame where the FAC signal needs to be
- * applied.
- */
-void CFac_ApplyGains(FIXP_DBL fac_data[LFAC], const INT fac_length,
-                     const FIXP_DBL tcx_gain, const FIXP_DBL alfd_gains[],
-                     const INT mod);
-
-/**
- * \brief Do FAC transition from frequency domain to ACELP domain.
- */
-INT CLpd_FAC_Mdct2Acelp(H_MDCT hMdct, FIXP_DBL *output, FIXP_DBL *pFac_data,
-                        const int fac_data_e, FIXP_LPC *A, INT A_exp,
-                        INT nrOutSamples, const INT fac_length,
-                        const INT isFdFac, UCHAR prevWindowShape);
-
-/**
- * \brief Do FAC transition from ACELP domain to frequency domain.
- * \param hMdct MDCT context.
- * \param output pointer for time domain output.
- * \param pSpec pointer to MDCT spectrum input.
- * \param spec_scale MDCT spectrum exponents.
- * \param nSpec amount of contiguos MDCT spectra.
- * \param pFac pointer to FAC MDCT domain data.
- * \param fac_scale exponent of FAC data.
- * \param fac_length length of FAC data.
- * \param nrSamples room in samples in output buffer.
- * \param tl MDCT transform length of pSpec.
- * \param wrs right MDCT window slope.
- * \param fr right MDCT window slope length.
- * \param A LP domain filter coefficients.
- * \param deemph_mem deemphasis filter state.
- * \param gain gain to be applied to FAC data before overlap add.
- * \param old_syn_mem Synthesis filter state.
- * \param isFdFac indicates fac processing from or to FD.
- * \param pFacData fac data stored for fullband LPD.
- * \param elFlags element specific parser guidance flags.
- * \param isFacForFullband indicates that fac is processed for fullband LPD.
- */
-INT CLpd_FAC_Acelp2Mdct(H_MDCT hMdct, FIXP_DBL *output, FIXP_DBL *pSpec,
-                        const SHORT spec_scale[], const int nSpec,
-                        FIXP_DBL *pFac_data, const int fac_data_e,
-                        const INT fac_length, INT nrSamples, const INT tl,
-                        const FIXP_WTP *wrs, const INT fr, FIXP_LPC A[16],
-                        INT A_exp, CAcelpStaticMem *acelp_mem,
-                        const FIXP_DBL gain, const int last_frame_lost,
-                        const int isFdFac, const UCHAR last_lpd, const int k,
-                        int currAliasingSymmetry);
-
-#endif /* USACDEC_FAC_H */
--- a/libAACdec/src/usacdec_lpc.cpp
+++ /dev/null
@@ -1,1194 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/**************************** AAC decoder library ******************************
-
-   Author(s):   Matthias Hildenbrand, Manuel Jander
-
-   Description: USAC LPC/AVQ decode
-
-*******************************************************************************/
-
-#include "usacdec_lpc.h"
-
-#include "usacdec_rom.h"
-#include "FDK_trigFcts.h"
-
-#define NQ_MAX 36
-
-/*
- * Helper functions.
- */
-
-/**
- * \brief Read unary code.
- * \param hBs bitstream handle as data source.
- * \return decoded value.
- */
-static int get_vlclbf(HANDLE_FDK_BITSTREAM hBs) {
-  int result = 0;
-
-  while (FDKreadBits(hBs, 1) && result <= NQ_MAX) {
-    result++;
-  }
-  return result;
-}
-
-/**
- * \brief Read bit count limited unary code.
- * \param hBs bitstream handle as data source
- * \param n max amount of bits to be read.
- * \return decoded value.
- */
-static int get_vlclbf_n(HANDLE_FDK_BITSTREAM hBs, int n) {
-  int result = 0;
-
-  while (FDKreadBits(hBs, 1)) {
-    result++;
-    n--;
-    if (n <= 0) {
-      break;
-    }
-  }
-
-  return result;
-}
-
-/*
- * Algebraic Vector Quantizer
- */
-
-/* ZF_SCALE must be greater than (number of FIXP_ZF)/2
-   because the loss of precision caused by fPow2Div2 in RE8_PPV() */
-//#define ZF_SCALE ((NQ_MAX-3)>>1)
-#define ZF_SCALE ((DFRACT_BITS / 2))
-#define FIXP_ZF FIXP_DBL
-#define INT2ZF(x, s) (FIXP_ZF)((x) << (ZF_SCALE - (s)))
-#define ZF2INT(x) (INT)((x) >> ZF_SCALE)
-
-/* 1.0 in ZF format format */
-#define ONEZF ((FIXP_ZF)INT2ZF(1, 0))
-
-/* static */
-void nearest_neighbor_2D8(FIXP_ZF x[8], int y[8]) {
-  FIXP_ZF s, em, e[8];
-  int i, j, sum;
-
-  /* round x into 2Z^8 i.e. compute y=(y1,...,y8) such that yi = 2[xi/2]
-     where [.] is the nearest integer operator
-     in the mean time, compute sum = y1+...+y8
-  */
-  sum = 0;
-  for (i = 0; i < 8; i++) {
-    FIXP_ZF tmp;
-    /* round to ..., -2, 0, 2, ... ([-1..1[ --> 0) */
-    if (x[i] < (FIXP_ZF)0) {
-      tmp = ONEZF - x[i];
-      y[i] = -2 * ((ZF2INT(tmp)) >> 1);
-    } else {
-      tmp = ONEZF + x[i];
-      y[i] = 2 * ((ZF2INT(tmp)) >> 1);
-    }
-    sum += y[i];
-  }
-  /* check if y1+...+y8 is a multiple of 4
-     if not, y is not round xj in the wrong way where j is defined by
-        j = arg max_i | xi -yi|
-     (this is called the Wagner rule)
-  */
-  if (sum % 4) {
-    /* find j = arg max_i | xi -yi| */
-    em = (FIXP_SGL)0;
-    j = 0;
-    for (i = 0; i < 8; i++) {
-      /* compute ei = xi-yi */
-      e[i] = x[i] - INT2ZF(y[i], 0);
-    }
-    for (i = 0; i < 8; i++) {
-      /* compute |ei| = | xi-yi | */
-      if (e[i] < (FIXP_ZF)0) {
-        s = -e[i];
-      } else {
-        s = e[i];
-      }
-      /* check if |ei| is maximal, if so, set j=i */
-      if (em < s) {
-        em = s;
-        j = i;
-      }
-    }
-    /* round xj in the "wrong way" */
-    if (e[j] < (FIXP_ZF)0) {
-      y[j] -= 2;
-    } else {
-      y[j] += 2;
-    }
-  }
-}
-
-/*--------------------------------------------------------------
-  RE8_PPV(x,y)
-  NEAREST NEIGHBOR SEARCH IN INFINITE LATTICE RE8
-  the algorithm is based on the definition of RE8 as
-      RE8 = (2D8) U (2D8+[1,1,1,1,1,1,1,1])
-  it applies the coset decoding of Sloane and Conway
-  (i) x: point in R^8 in 32-ZF_SCALE.ZF_SCALE format
-  (o) y: point in RE8 (8-dimensional integer vector)
-  --------------------------------------------------------------
-*/
-/* static */
-void RE8_PPV(FIXP_ZF x[], SHORT y[], int r) {
-  int i, y0[8], y1[8];
-  FIXP_ZF x1[8], tmp;
-  FIXP_DBL e;
-
-  /* find the nearest neighbor y0 of x in 2D8 */
-  nearest_neighbor_2D8(x, y0);
-  /* find the nearest neighbor y1 of x in 2D8+(1,...,1) (by coset decoding) */
-  for (i = 0; i < 8; i++) {
-    x1[i] = x[i] - ONEZF;
-  }
-  nearest_neighbor_2D8(x1, y1);
-  for (i = 0; i < 8; i++) {
-    y1[i] += 1;
-  }
-
-  /* compute e0=||x-y0||^2 and e1=||x-y1||^2 */
-  e = (FIXP_DBL)0;
-  for (i = 0; i < 8; i++) {
-    tmp = x[i] - INT2ZF(y0[i], 0);
-    e += fPow2Div2(
-        tmp << r); /* shift left to ensure that no fract part bits get lost. */
-    tmp = x[i] - INT2ZF(y1[i], 0);
-    e -= fPow2Div2(tmp << r);
-  }
-  /* select best candidate y0 or y1 to minimize distortion */
-  if (e < (FIXP_DBL)0) {
-    for (i = 0; i < 8; i++) {
-      y[i] = y0[i];
-    }
-  } else {
-    for (i = 0; i < 8; i++) {
-      y[i] = y1[i];
-    }
-  }
-}
-
-/* table look-up of unsigned value: find i where index >= table[i]
-   Note: range must be >= 2, index must be >= table[0] */
-static int table_lookup(const USHORT *table, unsigned int index, int range) {
-  int i;
-
-  for (i = 4; i < range; i += 4) {
-    if (index < table[i]) {
-      break;
-    }
-  }
-  if (i > range) {
-    i = range;
-  }
-
-  if (index < table[i - 2]) {
-    i -= 2;
-  }
-  if (index < table[i - 1]) {
-    i--;
-  }
-  i--;
-
-  return (i); /* index >= table[i] */
-}
-
-/*--------------------------------------------------------------------------
-  re8_decode_rank_of_permutation(rank, xs, x)
-  DECODING OF THE RANK OF THE PERMUTATION OF xs
-  (i) rank: index (rank) of a permutation
-  (i) xs:   signed leader in RE8 (8-dimensional integer vector)
-  (o) x:    point in RE8 (8-dimensional integer vector)
-  --------------------------------------------------------------------------
- */
-static void re8_decode_rank_of_permutation(int rank, int *xs, SHORT x[8]) {
-  INT a[8], w[8], B, fac, fac_B, target;
-  int i, j;
-
-  /* --- pre-processing based on the signed leader xs ---
-     - compute the alphabet a=[a[0] ... a[q-1]] of x (q elements)
-       such that a[0]!=...!=a[q-1]
-       it is assumed that xs is sorted in the form of a signed leader
-       which can be summarized in 2 requirements:
-          a) |xs[0]| >= |xs[1]| >= |xs[2]| >= ... >= |xs[7]|
-          b) if |xs[i]|=|xs[i-1]|, xs[i]>=xs[i+1]
-       where |.| indicates the absolute value operator
-     - compute q (the number of symbols in the alphabet)
-     - compute w[0..q-1] where w[j] counts the number of occurences of
-       the symbol a[j] in xs
-     - compute B = prod_j=0..q-1 (w[j]!) where .! is the factorial */
-  /* xs[i], xs[i-1] and ptr_w/a*/
-  j = 0;
-  w[j] = 1;
-  a[j] = xs[0];
-  B = 1;
-  for (i = 1; i < 8; i++) {
-    if (xs[i] != xs[i - 1]) {
-      j++;
-      w[j] = 1;
-      a[j] = xs[i];
-    } else {
-      w[j]++;
-      B *= w[j];
-    }
-  }
-
-  /* --- actual rank decoding ---
-     the rank of x (where x is a permutation of xs) is based on
-     Schalkwijk's formula
-     it is given by rank=sum_{k=0..7} (A_k * fac_k/B_k)
-     the decoding of this rank is sequential and reconstructs x[0..7]
-     element by element from x[0] to x[7]
-     [the tricky part is the inference of A_k for each k...]
-   */
-
-  if (w[0] == 8) {
-    for (i = 0; i < 8; i++) {
-      x[i] = a[0]; /* avoid fac of 40320 */
-    }
-  } else {
-    target = rank * B;
-    fac_B = 1;
-    /* decode x element by element */
-    for (i = 0; i < 8; i++) {
-      fac = fac_B * fdk_dec_tab_factorial[i]; /* fac = 1..5040 */
-      j = -1;
-      do {
-        target -= w[++j] * fac;
-      } while (target >= 0); /* max of 30 tests / SV */
-      x[i] = a[j];
-      /* update rank, denominator B (B_k) and counter w[j] */
-      target += w[j] * fac; /* target = fac_B*B*rank */
-      fac_B *= w[j];
-      w[j]--;
-    }
-  }
-}
-
-/*--------------------------------------------------------------------------
-  re8_decode_base_index(n, I, y)
-  DECODING OF AN INDEX IN Qn (n=0,2,3 or 4)
-  (i) n: codebook number (*n is an integer defined in {0,2,3,4})
-  (i) I: index of c (pointer to unsigned 16-bit word)
-  (o) y: point in RE8 (8-dimensional integer vector)
-  note: the index I is defined as a 32-bit word, but only
-  16 bits are required (long can be replaced by unsigned integer)
-  --------------------------------------------------------------------------
- */
-static void re8_decode_base_index(int *n, UINT index, SHORT y[8]) {
-  int i, im, t, sign_code, ka, ks, rank, leader[8];
-
-  if (*n < 2) {
-    for (i = 0; i < 8; i++) {
-      y[i] = 0;
-    }
-  } else {
-    // index = (unsigned int)*I;
-    /* search for the identifier ka of the absolute leader (table-lookup)
-       Q2 is a subset of Q3 - the two cases are considered in the same branch
-     */
-    switch (*n) {
-      case 2:
-      case 3:
-        i = table_lookup(fdk_dec_I3, index, NB_LDQ3);
-        ka = fdk_dec_A3[i];
-        break;
-      case 4:
-        i = table_lookup(fdk_dec_I4, index, NB_LDQ4);
-        ka = fdk_dec_A4[i];
-        break;
-      default:
-        FDK_ASSERT(0);
-        return;
-    }
-    /* reconstruct the absolute leader */
-    for (i = 0; i < 8; i++) {
-      leader[i] = fdk_dec_Da[ka][i];
-    }
-    /* search for the identifier ks of the signed leader (table look-up)
-       (this search is focused based on the identifier ka of the absolute
-        leader)*/
-    t = fdk_dec_Ia[ka];
-    im = fdk_dec_Ns[ka];
-    ks = table_lookup(fdk_dec_Is + t, index, im);
-
-    /* reconstruct the signed leader from its sign code */
-    sign_code = 2 * fdk_dec_Ds[t + ks];
-    for (i = 7; i >= 0; i--) {
-      leader[i] *= (1 - (sign_code & 2));
-      sign_code >>= 1;
-    }
-
-    /* compute and decode the rank of the permutation */
-    rank = index - fdk_dec_Is[t + ks]; /* rank = index - cardinality offset */
-
-    re8_decode_rank_of_permutation(rank, leader, y);
-  }
-  return;
-}
-
-/* re8_y2k(y,m,k)
-   VORONOI INDEXING (INDEX DECODING) k -> y
-   (i) k: Voronoi index k[0..7]
-   (i) m: Voronoi modulo (m = 2^r = 1<<r, where r is integer >=2)
-   (i) r: Voronoi order  (m = 2^r = 1<<r, where r is integer >=2)
-   (o) y: 8-dimensional point y[0..7] in RE8
- */
-static void re8_k2y(int *k, int r, SHORT *y) {
-  int i, tmp, sum;
-  SHORT v[8];
-  FIXP_ZF zf[8];
-
-  FDK_ASSERT(r <= ZF_SCALE);
-
-  /* compute y = k M and z=(y-a)/m, where
-     M = [4        ]
-         [2 2      ]
-         [|   \    ]
-         [2     2  ]
-         [1 1 _ 1 1]
-     a=(2,0,...,0)
-     m = 1<<r
-  */
-  for (i = 0; i < 8; i++) {
-    y[i] = k[7];
-  }
-  zf[7] = INT2ZF(y[7], r);
-  sum = 0;
-  for (i = 6; i >= 1; i--) {
-    tmp = 2 * k[i];
-    sum += tmp;
-    y[i] += tmp;
-    zf[i] = INT2ZF(y[i], r);
-  }
-  y[0] += (4 * k[0] + sum);
-  zf[0] = INT2ZF(y[0] - 2, r);
-  /* find nearest neighbor v of z in infinite RE8 */
-  RE8_PPV(zf, v, r);
-  /* compute y -= m v */
-  for (i = 0; i < 8; i++) {
-    y[i] -= (SHORT)(v[i] << r);
-  }
-}
-
-/*--------------------------------------------------------------------------
-  RE8_dec(n, I, k, y)
-  MULTI-RATE INDEXING OF A POINT y in THE LATTICE RE8 (INDEX DECODING)
-  (i) n: codebook number (*n is an integer defined in {0,2,3,4,..,n_max}). n_max
-  = 36 (i) I: index of c (pointer to unsigned 16-bit word) (i) k: index of v
-  (8-dimensional vector of binary indices) = Voronoi index (o) y: point in RE8
-  (8-dimensional integer vector) note: the index I is defined as a 32-bit word,
-  but only 16 bits are required (long can be replaced by unsigned integer)
-
-  return 0 on success, -1 on error.
-  --------------------------------------------------------------------------
- */
-static int RE8_dec(int n, int I, int *k, FIXP_DBL *y) {
-  SHORT v[8];
-  SHORT _y[8];
-  UINT r;
-  int i;
-
-  /* Check bound of codebook qn */
-  if (n > NQ_MAX) {
-    return -1;
-  }
-
-  /* decode the sub-indices I and kv[] according to the codebook number n:
-     if n=0,2,3,4, decode I (no Voronoi extension)
-     if n>4, Voronoi extension is used, decode I and kv[] */
-  if (n <= 4) {
-    re8_decode_base_index(&n, I, _y);
-    for (i = 0; i < 8; i++) {
-      y[i] = (LONG)_y[i];
-    }
-  } else {
-    /* compute the Voronoi modulo m = 2^r where r is extension order */
-    r = ((n - 3) >> 1);
-
-    while (n > 4) {
-      n -= 2;
-    }
-    /* decode base codebook index I into c (c is an element of Q3 or Q4)
-       [here c is stored in y to save memory] */
-    re8_decode_base_index(&n, I, _y);
-    /* decode Voronoi index k[] into v */
-    re8_k2y(k, r, v);
-    /* reconstruct y as y = m c + v (with m=2^r, r integer >=1) */
-    for (i = 0; i < 8; i++) {
-      y[i] = (LONG)((_y[i] << r) + v[i]);
-    }
-  }
-  return 0;
-}
-
-/**************************/
-/* start LPC decode stuff */
-/**************************/
-//#define M         16
-#define FREQ_MAX 6400.0f
-#define FREQ_DIV 400.0f
-#define LSF_GAP 50.0f
-
-/**
- * \brief calculate inverse weighting factor and add non-weighted residual
- *        LSF vector to first stage LSF approximation
- * \param lsfq first stage LSF approximation values.
- * \param xq weighted residual LSF vector
- * \param nk_mode code book number coding mode.
- */
-static void lsf_weight_2st(FIXP_LPC *lsfq, FIXP_DBL *xq, int nk_mode) {
-  FIXP_LPC d[M_LP_FILTER_ORDER + 1];
-  FIXP_SGL factor;
-  LONG w; /* inverse weight factor */
-  int i;
-
-  /* compute lsf distance */
-  d[0] = lsfq[0];
-  d[M_LP_FILTER_ORDER] =
-      FL2FXCONST_LPC(FREQ_MAX / (1 << LSF_SCALE)) - lsfq[M_LP_FILTER_ORDER - 1];
-  for (i = 1; i < M_LP_FILTER_ORDER; i++) {
-    d[i] = lsfq[i] - lsfq[i - 1];
-  }
-
-  switch (nk_mode) {
-    case 0:
-      factor = FL2FXCONST_SGL(2.0f * 60.0f / FREQ_DIV);
-      break; /* abs */
-    case 1:
-      factor = FL2FXCONST_SGL(2.0f * 65.0f / FREQ_DIV);
-      break; /* mid */
-    case 2:
-      factor = FL2FXCONST_SGL(2.0f * 64.0f / FREQ_DIV);
-      break; /* rel1 */
-    default:
-      factor = FL2FXCONST_SGL(2.0f * 63.0f / FREQ_DIV);
-      break; /* rel2 */
-  }
-  /* add non-weighted residual LSF vector to LSF1st */
-  for (i = 0; i < M_LP_FILTER_ORDER; i++) {
-    w = (LONG)fMultDiv2(factor, sqrtFixp(fMult(d[i], d[i + 1])));
-    lsfq[i] = fAddSaturate(lsfq[i], FX_DBL2FX_LPC((FIXP_DBL)(w * (LONG)xq[i])));
-  }
-
-  return;
-}
-
-/**
- * \brief decode nqn amount of code book numbers. These values determine the
- * amount of following bits for nqn AVQ RE8 vectors.
- * \param nk_mode quantization mode.
- * \param nqn amount code book number to read.
- * \param qn pointer to output buffer to hold decoded code book numbers qn.
- */
-static void decode_qn(HANDLE_FDK_BITSTREAM hBs, int nk_mode, int nqn,
-                      int qn[]) {
-  int n;
-
-  if (nk_mode == 1) { /* nk mode 1 */
-    /* Unary code for mid LPC1/LPC3 */
-    /* Q0=0, Q2=10, Q3=110, ... */
-    for (n = 0; n < nqn; n++) {
-      qn[n] = get_vlclbf(hBs);
-      if (qn[n] > 0) {
-        qn[n]++;
-      }
-    }
-  } else { /* nk_mode 0, 3 and 2 */
-    /* 2 bits to specify Q2,Q3,Q4,ext */
-    for (n = 0; n < nqn; n++) {
-      qn[n] = 2 + FDKreadBits(hBs, 2);
-    }
-    if (nk_mode == 2) {
-      /* Unary code for rel LPC1/LPC3 */
-      /* Q0 = 0, Q5=10, Q6=110, ... */
-      for (n = 0; n < nqn; n++) {
-        if (qn[n] > 4) {
-          qn[n] = get_vlclbf(hBs);
-          if (qn[n] > 0) qn[n] += 4;
-        }
-      }
-    } else { /* nk_mode == (0 and 3) */
-      /* Unary code for abs and rel LPC0/LPC2 */
-      /* Q5 = 0, Q6=10, Q0=110, Q7=1110, ... */
-      for (n = 0; n < nqn; n++) {
-        if (qn[n] > 4) {
-          qn[n] = get_vlclbf(hBs);
-          switch (qn[n]) {
-            case 0:
-              qn[n] = 5;
-              break;
-            case 1:
-              qn[n] = 6;
-              break;
-            case 2:
-              qn[n] = 0;
-              break;
-            default:
-              qn[n] += 4;
-              break;
-          }
-        }
-      }
-    }
-  }
-}
-
-/**
- * \brief reorder LSF coefficients to minimum distance.
- * \param lsf pointer to buffer containing LSF coefficients and where reordered
- * LSF coefficients will be stored into, scaled by LSF_SCALE.
- * \param min_dist min distance scaled by LSF_SCALE
- * \param n number of LSF/LSP coefficients.
- */
-static void reorder_lsf(FIXP_LPC *lsf, FIXP_LPC min_dist, int n) {
-  FIXP_LPC lsf_min;
-  int i;
-
-  lsf_min = min_dist;
-  for (i = 0; i < n; i++) {
-    if (lsf[i] < lsf_min) {
-      lsf[i] = lsf_min;
-    }
-    lsf_min = fAddSaturate(lsf[i], min_dist);
-  }
-
-  /* reverse */
-  lsf_min = FL2FXCONST_LPC(FREQ_MAX / (1 << LSF_SCALE)) - min_dist;
-  for (i = n - 1; i >= 0; i--) {
-    if (lsf[i] > lsf_min) {
-      lsf[i] = lsf_min;
-    }
-
-    lsf_min = lsf[i] - min_dist;
-  }
-}
-
-/**
- * \brief First stage approximation
- * \param hBs bitstream handle as data source
- * \param lsfq pointer to output buffer to hold LPC coefficients scaled by
- * LSF_SCALE.
- */
-static void vlpc_1st_dec(
-    HANDLE_FDK_BITSTREAM hBs, /* input:  codebook index                  */
-    FIXP_LPC *lsfq            /* i/o:    i:prediction   o:quantized lsf  */
-) {
-  const FIXP_LPC *p_dico;
-  int i, index;
-
-  index = FDKreadBits(hBs, 8);
-  p_dico = &fdk_dec_dico_lsf_abs_8b[index * M_LP_FILTER_ORDER];
-  for (i = 0; i < M_LP_FILTER_ORDER; i++) {
-    lsfq[i] = p_dico[i];
-  }
-}
-
-/**
- * \brief Do first stage approximation weighting and multiply with AVQ
- * refinement.
- * \param hBs bitstream handle data ssource.
- * \param lsfq buffer holding 1st stage approx, 2nd stage approx is added to
- * this values.
- * \param nk_mode quantization mode.
- * \return 0 on success, -1 on error.
- */
-static int vlpc_2st_dec(
-    HANDLE_FDK_BITSTREAM hBs,
-    FIXP_LPC *lsfq, /* i/o:    i:1st stage   o:1st+2nd stage   */
-    int nk_mode     /* input:  0=abs, >0=rel                   */
-) {
-  int err;
-  FIXP_DBL xq[M_LP_FILTER_ORDER]; /* weighted residual LSF vector */
-
-  /* Decode AVQ refinement */
-  { err = CLpc_DecodeAVQ(hBs, xq, nk_mode, 2, 8); }
-  if (err != 0) {
-    return -1;
-  }
-
-  /* add non-weighted residual LSF vector to LSF1st */
-  lsf_weight_2st(lsfq, xq, nk_mode);
-
-  /* reorder */
-  reorder_lsf(lsfq, FL2FXCONST_LPC(LSF_GAP / (1 << LSF_SCALE)),
-              M_LP_FILTER_ORDER);
-
-  return 0;
-}
-
-/*
- * Externally visible functions
- */
-
-int CLpc_DecodeAVQ(HANDLE_FDK_BITSTREAM hBs, FIXP_DBL *pOutput, int nk_mode,
-                   int no_qn, int length) {
-  int i, l;
-
-  for (i = 0; i < length; i += 8 * no_qn) {
-    int qn[2], nk, n, I;
-    int kv[8] = {0};
-
-    decode_qn(hBs, nk_mode, no_qn, qn);
-
-    for (l = 0; l < no_qn; l++) {
-      if (qn[l] == 0) {
-        FDKmemclear(&pOutput[i + l * 8], 8 * sizeof(FIXP_DBL));
-      }
-
-      /* Voronoi extension order ( nk ) */
-      nk = 0;
-      n = qn[l];
-      if (qn[l] > 4) {
-        nk = (qn[l] - 3) >> 1;
-        n = qn[l] - nk * 2;
-      }
-
-      /* Base codebook index, in reverse bit group order (!) */
-      I = FDKreadBits(hBs, 4 * n);
-
-      if (nk > 0) {
-        int j;
-
-        for (j = 0; j < 8; j++) {
-          kv[j] = FDKreadBits(hBs, nk);
-        }
-      }
-
-      if (RE8_dec(qn[l], I, kv, &pOutput[i + l * 8]) != 0) {
-        return -1;
-      }
-    }
-  }
-  return 0;
-}
-
-int CLpc_Read(HANDLE_FDK_BITSTREAM hBs, FIXP_LPC lsp[][M_LP_FILTER_ORDER],
-              FIXP_LPC lpc4_lsf[M_LP_FILTER_ORDER],
-              FIXP_LPC lsf_adaptive_mean_cand[M_LP_FILTER_ORDER],
-              FIXP_SGL pStability[], UCHAR *mod, int first_lpd_flag,
-              int last_lpc_lost, int last_frame_ok) {
-  int i, k, err;
-  int mode_lpc_bin = 0; /* mode_lpc bitstream representation */
-  int lpc_present[5] = {0, 0, 0, 0, 0};
-  int lpc0_available = 1;
-  int s = 0;
-  int l = 3;
-  const int nbDiv = NB_DIV;
-
-  lpc_present[4 >> s] = 1; /* LPC4 */
-
-  /* Decode LPC filters in the following order: LPC 4,0,2,1,3 */
-
-  /*** Decode LPC4 ***/
-  vlpc_1st_dec(hBs, lsp[4 >> s]);
-  err = vlpc_2st_dec(hBs, lsp[4 >> s], 0); /* nk_mode = 0 */
-  if (err != 0) {
-    return err;
-  }
-
-  /*** Decode LPC0 and LPC2 ***/
-  k = 0;
-  if (!first_lpd_flag) {
-    lpc_present[0] = 1;
-    lpc0_available = !last_lpc_lost;
-    /* old LPC4 is new LPC0 */
-    for (i = 0; i < M_LP_FILTER_ORDER; i++) {
-      lsp[0][i] = lpc4_lsf[i];
-    }
-    /* skip LPC0 and continue with LPC2 */
-    k = 2;
-  }
-
-  for (; k < l; k += 2) {
-    int nk_mode = 0;
-
-    if ((k == 2) && (mod[0] == 3)) {
-      break; /* skip LPC2 */
-    }
-
-    lpc_present[k >> s] = 1;
-
-    mode_lpc_bin = FDKreadBit(hBs);
-
-    if (mode_lpc_bin == 0) {
-      /* LPC0/LPC2: Abs */
-      vlpc_1st_dec(hBs, lsp[k >> s]);
-    } else {
-      /* LPC0/LPC2: RelR */
-      for (i = 0; i < M_LP_FILTER_ORDER; i++) {
-        lsp[k >> s][i] = lsp[4 >> s][i];
-      }
-      nk_mode = 3;
-    }
-
-    err = vlpc_2st_dec(hBs, lsp[k >> s], nk_mode);
-    if (err != 0) {
-      return err;
-    }
-  }
-
-  /*** Decode LPC1 ***/
-  if (mod[0] < 2) { /* else: skip LPC1 */
-    lpc_present[1] = 1;
-    mode_lpc_bin = get_vlclbf_n(hBs, 2);
-
-    switch (mode_lpc_bin) {
-      case 1:
-        /* LPC1: abs */
-        vlpc_1st_dec(hBs, lsp[1]);
-        err = vlpc_2st_dec(hBs, lsp[1], 0);
-        if (err != 0) {
-          return err;
-        }
-        break;
-      case 2:
-        /* LPC1: mid0 (no second stage AVQ quantizer in this case) */
-        if (lpc0_available) { /* LPC0/lsf[0] might be zero some times */
-          for (i = 0; i < M_LP_FILTER_ORDER; i++) {
-            lsp[1][i] = (lsp[0][i] >> 1) + (lsp[2][i] >> 1);
-          }
-        } else {
-          for (i = 0; i < M_LP_FILTER_ORDER; i++) {
-            lsp[1][i] = lsp[2][i];
-          }
-        }
-        break;
-      case 0:
-        /* LPC1: RelR */
-        for (i = 0; i < M_LP_FILTER_ORDER; i++) {
-          lsp[1][i] = lsp[2][i];
-        }
-        err = vlpc_2st_dec(hBs, lsp[1], 2 << s);
-        if (err != 0) {
-          return err;
-        }
-        break;
-    }
-  }
-
-  /*** Decode LPC3 ***/
-  if ((mod[2] < 2)) { /* else: skip LPC3 */
-    int nk_mode = 0;
-    lpc_present[3] = 1;
-
-    mode_lpc_bin = get_vlclbf_n(hBs, 3);
-
-    switch (mode_lpc_bin) {
-      case 1:
-        /* LPC3: abs */
-        vlpc_1st_dec(hBs, lsp[3]);
-        break;
-      case 0:
-        /* LPC3: mid */
-        for (i = 0; i < M_LP_FILTER_ORDER; i++) {
-          lsp[3][i] = (lsp[2][i] >> 1) + (lsp[4][i] >> 1);
-        }
-        nk_mode = 1;
-        break;
-      case 2:
-        /* LPC3: relL */
-        for (i = 0; i < M_LP_FILTER_ORDER; i++) {
-          lsp[3][i] = lsp[2][i];
-        }
-        nk_mode = 2;
-        break;
-      case 3:
-        /* LPC3: relR */
-        for (i = 0; i < M_LP_FILTER_ORDER; i++) {
-          lsp[3][i] = lsp[4][i];
-        }
-        nk_mode = 2;
-        break;
-    }
-    err = vlpc_2st_dec(hBs, lsp[3], nk_mode);
-    if (err != 0) {
-      return err;
-    }
-  }
-
-  if (!lpc0_available && !last_frame_ok) {
-    /* LPC(0) was lost. Use next available LPC(k) instead */
-    for (k = 1; k < (nbDiv + 1); k++) {
-      if (lpc_present[k]) {
-        for (i = 0; i < M_LP_FILTER_ORDER; i++) {
-#define LSF_INIT_TILT (0.25f)
-          if (mod[0] > 0) {
-            lsp[0][i] = FX_DBL2FX_LPC(
-                fMult(lsp[k][i], FL2FXCONST_SGL(1.0f - LSF_INIT_TILT)) +
-                fMult(fdk_dec_lsf_init[i], FL2FXCONST_SGL(LSF_INIT_TILT)));
-          } else {
-            lsp[0][i] = lsp[k][i];
-          }
-        }
-        break;
-      }
-    }
-  }
-
-  for (i = 0; i < M_LP_FILTER_ORDER; i++) {
-    lpc4_lsf[i] = lsp[4 >> s][i];
-  }
-
-  {
-    FIXP_DBL divFac;
-    int last, numLpc = 0;
-
-    i = nbDiv;
-    do {
-      numLpc += lpc_present[i--];
-    } while (i >= 0 && numLpc < 3);
-
-    last = i;
-
-    switch (numLpc) {
-      case 3:
-        divFac = FL2FXCONST_DBL(1.0f / 3.0f);
-        break;
-      case 2:
-        divFac = FL2FXCONST_DBL(1.0f / 2.0f);
-        break;
-      default:
-        divFac = FL2FXCONST_DBL(1.0f);
-        break;
-    }
-
-    /* get the adaptive mean for the next (bad) frame */
-    for (k = 0; k < M_LP_FILTER_ORDER; k++) {
-      FIXP_DBL tmp = (FIXP_DBL)0;
-      for (i = nbDiv; i > last; i--) {
-        if (lpc_present[i]) {
-          tmp = fMultAdd(tmp >> 1, lsp[i][k], divFac);
-        }
-      }
-      lsf_adaptive_mean_cand[k] = FX_DBL2FX_LPC(tmp);
-    }
-  }
-
-  /* calculate stability factor Theta. Needed for ACELP decoder and concealment
-   */
-  {
-    FIXP_LPC *lsf_prev, *lsf_curr;
-    k = 0;
-
-    FDK_ASSERT(lpc_present[0] == 1 && lpc_present[4 >> s] == 1);
-    lsf_prev = lsp[0];
-    for (i = 1; i < (nbDiv + 1); i++) {
-      if (lpc_present[i]) {
-        FIXP_DBL tmp = (FIXP_DBL)0;
-        int j;
-        lsf_curr = lsp[i];
-
-        /* sum = tmp * 2^(LSF_SCALE*2 + 4) */
-        for (j = 0; j < M_LP_FILTER_ORDER; j++) {
-          tmp += fPow2Div2((FIXP_SGL)(lsf_curr[j] - lsf_prev[j])) >> 3;
-        }
-
-        /* tmp = (float)(FL2FXCONST_DBL(1.25f) - fMult(tmp,
-         * FL2FXCONST_DBL(1/400000.0f))); */
-        tmp = FL2FXCONST_DBL(1.25f / (1 << LSF_SCALE)) -
-              fMult(tmp, FL2FXCONST_DBL((1 << (LSF_SCALE + 4)) / 400000.0f));
-        if (tmp >= FL2FXCONST_DBL(1.0f / (1 << LSF_SCALE))) {
-          pStability[k] = FL2FXCONST_SGL(1.0f / 2.0f);
-        } else if (tmp < FL2FXCONST_DBL(0.0f)) {
-          pStability[k] = FL2FXCONST_SGL(0.0f);
-        } else {
-          pStability[k] = FX_DBL2FX_SGL(tmp << (LSF_SCALE - 1));
-        }
-
-        lsf_prev = lsf_curr;
-        k = i;
-      } else {
-        /* Mark stability value as undefined. */
-        pStability[i] = (FIXP_SGL)-1;
-      }
-    }
-  }
-
-  /* convert into LSP domain */
-  for (i = 0; i < (nbDiv + 1); i++) {
-    if (lpc_present[i]) {
-      for (k = 0; k < M_LP_FILTER_ORDER; k++) {
-        lsp[i][k] = FX_DBL2FX_LPC(
-            fixp_cos(fMult(lsp[i][k],
-                           FL2FXCONST_SGL((1 << LSPARG_SCALE) * M_PI / 6400.0)),
-                     LSF_SCALE - LSPARG_SCALE));
-      }
-    }
-  }
-
-  return 0;
-}
-
-void CLpc_Conceal(FIXP_LPC lsp[][M_LP_FILTER_ORDER],
-                  FIXP_LPC lpc4_lsf[M_LP_FILTER_ORDER],
-                  FIXP_LPC lsf_adaptive_mean[M_LP_FILTER_ORDER],
-                  const int first_lpd_flag) {
-  int i, j;
-
-#define BETA (FL2FXCONST_SGL(0.25f))
-#define ONE_BETA (FL2FXCONST_SGL(0.75f))
-#define BFI_FAC (FL2FXCONST_SGL(0.90f))
-#define ONE_BFI_FAC (FL2FXCONST_SGL(0.10f))
-
-  /* Frame loss concealment (could be improved) */
-
-  if (first_lpd_flag) {
-    /* Reset past LSF values */
-    for (i = 0; i < M_LP_FILTER_ORDER; i++) {
-      lsp[0][i] = lpc4_lsf[i] = fdk_dec_lsf_init[i];
-    }
-  } else {
-    /* old LPC4 is new LPC0 */
-    for (i = 0; i < M_LP_FILTER_ORDER; i++) {
-      lsp[0][i] = lpc4_lsf[i];
-    }
-  }
-
-  /* LPC1 */
-  for (i = 0; i < M_LP_FILTER_ORDER; i++) {
-    FIXP_LPC lsf_mean = FX_DBL2FX_LPC(fMult(BETA, fdk_dec_lsf_init[i]) +
-                                      fMult(ONE_BETA, lsf_adaptive_mean[i]));
-
-    lsp[1][i] = FX_DBL2FX_LPC(fMult(BFI_FAC, lpc4_lsf[i]) +
-                              fMult(ONE_BFI_FAC, lsf_mean));
-  }
-
-  /* LPC2 - LPC4 */
-  for (j = 2; j <= 4; j++) {
-    for (i = 0; i < M_LP_FILTER_ORDER; i++) {
-      /* lsf_mean[i] =  FX_DBL2FX_LPC(fMult((FIXP_LPC)(BETA + j *
-         FL2FXCONST_LPC(0.1f)), fdk_dec_lsf_init[i])
-                                    + fMult((FIXP_LPC)(ONE_BETA - j *
-         FL2FXCONST_LPC(0.1f)), lsf_adaptive_mean[i])); */
-
-      FIXP_LPC lsf_mean = FX_DBL2FX_LPC(
-          fMult((FIXP_SGL)(BETA + (FIXP_SGL)(j * (INT)FL2FXCONST_SGL(0.1f))),
-                (FIXP_SGL)fdk_dec_lsf_init[i]) +
-          fMult(
-              (FIXP_SGL)(ONE_BETA - (FIXP_SGL)(j * (INT)FL2FXCONST_SGL(0.1f))),
-              lsf_adaptive_mean[i]));
-
-      lsp[j][i] = FX_DBL2FX_LPC(fMult(BFI_FAC, lsp[j - 1][i]) +
-                                fMult(ONE_BFI_FAC, lsf_mean));
-    }
-  }
-
-  /* Update past values for the future */
-  for (i = 0; i < M_LP_FILTER_ORDER; i++) {
-    lpc4_lsf[i] = lsp[4][i];
-  }
-
-  /* convert into LSP domain */
-  for (j = 0; j < 5; j++) {
-    for (i = 0; i < M_LP_FILTER_ORDER; i++) {
-      lsp[j][i] = FX_DBL2FX_LPC(fixp_cos(
-          fMult(lsp[j][i], FL2FXCONST_SGL((1 << LSPARG_SCALE) * M_PI / 6400.0)),
-          LSF_SCALE - LSPARG_SCALE));
-    }
-  }
-}
-
-void E_LPC_a_weight(FIXP_LPC *wA, const FIXP_LPC *A, int m) {
-  FIXP_DBL f;
-  int i;
-
-  f = FL2FXCONST_DBL(0.92f);
-  for (i = 0; i < m; i++) {
-    wA[i] = FX_DBL2FX_LPC(fMult(A[i], f));
-    f = fMult(f, FL2FXCONST_DBL(0.92f));
-  }
-}
-
-void CLpd_DecodeGain(FIXP_DBL *gain, INT *gain_e, int gain_code) {
-  /* gain * 2^(gain_e) = 10^(gain_code/28) */
-  *gain = fLdPow(
-      FL2FXCONST_DBL(3.3219280948873623478703194294894 / 4.0), /* log2(10)*/
-      2,
-      fMultDiv2((FIXP_DBL)gain_code << (DFRACT_BITS - 1 - 7),
-                FL2FXCONST_DBL(2.0f / 28.0f)),
-      7, gain_e);
-}
-
-  /**
-   * \brief *   Find the polynomial F1(z) or F2(z) from the LSPs.
-   * This is performed by expanding the product polynomials:
-   *
-   * F1(z) =   product   ( 1 - 2 LSP_i z^-1 + z^-2 )
-   *         i=0,2,4,6,8
-   * F2(z) =   product   ( 1 - 2 LSP_i z^-1 + z^-2 )
-   *         i=1,3,5,7,9
-   *
-   * where LSP_i are the LSPs in the cosine domain.
-   * R.A.Salami    October 1990
-   * \param lsp input, line spectral freq. (cosine domain)
-   * \param f output, the coefficients of F1 or F2, scaled by 8 bits
-   * \param n no of coefficients (m/2)
-   * \param flag 1 : F1(z) ; 2 : F2(z)
-   */
-
-#define SF_F 8
-
-static void get_lsppol(FIXP_LPC lsp[], FIXP_DBL f[], int n, int flag) {
-  FIXP_DBL b;
-  FIXP_LPC *plsp;
-  int i, j;
-
-  plsp = lsp + flag - 1;
-  f[0] = FL2FXCONST_DBL(1.0f / (1 << SF_F));
-  b = -FX_LPC2FX_DBL(*plsp);
-  f[1] = b >> (SF_F - 1);
-  for (i = 2; i <= n; i++) {
-    plsp += 2;
-    b = -FX_LPC2FX_DBL(*plsp);
-    f[i] = ((fMultDiv2(b, f[i - 1]) << 1) + (f[i - 2])) << 1;
-    for (j = i - 1; j > 1; j--) {
-      f[j] = f[j] + (fMultDiv2(b, f[j - 1]) << 2) + f[j - 2];
-    }
-    f[1] = f[1] + (b >> (SF_F - 1));
-  }
-  return;
-}
-
-#define NC M_LP_FILTER_ORDER / 2
-
-/**
- * \brief lsp input LSP vector
- * \brief a output LP filter coefficient vector scaled by SF_A_COEFFS.
- */
-void E_LPC_f_lsp_a_conversion(FIXP_LPC *lsp, FIXP_LPC *a, INT *a_exp) {
-  FIXP_DBL f1[NC + 1], f2[NC + 1];
-  int i, k;
-
-  /*-----------------------------------------------------*
-   *  Find the polynomials F1(z) and F2(z)               *
-   *-----------------------------------------------------*/
-
-  get_lsppol(lsp, f1, NC, 1);
-  get_lsppol(lsp, f2, NC, 2);
-
-  /*-----------------------------------------------------*
-   *  Multiply F1(z) by (1+z^-1) and F2(z) by (1-z^-1)   *
-   *-----------------------------------------------------*/
-  for (i = NC; i > 0; i--) {
-    f1[i] += f1[i - 1];
-    f2[i] -= f2[i - 1];
-  }
-
-  FIXP_DBL aDBL[M_LP_FILTER_ORDER];
-
-  for (i = 1, k = M_LP_FILTER_ORDER - 1; i <= NC; i++, k--) {
-    FIXP_DBL tmp1, tmp2;
-
-    tmp1 = f1[i] >> 1;
-    tmp2 = f2[i] >> 1;
-
-    aDBL[i - 1] = (tmp1 + tmp2);
-    aDBL[k] = (tmp1 - tmp2);
-  }
-
-  int headroom_a = getScalefactor(aDBL, M_LP_FILTER_ORDER);
-
-  for (i = 0; i < M_LP_FILTER_ORDER; i++) {
-    a[i] = FX_DBL2FX_LPC(aDBL[i] << headroom_a);
-  }
-
-  *a_exp = 8 - headroom_a;
-}
--- a/libAACdec/src/usacdec_lpc.h
+++ /dev/null
@@ -1,190 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/**************************** AAC decoder library ******************************
-
-   Author(s):   Matthias Hildenbrand, Manuel Jander
-
-   Description: USAC LPC/AVQ decode
-
-*******************************************************************************/
-
-#ifndef USACDEC_LPC_H
-#define USACDEC_LPC_H
-
-#include "channelinfo.h"
-#include "common_fix.h"
-#include "FDK_bitstream.h"
-#include "usacdec_rom.h"
-
-#define LSPARG_SCALE 10
-
-/**
- * \brief AVQ (refinement) decode
- * \param hBs bitstream handle
- * \param lsfq buffer for AVQ decode output.
- * \param nk_mode quantization mode.
- * \param nqn amount of split/interleaved RE8 vectors.
- * \param total amount of individual data values to decode.
- * \return 0 on success, -1 on error.
- */
-int CLpc_DecodeAVQ(HANDLE_FDK_BITSTREAM hBs, FIXP_DBL *lsfq, int nk_mode,
-                   int nqn, int length);
-
-/**
- * \brief Read and decode LPC coeficient sets. First stage approximation + AVQ
- * decode.
- * \param[in]  hBs bitstream handle to read data from.
- * \param[out] lsp buffer into which the decoded LSP coefficients will be stored
- * into.
- * \param[in,out] lpc4_lsf buffer into which the decoded LCP4 LSF coefficients
- * will be stored into (persistent).
- * \param[out] lsf_adaptive_mean_cand lsf adaptive mean vector needed for
- * concealment.
- * \param[out] pStability array with stability values for the ACELP decoder (and
- * concealment).
- * \param[in]  mod array which defines modes (ACELP, TCX20|40|80) are used in
- * the current superframe.
- * \param[in]  first_lpd_flag indicates the presence of LPC0
- * \param[in]  last_lpc_lost indicate that LPC4 of previous frame was lost.
- * \param[in]  last_frame_ok indicate that the last frame was ok.
- * \return 0 on success, -1 on error.
- */
-int CLpc_Read(HANDLE_FDK_BITSTREAM hBs, FIXP_LPC lsp[][M_LP_FILTER_ORDER],
-              FIXP_LPC lpc4_lsf[M_LP_FILTER_ORDER],
-              FIXP_LPC lsf_adaptive_mean_cand[M_LP_FILTER_ORDER],
-              FIXP_SGL pStability[], UCHAR *mod, int first_lpd_flag,
-              int last_lpc_lost, int last_frame_ok);
-
-/**
- * \brief Generate LPC coefficient sets in case frame loss.
- * \param lsp buffer into which the decoded LSP coefficients will be stored
- * into.
- * \param lpc4_lsf buffer into which the decoded LCP4 LSF coefficients will be
- * stored into (persistent).
- * \param isf_adaptive_mean
- * \param first_lpd_flag indicates the previous LSF4 coefficients lpc4_lsf[] are
- * not valid.
- */
-void CLpc_Conceal(FIXP_LPC lsp[][M_LP_FILTER_ORDER],
-                  FIXP_LPC lpc4_lsf[M_LP_FILTER_ORDER],
-                  FIXP_LPC isf_adaptive_mean[M_LP_FILTER_ORDER],
-                  const int first_lpd_flag);
-
-/**
- * \brief apply absolute weighting
- * \param A weighted LPC coefficient vector output. The first coeffcient is
- * implicitly 1.0
- * \param A LPC coefficient vector. The first coeffcient is implicitly 1.0
- * \param m length of vector A
- */
-/* static */
-void E_LPC_a_weight(FIXP_LPC *wA, const FIXP_LPC *A, const int m);
-
-/**
- * \brief decode TCX/FAC gain. In case of TCX the lg/sqrt(rms) part
- *        must still be applied to obtain the gain value.
- * \param gain (o) pointer were the gain mantissa is stored into.
- * \param gain_e (o) pointer were the gain exponent is stored into.
- * \param gain_code (i) the 7 bit binary word from the bitstream
- *                      representing the gain.
- */
-void CLpd_DecodeGain(FIXP_DBL *gain, INT *gain_e, int gain_code);
-
-/**
- * \brief convert LSP coefficients into LP domain.
- */
-void E_LPC_f_lsp_a_conversion(FIXP_LPC *lsp, FIXP_LPC *a, INT *a_exp);
-
-#endif /* USACDEC_LPC_H */
--- a/libAACdec/src/usacdec_lpd.cpp
+++ /dev/null
@@ -1,2017 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/**************************** AAC decoder library ******************************
-
-   Author(s):   Manuel Jander
-
-   Description: USAC Linear Prediction Domain coding
-
-*******************************************************************************/
-
-#include "usacdec_lpd.h"
-
-#include "usacdec_rom.h"
-#include "usacdec_fac.h"
-#include "usacdec_lpc.h"
-#include "FDK_tools_rom.h"
-#include "fft.h"
-#include "mdct.h"
-#include "usacdec_acelp.h"
-#include "overlapadd.h"
-
-#include "block.h"
-
-#define SF_PITCH_TRACK 6
-#define SF_GAIN 3
-#define MIN_VAL FL2FXCONST_DBL(0.0f)
-#define MAX_VAL (FIXP_DBL) MAXVAL_DBL
-
-#include "ac_arith_coder.h"
-
-void filtLP(const FIXP_DBL *syn, FIXP_PCM *syn_out, FIXP_DBL *noise,
-            const FIXP_SGL *filt, INT stop, int len) {
-  INT i, j;
-  FIXP_DBL tmp;
-
-  for (i = 0; i < stop; i++) {
-    tmp = fMultDiv2(noise[i], filt[0]);  // Filt in Q-1.16
-    for (j = 1; j <= len; j++) {
-      tmp += fMultDiv2((noise[i - j] + noise[i + j]), filt[j]);
-    }
-    syn_out[i] = (FIXP_PCM)(IMDCT_SCALE(syn[i] - tmp));
-  }
-}
-
-void bass_pf_1sf_delay(
-    FIXP_DBL *syn,   /* (i) : 12.8kHz synthesis to postfilter              */
-    const INT *T_sf, /* (i) : Pitch period for all subframes (T_sf[16])    */
-    FIXP_DBL *pit_gain,
-    const int frame_length, /* (i) : frame length (should be 768|1024) */
-    const INT l_frame,
-    const INT l_next, /* (i) : look ahead for symmetric filtering           */
-    FIXP_PCM *synth_out, /* (o) : filtered synthesis (with delay of 1 subfr) */
-    FIXP_DBL mem_bpf[]) /* i/o : memory state [L_FILT+L_SUBFR]                */
-{
-  INT i, sf, i_subfr, T, T2, lg;
-
-  FIXP_DBL tmp, ener, corr, gain;
-  FIXP_DBL *noise, *noise_in;
-  FIXP_DBL
-  noise_buf[L_FILT + (2 * L_SUBFR)];  // L_FILT = 12, L_SUBFR = 64 => 140
-  const FIXP_DBL *x, *y;
-
-  {
-    noise = noise_buf + L_FILT;  // L_FILT = 12 delay of upsampling filter
-    noise_in = noise_buf + L_FILT + L_SUBFR;
-    /* Input scaling of the BPF memory */
-    scaleValues(mem_bpf, (L_FILT + L_SUBFR), 1);
-  }
-
-  int gain_exp = 17;
-
-  sf = 0;
-  for (i_subfr = 0; i_subfr < l_frame; i_subfr += L_SUBFR, sf++) {
-    T = T_sf[sf];
-    gain = pit_gain[sf];
-
-    /* Gain is in Q17.14 */
-    /* If gain > 1 set to 1 */
-    if (gain > (FIXP_DBL)(1 << 14)) gain = (FIXP_DBL)(1 << 14);
-
-    /* If gain < 0 set to 0 */
-    if (gain < (FIXP_DBL)0) gain = (FIXP_DBL)0;
-
-    if (gain > (FIXP_DBL)0) {
-      /* pitch tracker: test pitch/2 to avoid continuous pitch doubling */
-      /* Note: pitch is limited to PIT_MIN (34 = 376Hz) at the encoder  */
-      T2 = T >> 1;
-      x = &syn[i_subfr - L_EXTRA];
-      y = &syn[i_subfr - T2 - L_EXTRA];
-
-      ener = (FIXP_DBL)0;
-      corr = (FIXP_DBL)0;
-      tmp = (FIXP_DBL)0;
-
-      int headroom_x = getScalefactor(x, L_SUBFR + L_EXTRA);
-      int headroom_y = getScalefactor(y, L_SUBFR + L_EXTRA);
-
-      int width_shift = 7;
-
-      for (i = 0; i < (L_SUBFR + L_EXTRA); i++) {
-        ener += fPow2Div2((x[i] << headroom_x)) >> width_shift;
-        corr += fMultDiv2((x[i] << headroom_x), (y[i] << headroom_y)) >>
-                width_shift;
-        tmp += fPow2Div2((y[i] << headroom_y)) >> width_shift;
-      }
-
-      int exp_ener = ((17 - headroom_x) << 1) + width_shift + 1;
-      int exp_corr = (17 - headroom_x) + (17 - headroom_y) + width_shift + 1;
-      int exp_tmp = ((17 - headroom_y) << 1) + width_shift + 1;
-
-      /* Add 0.01 to "ener". Adjust exponents */
-      FIXP_DBL point_zero_one = (FIXP_DBL)0x51eb851f; /* In Q-6.37 */
-      int diff;
-      ener = fAddNorm(ener, exp_ener, point_zero_one, -6, &exp_ener);
-      corr = fAddNorm(corr, exp_corr, point_zero_one, -6, &exp_corr);
-      tmp = fAddNorm(tmp, exp_tmp, point_zero_one, -6, &exp_tmp);
-
-      /* use T2 if normalized correlation > 0.95 */
-      INT s1, s2;
-      s1 = CntLeadingZeros(ener) - 1;
-      s2 = CntLeadingZeros(tmp) - 1;
-
-      FIXP_DBL ener_by_tmp = fMultDiv2(ener << s1, tmp << s2);
-      int ener_by_tmp_exp = (exp_ener - s1) + (exp_tmp - s2) + 1;
-
-      if (ener_by_tmp_exp & 1) {
-        ener_by_tmp <<= 1;
-        ener_by_tmp_exp -= 1;
-      }
-
-      int temp_exp = 0;
-
-      FIXP_DBL temp1 = invSqrtNorm2(ener_by_tmp, &temp_exp);
-
-      int temp1_exp = temp_exp - (ener_by_tmp_exp >> 1);
-
-      FIXP_DBL tmp_result = fMult(corr, temp1);
-
-      int tmp_result_exp = exp_corr + temp1_exp;
-
-      diff = tmp_result_exp - 0;
-      FIXP_DBL point95 = FL2FXCONST_DBL(0.95f);
-      if (diff >= 0) {
-        diff = fMin(diff, 31);
-        point95 = FL2FXCONST_DBL(0.95f) >> diff;
-      } else {
-        diff = fMax(diff, -31);
-        tmp_result >>= (-diff);
-      }
-
-      if (tmp_result > point95) T = T2;
-
-      /* prevent that noise calculation below reaches into not defined signal
-         parts at the end of the synth_buf or in other words restrict the below
-         used index (i+i_subfr+T) < l_frame + l_next
-      */
-      lg = l_frame + l_next - T - i_subfr;
-
-      if (lg > L_SUBFR)
-        lg = L_SUBFR;
-      else if (lg < 0)
-        lg = 0;
-
-      /* limit gain to avoid problem on burst */
-      if (lg > 0) {
-        FIXP_DBL tmp1;
-
-        /* max(lg) = 64 => scale with 6 bits minus 1 (fPow2Div2) */
-
-        s1 = getScalefactor(&syn[i_subfr], lg);
-        s2 = getScalefactor(&syn[i_subfr + T], lg);
-        INT s = fixMin(s1, s2);
-
-        tmp = (FIXP_DBL)0;
-        ener = (FIXP_DBL)0;
-        for (i = 0; i < lg; i++) {
-          tmp += fPow2Div2(syn[i + i_subfr] << s1) >> (SF_PITCH_TRACK);
-          ener += fPow2Div2(syn[i + i_subfr + T] << s2) >> (SF_PITCH_TRACK);
-        }
-        tmp = tmp >> fMin(DFRACT_BITS - 1, (2 * (s1 - s)));
-        ener = ener >> fMin(DFRACT_BITS - 1, (2 * (s2 - s)));
-
-        /* error robustness: for the specific case syn[...] == -1.0f for all 64
-           samples ener or tmp might overflow and become negative. For all sane
-           cases we have enough headroom.
-        */
-        if (ener <= (FIXP_DBL)0) {
-          ener = (FIXP_DBL)1;
-        }
-        if (tmp <= (FIXP_DBL)0) {
-          tmp = (FIXP_DBL)1;
-        }
-        FDK_ASSERT(ener > (FIXP_DBL)0);
-
-        /* tmp = sqrt(tmp/ener) */
-        int result_e = 0;
-        tmp1 = fDivNorm(tmp, ener, &result_e);
-        if (result_e & 1) {
-          tmp1 >>= 1;
-          result_e += 1;
-        }
-        tmp = sqrtFixp(tmp1);
-        result_e >>= 1;
-
-        gain_exp = 17;
-
-        diff = result_e - gain_exp;
-
-        FIXP_DBL gain1 = gain;
-
-        if (diff >= 0) {
-          diff = fMin(diff, 31);
-          gain1 >>= diff;
-        } else {
-          result_e += (-diff);
-          diff = fMax(diff, -31);
-          tmp >>= (-diff);
-        }
-
-        if (tmp < gain1) {
-          gain = tmp;
-          gain_exp = result_e;
-        }
-      }
-
-      /* calculate noise based on voiced pitch */
-      /* fMultDiv2() replaces weighting of gain with 0.5 */
-      diff = gain_exp - 17;
-      if (diff >= 0) {
-        gain <<= diff;
-      } else {
-        gain >>= (-diff);
-      }
-
-      s1 = CntLeadingZeros(gain) - 1;
-      s1 -= 16; /* Leading bits for SGL */
-
-      FIXP_SGL gainSGL = FX_DBL2FX_SGL(gain << 16);
-
-      gainSGL = gainSGL << s1;
-
-      {
-        for (i = 0; i < lg; i++) {
-          /* scaled with SF_SYNTH + gain_sf + 1 */
-          noise_in[i] =
-              (fMult(gainSGL, syn[i + i_subfr] - (syn[i + i_subfr - T] >> 1) -
-                                  (syn[i + i_subfr + T] >> 1))) >>
-              s1;
-        }
-
-        for (i = lg; i < L_SUBFR; i++) {
-          /* scaled with SF_SYNTH + gain_sf + 1 */
-          noise_in[i] =
-              (fMult(gainSGL, syn[i + i_subfr] - syn[i + i_subfr - T])) >> s1;
-        }
-      }
-    } else {
-      FDKmemset(noise_in, (FIXP_DBL)0, L_SUBFR * sizeof(FIXP_DBL));
-    }
-
-    {
-      FDKmemcpy(noise_buf, mem_bpf, (L_FILT + L_SUBFR) * sizeof(FIXP_DBL));
-
-      FDKmemcpy(mem_bpf, noise_buf + L_SUBFR,
-                (L_FILT + L_SUBFR) * sizeof(FIXP_DBL));
-    }
-
-    /* substract from voiced speech low-pass filtered noise */
-    /* filter coefficients are scaled with factor SF_FILT_LP (1) */
-
-    {
-      filtLP(&syn[i_subfr - L_SUBFR], &synth_out[i_subfr], noise,
-             fdk_dec_filt_lp, L_SUBFR, L_FILT);
-    }
-  }
-
-  {
-
-  }
-
-  // To be determined (info from Ben)
-  {
-    /* Output scaling of the BPF memory */
-    scaleValues(mem_bpf, (L_FILT + L_SUBFR), -1);
-    /* Copy the rest of the signal (after the fac) */
-    scaleValuesSaturate((FIXP_PCM *)&synth_out[l_frame],
-                        (FIXP_DBL *)&syn[l_frame - L_SUBFR],
-                        (frame_length - l_frame), MDCT_OUT_HEADROOM);
-  }
-
-  return;
-}
-
-/*
- * Frequency Domain Noise Shaping
- */
-
-/**
- * \brief Adaptive Low Frequencies Deemphasis of spectral coefficients.
- *
- * Ensure quantization of low frequencies in case where the
- * signal dynamic is higher than the LPC noise shaping.
- * This is the inverse operation of adap_low_freq_emph().
- * Output gain of all blocks.
- *
- * \param x pointer to the spectral coefficients, requires 1 bit headroom.
- * \param lg length of x.
- * \param bUseNewAlfe if set, apply ALFD for fullband lpd.
- * \param gainLpc1 pointer to gain based on old input LPC coefficients.
- * \param gainLpc2 pointer to gain based on new input LPC coefficients.
- * \param alfd_gains pointer to output gains.
- * \param s current scale shift factor of x.
- */
-#define ALFDPOW2_SCALE 3
-/*static*/
-void CLpd_AdaptLowFreqDeemph(FIXP_DBL x[], int lg, FIXP_DBL alfd_gains[],
-                             INT s) {
-  {
-    int i, j, k, i_max;
-    FIXP_DBL max, fac;
-    /* Note: This stack array saves temporary accumulation results to be used in
-     * a second run */
-    /*       The size should be limited to (1024/4)/8=32 */
-    FIXP_DBL tmp_pow2[32];
-
-    s = s * 2 + ALFDPOW2_SCALE;
-    s = fMin(31, s);
-
-    k = 8;
-    i_max = lg / 4; /* ALFD range = 1600Hz (lg = 6400Hz) */
-
-    /* find spectral peak */
-    max = FL2FX_DBL(0.01f) >> s;
-    for (i = 0; i < i_max; i += k) {
-      FIXP_DBL tmp;
-
-      tmp = FIXP_DBL(0);
-      FIXP_DBL *pX = &x[i];
-
-      j = 8;
-      do {
-        FIXP_DBL x0 = *pX++;
-        FIXP_DBL x1 = *pX++;
-        x0 = fPow2Div2(x0);
-        x1 = fPow2Div2(x1);
-        tmp = tmp + (x0 >> (ALFDPOW2_SCALE - 1));
-        tmp = tmp + (x1 >> (ALFDPOW2_SCALE - 1));
-      } while ((j = j - 2) != 0);
-      tmp = fMax(tmp, (FL2FX_DBL(0.01f) >> s));
-      tmp_pow2[i >> 3] = tmp;
-      if (tmp > max) {
-        max = tmp;
-      }
-    }
-
-    /* deemphasis of all blocks below the peak */
-    fac = FL2FX_DBL(0.1f) >> 1;
-    for (i = 0; i < i_max; i += k) {
-      FIXP_DBL tmp;
-      INT shifti;
-
-      tmp = tmp_pow2[i >> 3];
-
-      /* tmp = (float)sqrt(tmp/max); */
-
-      /* value of tmp is between 8/2*max^2 and max^2 / 2. */
-      /* required shift factor of division can grow up to 27
-         (grows exponentially for values toward zero)
-         thus using normalized division to assure valid result. */
-      {
-        INT sd;
-
-        if (tmp != (FIXP_DBL)0) {
-          tmp = fDivNorm(max, tmp, &sd);
-          if (sd & 1) {
-            sd++;
-            tmp >>= 1;
-          }
-        } else {
-          tmp = (FIXP_DBL)MAXVAL_DBL;
-          sd = 0;
-        }
-        tmp = invSqrtNorm2(tmp, &shifti);
-        tmp = scaleValue(tmp, shifti - 1 - (sd / 2));
-      }
-      if (tmp > fac) {
-        fac = tmp;
-      }
-      FIXP_DBL *pX = &x[i];
-
-      j = 8;
-      do {
-        FIXP_DBL x0 = pX[0];
-        FIXP_DBL x1 = pX[1];
-        x0 = fMultDiv2(x0, fac);
-        x1 = fMultDiv2(x1, fac);
-        x0 = x0 << 2;
-        x1 = x1 << 2;
-        *pX++ = x0;
-        *pX++ = x1;
-
-      } while ((j = j - 2) != 0);
-      /* Store gains for FAC */
-      *alfd_gains++ = fac;
-    }
-  }
-}
-
-/**
- * \brief Interpolated Noise Shaping for mdct coefficients.
- * This algorithm shapes temporally the spectral noise between
- * the two spectral noise represention (FDNS_NPTS of resolution).
- * The noise is shaped monotonically between the two points
- * using a curved shape to favor the lower gain in mid-frame.
- * ODFT and amplitud calculation are applied to the 2 LPC coefficients first.
- *
- * \param r pointer to spectrum data.
- * \param rms RMS of output spectrum.
- * \param lg length of r.
- * \param A1 pointer to old input LPC coefficients of length M_LP_FILTER_ORDER
- * scaled by SF_A_COEFFS.
- * \param A2 pointer to new input LPC coefficients of length M_LP_FILTER_ORDER
- * scaled by SF_A_COEFFS.
- * \param bLpc2Mdct flags control lpc2mdct conversion and noise shaping.
- * \param gainLpc1 pointer to gain based on old input LPC coefficients.
- * \param gainLpc2 pointer to gain based on new input LPC coefficients.
- * \param gLpc_e pointer to exponent of gainLpc1 and gainLpc2.
- */
-/* static */
-#define NSHAPE_SCALE (4)
-
-#define LPC2MDCT_CALC (1)
-#define LPC2MDCT_GAIN_LOAD (2)
-#define LPC2MDCT_GAIN_SAVE (4)
-#define LPC2MDCT_APPLY_NSHAPE (8)
-
-void lpc2mdctAndNoiseShaping(FIXP_DBL *r, SHORT *pScale, const INT lg,
-                             const INT fdns_npts, const FIXP_LPC *A1,
-                             const INT A1_exp, const FIXP_LPC *A2,
-                             const INT A2_exp) {
-  FIXP_DBL *tmp2 = NULL;
-  FIXP_DBL rr_minus_one;
-  int i, k, s, step;
-
-  C_AALLOC_SCRATCH_START(tmp1, FIXP_DBL, FDNS_NPTS * 8)
-
-  {
-    tmp2 = tmp1 + fdns_npts * 4;
-
-    /* lpc2mdct() */
-
-    /* ODFT. E_LPC_a_weight() for A1 and A2 vectors is included into the loop
-     * below. */
-    FIXP_DBL f = FL2FXCONST_DBL(0.92f);
-
-    const FIXP_STP *SinTab;
-    int k_step;
-    /* needed values: sin(phi), cos(phi); phi = i*PI/(2*fdns_npts), i = 0 ...
-     * M_LP_FILTER_ORDER */
-    switch (fdns_npts) {
-      case 64:
-        SinTab = SineTable512;
-        k_step = (512 / 64);
-        FDK_ASSERT(512 >= 64);
-        break;
-      case 48:
-        SinTab = SineTable384;
-        k_step = 384 / 48;
-        FDK_ASSERT(384 >= 48);
-        break;
-      default:
-        FDK_ASSERT(0);
-        return;
-    }
-
-    for (i = 0, k = k_step; i < M_LP_FILTER_ORDER; i++, k += k_step) {
-      FIXP_STP cs = SinTab[k];
-      FIXP_DBL wA1, wA2;
-
-      wA1 = fMult(A1[i], f);
-      wA2 = fMult(A2[i], f);
-
-      /* r[i] = A[i]*cos() */
-      tmp1[2 + i * 2] = fMult(wA1, cs.v.re);
-      tmp2[2 + i * 2] = fMult(wA2, cs.v.re);
-      /* i[i] = A[i]*sin() */
-      tmp1[3 + i * 2] = -fMult(wA1, cs.v.im);
-      tmp2[3 + i * 2] = -fMult(wA2, cs.v.im);
-
-      f = fMult(f, FL2FXCONST_DBL(0.92f));
-    }
-
-    /* Guarantee at least 2 bits of headroom for the FFT */
-    /* "3" stands for 1.0 with 2 bits of headroom; (A1_exp + 2) guarantess 2
-     * bits of headroom if A1_exp > 1 */
-    int A1_exp_fix = fMax(3, A1_exp + 2);
-    int A2_exp_fix = fMax(3, A2_exp + 2);
-
-    /* Set 1.0 in the proper format */
-    tmp1[0] = (FIXP_DBL)(INT)((ULONG)0x80000000 >> A1_exp_fix);
-    tmp2[0] = (FIXP_DBL)(INT)((ULONG)0x80000000 >> A2_exp_fix);
-
-    tmp1[1] = tmp2[1] = (FIXP_DBL)0;
-
-    /* Clear the resto of the array */
-    FDKmemclear(
-        tmp1 + 2 * (M_LP_FILTER_ORDER + 1),
-        2 * (fdns_npts * 2 - (M_LP_FILTER_ORDER + 1)) * sizeof(FIXP_DBL));
-    FDKmemclear(
-        tmp2 + 2 * (M_LP_FILTER_ORDER + 1),
-        2 * (fdns_npts * 2 - (M_LP_FILTER_ORDER + 1)) * sizeof(FIXP_DBL));
-
-    /* Guarantee 2 bits of headroom for FFT */
-    scaleValues(&tmp1[2], (2 * M_LP_FILTER_ORDER), (A1_exp - A1_exp_fix));
-    scaleValues(&tmp2[2], (2 * M_LP_FILTER_ORDER), (A2_exp - A2_exp_fix));
-
-    INT s2;
-    s = A1_exp_fix;
-    s2 = A2_exp_fix;
-
-    fft(2 * fdns_npts, tmp1, &s);
-    fft(2 * fdns_npts, tmp2, &s2);
-
-    /* Adjust the exponents of both fft outputs if necessary*/
-    if (s > s2) {
-      scaleValues(tmp2, 2 * fdns_npts, s2 - s);
-      s2 = s;
-    } else if (s < s2) {
-      scaleValues(tmp1, 2 * fdns_npts, s - s2);
-      s = s2;
-    }
-
-    FDK_ASSERT(s == s2);
-  }
-
-  /* Get amplitude and apply gains */
-  step = lg / fdns_npts;
-  rr_minus_one = (FIXP_DBL)0;
-
-  for (k = 0; k < fdns_npts; k++) {
-    FIXP_DBL g1, g2, inv_g1_g2, a, b;
-    INT inv_g1_g2_e;
-    int g_e, shift;
-
-    {
-      FIXP_DBL real, imag;
-      int si1, si2, sInput;
-
-      real = tmp1[k * 2];
-      imag = tmp1[k * 2 + 1];
-      sInput = fMax(fMin(fNorm(real), fNorm(imag)) - 1, 0);
-      real <<= sInput;
-      imag <<= sInput;
-      /* g1_e = si1 - 2*s/2 */
-      g1 = invSqrtNorm2(fPow2(real) + fPow2(imag), &si1);
-      si1 += sInput;
-
-      real = tmp2[k * 2];
-      imag = tmp2[k * 2 + 1];
-      sInput = fMax(fMin(fNorm(real), fNorm(imag)) - 1, 0);
-      real <<= sInput;
-      imag <<= sInput;
-      /* g2_e = si2 - 2*s/2 */
-      g2 = invSqrtNorm2(fPow2(real) + fPow2(imag), &si2);
-      si2 += sInput;
-
-      /* Pick a common scale factor for g1 and g2 */
-      if (si1 > si2) {
-        g2 >>= si1 - si2;
-        g_e = si1 - s;
-      } else {
-        g1 >>= si2 - si1;
-        g_e = si2 - s;
-      }
-    }
-
-    /* end of lpc2mdct() */
-
-    FDK_ASSERT(g1 >= (FIXP_DBL)0);
-    FDK_ASSERT(g2 >= (FIXP_DBL)0);
-
-    /* mdct_IntNoiseShaping() */
-    {
-      /* inv_g1_g2 * 2^inv_g1_g2_e = 1/(g1+g2) */
-      inv_g1_g2 = (g1 >> 1) + (g2 >> 1);
-      if (inv_g1_g2 != (FIXP_DBL)0) {
-        inv_g1_g2 = fDivNorm(FL2FXCONST_DBL(0.5f), inv_g1_g2, &inv_g1_g2_e);
-        inv_g1_g2_e = inv_g1_g2_e - g_e;
-      } else {
-        inv_g1_g2 = (FIXP_DBL)MAXVAL_DBL;
-        inv_g1_g2_e = 0;
-      }
-
-      if (g_e < 0) {
-        /* a_e = g_e + inv_g1_g2_e + 1 */
-        a = scaleValue(fMult(fMult(g1, g2), inv_g1_g2), g_e);
-        /* b_e = g_e + inv_g1_g2_e */
-        b = fMult(g2 - g1, inv_g1_g2);
-        shift = g_e + inv_g1_g2_e + 1 - NSHAPE_SCALE;
-      } else {
-        /* a_e = (g_e+g_e) + inv_g1_g2_e + 1 */
-        a = fMult(fMult(g1, g2), inv_g1_g2);
-        /* b_e = (g_e+g_e) + inv_g1_g2_e */
-        b = scaleValue(fMult(g2 - g1, inv_g1_g2), -g_e);
-        shift = (g_e + g_e) + inv_g1_g2_e + 1 - NSHAPE_SCALE;
-      }
-
-      for (i = k * step; i < (k + 1) * step; i++) {
-        FIXP_DBL tmp;
-
-        /* rr[i] = 2*a*r[i] + b*rr[i-1] */
-        tmp = fMult(a, r[i]);
-        tmp += scaleValue(fMultDiv2(b, rr_minus_one), NSHAPE_SCALE);
-        tmp = scaleValueSaturate(tmp, shift);
-        rr_minus_one = tmp;
-        r[i] = tmp;
-      }
-    }
-  }
-
-  /* end of mdct_IntNoiseShaping() */
-  { *pScale += NSHAPE_SCALE; }
-
-  C_AALLOC_SCRATCH_END(tmp1, FIXP_DBL, FDNS_NPTS * 8)
-}
-
-/**
- * \brief Calculates the energy.
- * \param r pointer to spectrum.
- * \param rs scale factor of spectrum r.
- * \param lg frame length in audio samples.
- * \param rms_e pointer to exponent of energy value.
- * \return mantissa of energy value.
- */
-static FIXP_DBL calcEnergy(const FIXP_DBL *r, const SHORT rs, const INT lg,
-                           INT *rms_e) {
-  int headroom = getScalefactor(r, lg);
-
-  FIXP_DBL rms_m = 0;
-
-  /* Calculate number of growth bits due to addition */
-  INT shift = (INT)(fNormz((FIXP_DBL)lg));
-  shift = 31 - shift;
-
-  /* Generate 1e-2 in Q-6.37 */
-  const FIXP_DBL value0_01 = 0x51eb851e;
-  const INT value0_01_exp = -6;
-
-  /* Find the exponent of the resulting energy value */
-  *rms_e = ((rs - headroom) << 1) + shift + 1;
-
-  INT delta = *rms_e - value0_01_exp;
-  if (delta > 0) {
-    /* Limit shift_to 31*/
-    delta = fMin(31, delta);
-    rms_m = value0_01 >> delta;
-  } else {
-    rms_m = value0_01;
-    *rms_e = value0_01_exp;
-    shift = shift - delta;
-    /* Limit shift_to 31*/
-    shift = fMin(31, shift);
-  }
-
-  for (int i = 0; i < lg; i++) {
-    rms_m += fPow2Div2(r[i] << headroom) >> shift;
-  }
-
-  return rms_m;
-}
-
-/**
- * \brief TCX gain calculation.
- * \param pAacDecoderChannelInfo channel context data.
- * \param r output spectrum.
- * \param rms_e pointer to mantissa of energy value.
- * \param rms_e pointer to exponent of energy value.
- * \param frame the frame index of the LPD super frame.
- * \param lg the frame length in audio samples.
- * \param gain_m pointer to mantissa of TCX gain.
- * \param gain_e pointer to exponent of TCX gain.
- * \param elFlags element specific parser guidance flags.
- * \param lg_fb the fullband frame length in audio samples.
- * \param IGF_bgn the IGF start index.
- */
-static void calcTCXGain(CAacDecoderChannelInfo *pAacDecoderChannelInfo,
-                        FIXP_DBL *r, FIXP_DBL rms_m, INT rms_e, const INT frame,
-                        const INT lg) {
-  if ((rms_m != (FIXP_DBL)0)) {
-    FIXP_DBL tcx_gain_m;
-    INT tcx_gain_e;
-
-    CLpd_DecodeGain(&tcx_gain_m, &tcx_gain_e,
-                    pAacDecoderChannelInfo->pDynData->specificTo.usac
-                        .tcx_global_gain[frame]);
-
-    /* rms * 2^rms_e = lg/sqrt(sum(spec^2)) */
-    if (rms_e & 1) {
-      rms_m >>= 1;
-      rms_e++;
-    }
-
-    {
-      FIXP_DBL fx_lg;
-      INT fx_lg_e, s;
-      INT inv_e;
-
-      /* lg = fx_lg * 2^fx_lg_e */
-      s = fNorm((FIXP_DBL)lg);
-      fx_lg = (FIXP_DBL)lg << s;
-      fx_lg_e = DFRACT_BITS - 1 - s;
-      /* 1/sqrt(rms) */
-      rms_m = invSqrtNorm2(rms_m, &inv_e);
-      rms_m = fMult(rms_m, fx_lg);
-      rms_e = inv_e - (rms_e >> 1) + fx_lg_e;
-    }
-
-    {
-      int s = fNorm(tcx_gain_m);
-      tcx_gain_m = tcx_gain_m << s;
-      tcx_gain_e -= s;
-    }
-
-    tcx_gain_m = fMultDiv2(tcx_gain_m, rms_m);
-    tcx_gain_e = tcx_gain_e + rms_e;
-
-    /* global_gain * 2^(global_gain_e+rms_e) = (10^(global_gain/28)) * rms *
-     * 2^rms_e */
-    {
-      { tcx_gain_e += 1; }
-    }
-
-    pAacDecoderChannelInfo->data.usac.tcx_gain[frame] = tcx_gain_m;
-    pAacDecoderChannelInfo->data.usac.tcx_gain_e[frame] = tcx_gain_e;
-
-    pAacDecoderChannelInfo->specScale[frame] += tcx_gain_e;
-  }
-}
-
-/**
- * \brief FDNS decoding.
- * \param pAacDecoderChannelInfo channel context data.
- * \param pAacDecoderStaticChannelInfo channel context static data.
- * \param r output spectrum.
- * \param lg the frame length in audio samples.
- * \param frame the frame index of the LPD super frame.
- * \param pScale pointer to current scale shift factor of r[].
- * \param A1 old input LPC coefficients of length M_LP_FILTER_ORDER.
- * \param A2 new input LPC coefficients of length M_LP_FILTER_ORDER.
- * \param pAlfdGains pointer for ALFD gains output scaled by 1.
- * \param fdns_npts number of lines (FDNS_NPTS).
- * \param inf_mask pointer to noise mask.
- * \param IGF_win_mode IGF window mode (LONG, SHORT, TCX10, TCX20).
- * \param frameType (IGF_FRAME_DIVISION_AAC_OR_TCX_LONG or
- * IGF_FRAME_DIVISION_TCX_SHORT_1).
- * \param elFlags element specific parser guidance flags.
- * \param lg_fb the fullband frame length in audio samples.
- * \param IGF_bgn the IGF start index.
- * \param rms_m mantisse of energy.
- * \param rms_e exponent of energy.
- */
-/* static */
-void CLpd_FdnsDecode(CAacDecoderChannelInfo *pAacDecoderChannelInfo,
-                     CAacDecoderStaticChannelInfo *pAacDecoderStaticChannelInfo,
-                     FIXP_DBL r[], const INT lg, const INT frame, SHORT *pScale,
-                     const FIXP_LPC A1[M_LP_FILTER_ORDER], const INT A1_exp,
-                     const FIXP_LPC A2[M_LP_FILTER_ORDER], const INT A2_exp,
-                     FIXP_DBL pAlfdGains[LFAC / 4], const INT fdns_npts) {
-  /* Weight LPC coefficients using Rm values */
-  CLpd_AdaptLowFreqDeemph(r, lg, pAlfdGains, *pScale);
-
-  FIXP_DBL rms_m = (FIXP_DBL)0;
-  INT rms_e = 0;
-  {
-    /* Calculate Energy */
-    rms_m = calcEnergy(r, *pScale, lg, &rms_e);
-  }
-
-  calcTCXGain(pAacDecoderChannelInfo, r, rms_m, rms_e, frame, lg);
-
-  /* Apply ODFT and Noise Shaping. LP coefficient (A1, A2) weighting is done
-   * inside on the fly. */
-
-  lpc2mdctAndNoiseShaping(r, pScale, lg, fdns_npts, A1, A1_exp, A2, A2_exp);
-}
-
-/**
- * find pitch for TCX20 (time domain) concealment.
- */
-static int find_mpitch(FIXP_DBL xri[], int lg) {
-  FIXP_DBL max, pitch;
-  INT pitch_e;
-  int i, n;
-
-  max = (FIXP_DBL)0;
-  n = 2;
-
-  /* find maximum below 400Hz */
-  for (i = 2; i < (lg >> 4); i += 2) {
-    FIXP_DBL tmp = fPow2Div2(xri[i]) + fPow2Div2(xri[i + 1]);
-    if (tmp > max) {
-      max = tmp;
-      n = i;
-    }
-  }
-
-  // pitch = ((float)lg<<1)/(float)n;
-  pitch = fDivNorm((FIXP_DBL)lg << 1, (FIXP_DBL)n, &pitch_e);
-  pitch >>= fixMax(0, DFRACT_BITS - 1 - pitch_e - 16);
-
-  /* find pitch multiple under 20ms */
-  if (pitch >= (FIXP_DBL)((256 << 16) - 1)) { /*231.0f*/
-    n = 256;
-  } else {
-    FIXP_DBL mpitch = pitch;
-    while (mpitch < (FIXP_DBL)(255 << 16)) {
-      mpitch += pitch;
-    }
-    n = (int)(mpitch - pitch) >> 16;
-  }
-
-  return (n);
-}
-
-/**
- * number of spectral coefficients / time domain samples using frame mode as
- * index.
- */
-static const int lg_table_ccfl[2][4] = {
-    {256, 256, 512, 1024}, /* coreCoderFrameLength = 1024 */
-    {192, 192, 384, 768}   /* coreCoderFrameLength = 768  */
-};
-
-/**
- * \brief Decode and render one MDCT-TCX frame.
- * \param pAacDecoderChannelInfo channel context data.
- * \param lg the frame length in audio samples.
- * \param frame the frame index of the LPD super frame.
- */
-static void CLpd_TcxDecode(
-    CAacDecoderChannelInfo *pAacDecoderChannelInfo,
-    CAacDecoderStaticChannelInfo *pAacDecoderStaticChannelInfo, UINT flags,
-    int mod, int last_mod, int frame, int frameOk) {
-  FIXP_DBL *pAlfd_gains = pAacDecoderStaticChannelInfo->last_alfd_gains;
-  ULONG *pSeed = &pAacDecoderStaticChannelInfo->nfRandomSeed;
-  int lg = (pAacDecoderChannelInfo->granuleLength == 128)
-               ? lg_table_ccfl[0][mod + 0]
-               : lg_table_ccfl[1][mod + 0];
-  int next_frame = frame + (1 << (mod - 1));
-  int isFullBandLpd = 0;
-
-  /* Obtain r[] vector by combining the quant[] and noise[] vectors */
-  {
-    FIXP_DBL noise_level;
-    FIXP_DBL *coeffs =
-        SPEC_TCX(pAacDecoderChannelInfo->pSpectralCoefficient, frame,
-                 pAacDecoderChannelInfo->granuleLength, isFullBandLpd);
-    int scale = pAacDecoderChannelInfo->specScale[frame];
-    int i, nfBgn, nfEnd;
-    UCHAR tcx_noise_factor = pAacDecoderChannelInfo->pDynData->specificTo.usac
-                                 .tcx_noise_factor[frame];
-
-    /* find pitch for bfi case */
-    pAacDecoderStaticChannelInfo->last_tcx_pitch = find_mpitch(coeffs, lg);
-
-    if (frameOk) {
-      /* store for concealment */
-      pAacDecoderStaticChannelInfo->last_tcx_noise_factor = tcx_noise_factor;
-    } else {
-      /* restore last frames value */
-      tcx_noise_factor = pAacDecoderStaticChannelInfo->last_tcx_noise_factor;
-    }
-
-    noise_level =
-        (FIXP_DBL)((LONG)FL2FXCONST_DBL(0.0625f) * (8 - tcx_noise_factor));
-    noise_level = scaleValue(noise_level, -scale);
-
-    const FIXP_DBL neg_noise_level = -noise_level;
-
-    {
-      nfBgn = lg / 6;
-      nfEnd = lg;
-    }
-
-    for (i = nfBgn; i < nfEnd - 7; i += 8) {
-      LONG tmp;
-
-      /* Fill all 8 consecutive zero coeffs with noise */
-      tmp = coeffs[i + 0] | coeffs[i + 1] | coeffs[i + 2] | coeffs[i + 3] |
-            coeffs[i + 4] | coeffs[i + 5] | coeffs[i + 6] | coeffs[i + 7];
-
-      if (tmp == 0) {
-        for (int k = i; k < i + 8; k++) {
-          UsacRandomSign(pSeed) ? (coeffs[k] = neg_noise_level)
-                                : (coeffs[k] = noise_level);
-        }
-      }
-    }
-    if ((nfEnd - i) >
-        0) { /* noise filling for last "band" with less than 8 bins */
-      LONG tmp = (LONG)coeffs[i];
-      int k;
-
-      FDK_ASSERT((nfEnd - i) < 8);
-      for (k = 1; k < (nfEnd - i); k++) {
-        tmp |= (LONG)coeffs[i + k];
-      }
-      if (tmp == 0) {
-        for (k = i; k < nfEnd; k++) {
-          UsacRandomSign(pSeed) ? (coeffs[k] = neg_noise_level)
-                                : (coeffs[k] = noise_level);
-        }
-      }
-    }
-  }
-
-  {
-    /* Convert LPC to LP domain */
-    if (last_mod == 0) {
-      /* Note: The case where last_mod == 255 is handled by other means
-       * in CLpdChannelStream_Read() */
-      E_LPC_f_lsp_a_conversion(
-          pAacDecoderChannelInfo->data.usac.lsp_coeff[frame],
-          pAacDecoderChannelInfo->data.usac.lp_coeff[frame],
-          &pAacDecoderChannelInfo->data.usac.lp_coeff_exp[frame]);
-    }
-
-    E_LPC_f_lsp_a_conversion(
-        pAacDecoderChannelInfo->data.usac.lsp_coeff[next_frame],
-        pAacDecoderChannelInfo->data.usac.lp_coeff[next_frame],
-        &pAacDecoderChannelInfo->data.usac.lp_coeff_exp[next_frame]);
-
-    /* FDNS decoding */
-    CLpd_FdnsDecode(
-        pAacDecoderChannelInfo, pAacDecoderStaticChannelInfo,
-        SPEC_TCX(pAacDecoderChannelInfo->pSpectralCoefficient, frame,
-                 pAacDecoderChannelInfo->granuleLength, isFullBandLpd),
-        lg, frame, pAacDecoderChannelInfo->specScale + frame,
-        pAacDecoderChannelInfo->data.usac.lp_coeff[frame],
-        pAacDecoderChannelInfo->data.usac.lp_coeff_exp[frame],
-        pAacDecoderChannelInfo->data.usac.lp_coeff[next_frame],
-        pAacDecoderChannelInfo->data.usac.lp_coeff_exp[next_frame], pAlfd_gains,
-        pAacDecoderChannelInfo->granuleLength / 2 /* == FDNS_NPTS(ccfl) */
-    );
-  }
-}
-
-/**
- * \brief Read the tcx_coding bitstream part
- * \param hBs bitstream handle to read from.
- * \param pAacDecoderChannelInfo channel context info to store data into.
- * \param lg the frame length in audio samples.
- * \param first_tcx_flag flag indicating that this is the first TCX frame.
- * \param frame the frame index of the LPD super frame.
- */
-static AAC_DECODER_ERROR CLpd_TCX_Read(
-    HANDLE_FDK_BITSTREAM hBs, CAacDecoderChannelInfo *pAacDecoderChannelInfo,
-    CAacDecoderStaticChannelInfo *pAacDecoderStaticChannelInfo, int lg,
-    int first_tcx_flag, int frame, UINT flags) {
-  AAC_DECODER_ERROR errorAAC = AAC_DEC_OK;
-  ARITH_CODING_ERROR error = ARITH_CODER_OK;
-  FIXP_DBL *pSpec;
-  int arith_reset_flag = 0;
-  int isFullBandLpd = 0;
-
-  pSpec = SPEC_TCX(pAacDecoderChannelInfo->pSpectralCoefficient, frame,
-                   pAacDecoderChannelInfo->granuleLength, isFullBandLpd);
-
-  /* TCX noise level */
-  {
-    pAacDecoderChannelInfo->pDynData->specificTo.usac.tcx_noise_factor[frame] =
-        FDKreadBits(hBs, 3);
-  }
-  /* TCX global gain */
-  pAacDecoderChannelInfo->pDynData->specificTo.usac.tcx_global_gain[frame] =
-      FDKreadBits(hBs, 7);
-
-  /* Arithmetic coded residual/spectrum */
-  if (first_tcx_flag) {
-    if (flags & AC_INDEP) {
-      arith_reset_flag = 1;
-    } else {
-      arith_reset_flag = FDKreadBits(hBs, 1);
-    }
-  }
-
-  /* CArco_DecodeArithData() output scale of "pSpec" is DFRACT_BITS-1 */
-  error = CArco_DecodeArithData(pAacDecoderStaticChannelInfo->hArCo, hBs, pSpec,
-                                lg, lg, arith_reset_flag);
-
-  /* Rescale residual/spectrum */
-  {
-    int scale = getScalefactor(pSpec, lg) - 2; /* Leave 2 bits headroom */
-
-    /* Exponent of CArco_DecodeArithData() output is DFRACT_BITS; integer
-     * values. */
-    scaleValues(pSpec, lg, scale);
-    scale = DFRACT_BITS - 1 - scale;
-
-    pAacDecoderChannelInfo->specScale[frame] = scale;
-  }
-
-  if (error == ARITH_CODER_ERROR) errorAAC = AAC_DEC_UNKNOWN;
-
-  return errorAAC;
-}
-
-/**
- * \brief translate lpd_mode into the mod[] array which describes the mode of
- * each each LPD frame
- * \param mod[] the array that will be filled with the mode indexes of the
- * inidividual frames.
- * \param lpd_mode the lpd_mode field read from the lpd_channel_stream
- */
-static AAC_DECODER_ERROR CLpd_ReadAndMapLpdModeToModArray(
-    UCHAR mod[4], HANDLE_FDK_BITSTREAM hBs, UINT elFlags) {
-  int lpd_mode;
-
-  {
-    lpd_mode = FDKreadBits(hBs, 5);
-
-    if (lpd_mode > 25 || lpd_mode < 0) {
-      return AAC_DEC_PARSE_ERROR;
-    }
-
-    switch (lpd_mode) {
-      case 25:
-        /* 1 80MS frame */
-        mod[0] = mod[1] = mod[2] = mod[3] = 3;
-        break;
-      case 24:
-        /* 2 40MS frames */
-        mod[0] = mod[1] = mod[2] = mod[3] = 2;
-        break;
-      default:
-        switch (lpd_mode >> 2) {
-          case 4:
-            /* lpd_mode 19 - 16  => 1 40MS and 2 20MS frames */
-            mod[0] = mod[1] = 2;
-            mod[2] = (lpd_mode & 1) ? 1 : 0;
-            mod[3] = (lpd_mode & 2) ? 1 : 0;
-            break;
-          case 5:
-            /* lpd_mode 23 - 20 => 2 20MS and 1 40MS frames */
-            mod[2] = mod[3] = 2;
-            mod[0] = (lpd_mode & 1) ? 1 : 0;
-            mod[1] = (lpd_mode & 2) ? 1 : 0;
-            break;
-          default:
-            /* lpd_mode < 16 => 4 20MS frames */
-            mod[0] = (lpd_mode & 1) ? 1 : 0;
-            mod[1] = (lpd_mode & 2) ? 1 : 0;
-            mod[2] = (lpd_mode & 4) ? 1 : 0;
-            mod[3] = (lpd_mode & 8) ? 1 : 0;
-            break;
-        }
-        break;
-    }
-  }
-  return AAC_DEC_OK;
-}
-
-static void CLpd_Reset(
-    CAacDecoderChannelInfo *pAacDecoderChannelInfo,
-    CAacDecoderStaticChannelInfo *pAacDecoderStaticChannelInfo,
-    int keep_past_signal) {
-  int i;
-
-  /* Reset TCX / ACELP common memory */
-  if (!keep_past_signal) {
-    FDKmemclear(pAacDecoderStaticChannelInfo->old_synth,
-                sizeof(pAacDecoderStaticChannelInfo->old_synth));
-  }
-
-  /* Initialize the LSFs */
-  for (i = 0; i < M_LP_FILTER_ORDER; i++) {
-    pAacDecoderStaticChannelInfo->lpc4_lsf[i] = fdk_dec_lsf_init[i];
-  }
-
-  /* Reset memory needed by bass post-filter */
-  FDKmemclear(pAacDecoderStaticChannelInfo->mem_bpf,
-              sizeof(pAacDecoderStaticChannelInfo->mem_bpf));
-
-  pAacDecoderStaticChannelInfo->old_bpf_control_info = 0;
-  for (i = 0; i < SYN_SFD; i++) {
-    pAacDecoderStaticChannelInfo->old_T_pf[i] = 64;
-    pAacDecoderStaticChannelInfo->old_gain_pf[i] = (FIXP_DBL)0;
-  }
-
-  /* Reset ACELP memory */
-  CLpd_AcelpReset(&pAacDecoderStaticChannelInfo->acelp);
-
-  pAacDecoderStaticChannelInfo->last_lpc_lost = 0;      /* prev_lpc_lost */
-  pAacDecoderStaticChannelInfo->last_tcx_pitch = L_DIV; /* pitch_tcx     */
-  pAacDecoderStaticChannelInfo->numLostLpdFrames = 0;   /* nbLostCmpt    */
-}
-
-/*
- * Externally visible functions
- */
-
-AAC_DECODER_ERROR CLpdChannelStream_Read(
-    HANDLE_FDK_BITSTREAM hBs, CAacDecoderChannelInfo *pAacDecoderChannelInfo,
-    CAacDecoderStaticChannelInfo *pAacDecoderStaticChannelInfo,
-    const SamplingRateInfo *pSamplingRateInfo, UINT flags) {
-  AAC_DECODER_ERROR error = AAC_DEC_OK;
-  int first_tcx_flag;
-  int k, nbDiv, fFacDataPresent, first_lpd_flag, acelp_core_mode,
-      facGetMemState = 0;
-  UCHAR *mod = pAacDecoderChannelInfo->data.usac.mod;
-  int lpd_mode_last, prev_frame_was_lpd;
-  USAC_COREMODE core_mode_last;
-  const int lg_table_offset = 0;
-  const int *lg_table = (pAacDecoderChannelInfo->granuleLength == 128)
-                            ? &lg_table_ccfl[0][lg_table_offset]
-                            : &lg_table_ccfl[1][lg_table_offset];
-  int last_lpc_lost = pAacDecoderStaticChannelInfo->last_lpc_lost;
-
-  int last_frame_ok = 1;
-
-  INT i_offset;
-  UINT samplingRate;
-
-  samplingRate = pSamplingRateInfo->samplingRate;
-
-  i_offset =
-      (INT)(samplingRate * PIT_MIN_12k8 + (FSCALE_DENOM / 2)) / FSCALE_DENOM -
-      (INT)PIT_MIN_12k8;
-
-  if ((samplingRate < FAC_FSCALE_MIN) || (samplingRate > FAC_FSCALE_MAX)) {
-    error = AAC_DEC_PARSE_ERROR;
-    goto bail;
-  }
-
-  acelp_core_mode = FDKreadBits(hBs, 3);
-
-  /* lpd_mode */
-  error = CLpd_ReadAndMapLpdModeToModArray(mod, hBs, 0);
-  if (error != AAC_DEC_OK) {
-    goto bail;
-  }
-
-  /* bpf_control_info */
-  pAacDecoderChannelInfo->data.usac.bpf_control_info = FDKreadBit(hBs);
-
-  /* last_core_mode */
-  prev_frame_was_lpd = FDKreadBit(hBs);
-  /* fac_data_present */
-  fFacDataPresent = FDKreadBit(hBs);
-
-  /* Set valid values from
-   * pAacDecoderStaticChannelInfo->{last_core_mode,last_lpd_mode} */
-  pAacDecoderChannelInfo->data.usac.core_mode_last =
-      pAacDecoderStaticChannelInfo->last_core_mode;
-  lpd_mode_last = pAacDecoderChannelInfo->data.usac.lpd_mode_last =
-      pAacDecoderStaticChannelInfo->last_lpd_mode;
-
-  if (prev_frame_was_lpd == 0) {
-    /* Last frame was FD */
-    pAacDecoderChannelInfo->data.usac.core_mode_last = FD_LONG;
-    pAacDecoderChannelInfo->data.usac.lpd_mode_last = 255;
-  } else {
-    /* Last frame was LPD */
-    pAacDecoderChannelInfo->data.usac.core_mode_last = LPD;
-    if (((mod[0] == 0) && fFacDataPresent) ||
-        ((mod[0] != 0) && !fFacDataPresent)) {
-      /* Currend mod is ACELP, fac data present -> TCX, current mod TCX, no fac
-       * data -> TCX */
-      if (lpd_mode_last == 0) {
-        /* Bit stream interruption detected. Assume last TCX mode as TCX20. */
-        pAacDecoderChannelInfo->data.usac.lpd_mode_last = 1;
-      }
-      /* Else assume that remembered TCX mode is correct. */
-    } else {
-      pAacDecoderChannelInfo->data.usac.lpd_mode_last = 0;
-    }
-  }
-
-  first_lpd_flag = (pAacDecoderChannelInfo->data.usac.core_mode_last !=
-                    LPD); /* Depends on bitstream configuration */
-  first_tcx_flag = 1;
-
-  if (pAacDecoderStaticChannelInfo->last_core_mode !=
-      LPD) { /* ATTENTION: Reset depends on what we rendered before! */
-    CLpd_Reset(pAacDecoderChannelInfo, pAacDecoderStaticChannelInfo, 0);
-
-    if (!last_frame_ok) {
-      /* If last rendered frame was not LPD and first lpd flag is not set, this
-       * must be an error - set last_lpc_lost flag */
-      last_lpc_lost |= (first_lpd_flag) ? 0 : 1;
-    }
-  }
-
-  core_mode_last = pAacDecoderChannelInfo->data.usac.core_mode_last;
-  lpd_mode_last = pAacDecoderChannelInfo->data.usac.lpd_mode_last;
-
-  nbDiv = NB_DIV;
-
-  /* k is the frame index. If a frame is of size 40MS or 80MS,
-     this frame index is incremented 2 or 4 instead of 1 respectively. */
-
-  k = 0;
-  while (k < nbDiv) {
-    /* Reset FAC data pointers in order to avoid applying old random FAC data.
-     */
-    pAacDecoderChannelInfo->data.usac.fac_data[k] = NULL;
-
-    if ((k == 0 && core_mode_last == LPD && fFacDataPresent) ||
-        (lpd_mode_last == 0 && mod[k] > 0) ||
-        ((lpd_mode_last != 255) && lpd_mode_last > 0 && mod[k] == 0)) {
-      int err;
-
-      /* Assign FAC memory */
-      pAacDecoderChannelInfo->data.usac.fac_data[k] =
-          CLpd_FAC_GetMemory(pAacDecoderChannelInfo, mod, &facGetMemState);
-
-      /* FAC for (ACELP -> TCX) or (TCX -> ACELP) */
-      err = CLpd_FAC_Read(
-          hBs, pAacDecoderChannelInfo->data.usac.fac_data[k],
-          pAacDecoderChannelInfo->data.usac.fac_data_e,
-          pAacDecoderChannelInfo->granuleLength, /* == fac_length */
-          0, k);
-      if (err != 0) {
-        error = AAC_DEC_PARSE_ERROR;
-        goto bail;
-      }
-    }
-
-    if (mod[k] == 0) /* acelp-mode */
-    {
-      int err;
-      err = CLpd_AcelpRead(
-          hBs, &pAacDecoderChannelInfo->data.usac.acelp[k], acelp_core_mode,
-          pAacDecoderChannelInfo->granuleLength * 8 /* coreCoderFrameLength */,
-          i_offset);
-      if (err != 0) {
-        error = AAC_DEC_PARSE_ERROR;
-        goto bail;
-      }
-
-      lpd_mode_last = 0;
-      k++;
-    } else /* mode != 0  =>  TCX */
-    {
-      error = CLpd_TCX_Read(hBs, pAacDecoderChannelInfo,
-                            pAacDecoderStaticChannelInfo, lg_table[mod[k]],
-                            first_tcx_flag, k, flags);
-
-      lpd_mode_last = mod[k];
-      first_tcx_flag = 0;
-      k += 1 << (mod[k] - 1);
-    }
-    if (error != AAC_DEC_OK) {
-      error = AAC_DEC_PARSE_ERROR;
-      goto bail;
-    }
-  }
-
-  {
-    int err;
-
-    /* Read LPC coefficients */
-    err = CLpc_Read(
-        hBs, pAacDecoderChannelInfo->data.usac.lsp_coeff,
-        pAacDecoderStaticChannelInfo->lpc4_lsf,
-        pAacDecoderChannelInfo->data.usac.lsf_adaptive_mean_cand,
-        pAacDecoderChannelInfo->data.usac.aStability, mod, first_lpd_flag,
-        /* if last lpc4 is available from concealment do not extrapolate lpc0
-           from lpc2 */
-        (mod[0] & 0x3) ? 0
-                       : (last_lpc_lost &&
-                          pAacDecoderStaticChannelInfo->last_core_mode != LPD),
-        last_frame_ok);
-    if (err != 0) {
-      error = AAC_DEC_PARSE_ERROR;
-      goto bail;
-    }
-  }
-
-  /* adjust old lsp[] following to a bad frame (to avoid overshoot) (ref:
-   * dec_LPD.c) */
-  if (last_lpc_lost && !last_frame_ok) {
-    int k_next;
-    k = 0;
-    while (k < nbDiv) {
-      int i;
-      k_next = k + (((mod[k] & 0x3) == 0) ? 1 : (1 << (mod[k] - 1)));
-      FIXP_LPC *lsp_old = pAacDecoderChannelInfo->data.usac.lsp_coeff[k];
-      FIXP_LPC *lsp_new = pAacDecoderChannelInfo->data.usac.lsp_coeff[k_next];
-
-      for (i = 0; i < M_LP_FILTER_ORDER; i++) {
-        if (lsp_new[i] < lsp_old[i]) {
-          lsp_old[i] = lsp_new[i];
-        }
-      }
-      k = k_next;
-    }
-  }
-
-  if (pAacDecoderStaticChannelInfo->last_lpd_mode != 0) {
-    if (pAacDecoderStaticChannelInfo->last_lpd_mode == 255) {
-      /* We need it for TCX decoding or ACELP excitation update */
-      E_LPC_f_lsp_a_conversion(
-          pAacDecoderChannelInfo->data.usac.lsp_coeff[0],
-          pAacDecoderChannelInfo->data.usac.lp_coeff[0],
-          &pAacDecoderChannelInfo->data.usac.lp_coeff_exp[0]);
-    } else { /* last_lpd_mode was TCX */
-      /* Copy old LPC4 LP domain coefficients to LPC0 LP domain buffer (to avoid
-       * converting LSP coefficients again). */
-      FDKmemcpy(pAacDecoderChannelInfo->data.usac.lp_coeff[0],
-                pAacDecoderStaticChannelInfo->lp_coeff_old[0],
-                M_LP_FILTER_ORDER * sizeof(FIXP_LPC));
-      pAacDecoderChannelInfo->data.usac.lp_coeff_exp[0] =
-          pAacDecoderStaticChannelInfo->lp_coeff_old_exp[0];
-    }
-  } /* case last_lpd_mode was ACELP is handled by CLpd_TcxDecode() */
-
-  if (fFacDataPresent && (core_mode_last != LPD)) {
-    int prev_frame_was_short;
-
-    prev_frame_was_short = FDKreadBit(hBs);
-
-    if (prev_frame_was_short) {
-      core_mode_last = pAacDecoderChannelInfo->data.usac.core_mode_last =
-          FD_SHORT;
-      pAacDecoderChannelInfo->data.usac.lpd_mode_last = 255;
-
-      if ((pAacDecoderStaticChannelInfo->last_core_mode != FD_SHORT)) {
-        /* USAC Conformance document:
-           short_fac_flag   shall be encoded with a value of 1 if the
-           window_sequence of the previous frame was 2 (EIGHT_SHORT_SEQUENCE).
-                            Otherwise short_fac_flag shall be encoded with a
-           value of 0. */
-        error = AAC_DEC_PARSE_ERROR;
-        goto bail;
-      }
-    }
-
-    /* Assign memory */
-    pAacDecoderChannelInfo->data.usac.fac_data[0] =
-        CLpd_FAC_GetMemory(pAacDecoderChannelInfo, mod, &facGetMemState);
-
-    {
-      int err;
-
-      /* FAC for FD -> ACELP */
-      err = CLpd_FAC_Read(
-          hBs, pAacDecoderChannelInfo->data.usac.fac_data[0],
-          pAacDecoderChannelInfo->data.usac.fac_data_e,
-          CLpd_FAC_getLength(core_mode_last != FD_SHORT,
-                             pAacDecoderChannelInfo->granuleLength),
-          1, 0);
-      if (err != 0) {
-        error = AAC_DEC_PARSE_ERROR;
-        goto bail;
-      }
-    }
-  }
-
-bail:
-  if (error == AAC_DEC_OK) {
-    /* check consitency of last core/lpd mode values */
-    if ((pAacDecoderChannelInfo->data.usac.core_mode_last !=
-         pAacDecoderStaticChannelInfo->last_core_mode) &&
-        (pAacDecoderStaticChannelInfo->last_lpc_lost == 0)) {
-      /* Something got wrong! */
-      /* error = AAC_DEC_PARSE_ERROR; */ /* Throwing errors does not help */
-    } else if ((pAacDecoderChannelInfo->data.usac.core_mode_last == LPD) &&
-               (pAacDecoderChannelInfo->data.usac.lpd_mode_last !=
-                pAacDecoderStaticChannelInfo->last_lpd_mode) &&
-               (pAacDecoderStaticChannelInfo->last_lpc_lost == 0)) {
-      /* Something got wrong! */
-      /* error = AAC_DEC_PARSE_ERROR; */ /* Throwing errors does not help */
-    }
-  }
-
-  return error;
-}
-
-void CLpdChannelStream_Decode(
-    CAacDecoderChannelInfo *pAacDecoderChannelInfo,
-    CAacDecoderStaticChannelInfo *pAacDecoderStaticChannelInfo, UINT flags) {
-  UCHAR *mod = pAacDecoderChannelInfo->data.usac.mod;
-  int k;
-  UCHAR last_lpd_mode;
-  int nbDiv = NB_DIV;
-
-  /* k is the frame index. If a frame is of size 40MS or 80MS,
-     this frame index is incremented 2 or 4 instead of 1 respectively. */
-  k = 0;
-  last_lpd_mode =
-      pAacDecoderChannelInfo->data.usac
-          .lpd_mode_last; /* could be different to what has been rendered */
-  while (k < nbDiv) {
-    if (mod[k] == 0) {
-      /* ACELP */
-
-      /* If FAC (fac_data[k] != NULL), and previous frame was TCX, apply (TCX)
-       * gains to FAC data */
-      if (last_lpd_mode > 0 && last_lpd_mode != 255 &&
-          pAacDecoderChannelInfo->data.usac.fac_data[k]) {
-        CFac_ApplyGains(pAacDecoderChannelInfo->data.usac.fac_data[k],
-                        pAacDecoderChannelInfo->granuleLength,
-                        pAacDecoderStaticChannelInfo->last_tcx_gain,
-                        pAacDecoderStaticChannelInfo->last_alfd_gains,
-                        (last_lpd_mode < 4) ? last_lpd_mode : 3);
-
-        pAacDecoderChannelInfo->data.usac.fac_data_e[k] +=
-            pAacDecoderStaticChannelInfo->last_tcx_gain_e;
-      }
-    } else {
-      /* TCX */
-      CLpd_TcxDecode(pAacDecoderChannelInfo, pAacDecoderStaticChannelInfo,
-                     flags, mod[k], last_lpd_mode, k, 1 /* frameOk == 1 */
-      );
-
-      /* Store TCX gain scale for next possible FAC transition. */
-      pAacDecoderStaticChannelInfo->last_tcx_gain =
-          pAacDecoderChannelInfo->data.usac.tcx_gain[k];
-      pAacDecoderStaticChannelInfo->last_tcx_gain_e =
-          pAacDecoderChannelInfo->data.usac.tcx_gain_e[k];
-
-      /* If FAC (fac_data[k] != NULL), apply gains */
-      if (last_lpd_mode == 0 && pAacDecoderChannelInfo->data.usac.fac_data[k]) {
-        CFac_ApplyGains(
-            pAacDecoderChannelInfo->data.usac.fac_data[k],
-            pAacDecoderChannelInfo->granuleLength /* == fac_length */,
-            pAacDecoderChannelInfo->data.usac.tcx_gain[k],
-            pAacDecoderStaticChannelInfo->last_alfd_gains, mod[k]);
-
-        pAacDecoderChannelInfo->data.usac.fac_data_e[k] +=
-            pAacDecoderChannelInfo->data.usac.tcx_gain_e[k];
-      }
-    }
-
-    /* remember previous mode */
-    last_lpd_mode = mod[k];
-
-    /* Increase k to next frame */
-    k += (mod[k] == 0) ? 1 : (1 << (mod[k] - 1));
-  }
-}
-
-AAC_DECODER_ERROR CLpd_RenderTimeSignal(
-    CAacDecoderStaticChannelInfo *pAacDecoderStaticChannelInfo,
-    CAacDecoderChannelInfo *pAacDecoderChannelInfo, FIXP_PCM *pTimeData,
-    INT lFrame, SamplingRateInfo *pSamplingRateInfo, UINT frameOk, UINT flags,
-    UINT strmFlags) {
-  UCHAR *mod = pAacDecoderChannelInfo->data.usac.mod;
-  AAC_DECODER_ERROR error = AAC_DEC_OK;
-  int k, i_offset;
-  int last_k;
-  int nrSamples = 0;
-  int facFB = 1;
-  int nbDiv = NB_DIV;
-  int lDiv = lFrame / nbDiv; /* length of division (acelp or tcx20 frame)*/
-  int lFac = lDiv / 2;
-  int nbSubfr =
-      lFrame / (nbDiv * L_SUBFR); /* number of subframes per division */
-  int nbSubfrSuperfr = nbDiv * nbSubfr;
-  int synSfd = (nbSubfrSuperfr / 2) - BPF_SFD;
-  int SynDelay = synSfd * L_SUBFR;
-  int aacDelay = lFrame / 2;
-
-  /*
-   In respect to the reference software, the synth pointer here is lagging by
-   aacDelay ( == SYN_DELAY + BPF_DELAY ) samples. The corresponding old
-   synthesis samples are handled by the IMDCT overlap.
-   */
-
-  FIXP_DBL *synth_buf =
-      pAacDecoderChannelInfo->pComStaticData->pWorkBufferCore1->synth_buf;
-  FIXP_DBL *synth = synth_buf + PIT_MAX_MAX - BPF_DELAY;
-  UCHAR last_lpd_mode, last_last_lpd_mode, last_lpc_lost, last_frame_lost;
-
-  INT pitch[NB_SUBFR_SUPERFR + SYN_SFD];
-  FIXP_DBL pit_gain[NB_SUBFR_SUPERFR + SYN_SFD];
-
-  const int *lg_table;
-  int lg_table_offset = 0;
-
-  UINT samplingRate = pSamplingRateInfo->samplingRate;
-
-  FDKmemclear(pitch, (NB_SUBFR_SUPERFR + SYN_SFD) * sizeof(INT));
-
-  if (flags & AACDEC_FLUSH) {
-    CLpd_Reset(pAacDecoderChannelInfo, pAacDecoderStaticChannelInfo,
-               flags & AACDEC_FLUSH);
-    frameOk = 0;
-  }
-
-  switch (lFrame) {
-    case 1024:
-      lg_table = &lg_table_ccfl[0][lg_table_offset];
-      break;
-    case 768:
-      lg_table = &lg_table_ccfl[1][lg_table_offset];
-      break;
-    default:
-      FDK_ASSERT(0);
-      return AAC_DEC_UNKNOWN;
-  }
-
-  last_frame_lost = 0;
-
-  /* Maintain LPD mode from previous frame */
-  if ((pAacDecoderStaticChannelInfo->last_core_mode == FD_LONG) ||
-      (pAacDecoderStaticChannelInfo->last_core_mode == FD_SHORT)) {
-    pAacDecoderStaticChannelInfo->last_lpd_mode = 255;
-  }
-
-  if (!frameOk) {
-    FIXP_DBL old_tcx_gain;
-    FIXP_SGL old_stab;
-    SCHAR old_tcx_gain_e;
-    int nLostSf;
-
-    last_lpd_mode = pAacDecoderStaticChannelInfo->last_lpd_mode;
-    old_tcx_gain = pAacDecoderStaticChannelInfo->last_tcx_gain;
-    old_tcx_gain_e = pAacDecoderStaticChannelInfo->last_tcx_gain_e;
-    old_stab = pAacDecoderStaticChannelInfo->oldStability;
-    nLostSf = pAacDecoderStaticChannelInfo->numLostLpdFrames;
-
-    /* patch the last LPD mode */
-    pAacDecoderChannelInfo->data.usac.lpd_mode_last = last_lpd_mode;
-
-    /* Do mode extrapolation and repeat the previous mode:
-       if previous mode = ACELP        -> ACELP
-       if previous mode = TCX-20/40    -> TCX-20
-       if previous mode = TCX-80       -> TCX-80
-       notes:
-       - ACELP is not allowed after TCX (no pitch information to reuse)
-       - TCX-40 is not allowed in the mode repetition to keep the logic simple
-     */
-    switch (last_lpd_mode) {
-      case 0:
-        mod[0] = mod[1] = mod[2] = mod[3] = 0; /* -> ACELP concealment */
-        break;
-      case 3:
-        mod[0] = mod[1] = mod[2] = mod[3] = 3; /* -> TCX FD concealment */
-        break;
-      case 2:
-        mod[0] = mod[1] = mod[2] = mod[3] = 2; /* -> TCX FD concealment */
-        break;
-      case 1:
-      default:
-        mod[0] = mod[1] = mod[2] = mod[3] = 4; /* -> TCX TD concealment */
-        break;
-    }
-
-    /* LPC extrapolation */
-    CLpc_Conceal(pAacDecoderChannelInfo->data.usac.lsp_coeff,
-                 pAacDecoderStaticChannelInfo->lpc4_lsf,
-                 pAacDecoderStaticChannelInfo->lsf_adaptive_mean,
-                 /*(pAacDecoderStaticChannelInfo->numLostLpdFrames == 0) ||*/
-                 (last_lpd_mode == 255));
-
-    if ((last_lpd_mode > 0) && (last_lpd_mode < 255)) {
-      /* Copy old LPC4 LP domain coefficients to LPC0 LP domain buffer (to avoid
-       * converting LSP coefficients again). */
-      FDKmemcpy(pAacDecoderChannelInfo->data.usac.lp_coeff[0],
-                pAacDecoderStaticChannelInfo->lp_coeff_old[0],
-                M_LP_FILTER_ORDER * sizeof(FIXP_LPC));
-      pAacDecoderChannelInfo->data.usac.lp_coeff_exp[0] =
-          pAacDecoderStaticChannelInfo->lp_coeff_old_exp[0];
-    } /* case last_lpd_mode was ACELP is handled by CLpd_TcxDecode() */
-    /* case last_lpd_mode was Time domain TCX concealment is handled after this
-     * "if (!frameOk)"-block */
-
-    /* k is the frame index. If a frame is of size 40MS or 80MS,
-       this frame index is incremented 2 or 4 instead of 1 respectively. */
-    k = 0;
-    while (k < nbDiv) {
-      pAacDecoderChannelInfo->data.usac.tcx_gain[k] = old_tcx_gain;
-      pAacDecoderChannelInfo->data.usac.tcx_gain_e[k] = old_tcx_gain_e;
-
-      /* restore stability value from last frame */
-      pAacDecoderChannelInfo->data.usac.aStability[k] = old_stab;
-
-      /* Increase k to next frame */
-      k += ((mod[k] & 0x3) == 0) ? 1 : (1 << ((mod[k] & 0x3) - 1));
-
-      nLostSf++;
-    }
-  } else {
-    if ((pAacDecoderStaticChannelInfo->last_lpd_mode == 4) && (mod[0] > 0)) {
-      /* Copy old LPC4 LP domain coefficients to LPC0 LP domain buffer (to avoid
-       * converting LSP coefficients again). */
-      FDKmemcpy(pAacDecoderChannelInfo->data.usac.lp_coeff[0],
-                pAacDecoderStaticChannelInfo->lp_coeff_old[0],
-                M_LP_FILTER_ORDER * sizeof(FIXP_LPC));
-      pAacDecoderChannelInfo->data.usac.lp_coeff_exp[0] =
-          pAacDecoderStaticChannelInfo->lp_coeff_old_exp[0];
-    }
-  }
-
-  Acelp_PreProcessing(synth_buf, pAacDecoderStaticChannelInfo->old_synth, pitch,
-                      pAacDecoderStaticChannelInfo->old_T_pf, pit_gain,
-                      pAacDecoderStaticChannelInfo->old_gain_pf, samplingRate,
-                      &i_offset, lFrame, synSfd, nbSubfrSuperfr);
-
-  /* k is the frame index. If a frame is of size 40MS or 80MS,
-     this frame index is incremented 2 or 4 instead of 1 respectively. */
-  k = 0;
-  last_k = -1; /* mark invalid */
-  last_lpd_mode = pAacDecoderStaticChannelInfo->last_lpd_mode;
-  last_last_lpd_mode = pAacDecoderStaticChannelInfo->last_last_lpd_mode;
-  last_lpc_lost = pAacDecoderStaticChannelInfo->last_lpc_lost | last_frame_lost;
-
-  /* This buffer must be avalable for the case of FD->ACELP transition. The
-  beginning of the buffer is used after the BPF to overwrite the output signal.
-  Only the FAC area must be affected by the BPF */
-
-  while (k < nbDiv) {
-    if (frameOk == 0) {
-      pAacDecoderStaticChannelInfo->numLostLpdFrames++;
-    } else {
-      last_frame_lost |=
-          (pAacDecoderStaticChannelInfo->numLostLpdFrames > 0) ? 1 : 0;
-      pAacDecoderStaticChannelInfo->numLostLpdFrames = 0;
-    }
-    if (mod[k] == 0 || mod[k] == 4) {
-      /* ACELP or TCX time domain concealment */
-      FIXP_DBL *acelp_out;
-
-      /* FAC management */
-      if ((last_lpd_mode != 0) && (last_lpd_mode != 4)) /* TCX TD concealment */
-      {
-        FIXP_DBL *pFacData = NULL;
-
-        if (frameOk && !last_frame_lost) {
-          pFacData = pAacDecoderChannelInfo->data.usac.fac_data[k];
-        }
-
-        nrSamples += CLpd_FAC_Mdct2Acelp(
-            &pAacDecoderStaticChannelInfo->IMdct, synth + nrSamples, pFacData,
-            pAacDecoderChannelInfo->data.usac.fac_data_e[k],
-            pAacDecoderChannelInfo->data.usac.lp_coeff[k],
-            pAacDecoderChannelInfo->data.usac.lp_coeff_exp[k],
-            lFrame - nrSamples,
-            CLpd_FAC_getLength(
-                (pAacDecoderStaticChannelInfo->last_core_mode != FD_SHORT) ||
-                    (k > 0),
-                lFac),
-            (pAacDecoderStaticChannelInfo->last_core_mode != LPD) && (k == 0),
-            0);
-
-        FDKmemcpy(
-            synth + nrSamples, pAacDecoderStaticChannelInfo->IMdct.overlap.time,
-            pAacDecoderStaticChannelInfo->IMdct.ov_offset * sizeof(FIXP_DBL));
-        {
-          FIXP_LPC *lp_prev =
-              pAacDecoderChannelInfo->data.usac
-                  .lp_coeff[0]; /* init value does not real matter */
-          INT lp_prev_exp = pAacDecoderChannelInfo->data.usac.lp_coeff_exp[0];
-
-          if (last_lpd_mode != 255) { /* last mode was tcx */
-            last_k = k - (1 << (last_lpd_mode - 1));
-            if (last_k < 0) {
-              lp_prev = pAacDecoderStaticChannelInfo->lp_coeff_old[1];
-              lp_prev_exp = pAacDecoderStaticChannelInfo->lp_coeff_old_exp[1];
-            } else {
-              lp_prev = pAacDecoderChannelInfo->data.usac.lp_coeff[last_k];
-              lp_prev_exp =
-                  pAacDecoderChannelInfo->data.usac.lp_coeff_exp[last_k];
-            }
-          }
-
-          CLpd_AcelpPrepareInternalMem(
-              synth + aacDelay + k * lDiv, last_lpd_mode,
-              (last_last_lpd_mode == 4) ? 0 : last_last_lpd_mode,
-              pAacDecoderChannelInfo->data.usac.lp_coeff[k],
-              pAacDecoderChannelInfo->data.usac.lp_coeff_exp[k], lp_prev,
-              lp_prev_exp, &pAacDecoderStaticChannelInfo->acelp, lFrame,
-              (last_frame_lost && k < 2), mod[k]);
-        }
-      } else {
-        if (k == 0 && pAacDecoderStaticChannelInfo->IMdct.ov_offset !=
-                          lFrame / facFB / 2) {
-          pAacDecoderStaticChannelInfo->IMdct.ov_offset = lFrame / facFB / 2;
-        }
-        nrSamples += imdct_drain(&pAacDecoderStaticChannelInfo->IMdct,
-                                 synth + nrSamples, lFrame / facFB - nrSamples);
-      }
-
-      if (nrSamples >= lFrame / facFB) {
-        /* Write ACELP time domain samples into IMDCT overlap buffer at
-         * pAacDecoderStaticChannelInfo->IMdct.overlap.time +
-         * pAacDecoderStaticChannelInfo->IMdct.ov_offset
-         */
-        acelp_out = pAacDecoderStaticChannelInfo->IMdct.overlap.time +
-                    pAacDecoderStaticChannelInfo->IMdct.ov_offset;
-
-        /* Account ACELP time domain output samples to overlap buffer */
-        pAacDecoderStaticChannelInfo->IMdct.ov_offset += lDiv;
-      } else {
-        /* Write ACELP time domain samples into output buffer at pTimeData +
-         * nrSamples */
-        acelp_out = synth + nrSamples;
-
-        /* Account ACELP time domain output samples to output buffer */
-        nrSamples += lDiv;
-      }
-
-      if (mod[k] == 4) {
-        pAacDecoderStaticChannelInfo->acelp.wsyn_rms = scaleValue(
-            pAacDecoderChannelInfo->data.usac.tcx_gain[k],
-            fixMin(0,
-                   pAacDecoderChannelInfo->data.usac.tcx_gain_e[k] - SF_EXC));
-        CLpd_TcxTDConceal(&pAacDecoderStaticChannelInfo->acelp,
-                          &pAacDecoderStaticChannelInfo->last_tcx_pitch,
-                          pAacDecoderChannelInfo->data.usac.lsp_coeff[k],
-                          pAacDecoderChannelInfo->data.usac.lsp_coeff[k + 1],
-                          pAacDecoderChannelInfo->data.usac.aStability[k],
-                          pAacDecoderStaticChannelInfo->numLostLpdFrames,
-                          acelp_out, lFrame,
-                          pAacDecoderStaticChannelInfo->last_tcx_noise_factor);
-
-      } else {
-        FDK_ASSERT(pAacDecoderChannelInfo->data.usac.aStability[k] >=
-                   (FIXP_SGL)0);
-        CLpd_AcelpDecode(&pAacDecoderStaticChannelInfo->acelp, i_offset,
-                         pAacDecoderChannelInfo->data.usac.lsp_coeff[k],
-                         pAacDecoderChannelInfo->data.usac.lsp_coeff[k + 1],
-                         pAacDecoderChannelInfo->data.usac.aStability[k],
-                         &pAacDecoderChannelInfo->data.usac.acelp[k],
-                         pAacDecoderStaticChannelInfo->numLostLpdFrames,
-                         last_lpc_lost, k, acelp_out,
-                         &pitch[(k * nbSubfr) + synSfd],
-                         &pit_gain[(k * nbSubfr) + synSfd], lFrame);
-      }
-
-      if (mod[k] != 4) {
-        if (last_lpd_mode != 0 &&
-            pAacDecoderChannelInfo->data.usac
-                .bpf_control_info) { /* FD/TCX -> ACELP transition */
-          /* bass post-filter past FAC area (past two (one for FD short)
-           * subframes) */
-          int currentSf = synSfd + k * nbSubfr;
-
-          if ((k > 0) || (pAacDecoderStaticChannelInfo->last_core_mode !=
-                          FD_SHORT)) { /* TCX or FD long -> ACELP */
-            pitch[currentSf - 2] = pitch[currentSf - 1] = pitch[currentSf];
-            pit_gain[currentSf - 2] = pit_gain[currentSf - 1] =
-                pit_gain[currentSf];
-          } else { /* FD short -> ACELP */
-            pitch[currentSf - 1] = pitch[currentSf];
-            pit_gain[currentSf - 1] = pit_gain[currentSf];
-          }
-        }
-      }
-    } else { /* TCX */
-      int lg = lg_table[mod[k]];
-      int isFullBandLpd = 0;
-
-      /* FAC management */
-      if ((last_lpd_mode == 0) || (last_lpd_mode == 4)) /* TCX TD concealment */
-      {
-        C_AALLOC_SCRATCH_START(fac_buf, FIXP_DBL, 1024 / 8);
-
-        /* pAacDecoderChannelInfo->data.usac.fac_data[k] == NULL means no FAC
-         * data available. */
-        if (last_frame_lost == 1 ||
-            pAacDecoderChannelInfo->data.usac.fac_data[k] == NULL) {
-          FDKmemclear(fac_buf, 1024 / 8 * sizeof(FIXP_DBL));
-          pAacDecoderChannelInfo->data.usac.fac_data[k] = fac_buf;
-          pAacDecoderChannelInfo->data.usac.fac_data_e[k] = 0;
-        }
-
-        nrSamples += CLpd_FAC_Acelp2Mdct(
-            &pAacDecoderStaticChannelInfo->IMdct, synth + nrSamples,
-            SPEC_TCX(pAacDecoderChannelInfo->pSpectralCoefficient, k,
-                     pAacDecoderChannelInfo->granuleLength, isFullBandLpd),
-            pAacDecoderChannelInfo->specScale + k, 1,
-            pAacDecoderChannelInfo->data.usac.fac_data[k],
-            pAacDecoderChannelInfo->data.usac.fac_data_e[k],
-            pAacDecoderChannelInfo->granuleLength /* == fac_length */,
-            lFrame - nrSamples, lg,
-            FDKgetWindowSlope(lDiv,
-                              GetWindowShape(&pAacDecoderChannelInfo->icsInfo)),
-            lDiv, pAacDecoderChannelInfo->data.usac.lp_coeff[k],
-            pAacDecoderChannelInfo->data.usac.lp_coeff_exp[k],
-            &pAacDecoderStaticChannelInfo->acelp,
-            pAacDecoderChannelInfo->data.usac.tcx_gain[k],
-            (last_frame_lost || !frameOk), 0 /* is not FD FAC */
-            ,
-            last_lpd_mode, k,
-            pAacDecoderChannelInfo
-                ->currAliasingSymmetry /* Note: The current aliasing
-                                          symmetry for a TCX (i.e. LPD)
-                                          frame must always be 0 */
-        );
-
-        pitch[(k * nbSubfr) + synSfd + 1] = pitch[(k * nbSubfr) + synSfd] =
-            pitch[(k * nbSubfr) + synSfd - 1];
-        pit_gain[(k * nbSubfr) + synSfd + 1] =
-            pit_gain[(k * nbSubfr) + synSfd] =
-                pit_gain[(k * nbSubfr) + synSfd - 1];
-
-        C_AALLOC_SCRATCH_END(fac_buf, FIXP_DBL, 1024 / 8);
-      } else {
-        int tl = lg;
-        int fl = lDiv;
-        int fr = lDiv;
-
-        nrSamples += imlt_block(
-            &pAacDecoderStaticChannelInfo->IMdct, synth + nrSamples,
-            SPEC_TCX(pAacDecoderChannelInfo->pSpectralCoefficient, k,
-                     pAacDecoderChannelInfo->granuleLength, isFullBandLpd),
-            pAacDecoderChannelInfo->specScale + k, 1, lFrame - nrSamples, tl,
-            FDKgetWindowSlope(fl,
-                              GetWindowShape(&pAacDecoderChannelInfo->icsInfo)),
-            fl,
-            FDKgetWindowSlope(fr,
-                              GetWindowShape(&pAacDecoderChannelInfo->icsInfo)),
-            fr, pAacDecoderChannelInfo->data.usac.tcx_gain[k],
-            pAacDecoderChannelInfo->currAliasingSymmetry
-                ? MLT_FLAG_CURR_ALIAS_SYMMETRY
-                : 0);
-      }
-    }
-    /* remember previous mode */
-    last_last_lpd_mode = last_lpd_mode;
-    last_lpd_mode = mod[k];
-    last_lpc_lost = (frameOk == 0) ? 1 : 0;
-
-    /* Increase k to next frame */
-    last_k = k;
-    k += ((mod[k] & 0x3) == 0) ? 1 : (1 << (mod[k] - 1));
-  }
-
-  if (frameOk) {
-    /* assume data was ok => store for concealment */
-    FDK_ASSERT(pAacDecoderChannelInfo->data.usac.aStability[last_k] >=
-               (FIXP_SGL)0);
-    pAacDecoderStaticChannelInfo->oldStability =
-        pAacDecoderChannelInfo->data.usac.aStability[last_k];
-    FDKmemcpy(pAacDecoderStaticChannelInfo->lsf_adaptive_mean,
-              pAacDecoderChannelInfo->data.usac.lsf_adaptive_mean_cand,
-              M_LP_FILTER_ORDER * sizeof(FIXP_LPC));
-  }
-
-  /* store past lp coeffs for next superframe (they are only valid and needed if
-   * last_lpd_mode was tcx) */
-  if (last_lpd_mode > 0) {
-    FDKmemcpy(pAacDecoderStaticChannelInfo->lp_coeff_old[0],
-              pAacDecoderChannelInfo->data.usac.lp_coeff[nbDiv],
-              M_LP_FILTER_ORDER * sizeof(FIXP_LPC));
-    pAacDecoderStaticChannelInfo->lp_coeff_old_exp[0] =
-        pAacDecoderChannelInfo->data.usac.lp_coeff_exp[nbDiv];
-    FDKmemcpy(pAacDecoderStaticChannelInfo->lp_coeff_old[1],
-              pAacDecoderChannelInfo->data.usac.lp_coeff[last_k],
-              M_LP_FILTER_ORDER * sizeof(FIXP_LPC));
-    pAacDecoderStaticChannelInfo->lp_coeff_old_exp[1] =
-        pAacDecoderChannelInfo->data.usac.lp_coeff_exp[last_k];
-  }
-
-  FDK_ASSERT(nrSamples == lFrame);
-
-  /* check whether usage of bass postfilter was de-activated in the bitstream;
-   if yes, set pitch gain to 0 */
-  if (!(pAacDecoderChannelInfo->data.usac.bpf_control_info)) {
-    if (mod[0] != 0 && (pAacDecoderStaticChannelInfo->old_bpf_control_info)) {
-      for (int i = 2; i < nbSubfrSuperfr; i++)
-        pit_gain[synSfd + i] = (FIXP_DBL)0;
-    } else {
-      for (int i = 0; i < nbSubfrSuperfr; i++)
-        pit_gain[synSfd + i] = (FIXP_DBL)0;
-    }
-  }
-
-  /* for bass postfilter */
-  for (int n = 0; n < synSfd; n++) {
-    pAacDecoderStaticChannelInfo->old_T_pf[n] = pitch[nbSubfrSuperfr + n];
-    pAacDecoderStaticChannelInfo->old_gain_pf[n] = pit_gain[nbSubfrSuperfr + n];
-  }
-
-  pAacDecoderStaticChannelInfo->old_bpf_control_info =
-      pAacDecoderChannelInfo->data.usac.bpf_control_info;
-
-  {
-    INT lookahead = -BPF_DELAY;
-    int copySamp = (mod[nbDiv - 1] == 0) ? (aacDelay) : (aacDelay - lFac);
-
-    /* Copy enough time domain samples from MDCT to synthesis buffer as needed
-     * by the bass postfilter */
-
-    lookahead += imdct_copy_ov_and_nr(&pAacDecoderStaticChannelInfo->IMdct,
-                                      synth + nrSamples, copySamp);
-
-    FDK_ASSERT(lookahead == copySamp - BPF_DELAY);
-
-    FIXP_DBL *p2_synth = synth + BPF_DELAY;
-
-    /* recalculate pitch gain to allow postfilering on FAC area */
-    for (int i = 0; i < nbSubfrSuperfr; i++) {
-      int T = pitch[i];
-      FIXP_DBL gain = pit_gain[i];
-
-      if (gain > (FIXP_DBL)0) {
-        gain = get_gain(&p2_synth[i * L_SUBFR], &p2_synth[(i * L_SUBFR) - T],
-                        L_SUBFR);
-        pit_gain[i] = gain;
-      }
-    }
-
-    {
-      bass_pf_1sf_delay(p2_synth, pitch, pit_gain, lFrame, lFrame / facFB,
-                        mod[nbDiv - 1] ? (SynDelay - (lDiv / 2)) : SynDelay,
-                        pTimeData, pAacDecoderStaticChannelInfo->mem_bpf);
-    }
-  }
-
-  Acelp_PostProcessing(synth_buf, pAacDecoderStaticChannelInfo->old_synth,
-                       pitch, pAacDecoderStaticChannelInfo->old_T_pf, lFrame,
-                       synSfd, nbSubfrSuperfr);
-
-  /* Store last mode for next super frame */
-  { pAacDecoderStaticChannelInfo->last_core_mode = LPD; }
-  pAacDecoderStaticChannelInfo->last_lpd_mode = last_lpd_mode;
-  pAacDecoderStaticChannelInfo->last_last_lpd_mode = last_last_lpd_mode;
-  pAacDecoderStaticChannelInfo->last_lpc_lost = last_lpc_lost;
-
-  return error;
-}
--- a/libAACdec/src/usacdec_lpd.h
+++ /dev/null
@@ -1,198 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/**************************** AAC decoder library ******************************
-
-   Author(s):   Manuel Jander
-
-   Description: USAC Linear Prediction Domain coding
-
-*******************************************************************************/
-
-#ifndef USACDEC_LPD_H
-#define USACDEC_LPD_H
-
-#include "channelinfo.h"
-
-#define OPTIMIZE_AVG_PERFORMANCE
-
-/**
- * \brief read a lpd_channel_stream.
- * \param hBs a bit stream handle, where the lpd_channel_stream is located.
- * \param pAacDecoderChannelInfo the channel context structure for storing read
- * data.
- * \param flags bit stream syntax flags.
- * \return AAC_DECODER_ERROR error code.
- */
-AAC_DECODER_ERROR CLpdChannelStream_Read(
-    HANDLE_FDK_BITSTREAM hBs, CAacDecoderChannelInfo *pAacDecoderChannelInfo,
-    CAacDecoderStaticChannelInfo *pAacDecoderStaticChannelInfo,
-    const SamplingRateInfo *pSamplingRateInfo, UINT flags);
-
-/**
- * \brief decode one lpd_channel_stream and render the audio output.
- * \param pAacDecoderChannelInfo struct holding the channel information to be
- * rendered.
- * \param pAacDecoderStaticChannelInfo struct holding the persistent channel
- * information to be rendered.
- * \param pSamplingRateInfo holds the sampling rate information
- * \param elFlags holds the internal decoder flags
- */
-void CLpdChannelStream_Decode(
-    CAacDecoderChannelInfo *pAacDecoderChannelInfo,
-    CAacDecoderStaticChannelInfo *pAacDecoderStaticChannelInfo, UINT flags);
-
-/**
- * \brief generate time domain output signal for LPD channel streams
- * \param pAacDecoderStaticChannelInfo
- * \param pAacDecoderChannelInfo
- * \param pTimeData pointer to output buffer
- * \param samplesPerFrame amount of output samples
- * \param pSamplingRateInfo holds the sampling rate information
- * \param pWorkBuffer1 pointer to work buffer for temporal data
- */
-AAC_DECODER_ERROR CLpd_RenderTimeSignal(
-    CAacDecoderStaticChannelInfo *pAacDecoderStaticChannelInfo,
-    CAacDecoderChannelInfo *pAacDecoderChannelInfo, FIXP_PCM *pTimeData,
-    INT samplesPerFrame, SamplingRateInfo *pSamplingRateInfo, UINT frameOk,
-    UINT flags, UINT strmFlags);
-
-static inline INT CLpd_FAC_getLength(int fNotShortBlock, int fac_length_long) {
-  if (fNotShortBlock) {
-    return (fac_length_long);
-  } else {
-    return fac_length_long / 2;
-  }
-}
-
-void filtLP(const FIXP_DBL *syn, FIXP_PCM *syn_out, FIXP_DBL *noise,
-            const FIXP_SGL *filt, INT stop, int len);
-
-/**
- * \brief perform a low-frequency pitch enhancement on time domain signal
- * \param[in] syn pointer to time domain input signal
- * \param[in] synFB pointer to time domain input signal
- * \param[in] upsampling factor
- * \param[in] T_sf array with past decoded pitch period values for each subframe
- * \param[in] non_zero_gain_flags indicates whether pitch gains of past
- * subframes are zero or not, msb -> [1 BPF_DELAY subfr][7 SYN_DELAY subfr][16
- * new subfr] <- lsb
- * \param[in] l_frame length of filtering, must be multiple of L_SUBFR
- * \param[in] l_next length of allowed look ahead on syn[i], i < l_frame+l_next
- * \param[out] synth_out pointer to time domain output signal
- * \param[in,out] mem_bpf pointer to filter memory (L_FILT+L_SUBFR)
- */
-
-void bass_pf_1sf_delay(FIXP_DBL syn[], const INT T_sf[], FIXP_DBL *pit_gain,
-                       const int frame_length, const INT l_frame,
-                       const INT l_next, FIXP_PCM *synth_out,
-                       FIXP_DBL mem_bpf[]);
-
-/**
- * \brief random sign generator for FD and TCX noise filling
- * \param[in,out] seed pointer to random seed
- * \return if return value is zero use positive sign
- * \Note: This code is also implemented as a copy in block.cpp, grep for
- * "UsacRandomSign"
- */
-FDK_INLINE
-int UsacRandomSign(ULONG *seed) {
-  *seed = (ULONG)((UINT64)(*seed) * 69069 + 5);
-
-  return (int)((*seed) & 0x10000);
-}
-
-void CFdp_Reset(CAacDecoderStaticChannelInfo *pAacDecoderStaticChannelInfo);
-
-#endif /* USACDEC_LPD_H */
--- a/libAACdec/src/usacdec_rom.cpp
+++ /dev/null
@@ -1,1504 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/**************************** AAC decoder library ******************************
-
-   Author(s):   M. Jander
-
-   Description:
-
-*******************************************************************************/
-
-#include "usacdec_rom.h"
-
-#define NB_SPHERE 32
-#define NB_LEADER 37
-#define NB_LDSIGN 226
-#define NB_LDQ3 9
-#define NB_LDQ4 28
-
-/* For bass post filter */
-#define FL2FXCONST_SGL_FILT(a) FL2FXCONST_SGL(a*(1 << SF_FILT_LP))
-#define SF_FILT_LP 1
-
-/* table of factorial */
-const UINT fdk_dec_tab_factorial[8] = {5040, 720, 120, 24, 6, 2, 1, 1};
-
-/*  Da - Absolute leaders */
-const UCHAR fdk_dec_Da[NB_LEADER][8] = {
-    {1, 1, 1, 1, 1, 1, 1, 1},   {2, 2, 0, 0, 0, 0, 0, 0},
-    {2, 2, 2, 2, 0, 0, 0, 0},   {3, 1, 1, 1, 1, 1, 1, 1},
-    {4, 0, 0, 0, 0, 0, 0, 0},   {2, 2, 2, 2, 2, 2, 0, 0},
-    {3, 3, 1, 1, 1, 1, 1, 1},   {4, 2, 2, 0, 0, 0, 0, 0},
-    {2, 2, 2, 2, 2, 2, 2, 2},   {3, 3, 3, 1, 1, 1, 1, 1},
-    {4, 2, 2, 2, 2, 0, 0, 0},   {4, 4, 0, 0, 0, 0, 0, 0},
-    {5, 1, 1, 1, 1, 1, 1, 1},   {3, 3, 3, 3, 1, 1, 1, 1},
-    {4, 2, 2, 2, 2, 2, 2, 0},   {4, 4, 2, 2, 0, 0, 0, 0},
-    {5, 3, 1, 1, 1, 1, 1, 1},   {6, 2, 0, 0, 0, 0, 0, 0},
-    {4, 4, 4, 0, 0, 0, 0, 0},   {6, 2, 2, 2, 0, 0, 0, 0},
-    {6, 4, 2, 0, 0, 0, 0, 0},   {7, 1, 1, 1, 1, 1, 1, 1},
-    {8, 0, 0, 0, 0, 0, 0, 0},   {6, 6, 0, 0, 0, 0, 0, 0},
-    {8, 2, 2, 0, 0, 0, 0, 0},   {8, 4, 0, 0, 0, 0, 0, 0},
-    {9, 1, 1, 1, 1, 1, 1, 1},   {10, 2, 0, 0, 0, 0, 0, 0},
-    {8, 8, 0, 0, 0, 0, 0, 0},   {10, 6, 0, 0, 0, 0, 0, 0},
-    {12, 0, 0, 0, 0, 0, 0, 0},  {12, 4, 0, 0, 0, 0, 0, 0},
-    {10, 10, 0, 0, 0, 0, 0, 0}, {14, 2, 0, 0, 0, 0, 0, 0},
-    {12, 8, 0, 0, 0, 0, 0, 0},  {16, 0, 0, 0, 0, 0, 0, 0},
-    {20, 0, 0, 0, 0, 0, 0, 0}};
-
-/* Ds - Sign codes of all signed leaders */
-const UCHAR fdk_dec_Ds[NB_LDSIGN] = {
-    0,   3,   15,  63,  255, 0,   64,  192, 0,   16,  48,  112, 240, 1,   7,
-    31,  127, 128, 131, 143, 191, 0,   128, 0,   4,   12,  28,  60,  124, 252,
-    0,   3,   15,  63,  65,  71,  95,  192, 195, 207, 255, 0,   32,  96,  128,
-    160, 224, 0,   1,   3,   7,   15,  31,  63,  127, 255, 1,   7,   31,  32,
-    35,  47,  97,  103, 127, 224, 227, 239, 0,   8,   24,  56,  120, 128, 136,
-    152, 184, 248, 0,   64,  192, 0,   3,   15,  63,  129, 135, 159, 255, 0,
-    3,   15,  17,  23,  48,  51,  63,  113, 119, 240, 243, 255, 0,   2,   6,
-    14,  30,  62,  126, 128, 130, 134, 142, 158, 190, 254, 0,   16,  48,  64,
-    80,  112, 192, 208, 240, 1,   7,   31,  64,  67,  79,  127, 128, 131, 143,
-    191, 193, 199, 223, 0,   64,  128, 192, 0,   32,  96,  224, 0,   16,  48,
-    112, 128, 144, 176, 240, 0,   32,  64,  96,  128, 160, 192, 224, 1,   7,
-    31,  127, 128, 131, 143, 191, 0,   128, 0,   64,  192, 0,   32,  96,  128,
-    160, 224, 0,   64,  128, 192, 0,   3,   15,  63,  129, 135, 159, 255, 0,
-    64,  128, 192, 0,   64,  192, 0,   64,  128, 192, 0,   128, 0,   64,  128,
-    192, 0,   64,  192, 0,   64,  128, 192, 0,   64,  128, 192, 0,   128, 0,
-    128};
-
-/* Ns - Number of signed leader associated to a given absolute leader */
-const UCHAR fdk_dec_Ns[NB_LEADER] = {
-    5, 3, 5, 8, 2, 7, 11, 6, 9, 12, 10, 3, 8, 13, 14, 9, 14, 4, 4,
-    8, 8, 8, 2, 3, 6, 4,  8, 4, 3,  4,  2, 4, 3,  4,  4, 2,  2};
-
-/* Ia - Position of the first signed leader associated to an absolute leader */
-const UCHAR fdk_dec_Ia[NB_LEADER] = {
-    0,   5,   8,   13,  21,  23,  30,  41,  47,  56,  68,  78,  81,
-    89,  102, 116, 125, 139, 143, 147, 155, 163, 171, 173, 176, 182,
-    186, 194, 198, 201, 205, 207, 211, 214, 218, 222, 224};
-
-/* Is - Cardinalite offset of signed leaders */
-const USHORT fdk_dec_Is[NB_LDSIGN] = {
-    0,     1,     29,    99,    127,   128,   156,   212,   256,   326,   606,
-    1026,  1306,  1376,  1432,  1712,  1880,  1888,  1896,  2064,  2344,  240,
-    248,   0,     28,    196,   616,   1176,  1596,  1764,  1792,  1820,  2240,
-    2660,  2688,  3024,  4144,  4480,  4508,  4928,  5348,  2400,  2568,  2904,
-    3072,  3240,  3576,  5376,  5377,  5385,  5413,  5469,  5539,  5595,  5623,
-    5631,  5632,  5912,  6472,  6528,  6696,  8376,  9216,  10056, 11736, 11904,
-    11960, 12520, 12800, 13080, 14200, 15880, 17000, 17280, 17560, 18680, 20360,
-    21480, 3744,  3772,  3828,  21760, 21768, 21936, 22216, 22272, 22328, 22608,
-    22776, 22784, 22854, 23274, 23344, 24464, 25584, 26004, 28524, 28944, 30064,
-    31184, 31254, 31674, 31744, 31800, 32136, 32976, 34096, 34936, 35272, 35328,
-    35384, 35720, 36560, 37680, 38520, 38856, 38912, 39332, 40172, 40592, 41432,
-    43112, 43952, 44372, 45212, 45632, 45968, 47088, 47424, 47480, 48320, 49160,
-    49216, 49272, 50112, 50952, 51008, 51344, 52464, 3856,  3912,  3968,  4024,
-    52800, 52856, 53024, 53192, 53248, 53528, 54368, 55208, 55488, 55768, 56608,
-    57448, 57728, 58064, 58400, 58736, 59072, 59408, 59744, 60080, 60416, 60472,
-    60752, 60920, 60928, 60936, 61104, 61384, 4080,  4088,  61440, 61468, 61524,
-    61552, 61720, 62056, 62224, 62392, 62728, 62896, 62952, 63008, 63064, 63120,
-    63128, 63296, 63576, 63632, 63688, 63968, 64136, 64144, 64200, 64256, 64312,
-    64368, 64396, 64452, 64480, 64536, 64592, 64648, 64704, 64712, 64720, 64776,
-    64832, 64888, 64944, 64972, 65028, 65056, 65112, 65168, 65224, 65280, 65336,
-    65392, 65448, 65504, 65512, 65520, 65528};
-
-/* A3 - Number of the absolute leaders in codebooks Q2 and Q3 */
-const UCHAR fdk_dec_A3[NB_LDQ3] = {0, 1, 4, 2, 3, 7, 11, 17, 22};
-
-/* A4 - Number of the absolute leaders in codebook Q4 */
-const UCHAR fdk_dec_A4[NB_LDQ4] = {5,  6,  8,  9,  10, 12, 13, 14, 15, 16,
-                                   18, 19, 20, 21, 23, 24, 25, 26, 27, 28,
-                                   29, 30, 31, 32, 33, 34, 35, 36};
-
-/* I3 - Cardinality offsets for absolute leaders in Q3 */
-const USHORT fdk_dec_I3[NB_LDQ3] = {0,    128,  240,  256, 1376,
-                                    2400, 3744, 3856, 4080};
-
-/* I4 - Cardinality offset for absolute leaders in Q4 */
-const USHORT fdk_dec_I4[NB_LDQ4] = {
-    0,     1792,  5376,  5632,  12800, 21760, 22784, 31744, 38912, 45632,
-    52800, 53248, 57728, 60416, 61440, 61552, 62896, 63120, 64144, 64368,
-    64480, 64704, 64720, 64944, 65056, 65280, 65504, 65520};
-
-/* Initial ISF memory for concealment case */
-#define LSFI(x) ((x) << (FRACT_BITS - LSF_SCALE - 1))
-
-const FIXP_LPC fdk_dec_lsf_init[16] = {1506,  3012,  4518,  6024,  7529,  9035,
-                                       10541, 12047, 13553, 15059, 16565, 18071,
-                                       19576, 21082, 22588, 24094};
-
-/* dico_lsf_abs_8b is scaled by 1/(1<<13) */
-#define DICO(x) FX_DBL2FXCONST_LPC(x >> (LSF_SCALE - 13))
-
-const FIXP_LPC fdk_dec_dico_lsf_abs_8b[] = {
-    DICO(0x05e57fe8), DICO(0x0ac00810), DICO(0x11ed8500), DICO(0x16d42ce0),
-    DICO(0x1beb1e20), DICO(0x217eaf40), DICO(0x2768c740), DICO(0x2d26f600),
-    DICO(0x32fe68c0), DICO(0x38b1d980), DICO(0x3e95bd80), DICO(0x446dab00),
-    DICO(0x4abfd280), DICO(0x5094b380), DICO(0x56ccb800), DICO(0x5c9aba00),
-    DICO(0x09660ca0), DICO(0x10ab4c00), DICO(0x15a16f20), DICO(0x19d3c780),
-    DICO(0x1ee99060), DICO(0x241d1200), DICO(0x29c83700), DICO(0x2f098f00),
-    DICO(0x34803fc0), DICO(0x3a37bc00), DICO(0x3ff55580), DICO(0x45da9280),
-    DICO(0x4bec6700), DICO(0x5169e300), DICO(0x57797c80), DICO(0x5d09ae80),
-    DICO(0x08a203b0), DICO(0x0d6ed1a0), DICO(0x152ccf20), DICO(0x19639dc0),
-    DICO(0x1d7e3e60), DICO(0x21f4a7c0), DICO(0x27b2f8c0), DICO(0x2dbb4480),
-    DICO(0x33ecde80), DICO(0x3982e100), DICO(0x3ea16100), DICO(0x43ab6080),
-    DICO(0x49534a80), DICO(0x4ea7e100), DICO(0x550d6300), DICO(0x5bcdcc80),
-    DICO(0x072dd048), DICO(0x0c654690), DICO(0x1436e940), DICO(0x19459680),
-    DICO(0x1e0041c0), DICO(0x2240dc80), DICO(0x26de4040), DICO(0x2b509b00),
-    DICO(0x309d8780), DICO(0x36151180), DICO(0x3c6c1200), DICO(0x42df6b80),
-    DICO(0x4a144400), DICO(0x50541280), DICO(0x56c34b80), DICO(0x5cb6c600),
-    DICO(0x051fef00), DICO(0x06b9fb48), DICO(0x0b4f9cc0), DICO(0x17e27800),
-    DICO(0x1b8c7340), DICO(0x1f772ca0), DICO(0x2478dc80), DICO(0x28242240),
-    DICO(0x2f27c640), DICO(0x33b03e80), DICO(0x381f20c0), DICO(0x3c662c00),
-    DICO(0x49565080), DICO(0x529b0f00), DICO(0x583ed080), DICO(0x5d8cec00),
-    DICO(0x071c4d18), DICO(0x097853b0), DICO(0x0f0f0690), DICO(0x157bf980),
-    DICO(0x1801f580), DICO(0x1deb0c20), DICO(0x2523da40), DICO(0x28534600),
-    DICO(0x2eb499c0), DICO(0x32eb5ac0), DICO(0x36749580), DICO(0x3a748200),
-    DICO(0x4325f700), DICO(0x515d8300), DICO(0x58a18700), DICO(0x5d722100),
-    DICO(0x06cbcd88), DICO(0x08bb6740), DICO(0x0dead310), DICO(0x152f0cc0),
-    DICO(0x18427640), DICO(0x1d9f2f20), DICO(0x22ba3b40), DICO(0x271a6e80),
-    DICO(0x2c677ec0), DICO(0x31061b00), DICO(0x349eef40), DICO(0x3c531b80),
-    DICO(0x4aed0580), DICO(0x4f8bbf80), DICO(0x54b74980), DICO(0x5bc9b700),
-    DICO(0x046410c8), DICO(0x06522ab0), DICO(0x0b6528c0), DICO(0x0f94bd90),
-    DICO(0x1a8f8b80), DICO(0x1ea57820), DICO(0x233ee180), DICO(0x27b3acc0),
-    DICO(0x2bd1d240), DICO(0x2fc4bcc0), DICO(0x3a98ea40), DICO(0x43d3f500),
-    DICO(0x49b37580), DICO(0x4e2afd00), DICO(0x55953300), DICO(0x5d36f600),
-    DICO(0x05d0f6c8), DICO(0x07e56d90), DICO(0x0be98080), DICO(0x0f956f30),
-    DICO(0x1259b3c0), DICO(0x1f08b240), DICO(0x25008c00), DICO(0x2900b180),
-    DICO(0x31ea6f00), DICO(0x352d1e00), DICO(0x3c970c80), DICO(0x45271200),
-    DICO(0x4b632280), DICO(0x5098a480), DICO(0x5672fc80), DICO(0x5c163180),
-    DICO(0x05bd81a0), DICO(0x07d4b8f0), DICO(0x0ce224b0), DICO(0x110abe20),
-    DICO(0x13dfeac0), DICO(0x17dedae0), DICO(0x2535c0c0), DICO(0x2a19da80),
-    DICO(0x2e5224c0), DICO(0x38ddeec0), DICO(0x3da99d80), DICO(0x42799100),
-    DICO(0x48973b00), DICO(0x4ea62880), DICO(0x53f77e80), DICO(0x5bd9c100),
-    DICO(0x0395cd50), DICO(0x058244b8), DICO(0x0af45520), DICO(0x1329cea0),
-    DICO(0x1a3970c0), DICO(0x1d9f2e00), DICO(0x21704400), DICO(0x277a34c0),
-    DICO(0x30215b40), DICO(0x33875040), DICO(0x3c159840), DICO(0x452fea00),
-    DICO(0x4981d200), DICO(0x4e15a980), DICO(0x54e84780), DICO(0x5c79ea00),
-    DICO(0x05413b98), DICO(0x08132a80), DICO(0x0dc7f050), DICO(0x13e25460),
-    DICO(0x1784bf80), DICO(0x1d630200), DICO(0x238bc880), DICO(0x28cc0880),
-    DICO(0x30da1a40), DICO(0x391e2200), DICO(0x415d8d00), DICO(0x48f13280),
-    DICO(0x4e300300), DICO(0x52e56580), DICO(0x5849fe80), DICO(0x5cdef400),
-    DICO(0x04a058c8), DICO(0x07569b88), DICO(0x0ef26610), DICO(0x13208140),
-    DICO(0x168c0500), DICO(0x1afec080), DICO(0x22a0abc0), DICO(0x2a057880),
-    DICO(0x2fd1c840), DICO(0x3703c680), DICO(0x3d326b80), DICO(0x43df2e80),
-    DICO(0x4a6f9000), DICO(0x50900d80), DICO(0x56c73f00), DICO(0x5cc3da80),
-    DICO(0x065c99e8), DICO(0x09060c50), DICO(0x0d1ef1c0), DICO(0x16bd9020),
-    DICO(0x1a04dae0), DICO(0x1e3c0580), DICO(0x25783700), DICO(0x29710ac0),
-    DICO(0x309cbb80), DICO(0x36c66280), DICO(0x3adb0580), DICO(0x41b37e00),
-    DICO(0x496ca700), DICO(0x4dab7600), DICO(0x52be6280), DICO(0x58fec480),
-    DICO(0x04640880), DICO(0x05a75ab8), DICO(0x0edba410), DICO(0x16e076a0),
-    DICO(0x198acec0), DICO(0x1eb5fae0), DICO(0x228c9000), DICO(0x29986c00),
-    DICO(0x2c780c80), DICO(0x38078dc0), DICO(0x3f42dc00), DICO(0x441ba900),
-    DICO(0x492f8080), DICO(0x4ed85d00), DICO(0x54605800), DICO(0x5d106a80),
-    DICO(0x045cb970), DICO(0x0627a828), DICO(0x0db35290), DICO(0x1778f780),
-    DICO(0x1a243c60), DICO(0x23c2dd40), DICO(0x27c57840), DICO(0x2f53cd80),
-    DICO(0x36f65600), DICO(0x3bc1b2c0), DICO(0x40c36500), DICO(0x46074180),
-    DICO(0x4b551b80), DICO(0x50a99700), DICO(0x569b6c80), DICO(0x5ca25780),
-    DICO(0x05ef2828), DICO(0x07d3adf8), DICO(0x0b5416d0), DICO(0x0f9adb70),
-    DICO(0x126e7360), DICO(0x1baff460), DICO(0x2b5decc0), DICO(0x31036200),
-    DICO(0x34ca7500), DICO(0x39681340), DICO(0x3da97100), DICO(0x4161ee00),
-    DICO(0x46a62e80), DICO(0x4d1b9380), DICO(0x530e0300), DICO(0x59ff0480),
-    DICO(0x04f5bc50), DICO(0x06e90d18), DICO(0x0c2af480), DICO(0x123f7400),
-    DICO(0x1530a160), DICO(0x18aa3dc0), DICO(0x1cc0a240), DICO(0x2cdb02c0),
-    DICO(0x32909a00), DICO(0x36bae640), DICO(0x3c917a80), DICO(0x40121900),
-    DICO(0x48a90d80), DICO(0x51ccc180), DICO(0x5884ea00), DICO(0x5dbc4280),
-    DICO(0x05791410), DICO(0x07b0dd80), DICO(0x0bec4190), DICO(0x13c30520),
-    DICO(0x17ac1900), DICO(0x1b6f1d00), DICO(0x26e54f40), DICO(0x2d4a8040),
-    DICO(0x311c6840), DICO(0x38ec4180), DICO(0x3f0c4340), DICO(0x427c5b00),
-    DICO(0x4886e480), DICO(0x504a0b00), DICO(0x56d48700), DICO(0x5c80f600),
-    DICO(0x04b58880), DICO(0x0743f0d8), DICO(0x0be95e20), DICO(0x0fd0d9b0),
-    DICO(0x1c2e11a0), DICO(0x2241af80), DICO(0x296e83c0), DICO(0x2f16adc0),
-    DICO(0x32cd6fc0), DICO(0x374ddec0), DICO(0x3da95f80), DICO(0x45d56c80),
-    DICO(0x4c6afa80), DICO(0x5141f380), DICO(0x5616b380), DICO(0x5c58f580),
-    DICO(0x03f4b368), DICO(0x05939890), DICO(0x09d95480), DICO(0x122cac60),
-    DICO(0x17e27e00), DICO(0x1f9dc680), DICO(0x26e26680), DICO(0x2ae64040),
-    DICO(0x2dd6cf40), DICO(0x3295c400), DICO(0x3e23b400), DICO(0x44fd0380),
-    DICO(0x4ad7a700), DICO(0x51295e80), DICO(0x594a9400), DICO(0x5e41aa00),
-    DICO(0x0424b9d8), DICO(0x05b30508), DICO(0x09380f20), DICO(0x0c9509c0),
-    DICO(0x18730860), DICO(0x219a9d40), DICO(0x24f699c0), DICO(0x289b2680),
-    DICO(0x2cb62240), DICO(0x36e88180), DICO(0x3e968800), DICO(0x48053c80),
-    DICO(0x4d6dca80), DICO(0x51d9a580), DICO(0x563e5a80), DICO(0x5c0b2b80),
-    DICO(0x03456ae8), DICO(0x04e49948), DICO(0x07dd0e88), DICO(0x0ed5cd30),
-    DICO(0x1b06e980), DICO(0x1de2b9c0), DICO(0x21160540), DICO(0x270a8240),
-    DICO(0x3352a280), DICO(0x3b8b6c00), DICO(0x40241400), DICO(0x43f60f80),
-    DICO(0x4a897900), DICO(0x51692a00), DICO(0x57449d00), DICO(0x5d497480),
-    DICO(0x04b94290), DICO(0x067e99d0), DICO(0x0ab06840), DICO(0x0e697070),
-    DICO(0x1745c460), DICO(0x22ee8040), DICO(0x2647e8c0), DICO(0x2bc2c680),
-    DICO(0x2fd57d00), DICO(0x37186680), DICO(0x3d074500), DICO(0x412b2800),
-    DICO(0x4579af00), DICO(0x4caff980), DICO(0x557add00), DICO(0x5c6ae780),
-    DICO(0x0423a090), DICO(0x05b9bca0), DICO(0x091b45d0), DICO(0x0c5b6d60),
-    DICO(0x194dd1c0), DICO(0x1fc85020), DICO(0x2486b080), DICO(0x2920af80),
-    DICO(0x2dd4f140), DICO(0x3598be40), DICO(0x3b9c1440), DICO(0x42d19280),
-    DICO(0x4a314280), DICO(0x50b00a00), DICO(0x56c55400), DICO(0x5d5ba300),
-    DICO(0x03e68b28), DICO(0x05a7b190), DICO(0x0917f000), DICO(0x0d247050),
-    DICO(0x19e637a0), DICO(0x2221a540), DICO(0x2777e540), DICO(0x2c103380),
-    DICO(0x30c2e040), DICO(0x389f1240), DICO(0x3f4a2c80), DICO(0x454a4c00),
-    DICO(0x4b0ab680), DICO(0x50cf6000), DICO(0x571c0700), DICO(0x5d2ef600),
-    DICO(0x04886f18), DICO(0x065103e8), DICO(0x0a607d40), DICO(0x0db91960),
-    DICO(0x13546f20), DICO(0x22f5e200), DICO(0x27064240), DICO(0x2e371d40),
-    DICO(0x33659240), DICO(0x38aa1c40), DICO(0x417bb280), DICO(0x47ca9480),
-    DICO(0x4dd6fb80), DICO(0x528e3480), DICO(0x57c49d80), DICO(0x5cc98100),
-    DICO(0x02db2370), DICO(0x04398848), DICO(0x07a8da38), DICO(0x10b90280),
-    DICO(0x1a2a4a20), DICO(0x20b1f640), DICO(0x277096c0), DICO(0x2dc568c0),
-    DICO(0x341b33c0), DICO(0x3a000640), DICO(0x40152880), DICO(0x45eeee00),
-    DICO(0x4c08c480), DICO(0x51bf0600), DICO(0x5799a180), DICO(0x5d23db80),
-    DICO(0x047b1498), DICO(0x06089848), DICO(0x0905af20), DICO(0x0bf13c20),
-    DICO(0x11fcf620), DICO(0x1f79cd00), DICO(0x257f6b40), DICO(0x2cfc2600),
-    DICO(0x31610040), DICO(0x35ea8280), DICO(0x3c774bc0), DICO(0x44417280),
-    DICO(0x4b432500), DICO(0x510e9480), DICO(0x56f2e480), DICO(0x5d282780),
-    DICO(0x02cfd0b0), DICO(0x042845d8), DICO(0x0a1fa610), DICO(0x15911fc0),
-    DICO(0x1bc07f00), DICO(0x2281d640), DICO(0x287abcc0), DICO(0x2ec6b400),
-    DICO(0x34a0d040), DICO(0x3aa4dcc0), DICO(0x4074d980), DICO(0x46726b80),
-    DICO(0x4c3bf900), DICO(0x52055100), DICO(0x57b20500), DICO(0x5d34da80),
-    DICO(0x04d4f768), DICO(0x06cad828), DICO(0x0b52a540), DICO(0x0ea224e0),
-    DICO(0x13c3f460), DICO(0x23808900), DICO(0x27d1cec0), DICO(0x2d6051c0),
-    DICO(0x33c5ff00), DICO(0x37ef2440), DICO(0x3d2a5300), DICO(0x43266000),
-    DICO(0x4a53a100), DICO(0x50acce80), DICO(0x57612100), DICO(0x5cdee380),
-    DICO(0x04039a88), DICO(0x0626dcb0), DICO(0x0c059620), DICO(0x12c3db20),
-    DICO(0x1bb9eb40), DICO(0x240fda00), DICO(0x2baab840), DICO(0x3177c5c0),
-    DICO(0x36cf2e40), DICO(0x3c025100), DICO(0x40bb8d00), DICO(0x45960800),
-    DICO(0x4adaca00), DICO(0x505a7300), DICO(0x566a6400), DICO(0x5c8ce000),
-    DICO(0x062891e8), DICO(0x09680810), DICO(0x0e9a11b0), DICO(0x1523e320),
-    DICO(0x1c57db00), DICO(0x21f22c80), DICO(0x28aeeb00), DICO(0x2e4fd600),
-    DICO(0x341cf000), DICO(0x3a5034c0), DICO(0x40600f80), DICO(0x461fde00),
-    DICO(0x4c368480), DICO(0x51dbbc00), DICO(0x57709780), DICO(0x5cce9880),
-    DICO(0x05d41f70), DICO(0x0a65bb30), DICO(0x132ddfa0), DICO(0x17d26820),
-    DICO(0x1e6d8380), DICO(0x24e68dc0), DICO(0x2b68c4c0), DICO(0x30fa2880),
-    DICO(0x361998c0), DICO(0x3aa1d640), DICO(0x3f942400), DICO(0x44d11680),
-    DICO(0x4ab8e580), DICO(0x50643b80), DICO(0x5697fe00), DICO(0x5cb3a780),
-    DICO(0x0707fa10), DICO(0x0cb8beb0), DICO(0x15011d20), DICO(0x1a4ad300),
-    DICO(0x20997080), DICO(0x26dbe240), DICO(0x2d907880), DICO(0x3307a3c0),
-    DICO(0x38819740), DICO(0x3d3e89c0), DICO(0x41ea2300), DICO(0x469ce200),
-    DICO(0x4be61680), DICO(0x51261b80), DICO(0x5716ef80), DICO(0x5cba2900),
-    DICO(0x084dc830), DICO(0x0f16f610), DICO(0x16ca2420), DICO(0x1bb58380),
-    DICO(0x22f00f00), DICO(0x296ba4c0), DICO(0x306d2600), DICO(0x362ca080),
-    DICO(0x3b86d280), DICO(0x3ffa96c0), DICO(0x446a5300), DICO(0x48d0fd00),
-    DICO(0x4d8a0800), DICO(0x525bf200), DICO(0x57f5aa00), DICO(0x5d569480),
-    DICO(0x08d664f0), DICO(0x110c8520), DICO(0x1865fa40), DICO(0x1efe3160),
-    DICO(0x26f38740), DICO(0x2d4608c0), DICO(0x32862500), DICO(0x374f8840),
-    DICO(0x3bfa9900), DICO(0x3ff5c8c0), DICO(0x4450c500), DICO(0x4918e680),
-    DICO(0x4e1d0f00), DICO(0x53342600), DICO(0x58a38e00), DICO(0x5dbbff00),
-    DICO(0x09143fd0), DICO(0x0f401c30), DICO(0x169c1ee0), DICO(0x1bcfb280),
-    DICO(0x2190dd00), DICO(0x27bf56c0), DICO(0x2e8e0640), DICO(0x34b67080),
-    DICO(0x3b534dc0), DICO(0x41134c00), DICO(0x467a3280), DICO(0x4bd63600),
-    DICO(0x50de8700), DICO(0x55657580), DICO(0x5a0cef00), DICO(0x5e8aa200),
-    DICO(0x06b5d860), DICO(0x0c8a5000), DICO(0x13343620), DICO(0x17a2abe0),
-    DICO(0x1caf7340), DICO(0x22a3f740), DICO(0x29059980), DICO(0x2ecff880),
-    DICO(0x34ce0f00), DICO(0x3ad32280), DICO(0x40f08d80), DICO(0x46d1d400),
-    DICO(0x4ca9df00), DICO(0x523b9580), DICO(0x57ea9b80), DICO(0x5d4a9a00),
-    DICO(0x03822fec), DICO(0x0522c670), DICO(0x099f89a0), DICO(0x12ddc9c0),
-    DICO(0x17c3d380), DICO(0x1d27ec20), DICO(0x2219e480), DICO(0x25fdf580),
-    DICO(0x329d6500), DICO(0x368ba040), DICO(0x3afedb00), DICO(0x430db980),
-    DICO(0x4a105380), DICO(0x51205080), DICO(0x5673b880), DICO(0x5ca2e500),
-    DICO(0x04e07408), DICO(0x06a13dc0), DICO(0x0b31c780), DICO(0x0e67fcd0),
-    DICO(0x13723240), DICO(0x1f87a840), DICO(0x2321ab00), DICO(0x2c604680),
-    DICO(0x310bc180), DICO(0x351eea40), DICO(0x3a2d6440), DICO(0x3e7ebac0),
-    DICO(0x4798ef80), DICO(0x50721100), DICO(0x57ff9880), DICO(0x5dc2e080),
-    DICO(0x05d626b8), DICO(0x07eaf140), DICO(0x0c5675b0), DICO(0x0eba7b00),
-    DICO(0x1a7f36c0), DICO(0x1f969200), DICO(0x244d8c00), DICO(0x29666440),
-    DICO(0x2c94b100), DICO(0x31865380), DICO(0x3713c000), DICO(0x3c228f40),
-    DICO(0x4296ed80), DICO(0x4dcbde00), DICO(0x56059a00), DICO(0x5c932d00),
-    DICO(0x07dceb20), DICO(0x0b533fe0), DICO(0x0eb18880), DICO(0x13124220),
-    DICO(0x167f74e0), DICO(0x1afbee40), DICO(0x229e2f80), DICO(0x26b05ec0),
-    DICO(0x2c7b4040), DICO(0x32806140), DICO(0x38da6540), DICO(0x3e495540),
-    DICO(0x444d3880), DICO(0x4e784400), DICO(0x5865f580), DICO(0x5e616180),
-    DICO(0x06395790), DICO(0x084b8f20), DICO(0x0d0e26a0), DICO(0x10897ac0),
-    DICO(0x14bcd080), DICO(0x1c5babe0), DICO(0x2108f9c0), DICO(0x274f8e80),
-    DICO(0x2b0ba180), DICO(0x305b8480), DICO(0x383ad300), DICO(0x3e34f440),
-    DICO(0x47f7aa00), DICO(0x4fdb5880), DICO(0x56b8c280), DICO(0x5d07d700),
-    DICO(0x051f0880), DICO(0x071b8fa8), DICO(0x0ce79c90), DICO(0x1005bd60),
-    DICO(0x14a4a080), DICO(0x183def40), DICO(0x1ee8d0a0), DICO(0x2c5b9bc0),
-    DICO(0x309f9dc0), DICO(0x35659380), DICO(0x3c0439c0), DICO(0x49603800),
-    DICO(0x5018a800), DICO(0x54862380), DICO(0x593edd80), DICO(0x5d415b80),
-    DICO(0x051c8108), DICO(0x06bd97d8), DICO(0x0b47d030), DICO(0x0d9c81a0),
-    DICO(0x178f0be0), DICO(0x1cdf7c80), DICO(0x2183db40), DICO(0x26ec7180),
-    DICO(0x2a3856c0), DICO(0x366c9b40), DICO(0x3d3611c0), DICO(0x42788100),
-    DICO(0x4981f200), DICO(0x4dd68380), DICO(0x55286a00), DICO(0x5cc72500),
-    DICO(0x06ee58c8), DICO(0x098b1310), DICO(0x0ccbd880), DICO(0x0f9d68f0),
-    DICO(0x1277ac40), DICO(0x1d71faa0), DICO(0x230d9480), DICO(0x276b8c00),
-    DICO(0x2ec77000), DICO(0x31f2a700), DICO(0x3bee0200), DICO(0x42250700),
-    DICO(0x466b7100), DICO(0x4de41980), DICO(0x56a08d80), DICO(0x5d700880),
-    DICO(0x062f1d80), DICO(0x091bcd30), DICO(0x0cd875e0), DICO(0x0fd42e60),
-    DICO(0x1322b980), DICO(0x1f11b480), DICO(0x2651e5c0), DICO(0x29f9b480),
-    DICO(0x2e238840), DICO(0x30fc58c0), DICO(0x37aa3040), DICO(0x3e9ac580),
-    DICO(0x44c6fd00), DICO(0x4eba4300), DICO(0x56fdad00), DICO(0x5d885700),
-    DICO(0x04213a78), DICO(0x05d028c0), DICO(0x09a1f9e0), DICO(0x0d28ae90),
-    DICO(0x151819a0), DICO(0x1c78c860), DICO(0x21d78f00), DICO(0x29992cc0),
-    DICO(0x2fbdc180), DICO(0x36bab700), DICO(0x3d4db1c0), DICO(0x4402a280),
-    DICO(0x4a920700), DICO(0x50988600), DICO(0x5717c100), DICO(0x5d52c200),
-    DICO(0x036af4bc), DICO(0x0514cf40), DICO(0x09ec2d30), DICO(0x113de160),
-    DICO(0x1991b700), DICO(0x20590bc0), DICO(0x23892a00), DICO(0x2654cd00),
-    DICO(0x2ff5c0c0), DICO(0x387ed380), DICO(0x3e305300), DICO(0x46137700),
-    DICO(0x4bc29100), DICO(0x4f96dd80), DICO(0x564aca00), DICO(0x5c4d9e80),
-    DICO(0x041051a0), DICO(0x0734dad8), DICO(0x1064e780), DICO(0x14d8bf00),
-    DICO(0x19727e40), DICO(0x1f7bede0), DICO(0x25b5ebc0), DICO(0x2c71fd40),
-    DICO(0x32813740), DICO(0x39340c80), DICO(0x3f974f40), DICO(0x45ca1580),
-    DICO(0x4be69f00), DICO(0x51c9c900), DICO(0x57a1ce80), DICO(0x5d0b2b00),
-    DICO(0x04b73008), DICO(0x06598b60), DICO(0x0b0aee00), DICO(0x15ac7ba0),
-    DICO(0x18b5e340), DICO(0x1f5308c0), DICO(0x23cfc4c0), DICO(0x27d3fdc0),
-    DICO(0x30138080), DICO(0x343c85c0), DICO(0x389cb540), DICO(0x42def900),
-    DICO(0x4aa6a000), DICO(0x4f719580), DICO(0x5585d080), DICO(0x5bc03f00),
-    DICO(0x05601b88), DICO(0x07616b88), DICO(0x0c22ba40), DICO(0x16bc8200),
-    DICO(0x192ebf80), DICO(0x1f71c120), DICO(0x25c59d00), DICO(0x28f76d00),
-    DICO(0x33dbdd80), DICO(0x39f40d80), DICO(0x3da0c880), DICO(0x432c1e00),
-    DICO(0x4aa19d80), DICO(0x51006f80), DICO(0x56a62e80), DICO(0x5c67d000),
-    DICO(0x053095d0), DICO(0x06c43fc8), DICO(0x0f80a460), DICO(0x139b4960),
-    DICO(0x1769ed80), DICO(0x1c828b00), DICO(0x21195980), DICO(0x26329800),
-    DICO(0x29f35900), DICO(0x2dc9df80), DICO(0x3795f0c0), DICO(0x43139b00),
-    DICO(0x4acae680), DICO(0x5048de00), DICO(0x57c11880), DICO(0x5db35900),
-    DICO(0x0466e180), DICO(0x05d31550), DICO(0x10cad200), DICO(0x168c2be0),
-    DICO(0x1a5e9580), DICO(0x1ef2d480), DICO(0x238db240), DICO(0x2920ce80),
-    DICO(0x2c80b4c0), DICO(0x30bb2700), DICO(0x38b257c0), DICO(0x46abd580),
-    DICO(0x4c30dd80), DICO(0x50e51880), DICO(0x5782ab80), DICO(0x5d23da80),
-    DICO(0x06700f78), DICO(0x085ec0a0), DICO(0x0c037280), DICO(0x16d90a60),
-    DICO(0x1bf46c00), DICO(0x1e6f4740), DICO(0x22c2c180), DICO(0x263fa2c0),
-    DICO(0x2c4a74c0), DICO(0x3642b040), DICO(0x3a476900), DICO(0x3ea12840),
-    DICO(0x46b6e880), DICO(0x4b5bad80), DICO(0x5152a500), DICO(0x5c1c6080),
-    DICO(0x041f8108), DICO(0x05ef1d98), DICO(0x0ce43300), DICO(0x11647cc0),
-    DICO(0x16e77fe0), DICO(0x1cdafc40), DICO(0x218832c0), DICO(0x26dd1b40),
-    DICO(0x2c776100), DICO(0x34f1eb80), DICO(0x3caf6100), DICO(0x45630a80),
-    DICO(0x4c0c5380), DICO(0x517ae980), DICO(0x567f4280), DICO(0x5c4bf900),
-    DICO(0x06673f18), DICO(0x091ee510), DICO(0x0d6ccb10), DICO(0x12503240),
-    DICO(0x158696e0), DICO(0x1f035420), DICO(0x24e6eac0), DICO(0x2a03bf40),
-    DICO(0x329aa000), DICO(0x375aafc0), DICO(0x3da133c0), DICO(0x45645600),
-    DICO(0x4c447c00), DICO(0x51a26b00), DICO(0x57917c00), DICO(0x5c557680),
-    DICO(0x04f84c18), DICO(0x06db4c30), DICO(0x0d53a940), DICO(0x1095cd20),
-    DICO(0x142b0b20), DICO(0x184229c0), DICO(0x20147280), DICO(0x25152740),
-    DICO(0x2db89fc0), DICO(0x35f3d200), DICO(0x400aa680), DICO(0x47a51c00),
-    DICO(0x4d9c5c00), DICO(0x525d1680), DICO(0x5832af00), DICO(0x5d27d580),
-    DICO(0x05c973d0), DICO(0x07c25810), DICO(0x0e928e50), DICO(0x12f5ad00),
-    DICO(0x16b2a800), DICO(0x1c2c9ce0), DICO(0x20b0f100), DICO(0x28be1940),
-    DICO(0x2d0f3c00), DICO(0x30a06f40), DICO(0x399e4340), DICO(0x46b48280),
-    DICO(0x4bbbc300), DICO(0x50283700), DICO(0x54a1a800), DICO(0x5ab20c80),
-    DICO(0x03df9390), DICO(0x055ff1e0), DICO(0x0bbeb640), DICO(0x17d906c0),
-    DICO(0x1ac20140), DICO(0x1fd84440), DICO(0x24502600), DICO(0x2a9fe640),
-    DICO(0x2ef79700), DICO(0x34cbed40), DICO(0x3c48cd00), DICO(0x43ccce80),
-    DICO(0x49b1d500), DICO(0x50145e00), DICO(0x56f16f80), DICO(0x5d46dd80),
-    DICO(0x04a69ef0), DICO(0x06470480), DICO(0x0defbd00), DICO(0x1590e900),
-    DICO(0x18114000), DICO(0x1bda6c60), DICO(0x1f64d160), DICO(0x28d8d640),
-    DICO(0x2d4e2880), DICO(0x34cfe380), DICO(0x3b7077c0), DICO(0x42f36a80),
-    DICO(0x49615580), DICO(0x4ff9d200), DICO(0x5657ef80), DICO(0x5cb91300),
-    DICO(0x038893dc), DICO(0x0535cdf0), DICO(0x0aabff80), DICO(0x146daaa0),
-    DICO(0x1848c700), DICO(0x1ce578c0), DICO(0x21116000), DICO(0x2b116d40),
-    DICO(0x32113500), DICO(0x3751a480), DICO(0x3e88c200), DICO(0x44cb1800),
-    DICO(0x4af1c200), DICO(0x5122b980), DICO(0x5782bc80), DICO(0x5d20be00),
-    DICO(0x03118434), DICO(0x04afe2e8), DICO(0x08f144f0), DICO(0x12c787c0),
-    DICO(0x1c32e4e0), DICO(0x1f701180), DICO(0x2362f740), DICO(0x2b995cc0),
-    DICO(0x3322c540), DICO(0x3951f200), DICO(0x3f7c2c80), DICO(0x4569c480),
-    DICO(0x4b2a6200), DICO(0x50905e80), DICO(0x56236680), DICO(0x5c32fa00),
-    DICO(0x0460c3b0), DICO(0x061e1378), DICO(0x0b07f610), DICO(0x166e0680),
-    DICO(0x18d0f020), DICO(0x21120340), DICO(0x24d4c000), DICO(0x29bafc00),
-    DICO(0x338c0740), DICO(0x36cfbc00), DICO(0x3f313900), DICO(0x47bf9c00),
-    DICO(0x4dd5d480), DICO(0x52848200), DICO(0x585add00), DICO(0x5cf7b480),
-    DICO(0x041a4bc8), DICO(0x05ca0920), DICO(0x0a3ae5b0), DICO(0x13fbb840),
-    DICO(0x1cdd3d00), DICO(0x209d5b80), DICO(0x27e78e80), DICO(0x2d1f4ec0),
-    DICO(0x32d84c80), DICO(0x3b8aa680), DICO(0x4289c180), DICO(0x46c33580),
-    DICO(0x4c23e580), DICO(0x51583180), DICO(0x56f52680), DICO(0x5c7a3d00),
-    DICO(0x03067404), DICO(0x05914038), DICO(0x10d33e60), DICO(0x17377180),
-    DICO(0x1d7f32a0), DICO(0x23848880), DICO(0x29d32200), DICO(0x2fb167c0),
-    DICO(0x356c8480), DICO(0x3b420280), DICO(0x4106d080), DICO(0x46d29280),
-    DICO(0x4c8a1200), DICO(0x52383300), DICO(0x57db8f80), DICO(0x5d61f200),
-    DICO(0x04baf368), DICO(0x06670a08), DICO(0x0e0cbd90), DICO(0x126299c0),
-    DICO(0x17ed7220), DICO(0x1e369900), DICO(0x22d7d300), DICO(0x2c0f9300),
-    DICO(0x2f5e7fc0), DICO(0x3b7c0d40), DICO(0x405aff80), DICO(0x44f2ef80),
-    DICO(0x4982b400), DICO(0x4e501380), DICO(0x539daa00), DICO(0x5c114b00),
-    DICO(0x0694c170), DICO(0x092d6890), DICO(0x0d0faee0), DICO(0x13800d00),
-    DICO(0x170f8d80), DICO(0x1bcd8240), DICO(0x246a8480), DICO(0x28bab640),
-    DICO(0x2f482ac0), DICO(0x36e736c0), DICO(0x3aaa68c0), DICO(0x3fc43500),
-    DICO(0x46e16000), DICO(0x4b3fbc00), DICO(0x4ff68e80), DICO(0x5aabf600),
-    DICO(0x05e849a0), DICO(0x0b485a80), DICO(0x14be52c0), DICO(0x1a079380),
-    DICO(0x1e8b1ce0), DICO(0x22fbca00), DICO(0x28c36a40), DICO(0x2e3b2a00),
-    DICO(0x34360b80), DICO(0x3a24cf00), DICO(0x3fff6200), DICO(0x45a6bf00),
-    DICO(0x4baf7800), DICO(0x51720e80), DICO(0x57560c80), DICO(0x5ce57e00),
-    DICO(0x0751da38), DICO(0x0f0949f0), DICO(0x18141860), DICO(0x1dfcb2c0),
-    DICO(0x24adbf00), DICO(0x296af240), DICO(0x2dbe60c0), DICO(0x3179ae40),
-    DICO(0x35ec4400), DICO(0x3ab76400), DICO(0x4034f400), DICO(0x45cfc700),
-    DICO(0x4bea6b00), DICO(0x516f5f00), DICO(0x57655300), DICO(0x5cfc0e00),
-    DICO(0x069900d0), DICO(0x0d379520), DICO(0x175d0560), DICO(0x1c4d92c0),
-    DICO(0x21407680), DICO(0x250d0340), DICO(0x29804940), DICO(0x2dfb9ac0),
-    DICO(0x337a1f80), DICO(0x39105fc0), DICO(0x3efd0380), DICO(0x44bce380),
-    DICO(0x4b07cc80), DICO(0x50ad7d00), DICO(0x56ddce80), DICO(0x5cb9a000),
-    DICO(0x069c6948), DICO(0x0a56ea10), DICO(0x0f7cca20), DICO(0x12d18680),
-    DICO(0x17036d00), DICO(0x1f4c1e80), DICO(0x262e5540), DICO(0x2b951e40),
-    DICO(0x3468ad40), DICO(0x3a2b2100), DICO(0x3f02f0c0), DICO(0x4383e400),
-    DICO(0x48374180), DICO(0x4d8eec80), DICO(0x54d74800), DICO(0x5c309600),
-    DICO(0x05a50158), DICO(0x0797e350), DICO(0x0cf1f230), DICO(0x14f3fb20),
-    DICO(0x17676400), DICO(0x20636780), DICO(0x2617ef80), DICO(0x29cbf700),
-    DICO(0x32ed57c0), DICO(0x374c3080), DICO(0x3b348e40), DICO(0x3fde0180),
-    DICO(0x44d38c00), DICO(0x4a8c6100), DICO(0x55f0e400), DICO(0x5dfed100),
-    DICO(0x04b74228), DICO(0x0623d3e0), DICO(0x0ab4c670), DICO(0x1bde7fa0),
-    DICO(0x1fcb6ac0), DICO(0x2344a540), DICO(0x275f7c40), DICO(0x2b7a8300),
-    DICO(0x31407440), DICO(0x35237700), DICO(0x38798540), DICO(0x3d0af340),
-    DICO(0x4224c980), DICO(0x49a17900), DICO(0x57702880), DICO(0x5dba4c00),
-    DICO(0x03c83c84), DICO(0x05cc52d8), DICO(0x0b644c10), DICO(0x129ab9a0),
-    DICO(0x1cee46c0), DICO(0x2152b080), DICO(0x247b1c00), DICO(0x27697180),
-    DICO(0x304f7500), DICO(0x3895d880), DICO(0x3c3a1740), DICO(0x413ace80),
-    DICO(0x462b0100), DICO(0x4ab07e00), DICO(0x50967580), DICO(0x5ba5e700),
-    DICO(0x06bcfda8), DICO(0x08c8b920), DICO(0x0de21530), DICO(0x1028d320),
-    DICO(0x168cfe00), DICO(0x20f78a40), DICO(0x248493c0), DICO(0x2c34bf80),
-    DICO(0x2ff88540), DICO(0x32d28c40), DICO(0x36d99640), DICO(0x4438e500),
-    DICO(0x4bacdb00), DICO(0x50343700), DICO(0x56b79080), DICO(0x5b694d00),
-    DICO(0x069109a0), DICO(0x0a73bc50), DICO(0x0e3c8330), DICO(0x13082620),
-    DICO(0x1c3a3760), DICO(0x200b5e80), DICO(0x256a4880), DICO(0x2b256ac0),
-    DICO(0x2f34afc0), DICO(0x35580200), DICO(0x3e0bd9c0), DICO(0x43d92900),
-    DICO(0x494e6e00), DICO(0x4f1a2780), DICO(0x5532a980), DICO(0x5a835a80),
-    DICO(0x04053450), DICO(0x05cb8fe0), DICO(0x097387b0), DICO(0x1121af00),
-    DICO(0x1abf62c0), DICO(0x1e39bbe0), DICO(0x243de300), DICO(0x2b440ec0),
-    DICO(0x2f2c1480), DICO(0x34697d80), DICO(0x405f8600), DICO(0x440b6f80),
-    DICO(0x47373100), DICO(0x4c764f80), DICO(0x55293780), DICO(0x5c59a780),
-    DICO(0x03c5b4a4), DICO(0x056fb380), DICO(0x09b8f910), DICO(0x13833fa0),
-    DICO(0x185eed60), DICO(0x1ce33d40), DICO(0x242e4100), DICO(0x282e5b80),
-    DICO(0x2cfe4d40), DICO(0x38a06d80), DICO(0x3e002240), DICO(0x423be400),
-    DICO(0x49a5e600), DICO(0x5092b780), DICO(0x57023d00), DICO(0x5d5f7c80),
-    DICO(0x077ada38), DICO(0x09d5ac70), DICO(0x0e58be30), DICO(0x14fb2040),
-    DICO(0x17fc9dc0), DICO(0x1c2c31e0), DICO(0x26cf1b00), DICO(0x2a91ba80),
-    DICO(0x2ed880c0), DICO(0x38cbf900), DICO(0x3d2fc700), DICO(0x405d2280),
-    DICO(0x439c1d00), DICO(0x4dd16800), DICO(0x5672c080), DICO(0x5d313880),
-    DICO(0x04272090), DICO(0x05d76e18), DICO(0x0b4d8080), DICO(0x12883f60),
-    DICO(0x17952180), DICO(0x2040d480), DICO(0x23e8cc00), DICO(0x2819c200),
-    DICO(0x2b871040), DICO(0x357c8f00), DICO(0x3caf9ac0), DICO(0x40a39380),
-    DICO(0x45bc2780), DICO(0x4e4aa300), DICO(0x568c2280), DICO(0x5cadc400),
-    DICO(0x0375b03c), DICO(0x056f0b40), DICO(0x0b0dc930), DICO(0x128c51e0),
-    DICO(0x189fa360), DICO(0x1c8197e0), DICO(0x1eed52a0), DICO(0x23ed4500),
-    DICO(0x2e5eb840), DICO(0x36415a40), DICO(0x3dcf6340), DICO(0x43126e80),
-    DICO(0x4aeb7f80), DICO(0x501e1280), DICO(0x5852b100), DICO(0x5d040d80),
-    DICO(0x06351b88), DICO(0x07f90ac0), DICO(0x0bab4ea0), DICO(0x18d04b40),
-    DICO(0x1f1e1480), DICO(0x219abcc0), DICO(0x261c31c0), DICO(0x2a611a00),
-    DICO(0x2e725480), DICO(0x36b511c0), DICO(0x3d362f00), DICO(0x40be6d80),
-    DICO(0x456dc400), DICO(0x4b74c580), DICO(0x55c82680), DICO(0x5e318480),
-    DICO(0x046212d8), DICO(0x05ca95e8), DICO(0x0a02d910), DICO(0x1ae58f40),
-    DICO(0x1e73ec20), DICO(0x2197d640), DICO(0x2581df00), DICO(0x29c83780),
-    DICO(0x31294300), DICO(0x356f8a40), DICO(0x3b97d240), DICO(0x4505cc80),
-    DICO(0x4b497600), DICO(0x504e8780), DICO(0x55644480), DICO(0x5bdedf80),
-    DICO(0x0514f798), DICO(0x06bd0d00), DICO(0x0fc31550), DICO(0x13dfb1a0),
-    DICO(0x17dda900), DICO(0x204a8c40), DICO(0x23095300), DICO(0x2d0da040),
-    DICO(0x31b2a540), DICO(0x34620180), DICO(0x3ab3e000), DICO(0x448ac300),
-    DICO(0x4be6a600), DICO(0x5114e280), DICO(0x562b0780), DICO(0x5b833c00),
-    DICO(0x070f5ef0), DICO(0x0919c2b0), DICO(0x0e778740), DICO(0x154db320),
-    DICO(0x177cfbe0), DICO(0x1ea66040), DICO(0x23666680), DICO(0x2839c400),
-    DICO(0x30cc4ec0), DICO(0x3444a280), DICO(0x38c93580), DICO(0x42a80e00),
-    DICO(0x4c433880), DICO(0x519e4f80), DICO(0x56ff8f80), DICO(0x5be18200),
-    DICO(0x066c5968), DICO(0x08a589f0), DICO(0x0ca4d7a0), DICO(0x0ffdefb0),
-    DICO(0x12943f40), DICO(0x1be84ee0), DICO(0x21276540), DICO(0x265a9540),
-    DICO(0x2e0de140), DICO(0x325148c0), DICO(0x3bd05d40), DICO(0x41e81780),
-    DICO(0x4b7cf400), DICO(0x53289400), DICO(0x597d9000), DICO(0x5e458e00),
-    DICO(0x04da3e40), DICO(0x06e8e1b0), DICO(0x0b9b1a20), DICO(0x11264bc0),
-    DICO(0x14f3d7e0), DICO(0x1cf9c100), DICO(0x23568f40), DICO(0x292b5380),
-    DICO(0x33878d40), DICO(0x38dac840), DICO(0x3d578200), DICO(0x4223a880),
-    DICO(0x473fb700), DICO(0x4c765500), DICO(0x546c6480), DICO(0x5c76d280),
-    DICO(0x05e63bb0), DICO(0x07a1a428), DICO(0x0ec4ff10), DICO(0x1348a100),
-    DICO(0x16204f40), DICO(0x1a0a6440), DICO(0x1e33f6c0), DICO(0x2ae8ccc0),
-    DICO(0x2ed5e6c0), DICO(0x32427600), DICO(0x379d9980), DICO(0x3c0f4080),
-    DICO(0x441ea680), DICO(0x4e592b00), DICO(0x56e27700), DICO(0x5da2e280),
-    DICO(0x0474de80), DICO(0x06167248), DICO(0x0ce650e0), DICO(0x135b4aa0),
-    DICO(0x16cea2a0), DICO(0x1d138ac0), DICO(0x220a84c0), DICO(0x275ca380),
-    DICO(0x2c300340), DICO(0x333b3d80), DICO(0x37a35080), DICO(0x40b83880),
-    DICO(0x494c4780), DICO(0x4ff71c80), DICO(0x56db2d80), DICO(0x5d0aac00),
-    DICO(0x0746cd00), DICO(0x09deff10), DICO(0x0e4a3560), DICO(0x14f005e0),
-    DICO(0x186a4de0), DICO(0x1cd0b240), DICO(0x22287bc0), DICO(0x26ced500),
-    DICO(0x2d57c440), DICO(0x31d943c0), DICO(0x364b0f80), DICO(0x3c85a040),
-    DICO(0x4240ca00), DICO(0x4a648080), DICO(0x54d12200), DICO(0x5d1a1c00),
-    DICO(0x05522eb0), DICO(0x0704efb8), DICO(0x0c66cd50), DICO(0x15aefca0),
-    DICO(0x184f7b00), DICO(0x1e4b26a0), DICO(0x22667640), DICO(0x284e4e00),
-    DICO(0x2d8be3c0), DICO(0x31376f00), DICO(0x39cd9800), DICO(0x3e46b740),
-    DICO(0x43af0380), DICO(0x4e1dec00), DICO(0x562ac500), DICO(0x5d45f580),
-    DICO(0x062f5708), DICO(0x08d079a0), DICO(0x0c1b4920), DICO(0x13f147c0),
-    DICO(0x1ae77c80), DICO(0x1d200ea0), DICO(0x236e4740), DICO(0x2b98d000),
-    DICO(0x2eefc600), DICO(0x34c674c0), DICO(0x3d36f540), DICO(0x411d8c00),
-    DICO(0x45c50300), DICO(0x4d207480), DICO(0x55603100), DICO(0x5c442d80),
-    DICO(0x0510bcd0), DICO(0x06ec00a0), DICO(0x0b639550), DICO(0x15daa2c0),
-    DICO(0x18c0ba60), DICO(0x1e0f7d60), DICO(0x24b05c80), DICO(0x280638c0),
-    DICO(0x314a6580), DICO(0x35e4b2c0), DICO(0x3aef2bc0), DICO(0x4158c280),
-    DICO(0x4d245100), DICO(0x53c69a80), DICO(0x597f1000), DICO(0x5dcb0080),
-    DICO(0x042cb748), DICO(0x05d710b0), DICO(0x0afe6130), DICO(0x1256cdc0),
-    DICO(0x15b8cd00), DICO(0x1dc72d20), DICO(0x2205fc00), DICO(0x2a3d0d00),
-    DICO(0x2f3ba600), DICO(0x33b3d840), DICO(0x3b5a5440), DICO(0x416c9d00),
-    DICO(0x497cdd80), DICO(0x50405e00), DICO(0x570ca980), DICO(0x5d3aa180),
-    DICO(0x0443b7b8), DICO(0x063d8588), DICO(0x0c76ef20), DICO(0x12709b40),
-    DICO(0x1649f0a0), DICO(0x20c522c0), DICO(0x24cde400), DICO(0x2ba78280),
-    DICO(0x3104c340), DICO(0x360b1740), DICO(0x3cd6a6c0), DICO(0x42573800),
-    DICO(0x48b18480), DICO(0x4fca1e00), DICO(0x5700c100), DICO(0x5cf14480),
-    DICO(0x05123628), DICO(0x06bf10b0), DICO(0x0bde7570), DICO(0x175b7ee0),
-    DICO(0x1a134460), DICO(0x20fa4100), DICO(0x25eda440), DICO(0x29c3b540),
-    DICO(0x318a1b40), DICO(0x35e0d500), DICO(0x3a147f00), DICO(0x3f08e980),
-    DICO(0x445d7580), DICO(0x4ec48c80), DICO(0x588bce80), DICO(0x5dfae300),
-    DICO(0x04c9e750), DICO(0x065224f8), DICO(0x0c6f1e30), DICO(0x1a2ffca0),
-    DICO(0x1cac6140), DICO(0x21c2a640), DICO(0x25fb8ac0), DICO(0x2ab90f00),
-    DICO(0x33189200), DICO(0x38088ac0), DICO(0x3bb7de40), DICO(0x40180800),
-    DICO(0x4453c300), DICO(0x4cdba880), DICO(0x54902680), DICO(0x5bb21700),
-    DICO(0x06958570), DICO(0x097f32b0), DICO(0x0cb418b0), DICO(0x141b6900),
-    DICO(0x1c8cfb00), DICO(0x1fab7920), DICO(0x2477c800), DICO(0x2aabed40),
-    DICO(0x2eb1a080), DICO(0x339f67c0), DICO(0x3abcc240), DICO(0x3f661b00),
-    DICO(0x45663280), DICO(0x4c680800), DICO(0x51703000), DICO(0x58a0e000),
-    DICO(0x069f6c88), DICO(0x095e1490), DICO(0x0cf442b0), DICO(0x10ea8d60),
-    DICO(0x1377b580), DICO(0x195ed480), DICO(0x26542b00), DICO(0x2c9ea700),
-    DICO(0x318d8ac0), DICO(0x364e5a40), DICO(0x3a0db000), DICO(0x3e1087c0),
-    DICO(0x450ca380), DICO(0x4c781d00), DICO(0x53cf7a00), DICO(0x5c7d1280),
-    DICO(0x06e51d98), DICO(0x09eb8d30), DICO(0x0e6683d0), DICO(0x129418a0),
-    DICO(0x1562fc80), DICO(0x1f708660), DICO(0x253f1000), DICO(0x293a16c0),
-    DICO(0x2e7c1d80), DICO(0x316e75c0), DICO(0x35a7fbc0), DICO(0x3bfbf780),
-    DICO(0x416a9200), DICO(0x4be36400), DICO(0x56dc7a80), DICO(0x5d64ea80),
-    DICO(0x0574d0c8), DICO(0x0748efd0), DICO(0x0b510860), DICO(0x0e219e00),
-    DICO(0x1299cc00), DICO(0x1ef706a0), DICO(0x22ca38c0), DICO(0x28820a00),
-    DICO(0x2cc635c0), DICO(0x31ef4740), DICO(0x3a5e89c0), DICO(0x42acaa00),
-    DICO(0x4b2bf500), DICO(0x515e0980), DICO(0x57949400), DICO(0x5d002500),
-    DICO(0x07c715d0), DICO(0x0b3fa110), DICO(0x0e745370), DICO(0x11e93560),
-    DICO(0x14bad680), DICO(0x189a0400), DICO(0x240b1240), DICO(0x2a6b3580),
-    DICO(0x2e5e1380), DICO(0x352072c0), DICO(0x3a5037c0), DICO(0x3e3726c0),
-    DICO(0x4725ed80), DICO(0x4f885900), DICO(0x54c8d580), DICO(0x5b261680),
-    DICO(0x075f02a8), DICO(0x0a214900), DICO(0x0e189de0), DICO(0x1376d5a0),
-    DICO(0x163d5c80), DICO(0x1a94b3e0), DICO(0x21376980), DICO(0x259c3140),
-    DICO(0x2e663bc0), DICO(0x337884c0), DICO(0x3a035c00), DICO(0x40b32c00),
-    DICO(0x4b21de00), DICO(0x53298f00), DICO(0x58788080), DICO(0x5cfa7c00),
-    DICO(0x05658988), DICO(0x0797f470), DICO(0x0d250810), DICO(0x102fc2a0),
-    DICO(0x13738fe0), DICO(0x1740bbc0), DICO(0x2491b380), DICO(0x28bc5800),
-    DICO(0x2c75a940), DICO(0x325cb500), DICO(0x37944740), DICO(0x405f2d80),
-    DICO(0x48eb8f00), DICO(0x50676f80), DICO(0x56f70380), DICO(0x5d62c000),
-    DICO(0x0531b540), DICO(0x06ae64c0), DICO(0x0cf7ad30), DICO(0x11c83000),
-    DICO(0x14edc980), DICO(0x18d436c0), DICO(0x1e184080), DICO(0x2603bb80),
-    DICO(0x2a2f2f80), DICO(0x33bdbe00), DICO(0x3a1066c0), DICO(0x42b9ff00),
-    DICO(0x4a617580), DICO(0x51619480), DICO(0x57ccd500), DICO(0x5d4d1600),
-    DICO(0x03e40bac), DICO(0x05f53158), DICO(0x0e76d3b0), DICO(0x17c157a0),
-    DICO(0x1ccb5bc0), DICO(0x250129c0), DICO(0x2b7d9d00), DICO(0x33224d80),
-    DICO(0x3966f600), DICO(0x3f399480), DICO(0x4449fc80), DICO(0x49401b80),
-    DICO(0x4e2ab580), DICO(0x53117000), DICO(0x5848e080), DICO(0x5d66a280),
-    DICO(0x041d4f60), DICO(0x070e8080), DICO(0x1390ec40), DICO(0x177c42c0),
-    DICO(0x1beb1400), DICO(0x208b0580), DICO(0x264cbb40), DICO(0x2bd30940),
-    DICO(0x30b30880), DICO(0x36978e80), DICO(0x3cb2a140), DICO(0x43f6b080),
-    DICO(0x4a881000), DICO(0x505ca780), DICO(0x569a5d80), DICO(0x5cae3580),
-    DICO(0x03f3c760), DICO(0x05564e08), DICO(0x09e310d0), DICO(0x1b9b3d00),
-    DICO(0x20909ac0), DICO(0x2382eec0), DICO(0x278c6700), DICO(0x2b34d500),
-    DICO(0x30fa2ac0), DICO(0x34d27d40), DICO(0x38e334c0), DICO(0x3d732440),
-    DICO(0x46d07800), DICO(0x51f4d400), DICO(0x57744f80), DICO(0x5d56bb80),
-    DICO(0x03abfdd8), DICO(0x0512b140), DICO(0x135f7500), DICO(0x19fcc4c0),
-    DICO(0x1d0b1b80), DICO(0x21eca540), DICO(0x258f8700), DICO(0x29e292c0),
-    DICO(0x2c51fe80), DICO(0x31e2a180), DICO(0x3c638640), DICO(0x44873a00),
-    DICO(0x4bb7e800), DICO(0x5078f700), DICO(0x57fc9b80), DICO(0x5def1c00),
-    DICO(0x04721ef0), DICO(0x06688158), DICO(0x0f65a5d0), DICO(0x14499840),
-    DICO(0x1bf5b8c0), DICO(0x1f33b700), DICO(0x264b6900), DICO(0x2c3e6780),
-    DICO(0x2ec8d440), DICO(0x323885c0), DICO(0x37143300), DICO(0x3bafa800),
-    DICO(0x49030480), DICO(0x54c16b00), DICO(0x58ec4b00), DICO(0x5d713d00),
-    DICO(0x03d114e4), DICO(0x067e5b40), DICO(0x10393420), DICO(0x14961300),
-    DICO(0x1a59cfa0), DICO(0x20854240), DICO(0x26b3f300), DICO(0x2e3e2840),
-    DICO(0x323bd300), DICO(0x37c49280), DICO(0x3d79e500), DICO(0x4352d880),
-    DICO(0x49e17980), DICO(0x4fc72f80), DICO(0x55c0c680), DICO(0x5c53c700),
-    DICO(0x053f5de8), DICO(0x075162b8), DICO(0x0fae8050), DICO(0x13ec0ee0),
-    DICO(0x17f92440), DICO(0x1f054440), DICO(0x24b15d40), DICO(0x2add4480),
-    DICO(0x2e306300), DICO(0x35420680), DICO(0x3c6b6e00), DICO(0x42fc0380),
-    DICO(0x4732e380), DICO(0x4ceb2200), DICO(0x522efe00), DICO(0x5aa12680),
-    DICO(0x06111728), DICO(0x08183c80), DICO(0x0d026650), DICO(0x14b41940),
-    DICO(0x17e37320), DICO(0x1c40b160), DICO(0x219c5400), DICO(0x26d88840),
-    DICO(0x2bfdfe00), DICO(0x315a2800), DICO(0x38cd7140), DICO(0x3de22740),
-    DICO(0x48ff1300), DICO(0x53ef4180), DICO(0x5a479380), DICO(0x5ea1e380),
-    DICO(0x07ea0fa8), DICO(0x0a844ef0), DICO(0x0e1023c0), DICO(0x1208d980),
-    DICO(0x15891360), DICO(0x1bebc380), DICO(0x2087da40), DICO(0x257ac940),
-    DICO(0x2caefa00), DICO(0x300defc0), DICO(0x376aa000), DICO(0x438aad80),
-    DICO(0x49f00500), DICO(0x4e023780), DICO(0x524e5800), DICO(0x5abcb980),
-    DICO(0x079cfc88), DICO(0x0a367240), DICO(0x0f224330), DICO(0x15b51540),
-    DICO(0x19065420), DICO(0x1ddbe0a0), DICO(0x23a99d80), DICO(0x28c2d340),
-    DICO(0x2f627e40), DICO(0x3487e080), DICO(0x38b76bc0), DICO(0x3d135580),
-    DICO(0x43799a80), DICO(0x489a5000), DICO(0x4ece6280), DICO(0x5a82f500),
-    DICO(0x06c37e40), DICO(0x093f0540), DICO(0x0e0d0c30), DICO(0x17487860),
-    DICO(0x1bf78020), DICO(0x20318000), DICO(0x260b8300), DICO(0x2c615980),
-    DICO(0x30c88440), DICO(0x36433b40), DICO(0x3bdb8c40), DICO(0x40050c80),
-    DICO(0x44062f80), DICO(0x48a8d480), DICO(0x4dd64d00), DICO(0x55abd380),
-    DICO(0x05e9e828), DICO(0x07f24330), DICO(0x0c8b4fe0), DICO(0x0ecd2820),
-    DICO(0x17f05c00), DICO(0x1fdb4560), DICO(0x24b4c940), DICO(0x2968d0c0),
-    DICO(0x2cbf3500), DICO(0x381eadc0), DICO(0x3d3baf40), DICO(0x42828080),
-    DICO(0x47f36300), DICO(0x4c8c6600), DICO(0x51d66f00), DICO(0x5a7e0300),
-    DICO(0x065c5cf8), DICO(0x08882540), DICO(0x0d887c70), DICO(0x112ac560),
-    DICO(0x150ccdc0), DICO(0x19e49c20), DICO(0x1eb65680), DICO(0x2a76e040),
-    DICO(0x2f65fc00), DICO(0x36d79cc0), DICO(0x3c85a900), DICO(0x408dc680),
-    DICO(0x44964700), DICO(0x4a98eb00), DICO(0x5528b500), DICO(0x5d660f80),
-    DICO(0x06b56230), DICO(0x08e340f0), DICO(0x0e1e4380), DICO(0x112d2d40),
-    DICO(0x158dfde0), DICO(0x227e6040), DICO(0x26bff7c0), DICO(0x2b73a100),
-    DICO(0x32199580), DICO(0x3585a240), DICO(0x398a5d40), DICO(0x3db8c6c0),
-    DICO(0x43905600), DICO(0x4945f800), DICO(0x4f310380), DICO(0x5a6d2400),
-    DICO(0x05cfc6f8), DICO(0x0832e650), DICO(0x0de82f80), DICO(0x1a1afe80),
-    DICO(0x1e9a1f80), DICO(0x221acd80), DICO(0x27fa00c0), DICO(0x2c4df980),
-    DICO(0x31e04bc0), DICO(0x38c9ed40), DICO(0x3db86080), DICO(0x428ec800),
-    DICO(0x48500500), DICO(0x4e1ca580), DICO(0x53d3f500), DICO(0x5aa6be00),
-    DICO(0x050cc4d0), DICO(0x070c2180), DICO(0x0c4ca980), DICO(0x0fce9f40),
-    DICO(0x14af4160), DICO(0x2206a780), DICO(0x25848e80), DICO(0x2c2b84c0),
-    DICO(0x35a39980), DICO(0x3914bd80), DICO(0x3caff580), DICO(0x3fcb0600),
-    DICO(0x4426b380), DICO(0x486c9700), DICO(0x4f730480), DICO(0x5afd3980),
-    DICO(0x05e40640), DICO(0x0830df50), DICO(0x0b9e83e0), DICO(0x158bacc0),
-    DICO(0x1d0692e0), DICO(0x2021e0c0), DICO(0x26572e00), DICO(0x2d58cc40),
-    DICO(0x30dd0f80), DICO(0x361d68c0), DICO(0x3e3086c0), DICO(0x42450800),
-    DICO(0x46c25800), DICO(0x4c45cf00), DICO(0x51dd4200), DICO(0x57326500),
-    DICO(0x04d32fa0), DICO(0x064ed2c0), DICO(0x0b07cd70), DICO(0x1c7f6da0),
-    DICO(0x213bc140), DICO(0x25051fc0), DICO(0x295cd1c0), DICO(0x2c9f4f80),
-    DICO(0x32271540), DICO(0x36a8ec80), DICO(0x3a8e6b40), DICO(0x3e137580),
-    DICO(0x42795480), DICO(0x4779b780), DICO(0x4f7d9600), DICO(0x5c09b000),
-    DICO(0x044b0748), DICO(0x05fee680), DICO(0x08f66960), DICO(0x11db5940),
-    DICO(0x219ede80), DICO(0x27fb96c0), DICO(0x2affc980), DICO(0x2eadc3c0),
-    DICO(0x32895700), DICO(0x37180d00), DICO(0x3d4bf880), DICO(0x41741980),
-    DICO(0x460d8280), DICO(0x4c34be80), DICO(0x54531e80), DICO(0x5c874000),
-    DICO(0x03e25dcc), DICO(0x069e8170), DICO(0x13b3d9c0), DICO(0x1a803260),
-    DICO(0x1ed3a4a0), DICO(0x23ea6380), DICO(0x2883b900), DICO(0x2e0ceac0),
-    DICO(0x3308e400), DICO(0x38796dc0), DICO(0x3e318e80), DICO(0x441da080),
-    DICO(0x4a892300), DICO(0x509b9f80), DICO(0x56caa380), DICO(0x5cc39e00),
-    DICO(0x05023038), DICO(0x06b6b4d8), DICO(0x0a449370), DICO(0x15b86ea0),
-    DICO(0x224a9200), DICO(0x272e6f40), DICO(0x2a617700), DICO(0x2e915d00),
-    DICO(0x3240ac40), DICO(0x37636300), DICO(0x3dd3ea80), DICO(0x420e1f80),
-    DICO(0x45bf0680), DICO(0x4a26d980), DICO(0x4f82a900), DICO(0x56576800),
-    DICO(0x03d630f4), DICO(0x082140a0), DICO(0x12644700), DICO(0x16b80cc0),
-    DICO(0x1ba90c40), DICO(0x21c38300), DICO(0x27dd1480), DICO(0x2e18ee00),
-    DICO(0x33fb72c0), DICO(0x39f9d980), DICO(0x40219300), DICO(0x4607fd00),
-    DICO(0x4c07e500), DICO(0x51ba8f00), DICO(0x57a24280), DICO(0x5d367700),
-    DICO(0x080a5880), DICO(0x0ef3f570), DICO(0x141fd6c0), DICO(0x17c163a0),
-    DICO(0x1c2840a0), DICO(0x2111fe00), DICO(0x27376bc0), DICO(0x2cc7edc0),
-    DICO(0x329b0100), DICO(0x386d3e40), DICO(0x3ec1bdc0), DICO(0x453f6200),
-    DICO(0x4bf16080), DICO(0x51bded00), DICO(0x57ba6800), DICO(0x5d2ffd80),
-    DICO(0x08643590), DICO(0x0e911f00), DICO(0x15911380), DICO(0x1ab5e180),
-    DICO(0x207ff600), DICO(0x26399b00), DICO(0x2cadae80), DICO(0x3276ca40),
-    DICO(0x389d9cc0), DICO(0x3eb22180), DICO(0x44570700), DICO(0x49d15800),
-    DICO(0x4f591300), DICO(0x54566a80), DICO(0x5967db00), DICO(0x5e307780),
-    DICO(0x07120fa8), DICO(0x0c791c60), DICO(0x112d3b60), DICO(0x149452a0),
-    DICO(0x19d2c100), DICO(0x202f1540), DICO(0x269c10c0), DICO(0x2be22880),
-    DICO(0x312a07c0), DICO(0x36984fc0), DICO(0x3c7ac3c0), DICO(0x435b5000),
-    DICO(0x4aa60280), DICO(0x50f50c00), DICO(0x5719f700), DICO(0x5cb98680),
-    DICO(0x05517c88), DICO(0x06ba0a70), DICO(0x0da167c0), DICO(0x19918440),
-    DICO(0x1bb37220), DICO(0x20681080), DICO(0x23dc6740), DICO(0x2a1403c0),
-    DICO(0x31a71580), DICO(0x34ff0600), DICO(0x395b7cc0), DICO(0x42019200),
-    DICO(0x4c818d00), DICO(0x513ff400), DICO(0x5731ce00), DICO(0x5c5f1180),
-    DICO(0x04f74ec0), DICO(0x067b4628), DICO(0x0dc4c9c0), DICO(0x19e9fa40),
-    DICO(0x1cf00a00), DICO(0x21602a80), DICO(0x25334a80), DICO(0x29b3a800),
-    DICO(0x2f9b3600), DICO(0x338c0540), DICO(0x370c3cc0), DICO(0x3abbc3c0),
-    DICO(0x4053a000), DICO(0x4f14d980), DICO(0x57e0b600), DICO(0x5d95e780),
-    DICO(0x05d844b8), DICO(0x07a05608), DICO(0x0b7837f0), DICO(0x161fb460),
-    DICO(0x19c31d00), DICO(0x1cf36280), DICO(0x20ccc200), DICO(0x24ae3980),
-    DICO(0x2e2b5800), DICO(0x3316af80), DICO(0x37432b00), DICO(0x4050b280),
-    DICO(0x4605be00), DICO(0x4cc78900), DICO(0x556d2080), DICO(0x5c578300),
-    DICO(0x0551b768), DICO(0x07024f60), DICO(0x1045fde0), DICO(0x16480120),
-    DICO(0x19974420), DICO(0x1ec2b280), DICO(0x228b30c0), DICO(0x295e0ec0),
-    DICO(0x2d8775c0), DICO(0x30ef1440), DICO(0x35978080), DICO(0x3a2ab480),
-    DICO(0x40229780), DICO(0x4da40980), DICO(0x5718e480), DICO(0x5d68d400),
-    DICO(0x03f903e4), DICO(0x06731580), DICO(0x0ecf4850), DICO(0x12e57920),
-    DICO(0x1a69ece0), DICO(0x1fe32700), DICO(0x2585b9c0), DICO(0x2aa006c0),
-    DICO(0x2f20ea80), DICO(0x37298bc0), DICO(0x3df2a000), DICO(0x44a6c600),
-    DICO(0x4b10de00), DICO(0x510fb880), DICO(0x5749c280), DICO(0x5d0b9480),
-    DICO(0x03c418fc), DICO(0x056c4cd0), DICO(0x0d0cf070), DICO(0x1907a2c0),
-    DICO(0x1be9bc00), DICO(0x21599480), DICO(0x25700e40), DICO(0x2c83e280),
-    DICO(0x329fa7c0), DICO(0x389f4cc0), DICO(0x3ef60900), DICO(0x44c19300),
-    DICO(0x4af56d00), DICO(0x512eec80), DICO(0x5772ad00), DICO(0x5d37f380),
-    DICO(0x04d57920), DICO(0x0716b5e0), DICO(0x0cb3bcc0), DICO(0x1197f740),
-    DICO(0x163e5fc0), DICO(0x2194e400), DICO(0x274bb600), DICO(0x2f5d7080),
-    DICO(0x361ee340), DICO(0x3b3b22c0), DICO(0x3f800400), DICO(0x4327ef80),
-    DICO(0x48b5d200), DICO(0x5116d300), DICO(0x59652e80), DICO(0x5e444d00),
-    DICO(0x0755b6b0), DICO(0x0b68c2c0), DICO(0x0f3441d0), DICO(0x124a01a0),
-    DICO(0x18910600), DICO(0x20911b80), DICO(0x281f7100), DICO(0x2e4dd640),
-    DICO(0x335bd8c0), DICO(0x37f14a80), DICO(0x3cab7b80), DICO(0x43be3180),
-    DICO(0x4beee100), DICO(0x52292180), DICO(0x57efea00), DICO(0x5d177300),
-    DICO(0x071a7748), DICO(0x0c6cf1b0), DICO(0x10db1500), DICO(0x143bca00),
-    DICO(0x1b86a900), DICO(0x22ed1d80), DICO(0x2a1f61c0), DICO(0x305f1400),
-    DICO(0x3645f580), DICO(0x3be45b00), DICO(0x4166ea80), DICO(0x46c3f200),
-    DICO(0x4c740400), DICO(0x51e30d00), DICO(0x57a37000), DICO(0x5cfc4980),
-    DICO(0x08cdd5b0), DICO(0x0daf9840), DICO(0x11cc02a0), DICO(0x1588ed40),
-    DICO(0x1cfef5e0), DICO(0x239f12c0), DICO(0x296d3b40), DICO(0x2e61c240),
-    DICO(0x333dc800), DICO(0x385d0000), DICO(0x3e1e5180), DICO(0x44196e00),
-    DICO(0x4a833000), DICO(0x503d7b80), DICO(0x56556680), DICO(0x5c410c00),
-    DICO(0x07372408), DICO(0x0d5c41f0), DICO(0x155dc140), DICO(0x1a9a3cc0),
-    DICO(0x21740980), DICO(0x27139f40), DICO(0x2c977040), DICO(0x30cfe5c0),
-    DICO(0x35381240), DICO(0x39b83140), DICO(0x3ef3fe80), DICO(0x44547200),
-    DICO(0x4a812800), DICO(0x5046c200), DICO(0x56957d00), DICO(0x5c85cd80),
-    DICO(0x06da6990), DICO(0x0bc41250), DICO(0x13d54800), DICO(0x1979c220),
-    DICO(0x1fad2f00), DICO(0x24bbe0c0), DICO(0x29c08f00), DICO(0x2e34b940),
-    DICO(0x32c89e40), DICO(0x376a2040), DICO(0x3cd81080), DICO(0x4267bd00),
-    DICO(0x48e8e800), DICO(0x4f150280), DICO(0x55cb1980), DICO(0x5c428b80),
-    DICO(0x087d45d0), DICO(0x0cf1ef20), DICO(0x135cba20), DICO(0x16fc7420),
-    DICO(0x1b2772e0), DICO(0x1fd4fe60), DICO(0x260a0b80), DICO(0x2bc54c00),
-    DICO(0x31694cc0), DICO(0x36d08080), DICO(0x3c245c80), DICO(0x41170900),
-    DICO(0x47b18600), DICO(0x4e706180), DICO(0x558d2000), DICO(0x5c428d00),
-    DICO(0x081e6490), DICO(0x0d16a7d0), DICO(0x124ccd20), DICO(0x154c20c0),
-    DICO(0x1945d8c0), DICO(0x1ee0b700), DICO(0x26a01f00), DICO(0x2d554e40),
-    DICO(0x3432eb80), DICO(0x3a605500), DICO(0x401d8980), DICO(0x45737680),
-    DICO(0x4b03cb00), DICO(0x50666780), DICO(0x56a0cd00), DICO(0x5cb46480),
-    DICO(0x06c58278), DICO(0x091b10b0), DICO(0x0e0e74f0), DICO(0x11faf980),
-    DICO(0x14a48600), DICO(0x1e6f7500), DICO(0x27f77100), DICO(0x2ab49940),
-    DICO(0x32a1f680), DICO(0x38cb2a80), DICO(0x3c3ff140), DICO(0x3f681cc0),
-    DICO(0x44310700), DICO(0x4fa21700), DICO(0x586c6180), DICO(0x5df74200),
-    DICO(0x06a3e478), DICO(0x09714400), DICO(0x0d90b7a0), DICO(0x12df2720),
-    DICO(0x1618f320), DICO(0x1ac52840), DICO(0x27612900), DICO(0x2e438e00),
-    DICO(0x322b6ac0), DICO(0x38022940), DICO(0x3d2a5180), DICO(0x40d76b80),
-    DICO(0x46671500), DICO(0x4c5bd480), DICO(0x517a2500), DICO(0x57775b00),
-    DICO(0x056c2230), DICO(0x07b8f9d8), DICO(0x0bc6e060), DICO(0x16ac2c80),
-    DICO(0x1a92fc00), DICO(0x1e15f000), DICO(0x28b73200), DICO(0x2cd9e5c0),
-    DICO(0x3196ecc0), DICO(0x3abae340), DICO(0x4040c580), DICO(0x44c18d80),
-    DICO(0x4c086800), DICO(0x50b78500), DICO(0x54e42600), DICO(0x5a549a80),
-    DICO(0x04f9fa10), DICO(0x07419358), DICO(0x0c3e15f0), DICO(0x174c1800),
-    DICO(0x1ab1fe60), DICO(0x23a12680), DICO(0x27955780), DICO(0x2d14b1c0),
-    DICO(0x35cefb00), DICO(0x39576700), DICO(0x3e82b780), DICO(0x42b6a680),
-    DICO(0x476d1880), DICO(0x4b6cdd00), DICO(0x52758680), DICO(0x5b69e500),
-    DICO(0x060b7ab0), DICO(0x081c05c0), DICO(0x0b540300), DICO(0x0f564270),
-    DICO(0x1210aa80), DICO(0x1771e060), DICO(0x25d73280), DICO(0x2e49e380),
-    DICO(0x319c1100), DICO(0x3771e700), DICO(0x3c532f40), DICO(0x40c9a900),
-    DICO(0x48cbf580), DICO(0x4f819980), DICO(0x566f9400), DICO(0x5cfdd980),
-    DICO(0x04efb7b8), DICO(0x0b8a3710), DICO(0x124fd520), DICO(0x1846dde0),
-    DICO(0x1e77a9e0), DICO(0x243ea800), DICO(0x2a4e3280), DICO(0x2ff532c0),
-    DICO(0x35d27680), DICO(0x3b8cdb00), DICO(0x41463000), DICO(0x4706c700),
-    DICO(0x4ca42d80), DICO(0x525d9200), DICO(0x57dabb80), DICO(0x5d59a800),
-    DICO(0x03620dec), DICO(0x095872e0), DICO(0x108d4920), DICO(0x16e9ea00),
-    DICO(0x1d60b2e0), DICO(0x235e9d00), DICO(0x29893b80), DICO(0x2f59a3c0),
-    DICO(0x3556b880), DICO(0x3b10bdc0), DICO(0x40f49500), DICO(0x469cc480),
-    DICO(0x4c762d00), DICO(0x51f16980), DICO(0x578c6d00), DICO(0x5c9b5a00),
-    DICO(0x05dd9bc0), DICO(0x079c5b20), DICO(0x0d319af0), DICO(0x18997040),
-    DICO(0x1c0a1980), DICO(0x20e926c0), DICO(0x25ca1640), DICO(0x29879340),
-    DICO(0x30b27040), DICO(0x36077340), DICO(0x39ac3d00), DICO(0x3d686cc0),
-    DICO(0x428e5f00), DICO(0x47c1bf80), DICO(0x4e720800), DICO(0x5b419880),
-    DICO(0x07694258), DICO(0x0b50db90), DICO(0x0f384950), DICO(0x140dac40),
-    DICO(0x17c50d80), DICO(0x1b49b300), DICO(0x24746200), DICO(0x2ce92fc0),
-    DICO(0x309fdac0), DICO(0x35c02a00), DICO(0x3aa3df00), DICO(0x3e1edb00),
-    DICO(0x431ad280), DICO(0x4b57f500), DICO(0x51463980), DICO(0x586b5200),
-    DICO(0x06401dd0), DICO(0x08d3d9b0), DICO(0x0ca0f510), DICO(0x10ed1920),
-    DICO(0x1451c2e0), DICO(0x2082f640), DICO(0x2872c0c0), DICO(0x2ca9da00),
-    DICO(0x3219cd00), DICO(0x35977300), DICO(0x3a8ba1c0), DICO(0x43d5f280),
-    DICO(0x49a51f00), DICO(0x4de9b400), DICO(0x5362ef80), DICO(0x59387300),
-    DICO(0x0589c430), DICO(0x07809918), DICO(0x0d086f80), DICO(0x10371c20),
-    DICO(0x151842c0), DICO(0x1bfcb1c0), DICO(0x22441040), DICO(0x2722b5c0),
-    DICO(0x2b603fc0), DICO(0x314465c0), DICO(0x40308b00), DICO(0x47d5a200),
-    DICO(0x4bf7e000), DICO(0x4f937200), DICO(0x5584eb00), DICO(0x5cb02200),
-    DICO(0x03b592f0), DICO(0x056ba738), DICO(0x0a8e2250), DICO(0x172436c0),
-    DICO(0x1ad35da0), DICO(0x1d72dc80), DICO(0x20cd3900), DICO(0x2a962940),
-    DICO(0x2f3b6700), DICO(0x33312b40), DICO(0x38dc6680), DICO(0x41659200),
-    DICO(0x4d36a380), DICO(0x52b00980), DICO(0x58c82800), DICO(0x5d741600),
-    DICO(0x05bdfe10), DICO(0x0756da20), DICO(0x0cd31fe0), DICO(0x130f1820),
-    DICO(0x1561caa0), DICO(0x1962ab20), DICO(0x1c310840), DICO(0x28bf6f80),
-    DICO(0x2d2d4500), DICO(0x3230f900), DICO(0x3ac2ea80), DICO(0x3ebe71c0),
-    DICO(0x48280700), DICO(0x50254900), DICO(0x5850a200), DICO(0x5e687200),
-    DICO(0x04e2b7e8), DICO(0x067f5430), DICO(0x0a8899a0), DICO(0x0d571560),
-    DICO(0x1c42f440), DICO(0x22e21fc0), DICO(0x27074340), DICO(0x2c493240),
-    DICO(0x2f7ece00), DICO(0x33959ec0), DICO(0x392d3000), DICO(0x459fc800),
-    DICO(0x4ba5f700), DICO(0x4fde7780), DICO(0x55f90380), DICO(0x5c928b00),
-    DICO(0x0557b940), DICO(0x075f0158), DICO(0x0bd8c540), DICO(0x0f4ee370),
-    DICO(0x141dc900), DICO(0x1b241f00), DICO(0x21c32a80), DICO(0x29a23980),
-    DICO(0x2e475380), DICO(0x3616f9c0), DICO(0x3a52a500), DICO(0x40345f00),
-    DICO(0x4763a500), DICO(0x4eb5bb80), DICO(0x561d4480), DICO(0x5d388580),
-    DICO(0x057d7d08), DICO(0x0738c240), DICO(0x0bf46e10), DICO(0x0ec93da0),
-    DICO(0x14ab3cc0), DICO(0x23d0f5c0), DICO(0x271e9900), DICO(0x2c0ee4c0),
-    DICO(0x301d1f00), DICO(0x33868040), DICO(0x37cdde00), DICO(0x3c805440),
-    DICO(0x43c69200), DICO(0x4f5c9a00), DICO(0x56eb3e80), DICO(0x5cdadc80),
-    DICO(0x06cdbab0), DICO(0x0999e600), DICO(0x0df39790), DICO(0x12ffc9a0),
-    DICO(0x15cfe7a0), DICO(0x1c599300), DICO(0x21afd600), DICO(0x26842bc0),
-    DICO(0x32067c00), DICO(0x368bb080), DICO(0x3c350c40), DICO(0x44e8be00),
-    DICO(0x4ac84000), DICO(0x4f9c1280), DICO(0x5449ec00), DICO(0x594d5880),
-    DICO(0x049a6bd0), DICO(0x06849f08), DICO(0x10592b40), DICO(0x168c1940),
-    DICO(0x1992df40), DICO(0x1e91b300), DICO(0x2237e100), DICO(0x2cd73a80),
-    DICO(0x30e7c100), DICO(0x361a45c0), DICO(0x3cdd1f40), DICO(0x41d5d100),
-    DICO(0x46f79480), DICO(0x4e44c880), DICO(0x55830e80), DICO(0x5d7c0680),
-    DICO(0x05087958), DICO(0x06fb7e40), DICO(0x0ac5ace0), DICO(0x14e91d80),
-    DICO(0x19ac68c0), DICO(0x1dbf7600), DICO(0x26f916c0), DICO(0x2bd2c980),
-    DICO(0x307f7900), DICO(0x38e07e40), DICO(0x3df7f1c0), DICO(0x41323d00),
-    DICO(0x44d2f480), DICO(0x48fb0480), DICO(0x51e17900), DICO(0x5c15d700),
-    DICO(0x0346cf40), DICO(0x05423408), DICO(0x0b640ce0), DICO(0x13055060),
-    DICO(0x1a8c0b60), DICO(0x1d8d2280), DICO(0x218b6500), DICO(0x2c385700),
-    DICO(0x30927b40), DICO(0x35d82880), DICO(0x3aa87e00), DICO(0x3da46a40),
-    DICO(0x45ea5280), DICO(0x511ecb80), DICO(0x57b53b00), DICO(0x5d491400),
-    DICO(0x056aa1c8), DICO(0x075a09a0), DICO(0x0a5d61d0), DICO(0x13cb9fe0),
-    DICO(0x1f924dc0), DICO(0x237a11c0), DICO(0x277d6b80), DICO(0x2c2ba440),
-    DICO(0x30195c80), DICO(0x35250cc0), DICO(0x3b718200), DICO(0x40113c80),
-    DICO(0x44df2680), DICO(0x49f0ed80), DICO(0x50791980), DICO(0x5ac10600),
-    DICO(0x046f1e50), DICO(0x061dd758), DICO(0x1236bec0), DICO(0x16c07340),
-    DICO(0x1a7399c0), DICO(0x1f61ee20), DICO(0x244b2280), DICO(0x2b803e40),
-    DICO(0x2eda5300), DICO(0x331210c0), DICO(0x3773bfc0), DICO(0x411c8400),
-    DICO(0x488ff380), DICO(0x4fad2700), DICO(0x55845000), DICO(0x5ca74c00),
-    DICO(0x04b456f0), DICO(0x05fca198), DICO(0x0ad056d0), DICO(0x19c3bfe0),
-    DICO(0x1d446100), DICO(0x20f67200), DICO(0x24a40b40), DICO(0x28d472c0),
-    DICO(0x2da813c0), DICO(0x31880200), DICO(0x35344f40), DICO(0x3ca7f340),
-    DICO(0x4aa94300), DICO(0x4f921500), DICO(0x5516d700), DICO(0x5c832880),
-    DICO(0x07f468c0), DICO(0x0bbb6e90), DICO(0x0f0f8730), DICO(0x143d6180),
-    DICO(0x198b84c0), DICO(0x1c6b30a0), DICO(0x219c8000), DICO(0x28795780),
-    DICO(0x2cce3d00), DICO(0x329b1100), DICO(0x3a8d2240), DICO(0x3f579080),
-    DICO(0x45a74400), DICO(0x4d000f80), DICO(0x52bd6880), DICO(0x5a743a80),
-    DICO(0x06979498), DICO(0x088fecf0), DICO(0x0f1dac90), DICO(0x12077160),
-    DICO(0x16d5b120), DICO(0x1c5465c0), DICO(0x21ad14c0), DICO(0x282be280),
-    DICO(0x2b66a380), DICO(0x2fa3f200), DICO(0x35a06500), DICO(0x3a458d00),
-    DICO(0x44aefc00), DICO(0x4e92f600), DICO(0x55b9fa80), DICO(0x5cfe0280),
-    DICO(0x0552b408), DICO(0x06f6ce38), DICO(0x0e8f8d80), DICO(0x1395e900),
-    DICO(0x17c7b440), DICO(0x1ec64dc0), DICO(0x236e2200), DICO(0x2abc0b80),
-    DICO(0x2e131240), DICO(0x32921100), DICO(0x372633c0), DICO(0x3ca97840),
-    DICO(0x496e5000), DICO(0x4f86a800), DICO(0x54072300), DICO(0x5be31c80),
-    DICO(0x0470c0b8), DICO(0x0662c468), DICO(0x0c493fd0), DICO(0x1a1949c0),
-    DICO(0x1febcc20), DICO(0x2364e900), DICO(0x2a0cce00), DICO(0x2f6f8140),
-    DICO(0x3418b000), DICO(0x3c5c7a40), DICO(0x42d39100), DICO(0x476c2b00),
-    DICO(0x4e11c300), DICO(0x53621500), DICO(0x583fd280), DICO(0x5ce26600),
-    DICO(0x04b006c0), DICO(0x09a1ed40), DICO(0x135aee00), DICO(0x193b5180),
-    DICO(0x1f3679a0), DICO(0x24fdbcc0), DICO(0x2b823e00), DICO(0x31835780),
-    DICO(0x37c74cc0), DICO(0x3df66780), DICO(0x43c18580), DICO(0x49465980),
-    DICO(0x4ed0ce00), DICO(0x53d6fb80), DICO(0x59064300), DICO(0x5deaa100),
-    DICO(0x03cbc49c), DICO(0x07735930), DICO(0x138aaa20), DICO(0x1a1e69a0),
-    DICO(0x21be93c0), DICO(0x2936f780), DICO(0x2fa76f80), DICO(0x34ae6b00),
-    DICO(0x396b7b80), DICO(0x3dbc6700), DICO(0x421a9100), DICO(0x46fd2180),
-    DICO(0x4c5dca80), DICO(0x51923b80), DICO(0x576d1300), DICO(0x5d288680),
-    DICO(0x03cab7d0), DICO(0x052c88b8), DICO(0x09ed24f0), DICO(0x1c261820),
-    DICO(0x209096c0), DICO(0x2361e080), DICO(0x27292800), DICO(0x2bbdc6c0),
-    DICO(0x3292da80), DICO(0x36866a40), DICO(0x3c4d5100), DICO(0x45233400),
-    DICO(0x4d928a00), DICO(0x52ca9d00), DICO(0x5820d000), DICO(0x5d903880),
-    DICO(0x03f83718), DICO(0x0540fa90), DICO(0x13028120), DICO(0x1ad6e160),
-    DICO(0x1d784880), DICO(0x22028900), DICO(0x25976b40), DICO(0x2b293700),
-    DICO(0x2ddb86c0), DICO(0x317c4340), DICO(0x34e62ec0), DICO(0x3b71bd00),
-    DICO(0x4bc34780), DICO(0x52982400), DICO(0x57fa2800), DICO(0x5f19cc00),
-    DICO(0x049ceb50), DICO(0x06a8d4e0), DICO(0x09db2470), DICO(0x120e3e60),
-    DICO(0x1c8ebb80), DICO(0x21221d00), DICO(0x2679bfc0), DICO(0x2b1e7600),
-    DICO(0x2ebbcf80), DICO(0x32d5afc0), DICO(0x3d1bef00), DICO(0x41b11a00),
-    DICO(0x45bb2d80), DICO(0x4cb70300), DICO(0x572fdc80), DICO(0x5d876e80),
-    DICO(0x04abda68), DICO(0x06698cd0), DICO(0x0ca87230), DICO(0x15086a80),
-    DICO(0x176cf4e0), DICO(0x22899440), DICO(0x268fc500), DICO(0x2ba2d940),
-    DICO(0x33505980), DICO(0x36944bc0), DICO(0x3b20c280), DICO(0x437e8f00),
-    DICO(0x4bf29e80), DICO(0x51776a80), DICO(0x57a77800), DICO(0x5cf6c180),
-    DICO(0x06d7f5c0), DICO(0x08fd3cc0), DICO(0x0d8807e0), DICO(0x1140d500),
-    DICO(0x146dfc80), DICO(0x1e9fbaa0), DICO(0x23d7bf00), DICO(0x28b2ae80),
-    DICO(0x2e5a9b00), DICO(0x327005c0), DICO(0x37736640), DICO(0x4001c500),
-    DICO(0x4a862b00), DICO(0x4f7a2e00), DICO(0x54a22080), DICO(0x5b76c380),
-    DICO(0x0671fb68), DICO(0x08e4bf30), DICO(0x0d801250), DICO(0x1176b820),
-    DICO(0x15128860), DICO(0x1ee21180), DICO(0x24799580), DICO(0x29415a40),
-    DICO(0x2efa2380), DICO(0x33fe5040), DICO(0x39bf6d00), DICO(0x3f28b380),
-    DICO(0x442b2280), DICO(0x493de680), DICO(0x54377700), DICO(0x5d3a5480),
-    DICO(0x065b7970), DICO(0x087820b0), DICO(0x0d8d6aa0), DICO(0x16718620),
-    DICO(0x1a3a8f40), DICO(0x1f4099c0), DICO(0x24d87b40), DICO(0x296d85c0),
-    DICO(0x2f887c80), DICO(0x342d1b40), DICO(0x3887fc40), DICO(0x3d758b40),
-    DICO(0x42641c80), DICO(0x47bf6980), DICO(0x55f82900), DICO(0x5e132a00),
-    DICO(0x05ddbc00), DICO(0x081f17a0), DICO(0x0bf23ac0), DICO(0x12fc8d60),
-    DICO(0x172bc440), DICO(0x1a833540), DICO(0x1e942200), DICO(0x21e477c0),
-    DICO(0x2e75da80), DICO(0x399efac0), DICO(0x3dfb6900), DICO(0x428b3780),
-    DICO(0x4922a080), DICO(0x4d4c1700), DICO(0x51bbee00), DICO(0x5b4cfc80),
-    DICO(0x06ecf380), DICO(0x08f83990), DICO(0x0cb55680), DICO(0x140b2860),
-    DICO(0x18084d00), DICO(0x1aff9940), DICO(0x1f5f6f00), DICO(0x224a3d80),
-    DICO(0x2b0f49c0), DICO(0x3613b280), DICO(0x39188f40), DICO(0x3efa3640),
-    DICO(0x4771e400), DICO(0x4ca32380), DICO(0x54627580), DICO(0x5cb91000),
-    DICO(0x069e7f98), DICO(0x0870c760), DICO(0x0d7b73a0), DICO(0x15ab1040),
-    DICO(0x18a4d220), DICO(0x1c4c1f20), DICO(0x1ffaf200), DICO(0x24142580),
-    DICO(0x30e47540), DICO(0x37340200), DICO(0x3a69af40), DICO(0x3ed471c0),
-    DICO(0x44157880), DICO(0x486b7f00), DICO(0x52ed2b00), DICO(0x5ce3a980),
-    DICO(0x047f1080), DICO(0x06463230), DICO(0x0b566e80), DICO(0x0edb9080),
-    DICO(0x128a2fa0), DICO(0x1748b340), DICO(0x210b2b00), DICO(0x28099b80),
-    DICO(0x2f519740), DICO(0x36fe82c0), DICO(0x3d924b80), DICO(0x43cd3c00),
-    DICO(0x4a774680), DICO(0x50d15f00), DICO(0x573b3580), DICO(0x5d4c1c00),
-    DICO(0x05fa6a68), DICO(0x0866e4c0), DICO(0x0d133cc0), DICO(0x156d6b20),
-    DICO(0x18abebe0), DICO(0x1d374900), DICO(0x23d23d00), DICO(0x27b370c0),
-    DICO(0x2f63ef00), DICO(0x352a0600), DICO(0x3a643a40), DICO(0x3f57f980),
-    DICO(0x457a7f00), DICO(0x520f6200), DICO(0x593b2c80), DICO(0x5e192b80),
-    DICO(0x04e4e0c8), DICO(0x067c3450), DICO(0x0acabe70), DICO(0x1865eec0),
-    DICO(0x1c5e9bc0), DICO(0x202facc0), DICO(0x24a609c0), DICO(0x28db7b00),
-    DICO(0x2efbd780), DICO(0x336fe5c0), DICO(0x3819a5c0), DICO(0x3e709b40),
-    DICO(0x4435ff80), DICO(0x4bd5fb80), DICO(0x5564a100), DICO(0x5d0a4980),
-    DICO(0x05a72f00), DICO(0x070199b0), DICO(0x0e654780), DICO(0x14fc7780),
-    DICO(0x174283c0), DICO(0x1b231480), DICO(0x1e7b9000), DICO(0x27a013c0),
-    DICO(0x2b42f500), DICO(0x2fd9ca00), DICO(0x3672a0c0), DICO(0x3cc23f40),
-    DICO(0x48299d80), DICO(0x4f92a800), DICO(0x564d7680), DICO(0x5d3ab580),
-    DICO(0x03e63764), DICO(0x05baa3f0), DICO(0x0ab2a300), DICO(0x12cc5f60),
-    DICO(0x19a8d5e0), DICO(0x1ea788e0), DICO(0x22cd50c0), DICO(0x25d48a00),
-    DICO(0x29924540), DICO(0x32762a00), DICO(0x3bba55c0), DICO(0x4222e800),
-    DICO(0x4aba1280), DICO(0x501d0b80), DICO(0x57091200), DICO(0x5d6bf180),
-    DICO(0x047daeb0), DICO(0x069548b8), DICO(0x0b002410), DICO(0x13ff7060),
-    DICO(0x186aec40), DICO(0x210db240), DICO(0x26f1ce80), DICO(0x2b73c9c0),
-    DICO(0x33d57240), DICO(0x385898c0), DICO(0x3eea8cc0), DICO(0x43c79b00),
-    DICO(0x496ec200), DICO(0x4e150780), DICO(0x54dcb700), DICO(0x5c3f7380),
-    DICO(0x079fd258), DICO(0x0b93bd50), DICO(0x0ff7d8b0), DICO(0x14bd4e00),
-    DICO(0x19536ae0), DICO(0x1d8b1640), DICO(0x23747cc0), DICO(0x2861f280),
-    DICO(0x2d7d2880), DICO(0x3583b040), DICO(0x3c3cab00), DICO(0x41b7b580),
-    DICO(0x498cfc80), DICO(0x506cbd00), DICO(0x57847600), DICO(0x5d05de80),
-    DICO(0x06434ec0), DICO(0x0805ccd0), DICO(0x0c4b4c00), DICO(0x13d551c0),
-    DICO(0x1685abe0), DICO(0x1a83ea60), DICO(0x1ddc3700), DICO(0x22bc4600),
-    DICO(0x2c7ca5c0), DICO(0x30a589c0), DICO(0x395a8700), DICO(0x40c92900),
-    DICO(0x472fae80), DICO(0x4f6f6e80), DICO(0x571b3f80), DICO(0x5d8e6980),
-    DICO(0x05ec21b0), DICO(0x079ee388), DICO(0x0e4b4580), DICO(0x11abf100),
-    DICO(0x16588ec0), DICO(0x1c984ec0), DICO(0x20a384c0), DICO(0x28d6be00),
-    DICO(0x2bcca740), DICO(0x3604b600), DICO(0x3f027280), DICO(0x434af000),
-    DICO(0x48dac280), DICO(0x4d7e8a00), DICO(0x51f61800), DICO(0x5a6d9380),
-    DICO(0x0552c6c0), DICO(0x070c22a0), DICO(0x0a411b50), DICO(0x0e3e5270),
-    DICO(0x1193bb60), DICO(0x1b177e00), DICO(0x275b2500), DICO(0x2b42bd80),
-    DICO(0x322d7e40), DICO(0x3a170880), DICO(0x3d66b580), DICO(0x41413280),
-    DICO(0x46a9ce80), DICO(0x4e4e3800), DICO(0x571f8380), DICO(0x5ddae380),
-    DICO(0x055602c0), DICO(0x06e69118), DICO(0x0c9d13f0), DICO(0x1090d500),
-    DICO(0x138d2280), DICO(0x171bf540), DICO(0x1b585180), DICO(0x288b9740),
-    DICO(0x2db202c0), DICO(0x3525e680), DICO(0x3c303900), DICO(0x4311df80),
-    DICO(0x49b92c00), DICO(0x509de900), DICO(0x56e9a080), DICO(0x5d523a80),
-    DICO(0x04e79810), DICO(0x069626e8), DICO(0x0a6cf680), DICO(0x0da668c0),
-    DICO(0x115872a0), DICO(0x2032eec0), DICO(0x25345dc0), DICO(0x2ae8ea40),
-    DICO(0x30224280), DICO(0x351ff640), DICO(0x3ce65a80), DICO(0x454bff00),
-    DICO(0x4ee08980), DICO(0x543b4280), DICO(0x59c19280), DICO(0x5ddfbb00),
-    DICO(0x03f0bb98), DICO(0x0588f4f0), DICO(0x0a862bc0), DICO(0x14ec76e0),
-    DICO(0x184b8a80), DICO(0x1f7bbd80), DICO(0x23f1a7c0), DICO(0x2c367900),
-    DICO(0x3234af80), DICO(0x35460ac0), DICO(0x38514c00), DICO(0x3d5f3540),
-    DICO(0x48394980), DICO(0x4fbdd380), DICO(0x56de0280), DICO(0x5d4e6500),
-    DICO(0x06050f28), DICO(0x08070af0), DICO(0x0be31240), DICO(0x0f5e53e0),
-    DICO(0x125f1740), DICO(0x215b1fc0), DICO(0x2883d880), DICO(0x2c181080),
-    DICO(0x32810280), DICO(0x35d56800), DICO(0x3a9b0880), DICO(0x3ffaaf80),
-    DICO(0x44c65500), DICO(0x4a45ae80), DICO(0x56b4ed80), DICO(0x5e4adc00),
-    DICO(0x0372bbb4), DICO(0x04ea4848), DICO(0x09b8de70), DICO(0x151b4a40),
-    DICO(0x1be65a00), DICO(0x207655c0), DICO(0x2720dd00), DICO(0x2fc6cc00),
-    DICO(0x35b063c0), DICO(0x39bd30c0), DICO(0x3dc5b580), DICO(0x42af7b00),
-    DICO(0x48d2bf00), DICO(0x4f46bb80), DICO(0x55f7ca80), DICO(0x5ca7e980),
-    DICO(0x033f868c), DICO(0x04d9a0e0), DICO(0x0a18d6d0), DICO(0x13da5580),
-    DICO(0x181ae880), DICO(0x207d8580), DICO(0x262022c0), DICO(0x2c6de040),
-    DICO(0x3321f100), DICO(0x3927f0c0), DICO(0x3f74ce40), DICO(0x4573e980),
-    DICO(0x4ba66c80), DICO(0x51a26100), DICO(0x57d3a800), DICO(0x5d52e780),
-    DICO(0x05189860), DICO(0x07231848), DICO(0x0b915710), DICO(0x0f05d6c0),
-    DICO(0x13bb0820), DICO(0x223adf00), DICO(0x26ce1ec0), DICO(0x2ce1ac00),
-    DICO(0x3401f6c0), DICO(0x3b8c2240), DICO(0x40e4a400), DICO(0x45674f00),
-    DICO(0x4b04b880), DICO(0x4f253200), DICO(0x54168600), DICO(0x58f52780),
-    DICO(0x0338d184), DICO(0x05205790), DICO(0x09abcd80), DICO(0x0f53ff60),
-    DICO(0x1a7fe900), DICO(0x1ef93860), DICO(0x238e2d80), DICO(0x2bd81bc0),
-    DICO(0x33161240), DICO(0x368cfb80), DICO(0x3a28b5c0), DICO(0x40c7a600),
-    DICO(0x4bac7780), DICO(0x524b7880), DICO(0x58638480), DICO(0x5da07b00),
-    DICO(0x04d06f38), DICO(0x065f1518), DICO(0x0c9b31b0), DICO(0x10570d40),
-    DICO(0x15e790a0), DICO(0x20f16380), DICO(0x246f23c0), DICO(0x2e222800),
-    DICO(0x3198bf00), DICO(0x34b84640), DICO(0x38f5b440), DICO(0x4312df80),
-    DICO(0x4d2d3000), DICO(0x5209ee80), DICO(0x579cf180), DICO(0x5cb37680),
-    DICO(0x042e6560), DICO(0x05eaff30), DICO(0x0a090d30), DICO(0x0d9f2ab0),
-    DICO(0x1a6f0260), DICO(0x209e0c00), DICO(0x25dc95c0), DICO(0x29f89840),
-    DICO(0x2f372840), DICO(0x3a301940), DICO(0x3f0e2e80), DICO(0x44465c80),
-    DICO(0x49207780), DICO(0x4dfdab80), DICO(0x532ec000), DICO(0x5acefd00),
-    DICO(0x04e18ad8), DICO(0x06d5b660), DICO(0x0b2a22d0), DICO(0x0e0e4ef0),
-    DICO(0x198304a0), DICO(0x1e4a25c0), DICO(0x23de37c0), DICO(0x290679c0),
-    DICO(0x2d523b00), DICO(0x337df940), DICO(0x37948100), DICO(0x3de07300),
-    DICO(0x49ee6e80), DICO(0x50576100), DICO(0x55fb1e00), DICO(0x5d080500),
-    DICO(0x05312308), DICO(0x070463f0), DICO(0x0daffba0), DICO(0x12d8c3c0),
-    DICO(0x163ab7a0), DICO(0x20c64c40), DICO(0x24c8fe40), DICO(0x2a6f65c0),
-    DICO(0x3055e100), DICO(0x34420d80), DICO(0x389ded00), DICO(0x3cc57640),
-    DICO(0x4280cd00), DICO(0x4e0a4c00), DICO(0x57675f00), DICO(0x5d87d480),
-    DICO(0x047bd598), DICO(0x06cb1498), DICO(0x0c359930), DICO(0x138165e0),
-    DICO(0x1cae3640), DICO(0x21647640), DICO(0x2836fac0), DICO(0x2cd7b840),
-    DICO(0x30d839c0), DICO(0x360c9440), DICO(0x3ae5ca40), DICO(0x40a93b00),
-    DICO(0x49401e80), DICO(0x4f739c80), DICO(0x54f33c00), DICO(0x5c190200),
-    DICO(0x051c0000), DICO(0x06b45258), DICO(0x0a5eee50), DICO(0x0d46fc30),
-    DICO(0x125bbc60), DICO(0x253d8cc0), DICO(0x2a1fd6c0), DICO(0x2df4cf80),
-    DICO(0x3239e3c0), DICO(0x35a683c0), DICO(0x3b0bb980), DICO(0x409b3d00),
-    DICO(0x46633580), DICO(0x4f2b0600), DICO(0x577cea80), DICO(0x5d86ef00),
-    DICO(0x03d19eec), DICO(0x07cce6d0), DICO(0x143b4b00), DICO(0x1a657880),
-    DICO(0x212e0280), DICO(0x2831fbc0), DICO(0x2f8ba080), DICO(0x35db8040),
-    DICO(0x3bf17f00), DICO(0x413eb100), DICO(0x46154900), DICO(0x4ae18080),
-    DICO(0x4f9ba180), DICO(0x5428ba00), DICO(0x590e9080), DICO(0x5de0d880),
-    DICO(0x08c7e720), DICO(0x0ff14810), DICO(0x1758cc40), DICO(0x1cc744c0),
-    DICO(0x23e45cc0), DICO(0x2b527940), DICO(0x32138580), DICO(0x37b77380),
-    DICO(0x3d7da480), DICO(0x4275a800), DICO(0x473ecf00), DICO(0x4bc7dc80),
-    DICO(0x50512400), DICO(0x54d2c600), DICO(0x598ce680), DICO(0x5e1e0800),
-    DICO(0x09167910), DICO(0x107644a0), DICO(0x171a59e0), DICO(0x1be1ea60),
-    DICO(0x21347680), DICO(0x265a5b00), DICO(0x2be41a40), DICO(0x3116e700),
-    DICO(0x368b0300), DICO(0x3c225e80), DICO(0x41a6e880), DICO(0x47631680),
-    DICO(0x4d47d900), DICO(0x52a28400), DICO(0x583f0e80), DICO(0x5d77bc80),
-    DICO(0x040bdf88), DICO(0x05b062a0), DICO(0x0b4a2f70), DICO(0x1b8cd880),
-    DICO(0x1ec58c40), DICO(0x23661880), DICO(0x2790ba80), DICO(0x2d0d6c40),
-    DICO(0x34f0bc40), DICO(0x3a353f80), DICO(0x3fc3bc40), DICO(0x44998700),
-    DICO(0x49b17080), DICO(0x4f31fa00), DICO(0x55311c80), DICO(0x5b5c8f80),
-    DICO(0x043e2bd0), DICO(0x0645b0f0), DICO(0x0ade5b90), DICO(0x0d653a90),
-    DICO(0x1bc224a0), DICO(0x1f623dc0), DICO(0x27e9a840), DICO(0x2c719bc0),
-    DICO(0x2f2ac040), DICO(0x32688300), DICO(0x36695c00), DICO(0x3b8abe40),
-    DICO(0x47153a80), DICO(0x52491b00), DICO(0x57ba7680), DICO(0x5ce6c300),
-    DICO(0x052940b8), DICO(0x06f28228), DICO(0x0a741c90), DICO(0x0daa3110),
-    DICO(0x113bb2e0), DICO(0x2010b640), DICO(0x2610f380), DICO(0x2a5c7740),
-    DICO(0x2f7703c0), DICO(0x3388d080), DICO(0x3ceabe40), DICO(0x42462a80),
-    DICO(0x47fb0e00), DICO(0x4f7ac480), DICO(0x5706f580), DICO(0x5d92b800),
-    DICO(0x03a134a4), DICO(0x05623470), DICO(0x090a0fe0), DICO(0x12f7d3e0),
-    DICO(0x1d63e440), DICO(0x20e6ac80), DICO(0x247da8c0), DICO(0x27d99600),
-    DICO(0x312e99c0), DICO(0x368fb380), DICO(0x3b3e3ec0), DICO(0x40fead80),
-    DICO(0x4888fa00), DICO(0x4fbd5600), DICO(0x5795a480), DICO(0x5d973000),
-    DICO(0x05697990), DICO(0x06f33800), DICO(0x0b298290), DICO(0x0de47a60),
-    DICO(0x12ef62a0), DICO(0x21e30a00), DICO(0x25f8ff00), DICO(0x2b2287c0),
-    DICO(0x2f11fc00), DICO(0x33138000), DICO(0x37b49f80), DICO(0x41325100),
-    DICO(0x4ab62800), DICO(0x501eae80), DICO(0x56228780), DICO(0x5c5d8300),
-    DICO(0x063830d8), DICO(0x08a76a30), DICO(0x0d376890), DICO(0x117d3a00),
-    DICO(0x1476e5c0), DICO(0x1e215720), DICO(0x24bcd680), DICO(0x29674ac0),
-    DICO(0x2faab340), DICO(0x33843a00), DICO(0x3822e900), DICO(0x3d30b6c0),
-    DICO(0x49cd5480), DICO(0x53187d00), DICO(0x591fe100), DICO(0x5db30f80),
-    DICO(0x05cdc378), DICO(0x075c50c8), DICO(0x0e01f830), DICO(0x12b70480),
-    DICO(0x15e333e0), DICO(0x192c9f40), DICO(0x1d2d6b80), DICO(0x2c09ca40),
-    DICO(0x2eea5cc0), DICO(0x32c89380), DICO(0x376a5b40), DICO(0x42a42600),
-    DICO(0x4c695900), DICO(0x5269e380), DICO(0x586d6c80), DICO(0x5cebdb80),
-    DICO(0x052bbb80), DICO(0x0702e268), DICO(0x0ca196d0), DICO(0x0f48cef0),
-    DICO(0x19d28b60), DICO(0x1ec44a40), DICO(0x24d40f00), DICO(0x29e1eac0),
-    DICO(0x2cafaa80), DICO(0x301bd4c0), DICO(0x357ec200), DICO(0x42254480),
-    DICO(0x4be32000), DICO(0x4f7a4a00), DICO(0x5447fc00), DICO(0x5cca6a00),
-    DICO(0x050fdd18), DICO(0x06c77e10), DICO(0x10561140), DICO(0x1564c340),
-    DICO(0x1867abe0), DICO(0x1f00fba0), DICO(0x22c06240), DICO(0x2aed7680),
-    DICO(0x2ecc24c0), DICO(0x32abb300), DICO(0x36b42340), DICO(0x3ed8f480),
-    DICO(0x4bbdfe80), DICO(0x516bf800), DICO(0x58688b00), DICO(0x5dd44980),
-    DICO(0x058aa130), DICO(0x07d69ba8), DICO(0x0d521f40), DICO(0x0ff37ba0),
-    DICO(0x18125ec0), DICO(0x1f3a4520), DICO(0x23349840), DICO(0x2c759580),
-    DICO(0x2fc21c00), DICO(0x33a42fc0), DICO(0x3dc92900), DICO(0x47befd00),
-    DICO(0x4ccd2480), DICO(0x5197a200), DICO(0x56a2ea00), DICO(0x5bdfa900),
-    DICO(0x05ac8640), DICO(0x076aec88), DICO(0x0e2e3230), DICO(0x114b6f40),
-    DICO(0x155d10a0), DICO(0x19bac600), DICO(0x1fbd75c0), DICO(0x2459c0c0),
-    DICO(0x28229b80), DICO(0x2f586fc0), DICO(0x3d0697c0), DICO(0x42a7a500),
-    DICO(0x49b0bb80), DICO(0x4e642e80), DICO(0x55774280), DICO(0x5d1a7900),
-    DICO(0x05efb470), DICO(0x0831c8a0), DICO(0x0d35ece0), DICO(0x13edc400),
-    DICO(0x16c8fec0), DICO(0x1bb25860), DICO(0x204f3140), DICO(0x277b8a40),
-    DICO(0x2fe9a000), DICO(0x33af7c40), DICO(0x3b7d2900), DICO(0x419c9a80),
-    DICO(0x4591dc80), DICO(0x4bdafd00), DICO(0x55638880), DICO(0x5cef2300),
-    DICO(0x05cf4988), DICO(0x078fa8c0), DICO(0x0c291950), DICO(0x12e05320),
-    DICO(0x155997e0), DICO(0x195df540), DICO(0x1c1b82c0), DICO(0x22c29400),
-    DICO(0x307edec0), DICO(0x34e829c0), DICO(0x3b1b5040), DICO(0x434de400),
-    DICO(0x496b9900), DICO(0x4ff88080), DICO(0x5604c480), DICO(0x5c84b080),
-    DICO(0x03679fa4), DICO(0x050d4a20), DICO(0x09feec10), DICO(0x100a21e0),
-    DICO(0x1483b260), DICO(0x1d76c780), DICO(0x24e75c80), DICO(0x2bd62880),
-    DICO(0x32350a40), DICO(0x38be01c0), DICO(0x3f05a280), DICO(0x45295e80),
-    DICO(0x4b554800), DICO(0x51618880), DICO(0x575a1500), DICO(0x5d109d80),
-    DICO(0x034ffd08), DICO(0x04dccea8), DICO(0x07e289b8), DICO(0x0d6950d0),
-    DICO(0x189acec0), DICO(0x1e3bf240), DICO(0x2535aa40), DICO(0x2b88d140),
-    DICO(0x329bbb00), DICO(0x386c3500), DICO(0x3e950800), DICO(0x44c43f00),
-    DICO(0x4b089780), DICO(0x51223280), DICO(0x574c9780), DICO(0x5d366400),
-    DICO(0x036d8db8), DICO(0x04fd88b8), DICO(0x09700a70), DICO(0x116b73c0),
-    DICO(0x17258c40), DICO(0x1fd03000), DICO(0x23fdf400), DICO(0x28e08dc0),
-    DICO(0x32d688c0), DICO(0x37920b00), DICO(0x3daaa080), DICO(0x46a16c00),
-    DICO(0x4f8c3100), DICO(0x54a13700), DICO(0x59d24b80), DICO(0x5cea4d80),
-    DICO(0x05797c88), DICO(0x080dc8f0), DICO(0x0bd21520), DICO(0x1095b540),
-    DICO(0x138fd400), DICO(0x1aed19c0), DICO(0x29fead00), DICO(0x2f70cec0),
-    DICO(0x3327df00), DICO(0x3a812d00), DICO(0x400a8380), DICO(0x449daa00),
-    DICO(0x4cd6b600), DICO(0x51f12400), DICO(0x56bdfd80), DICO(0x5be0a100),
-    DICO(0x04de6d78), DICO(0x072aed40), DICO(0x0c6fc460), DICO(0x0f260220),
-    DICO(0x179d00c0), DICO(0x1e8244e0), DICO(0x23867240), DICO(0x2baf7680),
-    DICO(0x2fa6d240), DICO(0x37e83d40), DICO(0x3d1cbfc0), DICO(0x439d0a00),
-    DICO(0x49fd3e00), DICO(0x50095e80), DICO(0x559f2080), DICO(0x5b889a00),
-    DICO(0x042f5c10), DICO(0x061ab3e8), DICO(0x0dd8f160), DICO(0x126e0b40),
-    DICO(0x16ea9040), DICO(0x20a31700), DICO(0x24608140), DICO(0x2ec65080),
-    DICO(0x334e1a40), DICO(0x38252100), DICO(0x3fff0900), DICO(0x46519a80),
-    DICO(0x4c5e0d80), DICO(0x518c5800), DICO(0x56c5b080), DICO(0x5c6ebb80),
-    DICO(0x045ce230), DICO(0x067547b0), DICO(0x0a21c670), DICO(0x1408b820),
-    DICO(0x1c0505c0), DICO(0x1e806c80), DICO(0x26d3c640), DICO(0x2ca573c0),
-    DICO(0x3014d880), DICO(0x377108c0), DICO(0x3f35cf80), DICO(0x43566100),
-    DICO(0x4a612900), DICO(0x5160c780), DICO(0x57d3e300), DICO(0x5d414b80),
-    DICO(0x04c8eda8), DICO(0x06a32320), DICO(0x09ab2590), DICO(0x14230760),
-    DICO(0x20fb23c0), DICO(0x24aa2880), DICO(0x285a2580), DICO(0x2c464ac0),
-    DICO(0x30098280), DICO(0x36232780), DICO(0x3e428d40), DICO(0x42982280),
-    DICO(0x47e60d80), DICO(0x4e1ecc00), DICO(0x55eb9200), DICO(0x5c81ed00),
-    DICO(0x040d0b90), DICO(0x0586c5c0), DICO(0x0bea2190), DICO(0x1dc8dd60),
-    DICO(0x20a07c40), DICO(0x2437e580), DICO(0x27ca5fc0), DICO(0x2d017980),
-    DICO(0x34100040), DICO(0x38d3afc0), DICO(0x3da9b700), DICO(0x42082480),
-    DICO(0x46586f00), DICO(0x4e3c3d80), DICO(0x55e1ee00), DICO(0x5c938d00),
-    DICO(0x03d18c64), DICO(0x05941d60), DICO(0x116b2560), DICO(0x19cc8820),
-    DICO(0x1ce930c0), DICO(0x22626080), DICO(0x26d2cf80), DICO(0x2ce2c980),
-    DICO(0x305361c0), DICO(0x34b65900), DICO(0x39ee5b40), DICO(0x41508400),
-    DICO(0x47ee1e80), DICO(0x50311180), DICO(0x56cb0c00), DICO(0x5d561680),
-    DICO(0x0af22cf0), DICO(0x154e1c60), DICO(0x1b44ff60), DICO(0x2087d0c0),
-    DICO(0x252f7380), DICO(0x28fe66c0), DICO(0x2d0e9800), DICO(0x30f7ee00),
-    DICO(0x3606d640), DICO(0x3bac0a40), DICO(0x417c3700), DICO(0x470c2900),
-    DICO(0x4cc20d00), DICO(0x51e55e80), DICO(0x576bc200), DICO(0x5caa7080),
-    DICO(0x043314e0), DICO(0x05cb47b0), DICO(0x0985df20), DICO(0x185a22c0),
-    DICO(0x1ea68300), DICO(0x21af9100), DICO(0x25cdcb40), DICO(0x297e0a80),
-    DICO(0x3142ac80), DICO(0x358bb040), DICO(0x3a1345c0), DICO(0x402ca580),
-    DICO(0x4d964780), DICO(0x5420cf80), DICO(0x592adf80), DICO(0x5dfe7a80),
-    DICO(0x04c70e20), DICO(0x062fd6f0), DICO(0x113c60a0), DICO(0x159e9900),
-    DICO(0x1933e5a0), DICO(0x1decffa0), DICO(0x22373400), DICO(0x27ed7180),
-    DICO(0x2a8349c0), DICO(0x2f78f940), DICO(0x3d5c8540), DICO(0x429c3500),
-    DICO(0x4936e300), DICO(0x4de08d00), DICO(0x52627700), DICO(0x5d822680),
-    DICO(0x04982770), DICO(0x06ab1ad8), DICO(0x0cba1090), DICO(0x10839d60),
-    DICO(0x1acd6a60), DICO(0x1f554560), DICO(0x2431c1c0), DICO(0x295db800),
-    DICO(0x2d374c00), DICO(0x31f2fd80), DICO(0x3a200480), DICO(0x416bea80),
-    DICO(0x4ba1ce00), DICO(0x52a88000), DICO(0x58d0db00), DICO(0x5d3e5800),
-    DICO(0x059e0e70), DICO(0x08166ba0), DICO(0x0c9df590), DICO(0x11de5f40),
-    DICO(0x14c08ea0), DICO(0x1c5ad6e0), DICO(0x24178ec0), DICO(0x28eb7640),
-    DICO(0x31626280), DICO(0x35d43100), DICO(0x3cad10c0), DICO(0x422e1480),
-    DICO(0x49baee00), DICO(0x53dd7180), DICO(0x5a17bb80), DICO(0x5e4bb180),
-    DICO(0x03c64d00), DICO(0x05de0b28), DICO(0x0ccb82b0), DICO(0x144b1c00),
-    DICO(0x19e39ec0), DICO(0x21e795c0), DICO(0x28149380), DICO(0x2f1ff7c0),
-    DICO(0x35b7c900), DICO(0x3c5f4800), DICO(0x42799c00), DICO(0x48746180),
-    DICO(0x4e8f4d00), DICO(0x53b98380), DICO(0x58d60000), DICO(0x5d71a000),
-    DICO(0x050a2990), DICO(0x071bdb88), DICO(0x0f0d76b0), DICO(0x17a78de0),
-    DICO(0x1aa20720), DICO(0x22eea3c0), DICO(0x276e9640), DICO(0x2ecc4d80),
-    DICO(0x335f7900), DICO(0x37838640), DICO(0x3c81be80), DICO(0x41a4e400),
-    DICO(0x476fa280), DICO(0x4f2ab780), DICO(0x56e87b80), DICO(0x5cbf2900),
-    DICO(0x06724c98), DICO(0x099f5e20), DICO(0x119bcec0), DICO(0x16be11a0),
-    DICO(0x19d53b00), DICO(0x1eb51360), DICO(0x2302c300), DICO(0x29c20d40),
-    DICO(0x30dd5200), DICO(0x36576a80), DICO(0x3e3e7540), DICO(0x45aa9f80),
-    DICO(0x4c833300), DICO(0x51d7ed00), DICO(0x57a4a380), DICO(0x5cce9100),
-    DICO(0x05588b60), DICO(0x075a70a0), DICO(0x0ef96e30), DICO(0x12ac1100),
-    DICO(0x1649dde0), DICO(0x1a50cdc0), DICO(0x22486140), DICO(0x27c7c800),
-    DICO(0x2e08bd80), DICO(0x355d20c0), DICO(0x3925a9c0), DICO(0x44e2b480),
-    DICO(0x4fa4e680), DICO(0x5470e180), DICO(0x595fee80), DICO(0x5d672f00),
-    DICO(0x04a781c0), DICO(0x060a89f0), DICO(0x111f56a0), DICO(0x16b93be0),
-    DICO(0x19ce9120), DICO(0x1e1fda60), DICO(0x2259f880), DICO(0x285cad80),
-    DICO(0x2b140ec0), DICO(0x2f069940), DICO(0x33bbce40), DICO(0x3dd3e6c0),
-    DICO(0x49154880), DICO(0x5008e380), DICO(0x568c4680), DICO(0x5da43780),
-    DICO(0x053ade38), DICO(0x0708a200), DICO(0x0bad43d0), DICO(0x1860cf40),
-    DICO(0x1c40dbe0), DICO(0x1f5a0120), DICO(0x25bcf7c0), DICO(0x29e0c840),
-    DICO(0x2f223840), DICO(0x390c8940), DICO(0x3e1d7340), DICO(0x41c6a000),
-    DICO(0x46cc2880), DICO(0x5006e280), DICO(0x5744e180), DICO(0x5d297780),
-    DICO(0x0401a3f0), DICO(0x07be4a08), DICO(0x14f5f1a0), DICO(0x1c348080),
-    DICO(0x226753c0), DICO(0x274b1b80), DICO(0x2c11a300), DICO(0x30798c00),
-    DICO(0x35598c80), DICO(0x3aab18c0), DICO(0x4030f380), DICO(0x45c7b400),
-    DICO(0x4be5be00), DICO(0x5180db80), DICO(0x57613b00), DICO(0x5cffff80),
-    DICO(0x084b3090), DICO(0x0fe5b3b0), DICO(0x16dfd480), DICO(0x1d0aa700),
-    DICO(0x24e08180), DICO(0x2b498640), DICO(0x30885b80), DICO(0x34ccc480),
-    DICO(0x38fedec0), DICO(0x3cdf9c40), DICO(0x41737600), DICO(0x46ab9800),
-    DICO(0x4c772e80), DICO(0x51e5b980), DICO(0x57df9900), DICO(0x5d5d7180),
-    DICO(0x09549f00), DICO(0x12b84da0), DICO(0x1aeaf1c0), DICO(0x2142a9c0),
-    DICO(0x275c9a00), DICO(0x2c260c80), DICO(0x3038c700), DICO(0x34081d00),
-    DICO(0x38612f40), DICO(0x3d0bf8c0), DICO(0x42473e00), DICO(0x47ecad80),
-    DICO(0x4db34380), DICO(0x52f0ab00), DICO(0x584cc980), DICO(0x5d62ae80),
-    DICO(0x0aeca1e0), DICO(0x14354700), DICO(0x19955ba0), DICO(0x1de331e0),
-    DICO(0x21cd60c0), DICO(0x25e72d80), DICO(0x2a402880), DICO(0x2efa64c0),
-    DICO(0x3478d9c0), DICO(0x3a889e80), DICO(0x40744e00), DICO(0x4626fe80),
-    DICO(0x4bd80900), DICO(0x51120f00), DICO(0x56d8d280), DICO(0x5c654400),
-    DICO(0x07a40af8), DICO(0x0e65ec20), DICO(0x14c76780), DICO(0x19b35a60),
-    DICO(0x1f76b7c0), DICO(0x24f512c0), DICO(0x2ae89f00), DICO(0x3036c3c0),
-    DICO(0x36041800), DICO(0x3bc4df80), DICO(0x41adb080), DICO(0x477fbb80),
-    DICO(0x4d5aa480), DICO(0x52cb0600), DICO(0x586f7280), DICO(0x5db40180),
-    DICO(0x03997610), DICO(0x06175db0), DICO(0x0ea8c9c0), DICO(0x14397000),
-    DICO(0x1ba34f60), DICO(0x22346680), DICO(0x28958080), DICO(0x2ea76840),
-    DICO(0x33ee68c0), DICO(0x39e769c0), DICO(0x3f862500), DICO(0x4579b080),
-    DICO(0x4b49cd00), DICO(0x5107da80), DICO(0x573cde00), DICO(0x5d090780),
-    DICO(0x046fc2f8), DICO(0x0640dbc0), DICO(0x09da7ab0), DICO(0x174e4220),
-    DICO(0x23dc8cc0), DICO(0x27016200), DICO(0x2a9a5240), DICO(0x2e6cc7c0),
-    DICO(0x321ced40), DICO(0x38ca2d00), DICO(0x41482680), DICO(0x451e3700),
-    DICO(0x4b90d800), DICO(0x50d0ba80), DICO(0x55602e80), DICO(0x5a465200),
-    DICO(0x03ca7e28), DICO(0x057c9dd0), DICO(0x0c9ff0e0), DICO(0x1957fae0),
-    DICO(0x1fef7860), DICO(0x27920c80), DICO(0x2cb233c0), DICO(0x32015c80),
-    DICO(0x36af4f40), DICO(0x3ac18240), DICO(0x3f93d8c0), DICO(0x44eaef80),
-    DICO(0x4aab5d80), DICO(0x50840e80), DICO(0x56c4cc80), DICO(0x5cb26600),
-    DICO(0x038d53f8), DICO(0x050d1118), DICO(0x0bc14690), DICO(0x18918000),
-    DICO(0x1e2a6ee0), DICO(0x24cc0c00), DICO(0x2a767d40), DICO(0x2e614940),
-    DICO(0x32859c40), DICO(0x377fd940), DICO(0x3d3a3e40), DICO(0x43e81380),
-    DICO(0x4aaac080), DICO(0x509e7800), DICO(0x57023a00), DICO(0x5d733c00),
-    DICO(0x04cfa5e0), DICO(0x06deeb38), DICO(0x0a501c40), DICO(0x136d8aa0),
-    DICO(0x17f16e40), DICO(0x1c119300), DICO(0x26154b00), DICO(0x2a0da100),
-    DICO(0x2f5935c0), DICO(0x37108d40), DICO(0x3aef07c0), DICO(0x3fccf340),
-    DICO(0x47e4a080), DICO(0x4d8de100), DICO(0x54eb6980), DICO(0x5cdb5380)};
-
-/* ACELP: table for decoding
-   adaptive codebook gain g_p (left column). Scaled by 2.0f.
-   innovative codebook gain g_c (right column). Scaled by 16.0f.
-*/
-const FIXP_SGL fdk_t_qua_gain7b[128 * 2] = {
-    204,   441,   464,   1977,  869,   1077,  1072,  3062,  1281,  4759,  1647,
-    1539,  1845,  7020,  1853,  634,   1995,  2336,  2351,  15400, 2661,  1165,
-    2702,  3900,  2710,  10133, 3195,  1752,  3498,  2624,  3663,  849,   3984,
-    5697,  4214,  3399,  4415,  1304,  4695,  2056,  5376,  4558,  5386,  676,
-    5518,  23554, 5567,  7794,  5644,  3061,  5672,  1513,  5957,  2338,  6533,
-    1060,  6804,  5998,  6820,  1767,  6937,  3837,  7277,  414,   7305,  2665,
-    7466,  11304, 7942,  794,   8007,  1982,  8007,  1366,  8326,  3105,  8336,
-    4810,  8708,  7954,  8989,  2279,  9031,  1055,  9247,  3568,  9283,  1631,
-    9654,  6311,  9811,  2605,  10120, 683,   10143, 4179,  10245, 1946,  10335,
-    1218,  10468, 9960,  10651, 3000,  10951, 1530,  10969, 5290,  11203, 2305,
-    11325, 3562,  11771, 6754,  11839, 1849,  11941, 4495,  11954, 1298,  11975,
-    15223, 11977, 883,   11986, 2842,  12438, 2141,  12593, 3665,  12636, 8367,
-    12658, 1594,  12886, 2628,  12984, 4942,  13146, 1115,  13224, 524,   13341,
-    3163,  13399, 1923,  13549, 5961,  13606, 1401,  13655, 2399,  13782, 3909,
-    13868, 10923, 14226, 1723,  14232, 2939,  14278, 7528,  14439, 4598,  14451,
-    984,   14458, 2265,  14792, 1403,  14818, 3445,  14899, 5709,  15017, 15362,
-    15048, 1946,  15069, 2655,  15405, 9591,  15405, 4079,  15570, 7183,  15687,
-    2286,  15691, 1624,  15699, 3068,  15772, 5149,  15868, 1205,  15970, 696,
-    16249, 3584,  16338, 1917,  16424, 2560,  16483, 4438,  16529, 6410,  16620,
-    11966, 16839, 8780,  17030, 3050,  17033, 18325, 17092, 1568,  17123, 5197,
-    17351, 2113,  17374, 980,   17566, 26214, 17609, 3912,  17639, 32767, 18151,
-    7871,  18197, 2516,  18202, 5649,  18679, 3283,  18930, 1370,  19271, 13757,
-    19317, 4120,  19460, 1973,  19654, 10018, 19764, 6792,  19912, 5135,  20040,
-    2841,  21234, 19833};
-
-/* ACELP: factor table for interpolation of LPC coeffs in LSP domain */
-const FIXP_SGL lsp_interpol_factor[2][NB_SUBFR] = {
-    {FL2FXCONST_SGL(0.125f), FL2FXCONST_SGL(0.375f), FL2FXCONST_SGL(0.625f),
-     FL2FXCONST_SGL(0.875f)}, /* for coreCoderFrameLength = 1024 */
-    {FL2FXCONST_SGL(0.166667f), FL2FXCONST_SGL(0.5f), FL2FXCONST_SGL(0.833333f),
-     0x0} /* for coreCoderFrameLength = 768  */
-};
-
-/* For bass post filter */
-#ifndef TABLE_filt_lp
-const FIXP_SGL fdk_dec_filt_lp[1 + L_FILT] = {
-    FL2FXCONST_SGL_FILT(0.088250f), FL2FXCONST_SGL_FILT(0.086410f),
-    FL2FXCONST_SGL_FILT(0.081074f), FL2FXCONST_SGL_FILT(0.072768f),
-    FL2FXCONST_SGL_FILT(0.062294f), FL2FXCONST_SGL_FILT(0.050623f),
-    FL2FXCONST_SGL_FILT(0.038774f), FL2FXCONST_SGL_FILT(0.027692f),
-    FL2FXCONST_SGL_FILT(0.018130f), FL2FXCONST_SGL_FILT(0.010578f),
-    FL2FXCONST_SGL_FILT(0.005221f), FL2FXCONST_SGL_FILT(0.001946f),
-    FL2FXCONST_SGL_FILT(0.000385f)};
-#endif
-
-/* FAC window tables for coreCoderFrameLength = 1024 */
-const FIXP_WTB FacWindowSynth128[] = {
-    WTC(0x7fff6216), WTC(0x7ffa72d1), WTC(0x7ff09478), WTC(0x7fe1c76b),
-    WTC(0x7fce0c3e), WTC(0x7fb563b3), WTC(0x7f97cebd), WTC(0x7f754e80),
-    WTC(0x7f4de451), WTC(0x7f2191b4), WTC(0x7ef05860), WTC(0x7eba3a39),
-    WTC(0x7e7f3957), WTC(0x7e3f57ff), WTC(0x7dfa98a8), WTC(0x7db0fdf8),
-    WTC(0x7d628ac6), WTC(0x7d0f4218), WTC(0x7cb72724), WTC(0x7c5a3d50),
-    WTC(0x7bf88830), WTC(0x7b920b89), WTC(0x7b26cb4f), WTC(0x7ab6cba4),
-    WTC(0x7a4210d8), WTC(0x79c89f6e), WTC(0x794a7c12), WTC(0x78c7aba2),
-    WTC(0x78403329), WTC(0x77b417df), WTC(0x77235f2d), WTC(0x768e0ea6),
-    WTC(0x75f42c0b), WTC(0x7555bd4c), WTC(0x74b2c884), WTC(0x740b53fb),
-    WTC(0x735f6626), WTC(0x72af05a7), WTC(0x71fa3949), WTC(0x71410805),
-    WTC(0x708378ff), WTC(0x6fc19385), WTC(0x6efb5f12), WTC(0x6e30e34a),
-    WTC(0x6d6227fa), WTC(0x6c8f351c), WTC(0x6bb812d1), WTC(0x6adcc964),
-    WTC(0x69fd614a), WTC(0x6919e320), WTC(0x683257ab), WTC(0x6746c7d8),
-    WTC(0x66573cbb), WTC(0x6563bf92), WTC(0x646c59bf), WTC(0x637114cc),
-    WTC(0x6271fa69), WTC(0x616f146c), WTC(0x60686ccf), WTC(0x5f5e0db3),
-    WTC(0x5e50015d), WTC(0x5d3e5237), WTC(0x5c290acc), WTC(0x5b1035cf),
-    WTC(0x59f3de12), WTC(0x58d40e8c), WTC(0x57b0d256), WTC(0x568a34a9),
-    WTC(0x556040e2), WTC(0x5433027d), WTC(0x53028518), WTC(0x51ced46e),
-    WTC(0x5097fc5e), WTC(0x4f5e08e3), WTC(0x4e210617), WTC(0x4ce10034),
-    WTC(0x4b9e0390), WTC(0x4a581c9e), WTC(0x490f57ee), WTC(0x47c3c22f),
-    WTC(0x46756828), WTC(0x452456bd), WTC(0x43d09aed), WTC(0x427a41d0),
-    WTC(0x4121589b), WTC(0x3fc5ec98), WTC(0x3e680b2c), WTC(0x3d07c1d6),
-    WTC(0x3ba51e29), WTC(0x3a402dd2), WTC(0x38d8fe93), WTC(0x376f9e46),
-    WTC(0x36041ad9), WTC(0x34968250), WTC(0x3326e2c3), WTC(0x31b54a5e),
-    WTC(0x3041c761), WTC(0x2ecc681e), WTC(0x2d553afc), WTC(0x2bdc4e6f),
-    WTC(0x2a61b101), WTC(0x28e5714b), WTC(0x27679df4), WTC(0x25e845b6),
-    WTC(0x24677758), WTC(0x22e541af), WTC(0x2161b3a0), WTC(0x1fdcdc1b),
-    WTC(0x1e56ca1e), WTC(0x1ccf8cb3), WTC(0x1b4732ef), WTC(0x19bdcbf3),
-    WTC(0x183366e9), WTC(0x16a81305), WTC(0x151bdf86), WTC(0x138edbb1),
-    WTC(0x120116d5), WTC(0x1072a048), WTC(0x0ee38766), WTC(0x0d53db92),
-    WTC(0x0bc3ac35), WTC(0x0a3308bd), WTC(0x08a2009a), WTC(0x0710a345),
-    WTC(0x057f0035), WTC(0x03ed26e6), WTC(0x025b26d7), WTC(0x00c90f88),
-};
-const FIXP_WTB FacWindowZir128[] = {
-    WTC(0x7f36f078), WTC(0x7da4d929), WTC(0x7c12d91a), WTC(0x7a80ffcb),
-    WTC(0x78ef5cbb), WTC(0x775dff66), WTC(0x75ccf743), WTC(0x743c53cb),
-    WTC(0x72ac246e), WTC(0x711c789a), WTC(0x6f8d5fb8), WTC(0x6dfee92b),
-    WTC(0x6c71244f), WTC(0x6ae4207a), WTC(0x6957ecfb), WTC(0x67cc9917),
-    WTC(0x6642340d), WTC(0x64b8cd11), WTC(0x6330734d), WTC(0x61a935e2),
-    WTC(0x602323e5), WTC(0x5e9e4c60), WTC(0x5d1abe51), WTC(0x5b9888a8),
-    WTC(0x5a17ba4a), WTC(0x5898620c), WTC(0x571a8eb5), WTC(0x559e4eff),
-    WTC(0x5423b191), WTC(0x52aac504), WTC(0x513397e2), WTC(0x4fbe389f),
-    WTC(0x4e4ab5a2), WTC(0x4cd91d3d), WTC(0x4b697db0), WTC(0x49fbe527),
-    WTC(0x489061ba), WTC(0x4727016d), WTC(0x45bfd22e), WTC(0x445ae1d7),
-    WTC(0x42f83e2a), WTC(0x4197f4d4), WTC(0x403a1368), WTC(0x3edea765),
-    WTC(0x3d85be30), WTC(0x3c2f6513), WTC(0x3adba943), WTC(0x398a97d8),
-    WTC(0x383c3dd1), WTC(0x36f0a812), WTC(0x35a7e362), WTC(0x3461fc70),
-    WTC(0x331effcc), WTC(0x31def9e9), WTC(0x30a1f71d), WTC(0x2f6803a2),
-    WTC(0x2e312b92), WTC(0x2cfd7ae8), WTC(0x2bccfd83), WTC(0x2a9fbf1e),
-    WTC(0x2975cb57), WTC(0x284f2daa), WTC(0x272bf174), WTC(0x260c21ee),
-    WTC(0x24efca31), WTC(0x23d6f534), WTC(0x22c1adc9), WTC(0x21affea3),
-    WTC(0x20a1f24d), WTC(0x1f979331), WTC(0x1e90eb94), WTC(0x1d8e0597),
-    WTC(0x1c8eeb34), WTC(0x1b93a641), WTC(0x1a9c406e), WTC(0x19a8c345),
-    WTC(0x18b93828), WTC(0x17cda855), WTC(0x16e61ce0), WTC(0x16029eb6),
-    WTC(0x1523369c), WTC(0x1447ed2f), WTC(0x1370cae4), WTC(0x129dd806),
-    WTC(0x11cf1cb6), WTC(0x1104a0ee), WTC(0x103e6c7b), WTC(0x0f7c8701),
-    WTC(0x0ebef7fb), WTC(0x0e05c6b7), WTC(0x0d50fa59), WTC(0x0ca099da),
-    WTC(0x0bf4ac05), WTC(0x0b4d377c), WTC(0x0aaa42b4), WTC(0x0a0bd3f5),
-    WTC(0x0971f15a), WTC(0x08dca0d3), WTC(0x084be821), WTC(0x07bfccd7),
-    WTC(0x0738545e), WTC(0x06b583ee), WTC(0x06376092), WTC(0x05bdef28),
-    WTC(0x0549345c), WTC(0x04d934b1), WTC(0x046df477), WTC(0x040777d0),
-    WTC(0x03a5c2b0), WTC(0x0348d8dc), WTC(0x02f0bde8), WTC(0x029d753a),
-    WTC(0x024f0208), WTC(0x02056758), WTC(0x01c0a801), WTC(0x0180c6a9),
-    WTC(0x0145c5c7), WTC(0x010fa7a0), WTC(0x00de6e4c), WTC(0x00b21baf),
-    WTC(0x008ab180), WTC(0x00683143), WTC(0x004a9c4d), WTC(0x0031f3c2),
-    WTC(0x001e3895), WTC(0x000f6b88), WTC(0x00058d2f), WTC(0x00009dea),
-};
-const FIXP_WTB FacWindowSynth64[] = {
-    WTC(0x7ffd885a), WTC(0x7fe9cbc0), WTC(0x7fc25596), WTC(0x7f872bf3),
-    WTC(0x7f3857f6), WTC(0x7ed5e5c6), WTC(0x7e5fe493), WTC(0x7dd6668f),
-    WTC(0x7d3980ec), WTC(0x7c894bde), WTC(0x7bc5e290), WTC(0x7aef6323),
-    WTC(0x7a05eead), WTC(0x7909a92d), WTC(0x77fab989), WTC(0x76d94989),
-    WTC(0x75a585cf), WTC(0x745f9dd1), WTC(0x7307c3d0), WTC(0x719e2cd2),
-    WTC(0x7023109a), WTC(0x6e96a99d), WTC(0x6cf934fc), WTC(0x6b4af279),
-    WTC(0x698c246c), WTC(0x67bd0fbd), WTC(0x65ddfbd3), WTC(0x63ef3290),
-    WTC(0x61f1003f), WTC(0x5fe3b38d), WTC(0x5dc79d7c), WTC(0x5b9d1154),
-    WTC(0x59646498), WTC(0x571deefa), WTC(0x54ca0a4b), WTC(0x5269126e),
-    WTC(0x4ffb654d), WTC(0x4d8162c4), WTC(0x4afb6c98), WTC(0x4869e665),
-    WTC(0x45cd358f), WTC(0x4325c135), WTC(0x4073f21d), WTC(0x3db832a6),
-    WTC(0x3af2eeb7), WTC(0x382493b0), WTC(0x354d9057), WTC(0x326e54c7),
-    WTC(0x2f875262), WTC(0x2c98fbba), WTC(0x29a3c485), WTC(0x26a82186),
-    WTC(0x23a6887f), WTC(0x209f701c), WTC(0x1d934fe5), WTC(0x1a82a026),
-    WTC(0x176dd9de), WTC(0x145576b1), WTC(0x1139f0cf), WTC(0x0e1bc2e4),
-    WTC(0x0afb6805), WTC(0x07d95b9e), WTC(0x04b6195d), WTC(0x01921d20),
-};
-const FIXP_WTB FacWindowZir64[] = {
-    WTC(0x7e6de2e0), WTC(0x7b49e6a3), WTC(0x7826a462), WTC(0x750497fb),
-    WTC(0x71e43d1c), WTC(0x6ec60f31), WTC(0x6baa894f), WTC(0x68922622),
-    WTC(0x657d5fda), WTC(0x626cb01b), WTC(0x5f608fe4), WTC(0x5c597781),
-    WTC(0x5957de7a), WTC(0x565c3b7b), WTC(0x53670446), WTC(0x5078ad9e),
-    WTC(0x4d91ab39), WTC(0x4ab26fa9), WTC(0x47db6c50), WTC(0x450d1149),
-    WTC(0x4247cd5a), WTC(0x3f8c0de3), WTC(0x3cda3ecb), WTC(0x3a32ca71),
-    WTC(0x3796199b), WTC(0x35049368), WTC(0x327e9d3c), WTC(0x30049ab3),
-    WTC(0x2d96ed92), WTC(0x2b35f5b5), WTC(0x28e21106), WTC(0x269b9b68),
-    WTC(0x2462eeac), WTC(0x22386284), WTC(0x201c4c73), WTC(0x1e0effc1),
-    WTC(0x1c10cd70), WTC(0x1a22042d), WTC(0x1842f043), WTC(0x1673db94),
-    WTC(0x14b50d87), WTC(0x1306cb04), WTC(0x11695663), WTC(0x0fdcef66),
-    WTC(0x0e61d32e), WTC(0x0cf83c30), WTC(0x0ba0622f), WTC(0x0a5a7a31),
-    WTC(0x0926b677), WTC(0x08054677), WTC(0x06f656d3), WTC(0x05fa1153),
-    WTC(0x05109cdd), WTC(0x043a1d70), WTC(0x0376b422), WTC(0x02c67f14),
-    WTC(0x02299971), WTC(0x01a01b6d), WTC(0x012a1a3a), WTC(0x00c7a80a),
-    WTC(0x0078d40d), WTC(0x003daa6a), WTC(0x00163440), WTC(0x000277a6),
-};
-const FIXP_WTB FacWindowSynth32[] = {
-    WTC(0x7ff62182), WTC(0x7fa736b4), WTC(0x7f0991c4), WTC(0x7e1d93ea),
-    WTC(0x7ce3ceb2), WTC(0x7b5d039e), WTC(0x798a23b1), WTC(0x776c4edb),
-    WTC(0x7504d345), WTC(0x72552c85), WTC(0x6f5f02b2), WTC(0x6c242960),
-    WTC(0x68a69e81), WTC(0x64e88926), WTC(0x60ec3830), WTC(0x5cb420e0),
-    WTC(0x5842dd54), WTC(0x539b2af0), WTC(0x4ebfe8a5), WTC(0x49b41533),
-    WTC(0x447acd50), WTC(0x3f1749b8), WTC(0x398cdd32), WTC(0x33def287),
-    WTC(0x2e110a62), WTC(0x2826b928), WTC(0x2223a4c5), WTC(0x1c0b826a),
-    WTC(0x15e21445), WTC(0x0fab272b), WTC(0x096a9049), WTC(0x03242abf),
-};
-const FIXP_WTB FacWindowZir32[] = {
-    WTC(0x7cdbd541), WTC(0x76956fb7), WTC(0x7054d8d5), WTC(0x6a1debbb),
-    WTC(0x63f47d96), WTC(0x5ddc5b3b), WTC(0x57d946d8), WTC(0x51eef59e),
-    WTC(0x4c210d79), WTC(0x467322ce), WTC(0x40e8b648), WTC(0x3b8532b0),
-    WTC(0x364beacd), WTC(0x3140175b), WTC(0x2c64d510), WTC(0x27bd22ac),
-    WTC(0x234bdf20), WTC(0x1f13c7d0), WTC(0x1b1776da), WTC(0x1759617f),
-    WTC(0x13dbd6a0), WTC(0x10a0fd4e), WTC(0x0daad37b), WTC(0x0afb2cbb),
-    WTC(0x0893b125), WTC(0x0675dc4f), WTC(0x04a2fc62), WTC(0x031c314e),
-    WTC(0x01e26c16), WTC(0x00f66e3c), WTC(0x0058c94c), WTC(0x0009de7e),
-};
-
-/* FAC window tables for coreCoderFrameLength = 768 */
-const FIXP_WTB FacWindowSynth96[] = {
-    WTC(0x7ffee744), WTC(0x7ff62182), WTC(0x7fe49698), WTC(0x7fca47b9),
-    WTC(0x7fa736b4), WTC(0x7f7b65ef), WTC(0x7f46d86c), WTC(0x7f0991c4),
-    WTC(0x7ec3962a), WTC(0x7e74ea6a), WTC(0x7e1d93ea), WTC(0x7dbd98a4),
-    WTC(0x7d54ff2e), WTC(0x7ce3ceb2), WTC(0x7c6a0ef2), WTC(0x7be7c847),
-    WTC(0x7b5d039e), WTC(0x7ac9ca7a), WTC(0x7a2e26f2), WTC(0x798a23b1),
-    WTC(0x78ddcbf5), WTC(0x78292b8d), WTC(0x776c4edb), WTC(0x76a742d1),
-    WTC(0x75da14ef), WTC(0x7504d345), WTC(0x74278c72), WTC(0x73424fa0),
-    WTC(0x72552c85), WTC(0x71603361), WTC(0x706374ff), WTC(0x6f5f02b2),
-    WTC(0x6e52ee52), WTC(0x6d3f4a40), WTC(0x6c242960), WTC(0x6b019f1a),
-    WTC(0x69d7bf57), WTC(0x68a69e81), WTC(0x676e5183), WTC(0x662eedc3),
-    WTC(0x64e88926), WTC(0x639b3a0b), WTC(0x62471749), WTC(0x60ec3830),
-    WTC(0x5f8ab487), WTC(0x5e22a487), WTC(0x5cb420e0), WTC(0x5b3f42ae),
-    WTC(0x59c42381), WTC(0x5842dd54), WTC(0x56bb8a90), WTC(0x552e4605),
-    WTC(0x539b2af0), WTC(0x520254ef), WTC(0x5063e008), WTC(0x4ebfe8a5),
-    WTC(0x4d168b8b), WTC(0x4b67e5e4), WTC(0x49b41533), WTC(0x47fb3757),
-    WTC(0x463d6a87), WTC(0x447acd50), WTC(0x42b37e96), WTC(0x40e79d8c),
-    WTC(0x3f1749b8), WTC(0x3d42a2ec), WTC(0x3b69c947), WTC(0x398cdd32),
-    WTC(0x37abff5d), WTC(0x35c750bc), WTC(0x33def287), WTC(0x31f30638),
-    WTC(0x3003ad85), WTC(0x2e110a62), WTC(0x2c1b3efb), WTC(0x2a226db5),
-    WTC(0x2826b928), WTC(0x26284422), WTC(0x2427319d), WTC(0x2223a4c5),
-    WTC(0x201dc0ef), WTC(0x1e15a99a), WTC(0x1c0b826a), WTC(0x19ff6f2a),
-    WTC(0x17f193c5), WTC(0x15e21445), WTC(0x13d114d0), WTC(0x11beb9aa),
-    WTC(0x0fab272b), WTC(0x0d9681c2), WTC(0x0b80edf1), WTC(0x096a9049),
-    WTC(0x07538d6b), WTC(0x053c0a01), WTC(0x03242abf), WTC(0x010c1460),
-};
-const FIXP_WTB FacWindowZir96[] = {
-    WTC(0x7ef3eba0), WTC(0x7cdbd541), WTC(0x7ac3f5ff), WTC(0x78ac7295),
-    WTC(0x76956fb7), WTC(0x747f120f), WTC(0x72697e3e), WTC(0x7054d8d5),
-    WTC(0x6e414656), WTC(0x6c2eeb30), WTC(0x6a1debbb), WTC(0x680e6c3b),
-    WTC(0x660090d6), WTC(0x63f47d96), WTC(0x61ea5666), WTC(0x5fe23f11),
-    WTC(0x5ddc5b3b), WTC(0x5bd8ce63), WTC(0x59d7bbde), WTC(0x57d946d8),
-    WTC(0x55dd924b), WTC(0x53e4c105), WTC(0x51eef59e), WTC(0x4ffc527b),
-    WTC(0x4e0cf9c8), WTC(0x4c210d79), WTC(0x4a38af44), WTC(0x485400a3),
-    WTC(0x467322ce), WTC(0x449636b9), WTC(0x42bd5d14), WTC(0x40e8b648),
-    WTC(0x3f186274), WTC(0x3d4c816a), WTC(0x3b8532b0), WTC(0x39c29579),
-    WTC(0x3804c8a9), WTC(0x364beacd), WTC(0x34981a1c), WTC(0x32e97475),
-    WTC(0x3140175b), WTC(0x2f9c1ff8), WTC(0x2dfdab11), WTC(0x2c64d510),
-    WTC(0x2ad1b9fb), WTC(0x29447570), WTC(0x27bd22ac), WTC(0x263bdc7f),
-    WTC(0x24c0bd52), WTC(0x234bdf20), WTC(0x21dd5b79), WTC(0x20754b79),
-    WTC(0x1f13c7d0), WTC(0x1db8e8b7), WTC(0x1c64c5f5), WTC(0x1b1776da),
-    WTC(0x19d1123d), WTC(0x1891ae7d), WTC(0x1759617f), WTC(0x162840a9),
-    WTC(0x14fe60e6), WTC(0x13dbd6a0), WTC(0x12c0b5c0), WTC(0x11ad11ae),
-    WTC(0x10a0fd4e), WTC(0x0f9c8b01), WTC(0x0e9fcc9f), WTC(0x0daad37b),
-    WTC(0x0cbdb060), WTC(0x0bd8738e), WTC(0x0afb2cbb), WTC(0x0a25eb11),
-    WTC(0x0958bd2f), WTC(0x0893b125), WTC(0x07d6d473), WTC(0x0722340b),
-    WTC(0x0675dc4f), WTC(0x05d1d90e), WTC(0x05363586), WTC(0x04a2fc62),
-    WTC(0x041837b9), WTC(0x0395f10e), WTC(0x031c314e), WTC(0x02ab00d2),
-    WTC(0x0242675c), WTC(0x01e26c16), WTC(0x018b1596), WTC(0x013c69d6),
-    WTC(0x00f66e3c), WTC(0x00b92794), WTC(0x00849a11), WTC(0x0058c94c),
-    WTC(0x0035b847), WTC(0x001b6968), WTC(0x0009de7e), WTC(0x000118bc),
-};
-const FIXP_WTB FacWindowSynth48[] = {
-    WTC(0x7ffb9d15), WTC(0x7fd8878e), WTC(0x7f92661d), WTC(0x7f294bfd),
-    WTC(0x7e9d55fc), WTC(0x7deeaa7a), WTC(0x7d1d7958), WTC(0x7c29fbee),
-    WTC(0x7b1474fd), WTC(0x79dd3098), WTC(0x78848414), WTC(0x770acdec),
-    WTC(0x757075ac), WTC(0x73b5ebd1), WTC(0x71dba9ab), WTC(0x6fe2313c),
-    WTC(0x6dca0d14), WTC(0x6b93d02e), WTC(0x694015c3), WTC(0x66cf8120),
-    WTC(0x6442bd7e), WTC(0x619a7dce), WTC(0x5ed77c8a), WTC(0x5bfa7b82),
-    WTC(0x590443a7), WTC(0x55f5a4d2), WTC(0x52cf758f), WTC(0x4f9292dc),
-    WTC(0x4c3fdff4), WTC(0x48d84609), WTC(0x455cb40c), WTC(0x41ce1e65),
-    WTC(0x3e2d7eb1), WTC(0x3a7bd382), WTC(0x36ba2014), WTC(0x32e96c09),
-    WTC(0x2f0ac320), WTC(0x2b1f34eb), WTC(0x2727d486), WTC(0x2325b847),
-    WTC(0x1f19f97b), WTC(0x1b05b40f), WTC(0x16ea0646), WTC(0x12c8106f),
-    WTC(0x0ea0f48c), WTC(0x0a75d60e), WTC(0x0647d97c), WTC(0x02182427),
-};
-const FIXP_WTB FacWindowZir48[] = {
-    WTC(0x7de7dbd9), WTC(0x79b82684), WTC(0x758a29f2), WTC(0x715f0b74),
-    WTC(0x6d37ef91), WTC(0x6915f9ba), WTC(0x64fa4bf1), WTC(0x60e60685),
-    WTC(0x5cda47b9), WTC(0x58d82b7a), WTC(0x54e0cb15), WTC(0x50f53ce0),
-    WTC(0x4d1693f7), WTC(0x4945dfec), WTC(0x45842c7e), WTC(0x41d2814f),
-    WTC(0x3e31e19b), WTC(0x3aa34bf4), WTC(0x3727b9f7), WTC(0x33c0200c),
-    WTC(0x306d6d24), WTC(0x2d308a71), WTC(0x2a0a5b2e), WTC(0x26fbbc59),
-    WTC(0x2405847e), WTC(0x21288376), WTC(0x1e658232), WTC(0x1bbd4282),
-    WTC(0x19307ee0), WTC(0x16bfea3d), WTC(0x146c2fd2), WTC(0x1235f2ec),
-    WTC(0x101dcec4), WTC(0x0e245655), WTC(0x0c4a142f), WTC(0x0a8f8a54),
-    WTC(0x08f53214), WTC(0x077b7bec), WTC(0x0622cf68), WTC(0x04eb8b03),
-    WTC(0x03d60412), WTC(0x02e286a8), WTC(0x02115586), WTC(0x0162aa04),
-    WTC(0x00d6b403), WTC(0x006d99e3), WTC(0x00277872), WTC(0x000462eb),
-};
--- a/libAACdec/src/usacdec_rom.h
+++ /dev/null
@@ -1,154 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/**************************** AAC decoder library ******************************
-
-   Author(s):   M. Jander
-
-   Description: re8.h
-
-*******************************************************************************/
-
-#ifndef USACDEC_ROM_H
-#define USACDEC_ROM_H
-
-#include "common_fix.h"
-#include "FDK_lpc.h"
-
-#include "usacdec_const.h"
-
-/* RE8 lattice quantiser constants */
-#define NB_SPHERE 32
-#define NB_LEADER 37
-#define NB_LDSIGN 226
-#define NB_LDQ3 9
-#define NB_LDQ4 28
-
-#define LSF_SCALE 13
-
-/* RE8 lattice quantiser tables */
-extern const UINT fdk_dec_tab_factorial[8];
-extern const UCHAR fdk_dec_Ia[NB_LEADER];
-extern const UCHAR fdk_dec_Ds[NB_LDSIGN];
-extern const USHORT fdk_dec_Is[NB_LDSIGN];
-extern const UCHAR fdk_dec_Ns[], fdk_dec_A3[], fdk_dec_A4[];
-extern const UCHAR fdk_dec_Da[][8];
-extern const USHORT fdk_dec_I3[], fdk_dec_I4[];
-
-/* temp float tables for LPC decoding */
-extern const FIXP_LPC fdk_dec_lsf_init[16];
-extern const FIXP_LPC fdk_dec_dico_lsf_abs_8b[16 * 256];
-
-/* ACELP tables */
-#define SF_QUA_GAIN7B 4
-extern const FIXP_SGL fdk_t_qua_gain7b[128 * 2];
-extern const FIXP_SGL lsp_interpol_factor[2][NB_SUBFR];
-
-/* For bass post filter */
-#define L_FILT 12 /* Delay of up-sampling filter                */
-
-extern const FIXP_SGL fdk_dec_filt_lp[1 + L_FILT];
-
-extern const FIXP_WTB FacWindowSynth128[128];
-extern const FIXP_WTB FacWindowZir128[128];
-extern const FIXP_WTB FacWindowSynth64[64];
-extern const FIXP_WTB FacWindowZir64[64];
-extern const FIXP_WTB FacWindowSynth32[32];
-extern const FIXP_WTB FacWindowZir32[32];
-extern const FIXP_WTB FacWindowSynth96[96];
-extern const FIXP_WTB FacWindowZir96[96];
-extern const FIXP_WTB FacWindowSynth48[48];
-extern const FIXP_WTB FacWindowZir48[48];
-
-#endif /* USACDEC_ROM_H */
