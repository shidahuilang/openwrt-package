From b13485d2c310d339e4f55359741ae6b0d6912bbd Mon Sep 17 00:00:00 2001
From: Wim Taymans <wtaymans@redhat.com>
Date: Tue, 25 Jun 2019 12:31:47 +0200
Subject: Remove MPS surround sound encoder

---
 Makefile.am                              |   37 -
 Makefile.vc                              |   35 -
 libAACdec/src/aacdecoder.cpp             |  160 +--
 libAACdec/src/aacdecoder.h               |   11 -
 libAACdec/src/aacdecoder_lib.cpp         |  206 +--
 libAACenc/src/aacenc_lib.cpp             |   95 +-
 libAACenc/src/mps_main.cpp               |  529 --------
 libAACenc/src/mps_main.h                 |  270 ----
 libSACdec/include/sac_dec_errorcodes.h   |  157 ---
 libSACdec/include/sac_dec_lib.h          |  477 -------
 libSACdec/src/sac_bitdec.cpp             | 2167 ------------------------------
 libSACdec/src/sac_bitdec.h               |  161 ---
 libSACdec/src/sac_calcM1andM2.cpp        |  848 ------------
 libSACdec/src/sac_calcM1andM2.h          |  129 --
 libSACdec/src/sac_dec.cpp                | 1509 ---------------------
 libSACdec/src/sac_dec.h                  |  539 --------
 libSACdec/src/sac_dec_conceal.cpp        |  392 ------
 libSACdec/src/sac_dec_conceal.h          |  187 ---
 libSACdec/src/sac_dec_interface.h        |  335 -----
 libSACdec/src/sac_dec_lib.cpp            | 1995 ---------------------------
 libSACdec/src/sac_dec_ssc_struct.h       |  283 ----
 libSACdec/src/sac_process.cpp            | 1066 ---------------
 libSACdec/src/sac_process.h              |  297 ----
 libSACdec/src/sac_qmf.cpp                |  156 ---
 libSACdec/src/sac_qmf.h                  |  143 --
 libSACdec/src/sac_reshapeBBEnv.cpp       |  680 ----------
 libSACdec/src/sac_reshapeBBEnv.h         |  114 --
 libSACdec/src/sac_rom.cpp                |  709 ----------
 libSACdec/src/sac_rom.h                  |  230 ----
 libSACdec/src/sac_smoothing.cpp          |  295 ----
 libSACdec/src/sac_smoothing.h            |  114 --
 libSACdec/src/sac_stp.cpp                |  548 --------
 libSACdec/src/sac_stp.h                  |  115 --
 libSACdec/src/sac_tsd.cpp                |  353 -----
 libSACdec/src/sac_tsd.h                  |  167 ---
 libSACenc/include/sacenc_lib.h           |  405 ------
 libSACenc/src/sacenc_bitstream.cpp       |  826 ------------
 libSACenc/src/sacenc_bitstream.h         |  296 ----
 libSACenc/src/sacenc_const.h             |  126 --
 libSACenc/src/sacenc_delay.cpp           |  472 -------
 libSACenc/src/sacenc_delay.h             |  175 ---
 libSACenc/src/sacenc_dmx_tdom_enh.cpp    |  639 ---------
 libSACenc/src/sacenc_dmx_tdom_enh.h      |  134 --
 libSACenc/src/sacenc_filter.cpp          |  207 ---
 libSACenc/src/sacenc_filter.h            |  133 --
 libSACenc/src/sacenc_framewindowing.cpp  |  568 --------
 libSACenc/src/sacenc_framewindowing.h    |  181 ---
 libSACenc/src/sacenc_huff_tab.cpp        |  997 --------------
 libSACenc/src/sacenc_huff_tab.h          |  222 ---
 libSACenc/src/sacenc_lib.cpp             | 2042 ----------------------------
 libSACenc/src/sacenc_nlc_enc.cpp         | 1442 --------------------
 libSACenc/src/sacenc_nlc_enc.h           |  141 --
 libSACenc/src/sacenc_onsetdetect.cpp     |  381 ------
 libSACenc/src/sacenc_onsetdetect.h       |  154 ---
 libSACenc/src/sacenc_paramextract.cpp    |  725 ----------
 libSACenc/src/sacenc_paramextract.h      |  214 ---
 libSACenc/src/sacenc_staticgain.cpp      |  446 ------
 libSACenc/src/sacenc_staticgain.h        |  177 ---
 libSACenc/src/sacenc_tree.cpp            |  488 -------
 libSACenc/src/sacenc_tree.h              |  168 ---
 libSACenc/src/sacenc_vectorfunctions.cpp |  450 -------
 libSACenc/src/sacenc_vectorfunctions.h   |  488 -------
 62 files changed, 9 insertions(+), 28197 deletions(-)
 delete mode 100644 libAACenc/src/mps_main.cpp
 delete mode 100644 libAACenc/src/mps_main.h
 delete mode 100644 libSACdec/include/sac_dec_errorcodes.h
 delete mode 100644 libSACdec/include/sac_dec_lib.h
 delete mode 100644 libSACdec/src/sac_bitdec.cpp
 delete mode 100644 libSACdec/src/sac_bitdec.h
 delete mode 100644 libSACdec/src/sac_calcM1andM2.cpp
 delete mode 100644 libSACdec/src/sac_calcM1andM2.h
 delete mode 100644 libSACdec/src/sac_dec.cpp
 delete mode 100644 libSACdec/src/sac_dec.h
 delete mode 100644 libSACdec/src/sac_dec_conceal.cpp
 delete mode 100644 libSACdec/src/sac_dec_conceal.h
 delete mode 100644 libSACdec/src/sac_dec_interface.h
 delete mode 100644 libSACdec/src/sac_dec_lib.cpp
 delete mode 100644 libSACdec/src/sac_dec_ssc_struct.h
 delete mode 100644 libSACdec/src/sac_process.cpp
 delete mode 100644 libSACdec/src/sac_process.h
 delete mode 100644 libSACdec/src/sac_qmf.cpp
 delete mode 100644 libSACdec/src/sac_qmf.h
 delete mode 100644 libSACdec/src/sac_reshapeBBEnv.cpp
 delete mode 100644 libSACdec/src/sac_reshapeBBEnv.h
 delete mode 100644 libSACdec/src/sac_rom.cpp
 delete mode 100644 libSACdec/src/sac_rom.h
 delete mode 100644 libSACdec/src/sac_smoothing.cpp
 delete mode 100644 libSACdec/src/sac_smoothing.h
 delete mode 100644 libSACdec/src/sac_stp.cpp
 delete mode 100644 libSACdec/src/sac_stp.h
 delete mode 100644 libSACdec/src/sac_tsd.cpp
 delete mode 100644 libSACdec/src/sac_tsd.h
 delete mode 100644 libSACenc/include/sacenc_lib.h
 delete mode 100644 libSACenc/src/sacenc_bitstream.cpp
 delete mode 100644 libSACenc/src/sacenc_bitstream.h
 delete mode 100644 libSACenc/src/sacenc_const.h
 delete mode 100644 libSACenc/src/sacenc_delay.cpp
 delete mode 100644 libSACenc/src/sacenc_delay.h
 delete mode 100644 libSACenc/src/sacenc_dmx_tdom_enh.cpp
 delete mode 100644 libSACenc/src/sacenc_dmx_tdom_enh.h
 delete mode 100644 libSACenc/src/sacenc_filter.cpp
 delete mode 100644 libSACenc/src/sacenc_filter.h
 delete mode 100644 libSACenc/src/sacenc_framewindowing.cpp
 delete mode 100644 libSACenc/src/sacenc_framewindowing.h
 delete mode 100644 libSACenc/src/sacenc_huff_tab.cpp
 delete mode 100644 libSACenc/src/sacenc_huff_tab.h
 delete mode 100644 libSACenc/src/sacenc_lib.cpp
 delete mode 100644 libSACenc/src/sacenc_nlc_enc.cpp
 delete mode 100644 libSACenc/src/sacenc_nlc_enc.h
 delete mode 100644 libSACenc/src/sacenc_onsetdetect.cpp
 delete mode 100644 libSACenc/src/sacenc_onsetdetect.h
 delete mode 100644 libSACenc/src/sacenc_paramextract.cpp
 delete mode 100644 libSACenc/src/sacenc_paramextract.h
 delete mode 100644 libSACenc/src/sacenc_staticgain.cpp
 delete mode 100644 libSACenc/src/sacenc_staticgain.h
 delete mode 100644 libSACenc/src/sacenc_tree.cpp
 delete mode 100644 libSACenc/src/sacenc_tree.h
 delete mode 100644 libSACenc/src/sacenc_vectorfunctions.cpp
 delete mode 100644 libSACenc/src/sacenc_vectorfunctions.h

--- a/Makefile.am
+++ b/Makefile.am
@@ -6,8 +6,6 @@ AM_CPPFLAGS = \
     -I$(top_srcdir)/libAACenc/include \
     -I$(top_srcdir)/libArithCoding/include \
     -I$(top_srcdir)/libDRCdec/include \
-    -I$(top_srcdir)/libSACdec/include \
-    -I$(top_srcdir)/libSACenc/include \
     -I$(top_srcdir)/libMpegTPDec/include \
     -I$(top_srcdir)/libMpegTPEnc/include \
     -I$(top_srcdir)/libSYS/include \
@@ -89,7 +87,6 @@ AACENC_SRC = \
     libAACenc/src/line_pe.cpp \
     libAACenc/src/metadata_compressor.cpp \
     libAACenc/src/metadata_main.cpp \
-    libAACenc/src/mps_main.cpp \
     libAACenc/src/ms_stereo.cpp \
     libAACenc/src/noisedet.cpp \
     libAACenc/src/pnsparam.cpp \
@@ -159,35 +156,6 @@ PCMUTILS_SRC = \
     libPCMutils/src/pcm_utils.cpp \
     libPCMutils/src/pcmdmx_lib.cpp
 
-SACDEC_SRC = \
-    libSACdec/src/sac_bitdec.cpp \
-    libSACdec/src/sac_calcM1andM2.cpp \
-    libSACdec/src/sac_dec.cpp \
-    libSACdec/src/sac_dec_conceal.cpp \
-    libSACdec/src/sac_dec_lib.cpp \
-    libSACdec/src/sac_process.cpp \
-    libSACdec/src/sac_qmf.cpp \
-    libSACdec/src/sac_reshapeBBEnv.cpp \
-    libSACdec/src/sac_rom.cpp \
-    libSACdec/src/sac_smoothing.cpp \
-    libSACdec/src/sac_stp.cpp \
-    libSACdec/src/sac_tsd.cpp
-
-SACENC_SRC = \
-    libSACenc/src/sacenc_bitstream.cpp \
-    libSACenc/src/sacenc_delay.cpp \
-    libSACenc/src/sacenc_dmx_tdom_enh.cpp \
-    libSACenc/src/sacenc_filter.cpp \
-    libSACenc/src/sacenc_framewindowing.cpp \
-    libSACenc/src/sacenc_huff_tab.cpp \
-    libSACenc/src/sacenc_lib.cpp \
-    libSACenc/src/sacenc_nlc_enc.cpp \
-    libSACenc/src/sacenc_onsetdetect.cpp \
-    libSACenc/src/sacenc_paramextract.cpp \
-    libSACenc/src/sacenc_staticgain.cpp \
-    libSACenc/src/sacenc_tree.cpp \
-    libSACenc/src/sacenc_vectorfunctions.cpp
-
 SYS_SRC = \
     libSYS/src/genericStds.cpp \
     libSYS/src/syslib_channelMapDescr.cpp
@@ -197,7 +165,6 @@ libfdk_aac_la_SOURCES = \
     $(ARITHCODING_SRC) \
     $(DRCDEC_SRC) \
     $(MPEGTPDEC_SRC) $(MPEGTPENC_SRC) \
-    $(SACDEC_SRC) $(SACENC_SRC) \
     $(PCMUTILS_SRC) $(FDK_SRC) $(SYS_SRC)
 
 EXTRA_DIST = \
@@ -216,10 +183,6 @@ EXTRA_DIST = \
     $(top_srcdir)/libArithCoding/include/*.h \
     $(top_srcdir)/libDRCdec/include/*.h \
     $(top_srcdir)/libDRCdec/src/*.h \
-    $(top_srcdir)/libSACdec/include/*.h \
-    $(top_srcdir)/libSACdec/src/*.h \
-    $(top_srcdir)/libSACenc/include/*.h \
-    $(top_srcdir)/libSACenc/src/*.h \
     $(top_srcdir)/libSYS/include/*.h \
     $(top_srcdir)/libPCMutils/include/*.h \
     $(top_srcdir)/libPCMutils/src/*.h \
--- a/Makefile.vc
+++ b/Makefile.vc
@@ -21,8 +21,6 @@ AM_CPPFLAGS = \
     -IlibAACenc/include \
     -IlibArithCoding/include \
     -IlibDRCdec/include \
-    -IlibSACdec/include \
-    -IlibSACenc/include \
     -IlibMpegTPDec/include \
     -IlibMpegTPEnc/include \
     -IlibSYS/include \
@@ -73,7 +71,6 @@ AACENC_SRC = \
     libAACenc/src/line_pe.cpp \
     libAACenc/src/metadata_compressor.cpp \
     libAACenc/src/metadata_main.cpp \
-    libAACenc/src/mps_main.cpp \
     libAACenc/src/ms_stereo.cpp \
     libAACenc/src/noisedet.cpp \
     libAACenc/src/pnsparam.cpp \
@@ -143,35 +140,6 @@ PCMUTILS_SRC = \
     libPCMutils/src/pcm_utils.cpp \
     libPCMutils/src/pcmdmx_lib.cpp
 
-SACDEC_SRC = \
-    libSACdec/src/sac_bitdec.cpp \
-    libSACdec/src/sac_calcM1andM2.cpp \
-    libSACdec/src/sac_dec.cpp \
-    libSACdec/src/sac_dec_conceal.cpp \
-    libSACdec/src/sac_dec_lib.cpp \
-    libSACdec/src/sac_process.cpp \
-    libSACdec/src/sac_qmf.cpp \
-    libSACdec/src/sac_reshapeBBEnv.cpp \
-    libSACdec/src/sac_rom.cpp \
-    libSACdec/src/sac_smoothing.cpp \
-    libSACdec/src/sac_stp.cpp \
-    libSACdec/src/sac_tsd.cpp
-
-SACENC_SRC = \
-    libSACenc/src/sacenc_bitstream.cpp \
-    libSACenc/src/sacenc_delay.cpp \
-    libSACenc/src/sacenc_dmx_tdom_enh.cpp \
-    libSACenc/src/sacenc_filter.cpp \
-    libSACenc/src/sacenc_framewindowing.cpp \
-    libSACenc/src/sacenc_huff_tab.cpp \
-    libSACenc/src/sacenc_lib.cpp \
-    libSACenc/src/sacenc_nlc_enc.cpp \
-    libSACenc/src/sacenc_onsetdetect.cpp \
-    libSACenc/src/sacenc_paramextract.cpp \
-    libSACenc/src/sacenc_staticgain.cpp \
-    libSACenc/src/sacenc_tree.cpp \
-    libSACenc/src/sacenc_vectorfunctions.cpp
-
 SYS_SRC = \
     libSYS/src/genericStds.cpp \
     libSYS/src/syslib_channelMapDescr.cpp
@@ -181,7 +149,6 @@ libfdk_aac_SOURCES = \
     $(ARITHCODING_SRC) \
     $(DRCDEC_SRC) \
     $(MPEGTPDEC_SRC) $(MPEGTPENC_SRC) \
-    $(SACDEC_SRC) $(SACENC_SRC) \
     $(PCMUTILS_SRC) $(FDK_SRC) $(SYS_SRC)
 
 
@@ -227,8 +194,6 @@ clean:
 	del /f libMpegTPDec\src\*.obj 2>NUL
 	del /f libMpegTPEnc\src\*.obj 2>NUL
 	del /f libPCMutils\src\*.obj 2>NUL
-	del /f libSACdec\src\*.obj 2>NUL
-	del /f libSACenc\src\*.obj 2>NUL
 	del /f libSYS\src\*.obj 2>NUL
 
 install: $(INST_DIRS)
--- a/libAACdec/src/aacdecoder.cpp
+++ b/libAACdec/src/aacdecoder.cpp
@@ -161,8 +161,6 @@ amm-info@iis.fraunhofer.de
 
 #include "aacdec_pns.h"
 
-#include "sac_dec_lib.h"
-
 #include "usacdec_lpd.h"
 
 #include "ac_arith_coder.h"
@@ -201,47 +199,6 @@ void CAacDecoder_SyncQmfMode(HANDLE_AACD
     }
   }
 
-  if (self->mpsEnableCurr) {
-    if (IS_LOWDELAY(self->streamInfo.aot) &&
-        (self->qmfModeCurr == MODE_LP)) { /* Overrule user requested QMF mode */
-      self->qmfModeCurr = MODE_HQ;
-    }
-    /* Set and check if MPS decoder allows the current mode */
-    switch (mpegSurroundDecoder_SetParam(
-        (CMpegSurroundDecoder *)self->pMpegSurroundDecoder,
-        SACDEC_PARTIALLY_COMPLEX, self->qmfModeCurr == MODE_LP)) {
-      case MPS_OK:
-        break;
-      case MPS_INVALID_PARAMETER: { /* Only one mode supported. Find out which
-                                       one: */
-        LIB_INFO libInfo[FDK_MODULE_LAST];
-        UINT mpsCaps;
-
-        FDKinitLibInfo(libInfo);
-        mpegSurroundDecoder_GetLibInfo(libInfo);
-        mpsCaps = FDKlibInfo_getCapabilities(libInfo, FDK_MPSDEC);
-
-        if (((mpsCaps & CAPF_MPS_LP) && (self->qmfModeCurr == MODE_LP)) ||
-            ((mpsCaps & CAPF_MPS_HQ) &&
-             (self->qmfModeCurr ==
-              MODE_HQ))) { /* MPS decoder does support the requested mode. */
-          break;
-        }
-      }
-        FDK_FALLTHROUGH;
-      default:
-        if (self->qmfModeUser == NOT_DEFINED) {
-          /* Revert in case mpegSurroundDecoder_SetParam() fails. */
-          self->qmfModeCurr =
-              (self->qmfModeCurr == MODE_LP) ? MODE_HQ : MODE_LP;
-        } else {
-          /* in case specific mode was requested we disable MPS and playout the
-           * downmix */
-          self->mpsEnableCurr = 0;
-        }
-    }
-  }
-
   self->psPossible =
       ((CAN_DO_PS(self->streamInfo.aot) &&
         !PS_IS_EXPLICITLY_DISABLED(self->streamInfo.aot, self->flags[0]) &&
@@ -876,45 +833,6 @@ static AAC_DECODER_ERROR CAacDecoder_Ext
           goto bail;
         }
 
-        /* Handle SBR dual rate case */
-        if (self->streamInfo.extSamplingRate != 0) {
-          mpsSampleRate = self->streamInfo.extSamplingRate;
-          mpsFrameSize = self->streamInfo.aacSamplesPerFrame *
-                         (self->streamInfo.extSamplingRate /
-                          self->streamInfo.aacSampleRate);
-        } else {
-          mpsSampleRate = self->streamInfo.aacSampleRate;
-          mpsFrameSize = self->streamInfo.aacSamplesPerFrame;
-        }
-        /* Setting of internal MPS state; may be reset in
-           CAacDecoder_SyncQmfMode if decoder is unable to decode with user
-           defined qmfMode */
-        if (!(self->flags[0] & (AC_USAC | AC_RSVD50 | AC_ELD))) {
-          self->mpsEnableCurr = self->mpsEnableUser;
-        }
-        if (self->mpsEnableCurr) {
-          if (!self->qmfDomain.globalConf.qmfDomainExplicitConfig) {
-            /* if not done yet, allocate full MPEG Surround decoder instance */
-            if (mpegSurroundDecoder_IsFullMpegSurroundDecoderInstanceAvailable(
-                    (CMpegSurroundDecoder *)self->pMpegSurroundDecoder) ==
-                SAC_INSTANCE_NOT_FULL_AVAILABLE) {
-              if (mpegSurroundDecoder_Open(
-                      (CMpegSurroundDecoder **)&self->pMpegSurroundDecoder, -1,
-                      &self->qmfDomain)) {
-                return AAC_DEC_OUT_OF_MEMORY;
-              }
-            }
-          }
-          err = mpegSurroundDecoder_Parse(
-              (CMpegSurroundDecoder *)self->pMpegSurroundDecoder, hBs, count,
-              self->streamInfo.aot, mpsSampleRate, mpsFrameSize,
-              self->flags[0] & AC_INDEP);
-          if (err == MPS_OK) {
-            self->flags[0] |= AC_MPS_PRESENT;
-          } else {
-            error = AAC_DEC_PARSE_ERROR;
-          }
-        }
         /* Skip any trailing bytes */
         FDKpushFor(hBs, *count);
         *count = 0;
@@ -1080,15 +998,8 @@ static AAC_DECODER_ERROR aacDecoder_Pars
   if ((bitCnt > 0) && (self->flags[0] & (AC_USAC | AC_RSVD50))) {
     if ((self->flags[0] & AC_MPS_PRESENT) ||
         (self->elFlags[element_index] & AC_EL_USAC_MPS212)) {
-      int err;
-
-      err = mpegSurroundDecoder_ParseNoHeader(
-          (CMpegSurroundDecoder *)self->pMpegSurroundDecoder, bs, &bitCnt,
-          self->flags[0] & AC_INDEP);
-      if (err != MPS_OK) {
-        self->frameOK = 0;
-        ErrorStatus = AAC_DEC_PARSE_ERROR;
-      }
+      self->frameOK = 0;
+      ErrorStatus = AAC_DEC_PARSE_ERROR;
     }
   }
 
@@ -1581,58 +1492,6 @@ CAacDecoder_Init(HANDLE_AACDECODER self,
             asc->m_sc.m_usacConfig.m_usacNumElements;
       }
 
-      self->mpsEnableCurr = 0;
-      for (int _el = 0;
-           _el < (int)self->pUsacConfig[streamIndex]->m_usacNumElements;
-           _el++) {
-        int el = _el + elementOffset;
-        if (self->elements[el] !=
-            self->pUsacConfig[streamIndex]->element[_el].usacElementType) {
-          ascChanged = 1;
-        }
-        if (self->usacStereoConfigIndex[el] !=
-            asc->m_sc.m_usacConfig.element[_el].m_stereoConfigIndex) {
-          ascChanged = 1;
-        }
-        if (configMode & AC_CM_ALLOC_MEM) {
-          self->elements[el] =
-              self->pUsacConfig[streamIndex]->element[_el].usacElementType;
-          /* for Unified Stereo Coding */
-          self->usacStereoConfigIndex[el] =
-              asc->m_sc.m_usacConfig.element[_el].m_stereoConfigIndex;
-          if (self->elements[el] == ID_USAC_CPE) {
-            self->mpsEnableCurr |= self->usacStereoConfigIndex[el] ? 1 : 0;
-          }
-        }
-
-        self->elFlags[el] |=
-            (asc->m_sc.m_usacConfig.element[_el].m_noiseFilling)
-                ? AC_EL_USAC_NOISE
-                : 0;
-        self->elFlags[el] |=
-            (asc->m_sc.m_usacConfig.element[_el].m_stereoConfigIndex > 0)
-                ? AC_EL_USAC_MPS212
-                : 0;
-        self->elFlags[el] |= (asc->m_sc.m_usacConfig.element[_el].m_interTes)
-                                 ? AC_EL_USAC_ITES
-                                 : 0;
-        self->elFlags[el] |=
-            (asc->m_sc.m_usacConfig.element[_el].m_pvc) ? AC_EL_USAC_PVC : 0;
-        self->elFlags[el] |=
-            (asc->m_sc.m_usacConfig.element[_el].usacElementType == ID_USAC_LFE)
-                ? AC_EL_USAC_LFE
-                : 0;
-        self->elFlags[el] |=
-            (asc->m_sc.m_usacConfig.element[_el].usacElementType == ID_USAC_LFE)
-                ? AC_EL_LFE
-                : 0;
-        if ((asc->m_sc.m_usacConfig.element[_el].usacElementType ==
-             ID_USAC_CPE) &&
-            ((self->usacStereoConfigIndex[el] == 0))) {
-          self->elFlags[el] |= AC_EL_USAC_CP_POSSIBLE;
-        }
-      }
-
       self->hasAudioPreRoll = 0;
       if (self->pUsacConfig[streamIndex]->m_usacNumElements) {
         self->hasAudioPreRoll = asc->m_sc.m_usacConfig.element[0]
@@ -1764,7 +1623,6 @@ CAacDecoder_Init(HANDLE_AACDECODER self,
   self->flags[streamIndex] |= (asc->m_hcrFlag) ? AC_ER_HCR : 0;
 
   if (asc->m_aot == AOT_ER_AAC_ELD) {
-    self->mpsEnableCurr = 0;
     self->flags[streamIndex] |= AC_ELD;
     self->flags[streamIndex] |=
         (asc->m_sbrPresentFlag)
@@ -1776,9 +1634,7 @@ CAacDecoder_Init(HANDLE_AACDECODER self,
     self->flags[streamIndex] |=
         (asc->m_sc.m_eldSpecificConfig.m_useLdQmfTimeAlign) ? AC_MPS_PRESENT
                                                             : 0;
-    if (self->mpsApplicable) {
-      self->mpsEnableCurr = asc->m_sc.m_eldSpecificConfig.m_useLdQmfTimeAlign;
-    }
+
   }
   self->flags[streamIndex] |= (asc->m_aot == AOT_ER_AAC_LD) ? AC_LD : 0;
   self->flags[streamIndex] |= (asc->m_epConfig >= 0) ? AC_ER : 0;
@@ -1867,14 +1723,6 @@ CAacDecoder_Init(HANDLE_AACDECODER self,
       case AOT_USAC:
         break;
       case AOT_ER_AAC_ELD:
-        if (self->mpsEnableCurr &&
-            asc->m_sc.m_eldSpecificConfig.m_useLdQmfTimeAlign) {
-          SAC_INPUT_CONFIG sac_interface = SAC_INTERFACE_TIME;
-          mpegSurroundDecoder_ConfigureQmfDomain(
-              (CMpegSurroundDecoder *)self->pMpegSurroundDecoder, sac_interface,
-              (UINT)self->streamInfo.aacSampleRate, asc->m_aot);
-          self->qmfDomain.globalConf.qmfDomainExplicitConfig = 1;
-        }
         break;
       default:
         self->qmfDomain.globalConf.qmfDomainExplicitConfig =
@@ -3128,8 +2976,6 @@ LINKSPEC_CPP AAC_DECODER_ERROR CAacDecod
 
     if (self->flags[streamIndex] & AC_USAC) {
       int bsPseudoLr = 0;
-      mpegSurroundDecoder_IsPseudoLR(
-          (CMpegSurroundDecoder *)self->pMpegSurroundDecoder, &bsPseudoLr);
       /* ISO/IEC 23003-3, 7.11.2.6 Modification of core decoder output (pseudo
        * LR) */
       if ((aacChannels == 2) && bsPseudoLr) {
--- a/libAACdec/src/aacdecoder.h
+++ b/libAACdec/src/aacdecoder.h
@@ -276,17 +276,6 @@ This structure is allocated once for eac
   HANDLE_AAC_DRC hDrcInfo; /*!< handle to DRC data structure               */
   INT metadataExpiry;      /*!< Metadata expiry time in milli-seconds.     */
 
-  void *pMpegSurroundDecoder; /*!< pointer to mpeg surround decoder structure */
-  UCHAR mpsEnableUser;        /*!< MPS enable user flag                       */
-  UCHAR mpsEnableCurr;        /*!< MPS enable decoder state                   */
-  UCHAR mpsApplicable;        /*!< MPS applicable                             */
-  SCHAR mpsOutputMode; /*!< setting: normal = 0, binaural = 1, stereo = 2, 5.1ch
-                          = 3 */
-  INT mpsOutChannelsLast; /*!< The amount of channels returned by the last
-                             successful MPS decoder call. */
-  INT mpsFrameSizeLast;   /*!< The frame length returned by the last successful
-                             MPS decoder call. */
-
   CAncData ancData; /*!< structure to handle ancillary data         */
 
   HANDLE_PCM_DOWNMIX hPcmUtils; /*!< privat data for the PCM utils. */
--- a/libAACdec/src/aacdecoder_lib.cpp
+++ b/libAACdec/src/aacdecoder_lib.cpp
@@ -109,8 +109,6 @@ amm-info@iis.fraunhofer.de
 
 #include "aacdec_drc.h"
 
-#include "sac_dec_lib.h"
-
 #include "pcm_utils.h"
 
 /* Decoder library info */
@@ -306,14 +304,6 @@ static INT aacDecoder_FreeMemCallback(vo
     errTp = TRANSPORTDEC_UNKOWN_ERROR;
   }
 
-  /* free pSpatialDec and mpsData */
-  if (self->pMpegSurroundDecoder != NULL) {
-    if (mpegSurroundDecoder_FreeMem(
-            (CMpegSurroundDecoder *)self->pMpegSurroundDecoder) != MPS_OK) {
-      errTp = TRANSPORTDEC_UNKOWN_ERROR;
-    }
-  }
-
   /* free persistent qmf domain buffer, QmfWorkBufferCore3, QmfWorkBufferCore4,
    * QmfWorkBufferCore5 and configuration variables */
   FDK_QmfDomain_FreeMem(&self->qmfDomain);
@@ -344,44 +334,9 @@ static INT aacDecoder_SscCallback(void *
                                   const INT coreSbrFrameLengthIndex,
                                   const INT configBytes, const UCHAR configMode,
                                   UCHAR *configChanged) {
-  SACDEC_ERROR err;
   TRANSPORTDEC_ERROR errTp;
   HANDLE_AACDECODER hAacDecoder = (HANDLE_AACDECODER)handle;
-
-  err = mpegSurroundDecoder_Config(
-      (CMpegSurroundDecoder *)hAacDecoder->pMpegSurroundDecoder, hBs, coreCodec,
-      samplingRate, frameSize, stereoConfigIndex, coreSbrFrameLengthIndex,
-      configBytes, configMode, configChanged);
-
-  switch (err) {
-    case MPS_UNSUPPORTED_CONFIG:
-      /* MPS found but invalid or not decodable by this instance            */
-      /* We switch off MPS and keep going                                   */
-      hAacDecoder->mpsEnableCurr = 0;
-      hAacDecoder->mpsApplicable = 0;
-      errTp = TRANSPORTDEC_OK;
-      break;
-    case MPS_PARSE_ERROR:
-      /* MPS found but invalid or not decodable by this instance            */
-      hAacDecoder->mpsEnableCurr = 0;
-      hAacDecoder->mpsApplicable = 0;
-      if ((coreCodec == AOT_USAC) || (coreCodec == AOT_DRM_USAC) ||
-          IS_LOWDELAY(coreCodec)) {
-        errTp = TRANSPORTDEC_PARSE_ERROR;
-      } else {
-        errTp = TRANSPORTDEC_OK;
-      }
-      break;
-    case MPS_OK:
-      hAacDecoder->mpsApplicable = 1;
-      errTp = TRANSPORTDEC_OK;
-      break;
-    default:
-      /* especially Parsing error is critical for transport layer          */
-      hAacDecoder->mpsApplicable = 0;
-      errTp = TRANSPORTDEC_UNKOWN_ERROR;
-  }
-
+  errTp = TRANSPORTDEC_UNKOWN_ERROR;
   return (INT)errTp;
 }
 
@@ -451,8 +406,6 @@ static int isSupportedMpsConfig(AUDIO_OB
 
   FDKinitLibInfo(libInfo);
 
-  mpegSurroundDecoder_GetLibInfo(libInfo);
-
   mpsCaps = FDKlibInfo_getCapabilities(libInfo, FDK_MPSDEC);
 
   if (!(mpsCaps & CAPF_MPS_LD) && IS_LOWDELAY(aot)) {
@@ -869,19 +822,6 @@ LINKSPEC_CPP HANDLE_AACDECODER aacDecode
   FDKmemclear(&aacDec->qmfDomain, sizeof(FDK_QMF_DOMAIN));
   aacDec->qmfModeUser = NOT_DEFINED;
 
-  if (mpegSurroundDecoder_Open(
-          (CMpegSurroundDecoder **)&aacDec->pMpegSurroundDecoder,
-          stereoConfigIndex, &aacDec->qmfDomain)) {
-    err = -1;
-    goto bail;
-  }
-  /* Set MPEG Surround defaults */
-  aacDec->mpsEnableUser = 0;
-  aacDec->mpsEnableCurr = 0;
-  aacDec->mpsApplicable = 0;
-  aacDec->mpsOutputMode = (SCHAR)SACDEC_OUT_MODE_NORMAL;
-  transportDec_RegisterSscCallback(pIn, aacDecoder_SscCallback, (void *)aacDec);
-
   {
     if (FDK_drcDec_Open(&(aacDec->hUniDrcDecoder), DRC_DEC_ALL) != 0) {
       err = -1;
@@ -952,12 +892,6 @@ LINKSPEC_CPP AAC_DECODER_ERROR aacDecode
 
 static void aacDecoder_SignalInterruption(HANDLE_AACDECODER self) {
   CAacDecoder_SignalInterruption(self);
-
-  if (self->mpsEnableUser) {
-    mpegSurroundDecoder_SetParam(
-        (CMpegSurroundDecoder *)self->pMpegSurroundDecoder,
-        SACDEC_BS_INTERRUPTION, 1);
-  }
 }
 
 static void aacDecoder_UpdateBitStreamCounters(CStreamInfo *pSi,
@@ -1157,9 +1091,6 @@ aacDecoder_DecodeFrame(HANDLE_AACDECODER
        Tell other modules to clear states if required. */
     if (flags & AACDEC_CLRHIST) {
       if (!(self->flags[0] & AC_USAC)) {
-        mpegSurroundDecoder_SetParam(
-            (CMpegSurroundDecoder *)self->pMpegSurroundDecoder,
-            SACDEC_CLEAR_HISTORY, 1);
         if (FDK_QmfDomain_ClearPersistentMemory(&self->qmfDomain) != 0) {
           ErrorStatus = AAC_DEC_UNKNOWN;
           goto bail;
@@ -1247,48 +1178,8 @@ aacDecoder_DecodeFrame(HANDLE_AACDECODER
                         self->streamInfo.frameSize, 0);
       }
 
-      /* Setting of internal MPS state; may be reset in CAacDecoder_SyncQmfMode
-         if decoder is unable to decode with user defined qmfMode */
-      if (!(self->flags[0] & (AC_USAC | AC_RSVD50 | AC_RSV603DA | AC_ELD))) {
-        self->mpsEnableCurr =
-            (self->mpsEnableUser &&
-             isSupportedMpsConfig(self->streamInfo.aot,
-                                  self->streamInfo.numChannels,
-                                  (self->flags[0] & AC_MPS_PRESENT) ? 1 : 0));
-      }
-
-      if (!self->qmfDomain.globalConf.qmfDomainExplicitConfig &&
-          self->mpsEnableCurr) {
-        /* if not done yet, allocate full MPEG Surround decoder instance */
-        if (mpegSurroundDecoder_IsFullMpegSurroundDecoderInstanceAvailable(
-                (CMpegSurroundDecoder *)self->pMpegSurroundDecoder) ==
-            SAC_INSTANCE_NOT_FULL_AVAILABLE) {
-          if (mpegSurroundDecoder_Open(
-                  (CMpegSurroundDecoder **)&self->pMpegSurroundDecoder, -1,
-                  &self->qmfDomain)) {
-            return AAC_DEC_OUT_OF_MEMORY;
-          }
-        }
-      }
-
       CAacDecoder_SyncQmfMode(self);
 
-      if (!self->qmfDomain.globalConf.qmfDomainExplicitConfig &&
-          self->mpsEnableCurr) {
-        SAC_INPUT_CONFIG sac_interface = SAC_INTERFACE_TIME;
-        /* needs to be done before first SBR apply. */
-        mpegSurroundDecoder_ConfigureQmfDomain(
-            (CMpegSurroundDecoder *)self->pMpegSurroundDecoder, sac_interface,
-            (UINT)self->streamInfo.aacSampleRate, self->streamInfo.aot);
-        if (self->qmfDomain.globalConf.nBandsAnalysis_requested > 0) {
-          self->qmfDomain.globalConf.nQmfTimeSlots_requested =
-              self->streamInfo.aacSamplesPerFrame /
-              self->qmfDomain.globalConf.nBandsAnalysis_requested;
-        } else {
-          self->qmfDomain.globalConf.nQmfTimeSlots_requested = 0;
-        }
-      }
-
       self->qmfDomain.globalConf.TDinput = pTimeData;
 
       switch (FDK_QmfDomain_Configure(&self->qmfDomain)) {
@@ -1308,61 +1199,6 @@ aacDecoder_DecodeFrame(HANDLE_AACDECODER
                               decoder too */
       }
 
-      if (self->mpsEnableCurr) {
-        int err, sac_interface, nChannels, frameSize;
-
-        nChannels = self->streamInfo.numChannels;
-        frameSize = self->streamInfo.frameSize;
-        sac_interface = SAC_INTERFACE_TIME;
-
-        if (self->streamInfo.aot == AOT_USAC) {
-          if (self->flags[0] & AC_USAC_SCFGI3) {
-            sac_interface = SAC_INTERFACE_TIME;
-          }
-        }
-        err = mpegSurroundDecoder_SetParam(
-            (CMpegSurroundDecoder *)self->pMpegSurroundDecoder,
-            SACDEC_INTERFACE, sac_interface);
-
-        if (err == 0) {
-          err = mpegSurroundDecoder_Apply(
-              (CMpegSurroundDecoder *)self->pMpegSurroundDecoder,
-              (INT_PCM *)self->workBufferCore2, pTimeData, timeDataSize,
-              self->streamInfo.aacSamplesPerFrame, &nChannels, &frameSize,
-              self->streamInfo.sampleRate, self->streamInfo.aot,
-              self->channelType, self->channelIndices, &self->mapDescr);
-        }
-
-        if (err == MPS_OUTPUT_BUFFER_TOO_SMALL) {
-          ErrorStatus = AAC_DEC_OUTPUT_BUFFER_TOO_SMALL;
-          goto bail;
-        }
-        if (err == 0) {
-          /* Update output parameter */
-          self->streamInfo.numChannels = nChannels;
-          self->streamInfo.frameSize = frameSize;
-          self->streamInfo.outputDelay += mpegSurroundDecoder_GetDelay(
-              (CMpegSurroundDecoder *)self->pMpegSurroundDecoder);
-          /* Save current parameter for possible concealment of next frame */
-          self->mpsOutChannelsLast = nChannels;
-          self->mpsFrameSizeLast = frameSize;
-        } else if ((self->mpsOutChannelsLast > 0) &&
-                   (self->mpsFrameSizeLast > 0)) {
-          /* Restore parameters of last frame ... */
-          self->streamInfo.numChannels = self->mpsOutChannelsLast;
-          self->streamInfo.frameSize = self->mpsFrameSizeLast;
-          /* ... and clear output buffer so that potentially corrupted data does
-           * not reach the framework. */
-          FDKmemclear(pTimeData, self->mpsOutChannelsLast *
-                                     self->mpsFrameSizeLast * sizeof(INT_PCM));
-          /* Additionally proclaim that this frame had errors during decoding.
-           */
-          ErrorStatus = AAC_DEC_DECODE_FRAME_ERROR;
-        } else {
-          ErrorStatus = AAC_DEC_UNKNOWN; /* no output */
-        }
-      }
-
       /* Use dedicated memory for PCM postprocessing */
       pTimeDataPcmPost = self->pTimeData2;
       timeDataPcmPostSize = self->timeData2Size;
@@ -1395,11 +1231,6 @@ aacDecoder_DecodeFrame(HANDLE_AACDECODER
             reverseOutChannelMap[ch] = ch;
           }
 
-          /* If SBR and/or MPS is active, the DRC gains are aligned to the QMF
-             domain signal before the QMF synthesis. Therefore the DRC gains
-             need to be delayed by the QMF synthesis delay. */
-          if (self->mpsEnableCurr) drcDelay = 257;
-
           for (ch = 0; ch < self->streamInfo.numChannels; ch++) {
             UCHAR mapValue = FDK_chMapDescr_getMapValue(
                 &self->mapDescr, (UCHAR)ch, self->chMapIndex);
@@ -1411,27 +1242,7 @@ aacDecoder_DecodeFrame(HANDLE_AACDECODER
             if (mapValue < (8)) reverseOutChannelMap[mapValue] = ch;
           }
 
-          /* The output of SBR and MPS is interleaved. Deinterleaving may be
-           * necessary for FDK_drcDec_ProcessTime, which accepts deinterleaved
-           * audio only. */
-          if ((self->streamInfo.numChannels > 1) &&
-              (0 || (self->mpsEnableCurr))) {
-            /* interleaving/deinterleaving is performed on upper part of
-             * pTimeDataPcmPost. Check if this buffer is large enough. */
-            if (timeDataPcmPostSize <
-                (INT)(2 * self->streamInfo.numChannels *
-                      self->streamInfo.frameSize * sizeof(PCM_DEC))) {
-              ErrorStatus = AAC_DEC_UNKNOWN;
-              goto bail;
-            }
-            needsDeinterleaving = 1;
-            drcWorkBuffer =
-                (FIXP_DBL *)pTimeDataPcmPost +
-                self->streamInfo.numChannels * self->streamInfo.frameSize;
-            FDK_deinterleave(
-                pTimeDataPcmPost, drcWorkBuffer, self->streamInfo.numChannels,
-                self->streamInfo.frameSize, self->streamInfo.frameSize);
-          } else {
+	  {
             drcWorkBuffer = (FIXP_DBL *)pTimeDataPcmPost;
           }
 
@@ -1488,7 +1299,6 @@ aacDecoder_DecodeFrame(HANDLE_AACDECODER
         }
 
         INT interleaved = 0;
-        interleaved |= (self->mpsEnableCurr) ? 1 : 0;
 
         /* do PCM post processing */
         dmxErr = pcmDmx_ApplyFrame(
@@ -1525,8 +1335,7 @@ aacDecoder_DecodeFrame(HANDLE_AACDECODER
           pcmLimiter_SetSampleRate(self->hLimiter, self->streamInfo.sampleRate);
           pcmLimiterScale += PCM_OUT_HEADROOM;
 
-          if ((self->streamInfo.numChannels == 1) ||
-              (self->mpsEnableCurr)) {
+          if ((self->streamInfo.numChannels == 1)) {
             pInterleaveBuffer = (PCM_LIM *)pTimeDataPcmPost;
           } else {
             pInterleaveBuffer = (PCM_LIM *)pTimeData;
@@ -1549,8 +1358,7 @@ aacDecoder_DecodeFrame(HANDLE_AACDECODER
           /* If numChannels = 1 we do not need interleaving. The same applies if
           SBR or MPS are used, since their output is interleaved already
           (resampled or not) */
-          if ((self->streamInfo.numChannels == 1) ||
-              (self->mpsEnableCurr)) {
+          if ((self->streamInfo.numChannels == 1)) {
             scaleValuesSaturate(
                 pTimeData, pTimeDataPcmPost,
                 self->streamInfo.frameSize * self->streamInfo.numChannels,
@@ -1688,11 +1496,6 @@ LINKSPEC_CPP void aacDecoder_Close(HANDL
 
   FDK_drcDec_Close(&self->hUniDrcDecoder);
 
-  if (self->pMpegSurroundDecoder != NULL) {
-    mpegSurroundDecoder_Close(
-        (CMpegSurroundDecoder *)self->pMpegSurroundDecoder);
-  }
-
   if (self->hInput != NULL) {
     transportDec_Close(&self->hInput);
   }
@@ -1711,7 +1514,6 @@ LINKSPEC_CPP INT aacDecoder_GetLibInfo(L
     return -1;
   }
 
-  mpegSurroundDecoder_GetLibInfo(info);
   transportDec_GetLibInfo(info);
   FDK_toolsGetLibInfo(info);
   pcmDmx_GetLibInfo(info);
--- a/libAACenc/src/aacenc_lib.cpp
+++ b/libAACenc/src/aacenc_lib.cpp
@@ -130,8 +130,6 @@ amm-info@iis.fraunhofer.de
 #include "tpenc_lib.h"
 
 #include "metadata_main.h"
-#include "mps_main.h"
-#include "sacenc_lib.h"
 
 #define SBL(fl) \
   (fl /         \
@@ -223,8 +221,6 @@ struct AACENCODER {
                           Necessary for delay compensation. Metadata mode is a
                           separate parameter. */
 
-  HANDLE_MPS_ENCODER hMpsEnc;
-
   /* Transport */
   HANDLE_TRANSPORTENC hTpEnc;
 
@@ -541,14 +537,6 @@ static INT aacEncoder_LimitBitrate(const
                                    nChannels, cm.nChannelsEff, bitRate, -1,
                                    NULL, AACENC_BR_MODE_INVALID, nSubFrames);
 
-  /* Limit bit rate in respect to available MPS modes if active */
-  if ((aot == AOT_ER_AAC_ELD) && (syntaxFlags & AC_LD_MPS) &&
-      (channelMode == MODE_1)) {
-    bitRate = FDK_MpegsEnc_GetClosestBitRate(
-        aot, MODE_212, samplingRate, 0,
-        bitRate);
-  }
-
   return bitRate;
 }
 
@@ -863,17 +851,6 @@ static AACENC_ERROR FDKaacEnc_AdjustEncS
   return err;
 }
 
-INT aacenc_SscCallback(void *self, HANDLE_FDK_BITSTREAM hBs,
-                       const AUDIO_OBJECT_TYPE coreCodec,
-                       const INT samplingRate, const INT frameSize,
-                       const INT stereoConfigIndex,
-                       const INT coreSbrFrameLengthIndex, const INT configBytes,
-                       const UCHAR configMode, UCHAR *configChanged) {
-  HANDLE_AACENCODER hAacEncoder = (HANDLE_AACENCODER)self;
-
-  return (FDK_MpegsEnc_WriteSpatialSpecificConfig(hAacEncoder->hMpsEnc, hBs));
-}
-
 static AACENC_ERROR aacEncInit(HANDLE_AACENCODER hAacEncoder, ULONG InitFlags,
                                USER_PARAM *config) {
   AACENC_ERROR err = AACENC_OK;
@@ -918,23 +895,6 @@ static AACENC_ERROR aacEncInit(HANDLE_AA
     hAacConfig->ancDataBitRate = 0;
   }
 
-  if ((hAacEncoder->hMpsEnc != NULL) && (hAacConfig->syntaxFlags & AC_LD_MPS)) {
-    int coreCoderDelay = DELAY_AACELD(hAacConfig->framelength);
-
-    if (MPS_ENCODER_OK !=
-        FDK_MpegsEnc_Init(hAacEncoder->hMpsEnc, hAacConfig->audioObjectType,
-                          config->userSamplerate, hAacConfig->bitRate,
-                          0,
-                          frameLength, /* for dual rate sbr this value is
-                                          already multiplied by 2 */
-                          hAacEncoder->inputBufferSizePerChannel,
-                          coreCoderDelay)) {
-      return AACENC_INIT_MPS_ERROR;
-    }
-  }
-  hAacEncoder->nDelay =
-      fMax(FDK_MpegsEnc_GetDelay(hAacEncoder->hMpsEnc), hAacEncoder->nDelay);
-
   /*
    * Initialize Transport - Module.
    */
@@ -994,13 +954,7 @@ static AACENC_ERROR aacEncInit(HANDLE_AA
     hAacEncoder->nDelay += FDK_MetadataEnc_GetDelay(hAacEncoder->hMetadataEnc);
   }
 
-  /* Get custom delay, i.e. the codec delay w/o the decoder's SBR- or MPS delay
-   */
-  if ((hAacEncoder->hMpsEnc != NULL) && (hAacConfig->syntaxFlags & AC_LD_MPS)) {
-    hAacEncoder->nDelayCore =
-        hAacEncoder->nDelay -
-        fMax(0, FDK_MpegsEnc_GetDecDelay(hAacEncoder->hMpsEnc));
-  } else {
+  {
     hAacEncoder->nDelayCore = hAacEncoder->nDelay;
   }
 
@@ -1120,14 +1074,6 @@ AACENC_ERROR aacEncOpen(HANDLE_AACENCODE
     }
   } /* (encoder_modis&ENC_MODE_FLAG_META) */
 
-  /* Open MPEG Surround Encoder */
-  if (hAacEncoder->encoder_modis & ENC_MODE_FLAG_SAC) {
-    if (MPS_ENCODER_OK != FDK_MpegsEnc_Open(&hAacEncoder->hMpsEnc)) {
-      err = AACENC_MEMORY_ERROR;
-      goto bail;
-    }
-  } /* (hAacEncoder->encoder_modis&ENC_MODE_FLAG_SAC) */
-
   /* Open Transport Encoder */
   if (transportEnc_Open(&hAacEncoder->hTpEnc) != 0) {
     err = AACENC_MEMORY_ERROR;
@@ -1146,11 +1092,6 @@ AACENC_ERROR aacEncOpen(HANDLE_AACENCODE
 
     C_ALLOC_SCRATCH_END(_pLibInfo, LIB_INFO, FDK_MODULE_LAST)
   }
-  if (transportEnc_RegisterSscCallback(hAacEncoder->hTpEnc, aacenc_SscCallback,
-                                       hAacEncoder) != 0) {
-    err = AACENC_INIT_TP_ERROR;
-    goto bail;
-  }
 
   /* Initialize encoder instance with default parameters. */
   aacEncDefaultConfig(&hAacEncoder->aacConfig, &hAacEncoder->extParam);
@@ -1202,9 +1143,6 @@ AACENC_ERROR aacEncClose(HANDLE_AACENCOD
     if (hAacEncoder->hMetadataEnc) {
       FDK_MetadataEnc_Close(&hAacEncoder->hMetadataEnc);
     }
-    if (hAacEncoder->hMpsEnc) {
-      FDK_MpegsEnc_Close(&hAacEncoder->hMpsEnc);
-    }
 
     Free_AacEncoder(phAacEncoder);
   }
@@ -1399,30 +1337,6 @@ AACENC_ERROR aacEncEncode(const HANDLE_A
     }
   }
 
-  /*
-   * Encode MPS data.
-   */
-  if ((hAacEncoder->hMpsEnc != NULL) &&
-      (hAacEncoder->aacConfig.syntaxFlags & AC_LD_MPS)) {
-    AACENC_EXT_PAYLOAD mpsExtensionPayload;
-    FDKmemclear(&mpsExtensionPayload, sizeof(AACENC_EXT_PAYLOAD));
-
-    if (MPS_ENCODER_OK !=
-        FDK_MpegsEnc_Process(
-            hAacEncoder->hMpsEnc,
-            hAacEncoder->inputBuffer + hAacEncoder->inputBufferOffset /
-                                           hAacEncoder->coderConfig.noChannels,
-            hAacEncoder->nSamplesRead, &mpsExtensionPayload)) {
-      err = AACENC_ENCODE_ERROR;
-      goto bail;
-    }
-
-    if ((mpsExtensionPayload.pData != NULL) &&
-        ((mpsExtensionPayload.dataSize != 0))) {
-      hAacEncoder->extPayload[nExtensions++] = mpsExtensionPayload;
-    }
-  }
-
   if ((inargs->numAncBytes > 0) &&
       (getBufDescIdx(inBufDesc, IN_ANCILLRY_DATA) != -1)) {
     INT idx = getBufDescIdx(inBufDesc, IN_ANCILLRY_DATA);
@@ -1528,7 +1442,6 @@ AACENC_ERROR aacEncGetLibInfo(LIB_INFO *
 
   FDK_toolsGetLibInfo(info);
   transportEnc_GetLibInfo(info);
-  FDK_MpegsEnc_GetLibInfo(info);
 
   /* search for next free tab */
   for (i = 0; i < FDK_MODULE_LAST; i++) {
@@ -1645,11 +1558,7 @@ AACENC_ERROR aacEncoder_SetParam(const H
       break;
     case AACENC_CHANNELMODE:
       if (settings->userChannelMode != (CHANNEL_MODE)value) {
-        if (((CHANNEL_MODE)value == MODE_212) &&
-            (NULL != hAacEncoder->hMpsEnc)) {
-          settings->userChannelMode = (CHANNEL_MODE)value;
-          settings->nChannels = 2;
-        } else {
+        {
           const CHANNEL_MODE_CONFIG_TAB *pConfig =
               FDKaacEnc_GetChannelModeConfiguration((CHANNEL_MODE)value);
           if (pConfig == NULL) {
--- a/libAACenc/src/mps_main.cpp
+++ /dev/null
@@ -1,529 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/**************************** AAC encoder library ******************************
-
-   Author(s):   Markus Lohwasser
-
-   Description: Mpeg Surround library interface functions
-
-*******************************************************************************/
-
-/* Includes ******************************************************************/
-#include "mps_main.h"
-#include "sacenc_lib.h"
-
-/* Data Types ****************************************************************/
-struct MPS_ENCODER {
-  HANDLE_MP4SPACE_ENCODER hSacEncoder;
-
-  AUDIO_OBJECT_TYPE audioObjectType;
-
-  FDK_bufDescr inBufDesc;
-  FDK_bufDescr outBufDesc;
-  SACENC_InArgs inargs;
-  SACENC_OutArgs outargs;
-
-  void *pInBuffer[1];
-  UINT pInBufferSize[1];
-  UINT pInBufferElSize[1];
-  UINT pInBufferType[1];
-
-  void *pOutBuffer[2];
-  UINT pOutBufferSize[2];
-  UINT pOutBufferElSize[2];
-  UINT pOutBufferType[2];
-
-  UCHAR sacOutBuffer[1024]; /* Worst case memory consumption for ELDv2: 768
-                               bytes => 6144 bits (Core + SBR + MPS) */
-};
-
-struct MPS_CONFIG_TAB {
-  AUDIO_OBJECT_TYPE audio_object_type;
-  CHANNEL_MODE channel_mode;
-  ULONG sbr_ratio;
-  ULONG sampling_rate;
-  ULONG bitrate_min;
-  ULONG bitrate_max;
-};
-
-/* Constants *****************************************************************/
-static const MPS_CONFIG_TAB mpsConfigTab[] = {
-    {AOT_ER_AAC_ELD, MODE_212, 0, 16000, 16000, 39999},
-    {AOT_ER_AAC_ELD, MODE_212, 0, 22050, 16000, 49999},
-    {AOT_ER_AAC_ELD, MODE_212, 0, 24000, 16000, 61999},
-    {AOT_ER_AAC_ELD, MODE_212, 0, 32000, 20000, 84999},
-    {AOT_ER_AAC_ELD, MODE_212, 0, 44100, 50000, 192000},
-    {AOT_ER_AAC_ELD, MODE_212, 0, 48000, 62000, 192000},
-
-    {AOT_ER_AAC_ELD, MODE_212, 1, 16000, 18000, 31999},
-    {AOT_ER_AAC_ELD, MODE_212, 1, 22050, 18000, 31999},
-    {AOT_ER_AAC_ELD, MODE_212, 1, 24000, 20000, 64000},
-
-    {AOT_ER_AAC_ELD, MODE_212, 2, 32000, 18000, 64000},
-    {AOT_ER_AAC_ELD, MODE_212, 2, 44100, 21000, 64000},
-    {AOT_ER_AAC_ELD, MODE_212, 2, 48000, 26000, 64000}
-
-};
-
-/* Function / Class Declarations *********************************************/
-
-/* Function / Class Definition ***********************************************/
-static INT FDK_MpegsEnc_WriteFrameHeader(HANDLE_MPS_ENCODER hMpsEnc,
-                                         UCHAR *const pOutputBuffer,
-                                         const int outputBufferSize);
-
-MPS_ENCODER_ERROR FDK_MpegsEnc_Open(HANDLE_MPS_ENCODER *phMpsEnc) {
-  MPS_ENCODER_ERROR error = MPS_ENCODER_OK;
-  HANDLE_MPS_ENCODER hMpsEnc = NULL;
-
-  if (phMpsEnc == NULL) {
-    error = MPS_ENCODER_INVALID_HANDLE;
-    goto bail;
-  }
-
-  if (NULL ==
-      (hMpsEnc = (HANDLE_MPS_ENCODER)FDKcalloc(1, sizeof(MPS_ENCODER)))) {
-    error = MPS_ENCODER_MEMORY_ERROR;
-    goto bail;
-  }
-  FDKmemclear(hMpsEnc, sizeof(MPS_ENCODER));
-
-  if (SACENC_OK != FDK_sacenc_open(&hMpsEnc->hSacEncoder)) {
-    error = MPS_ENCODER_MEMORY_ERROR;
-    goto bail;
-  }
-
-  /* Return mps encoder instance */
-  *phMpsEnc = hMpsEnc;
-
-bail:
-  if (error != MPS_ENCODER_OK) {
-    FDK_MpegsEnc_Close(&hMpsEnc);
-  }
-  return error;
-}
-
-MPS_ENCODER_ERROR FDK_MpegsEnc_Close(HANDLE_MPS_ENCODER *phMpsEnc) {
-  MPS_ENCODER_ERROR error = MPS_ENCODER_OK;
-
-  if (phMpsEnc == NULL) {
-    error = MPS_ENCODER_INVALID_HANDLE;
-    goto bail;
-  }
-
-  if (*phMpsEnc != NULL) {
-    FDK_sacenc_close(&(*phMpsEnc)->hSacEncoder);
-    FDKfree(*phMpsEnc);
-    *phMpsEnc = NULL;
-  }
-bail:
-  return error;
-}
-
-MPS_ENCODER_ERROR FDK_MpegsEnc_Init(HANDLE_MPS_ENCODER hMpsEnc,
-                                    const AUDIO_OBJECT_TYPE audioObjectType,
-                                    const UINT samplingrate, const UINT bitrate,
-                                    const UINT sbrRatio, const UINT framelength,
-                                    const UINT inputBufferSizePerChannel,
-                                    const UINT coreCoderDelay) {
-  MPS_ENCODER_ERROR error = MPS_ENCODER_OK;
-  const UINT fs_low = 27713;  /* low MPS sampling frequencies */
-  const UINT fs_high = 55426; /* high MPS sampling frequencies */
-  UINT nTimeSlots = 0, nQmfBandsLd = 0;
-
-  if (hMpsEnc == NULL) {
-    error = MPS_ENCODER_INVALID_HANDLE;
-    goto bail;
-  }
-
-  /* Combine MPS with SBR only if the number of QMF band fits together.*/
-  switch (sbrRatio) {
-    case 1: /* downsampled sbr - 32 QMF bands required */
-      if (!(samplingrate < fs_low)) {
-        error = MPS_ENCODER_INIT_ERROR;
-        goto bail;
-      }
-      break;
-    case 2: /* dualrate - 64 QMF bands required */
-      if (!((samplingrate >= fs_low) && (samplingrate < fs_high))) {
-        error = MPS_ENCODER_INIT_ERROR;
-        goto bail;
-      }
-      break;
-    case 0:
-    default:; /* time interface - no samplingrate restriction */
-  }
-
-  /* 32  QMF-Bands  ( fs < 27713 )
-   * 64  QMF-Bands  ( 27713 >= fs <= 55426 )
-   * 128 QMF-Bands  ( fs > 55426 )
-   */
-  nQmfBandsLd =
-      (samplingrate < fs_low) ? 5 : ((samplingrate > fs_high) ? 7 : 6);
-  nTimeSlots = framelength >> nQmfBandsLd;
-
-  /* check if number of qmf bands is usable for given framelength */
-  if (framelength != (nTimeSlots << nQmfBandsLd)) {
-    error = MPS_ENCODER_INIT_ERROR;
-    goto bail;
-  }
-
-  /* is given bitrate intended to be supported */
-  if ((INT)bitrate != FDK_MpegsEnc_GetClosestBitRate(audioObjectType, MODE_212,
-                                                     samplingrate, sbrRatio,
-                                                     bitrate)) {
-    error = MPS_ENCODER_INIT_ERROR;
-    goto bail;
-  }
-
-  /* init SAC library */
-  switch (audioObjectType) {
-    case AOT_ER_AAC_ELD: {
-      const UINT noInterFrameCoding = 0;
-
-      if ((SACENC_OK !=
-           FDK_sacenc_setParam(hMpsEnc->hSacEncoder, SACENC_LOWDELAY,
-                               (noInterFrameCoding == 1) ? 1 : 2)) ||
-          (SACENC_OK != FDK_sacenc_setParam(hMpsEnc->hSacEncoder,
-                                            SACENC_ENC_MODE, SACENC_212)) ||
-          (SACENC_OK != FDK_sacenc_setParam(hMpsEnc->hSacEncoder,
-                                            SACENC_SAMPLERATE, samplingrate)) ||
-          (SACENC_OK != FDK_sacenc_setParam(hMpsEnc->hSacEncoder,
-                                            SACENC_FRAME_TIME_SLOTS,
-                                            nTimeSlots)) ||
-          (SACENC_OK != FDK_sacenc_setParam(hMpsEnc->hSacEncoder,
-                                            SACENC_PARAM_BANDS,
-                                            SACENC_BANDS_15)) ||
-          (SACENC_OK !=
-           FDK_sacenc_setParam(hMpsEnc->hSacEncoder, SACENC_TIME_DOM_DMX, 2)) ||
-          (SACENC_OK !=
-           FDK_sacenc_setParam(hMpsEnc->hSacEncoder, SACENC_COARSE_QUANT, 0)) ||
-          (SACENC_OK != FDK_sacenc_setParam(hMpsEnc->hSacEncoder,
-                                            SACENC_QUANT_MODE,
-                                            SACENC_QUANTMODE_FINE)) ||
-          (SACENC_OK != FDK_sacenc_setParam(hMpsEnc->hSacEncoder,
-                                            SACENC_TIME_ALIGNMENT, 0)) ||
-          (SACENC_OK != FDK_sacenc_setParam(hMpsEnc->hSacEncoder,
-                                            SACENC_INDEPENDENCY_FACTOR, 20))) {
-        error = MPS_ENCODER_INIT_ERROR;
-        goto bail;
-      }
-      break;
-    }
-    default:
-      error = MPS_ENCODER_INIT_ERROR;
-      goto bail;
-  }
-
-  if (SACENC_OK != FDK_sacenc_init(hMpsEnc->hSacEncoder, coreCoderDelay)) {
-    error = MPS_ENCODER_INIT_ERROR;
-  }
-
-  hMpsEnc->audioObjectType = audioObjectType;
-
-  hMpsEnc->inBufDesc.ppBase = (void **)&hMpsEnc->pInBuffer;
-  hMpsEnc->inBufDesc.pBufSize = hMpsEnc->pInBufferSize;
-  hMpsEnc->inBufDesc.pEleSize = hMpsEnc->pInBufferElSize;
-  hMpsEnc->inBufDesc.pBufType = hMpsEnc->pInBufferType;
-  hMpsEnc->inBufDesc.numBufs = 1;
-
-  hMpsEnc->outBufDesc.ppBase = (void **)&hMpsEnc->pOutBuffer;
-  hMpsEnc->outBufDesc.pBufSize = hMpsEnc->pOutBufferSize;
-  hMpsEnc->outBufDesc.pEleSize = hMpsEnc->pOutBufferElSize;
-  hMpsEnc->outBufDesc.pBufType = hMpsEnc->pOutBufferType;
-  hMpsEnc->outBufDesc.numBufs = 2;
-
-  hMpsEnc->pInBuffer[0] = NULL;
-  hMpsEnc->pInBufferSize[0] = 0;
-  hMpsEnc->pInBufferElSize[0] = sizeof(INT_PCM);
-  hMpsEnc->pInBufferType[0] = (FDK_BUF_TYPE_INPUT | FDK_BUF_TYPE_PCM_DATA);
-
-  hMpsEnc->pOutBuffer[0] = NULL;
-  hMpsEnc->pOutBufferSize[0] = 0;
-  hMpsEnc->pOutBufferElSize[0] = sizeof(INT_PCM);
-  hMpsEnc->pOutBufferType[0] = (FDK_BUF_TYPE_OUTPUT | FDK_BUF_TYPE_PCM_DATA);
-
-  hMpsEnc->pOutBuffer[1] = NULL;
-  hMpsEnc->pOutBufferSize[1] = 0;
-  hMpsEnc->pOutBufferElSize[1] = sizeof(UCHAR);
-  hMpsEnc->pOutBufferType[1] = (FDK_BUF_TYPE_OUTPUT | FDK_BUF_TYPE_BS_DATA);
-
-  hMpsEnc->inargs.isInputInterleaved = 0;
-  hMpsEnc->inargs.inputBufferSizePerChannel = inputBufferSizePerChannel;
-
-bail:
-  return error;
-}
-
-MPS_ENCODER_ERROR FDK_MpegsEnc_Process(HANDLE_MPS_ENCODER hMpsEnc,
-                                       INT_PCM *const pAudioSamples,
-                                       const INT nAudioSamples,
-                                       AACENC_EXT_PAYLOAD *pMpsExtPayload) {
-  MPS_ENCODER_ERROR error = MPS_ENCODER_OK;
-
-  if (hMpsEnc == NULL) {
-    error = MPS_ENCODER_INVALID_HANDLE;
-  } else {
-    int sacHeaderFlag = 1;
-    int sacOutBufferOffset = 0;
-
-    /* In case of eld the ssc is explicit and doesn't need to be inband */
-    if (hMpsEnc->audioObjectType == AOT_ER_AAC_ELD) {
-      sacHeaderFlag = 0;
-    }
-
-    /* 4 bits nibble after extension type */
-    hMpsEnc->sacOutBuffer[0] = (sacHeaderFlag == 0) ? 0x3 : 0x7;
-    sacOutBufferOffset += 1;
-
-    if (sacHeaderFlag) {
-      sacOutBufferOffset += FDK_MpegsEnc_WriteFrameHeader(
-          hMpsEnc, &hMpsEnc->sacOutBuffer[sacOutBufferOffset],
-          sizeof(hMpsEnc->sacOutBuffer) - sacOutBufferOffset);
-    }
-
-    /* Register input and output buffer. */
-    hMpsEnc->pInBuffer[0] = (void *)pAudioSamples;
-    hMpsEnc->inargs.nInputSamples = nAudioSamples;
-
-    hMpsEnc->pOutBuffer[0] = (void *)pAudioSamples;
-    hMpsEnc->pOutBufferSize[0] = sizeof(INT_PCM) * nAudioSamples / 2;
-
-    hMpsEnc->pOutBuffer[1] = (void *)&hMpsEnc->sacOutBuffer[sacOutBufferOffset];
-    hMpsEnc->pOutBufferSize[1] =
-        sizeof(hMpsEnc->sacOutBuffer) - sacOutBufferOffset;
-
-    /* encode SAC frame */
-    if (SACENC_OK != FDK_sacenc_encode(hMpsEnc->hSacEncoder,
-                                       &hMpsEnc->inBufDesc,
-                                       &hMpsEnc->outBufDesc, &hMpsEnc->inargs,
-                                       &hMpsEnc->outargs)) {
-      error = MPS_ENCODER_ENCODE_ERROR;
-      goto bail;
-    }
-
-    /* export MPS payload */
-    pMpsExtPayload->pData = (UCHAR *)hMpsEnc->sacOutBuffer;
-    pMpsExtPayload->dataSize =
-        hMpsEnc->outargs.nOutputBits + 8 * (sacOutBufferOffset - 1);
-    pMpsExtPayload->dataType = EXT_LDSAC_DATA;
-    pMpsExtPayload->associatedChElement = -1;
-  }
-
-bail:
-  return error;
-}
-
-INT FDK_MpegsEnc_WriteSpatialSpecificConfig(HANDLE_MPS_ENCODER hMpsEnc,
-                                            HANDLE_FDK_BITSTREAM hBs) {
-  INT sscBits = 0;
-
-  if (NULL != hMpsEnc) {
-    MP4SPACEENC_INFO mp4SpaceEncoderInfo;
-    FDK_sacenc_getInfo(hMpsEnc->hSacEncoder, &mp4SpaceEncoderInfo);
-
-    if (hBs != NULL) {
-      int i;
-      int writtenBits = 0;
-      for (i = 0; i<mp4SpaceEncoderInfo.pSscBuf->nSscSizeBits>> 3; i++) {
-        FDKwriteBits(hBs, mp4SpaceEncoderInfo.pSscBuf->pSsc[i], 8);
-        writtenBits += 8;
-      }
-      FDKwriteBits(hBs, mp4SpaceEncoderInfo.pSscBuf->pSsc[i],
-                   mp4SpaceEncoderInfo.pSscBuf->nSscSizeBits - writtenBits);
-    } /* hBS */
-
-    sscBits = mp4SpaceEncoderInfo.pSscBuf->nSscSizeBits;
-
-  } /* valid hMpsEnc */
-
-  return sscBits;
-}
-
-static INT FDK_MpegsEnc_WriteFrameHeader(HANDLE_MPS_ENCODER hMpsEnc,
-                                         UCHAR *const pOutputBuffer,
-                                         const int outputBufferSize) {
-  const int sacTimeAlignFlag = 0;
-
-  /* Initialize variables */
-  int numBits = 0;
-
-  if ((NULL != hMpsEnc) && (NULL != pOutputBuffer)) {
-    UINT alignAnchor, cnt;
-    FDK_BITSTREAM Bs;
-    FDKinitBitStream(&Bs, pOutputBuffer, outputBufferSize, 0, BS_WRITER);
-
-    /* Calculate SSC length information */
-    cnt = (FDK_MpegsEnc_WriteSpatialSpecificConfig(hMpsEnc, NULL) + 7) >> 3;
-
-    /* Write SSC */
-    FDKwriteBits(&Bs, sacTimeAlignFlag, 1);
-
-    if (cnt < 127) {
-      FDKwriteBits(&Bs, cnt, 7);
-    } else {
-      FDKwriteBits(&Bs, 127, 7);
-      FDKwriteBits(&Bs, cnt - 127, 16);
-    }
-
-    alignAnchor = FDKgetValidBits(&Bs);
-    FDK_MpegsEnc_WriteSpatialSpecificConfig(hMpsEnc, &Bs);
-    FDKbyteAlign(&Bs, alignAnchor); /* bsFillBits */
-
-    if (sacTimeAlignFlag) {
-      FDK_ASSERT(1); /* time alignment not supported */
-    }
-
-    numBits = FDKgetValidBits(&Bs);
-  } /* valid handle */
-
-  return ((numBits + 7) >> 3);
-}
-
-INT FDK_MpegsEnc_GetClosestBitRate(const AUDIO_OBJECT_TYPE audioObjectType,
-                                   const CHANNEL_MODE channelMode,
-                                   const UINT samplingrate, const UINT sbrRatio,
-                                   const UINT bitrate) {
-  unsigned int i;
-  int targetBitrate = -1;
-
-  for (i = 0; i < sizeof(mpsConfigTab) / sizeof(MPS_CONFIG_TAB); i++) {
-    if ((mpsConfigTab[i].audio_object_type == audioObjectType) &&
-        (mpsConfigTab[i].channel_mode == channelMode) &&
-        (mpsConfigTab[i].sbr_ratio == sbrRatio) &&
-        (mpsConfigTab[i].sampling_rate == samplingrate)) {
-      targetBitrate = fMin(fMax(bitrate, mpsConfigTab[i].bitrate_min),
-                           mpsConfigTab[i].bitrate_max);
-    }
-  }
-
-  return targetBitrate;
-}
-
-INT FDK_MpegsEnc_GetDelay(HANDLE_MPS_ENCODER hMpsEnc) {
-  INT delay = 0;
-
-  if (NULL != hMpsEnc) {
-    MP4SPACEENC_INFO mp4SpaceEncoderInfo;
-    FDK_sacenc_getInfo(hMpsEnc->hSacEncoder, &mp4SpaceEncoderInfo);
-    delay = mp4SpaceEncoderInfo.nCodecDelay;
-  }
-
-  return delay;
-}
-
-INT FDK_MpegsEnc_GetDecDelay(HANDLE_MPS_ENCODER hMpsEnc) {
-  INT delay = 0;
-
-  if (NULL != hMpsEnc) {
-    MP4SPACEENC_INFO mp4SpaceEncoderInfo;
-    FDK_sacenc_getInfo(hMpsEnc->hSacEncoder, &mp4SpaceEncoderInfo);
-    delay = mp4SpaceEncoderInfo.nDecoderDelay;
-  }
-
-  return delay;
-}
-
-MPS_ENCODER_ERROR FDK_MpegsEnc_GetLibInfo(LIB_INFO *info) {
-  MPS_ENCODER_ERROR error = MPS_ENCODER_OK;
-
-  if (NULL == info) {
-    error = MPS_ENCODER_INVALID_HANDLE;
-  } else if (SACENC_OK != FDK_sacenc_getLibInfo(info)) {
-    error = MPS_ENCODER_INIT_ERROR;
-  }
-
-  return error;
-}
--- a/libAACenc/src/mps_main.h
+++ /dev/null
@@ -1,270 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/**************************** AAC encoder library ******************************
-
-   Author(s):   Markus Lohwasser
-
-   Description: Mpeg Surround library interface functions
-
-*******************************************************************************/
-
-#ifndef MPS_MAIN_H
-#define MPS_MAIN_H
-
-/* Includes ******************************************************************/
-#include "aacenc.h"
-#include "FDK_audio.h"
-#include "machine_type.h"
-
-/* Defines *******************************************************************/
-typedef enum {
-  MPS_ENCODER_OK = 0x0000, /*!< No error happened. All fine. */
-  MPS_ENCODER_INVALID_HANDLE =
-      0x0020, /*!< Handle passed to function call was invalid. */
-  MPS_ENCODER_MEMORY_ERROR = 0x0021, /*!< Memory allocation failed. */
-  MPS_ENCODER_INIT_ERROR = 0x0040,   /*!< General initialization error. */
-  MPS_ENCODER_ENCODE_ERROR =
-      0x0060 /*!< The encoding process was interrupted by an unexpected error.
-              */
-
-} MPS_ENCODER_ERROR;
-
-/* Data Types ****************************************************************/
-
-/**
- *  MPEG Surround Encoder interface handle.
- */
-typedef struct MPS_ENCODER MPS_ENCODER, *HANDLE_MPS_ENCODER;
-
-/* Function / Class Declarations *********************************************/
-
-/**
- * \brief  Open a Mpeg Surround Encoder instance.
- *
- * \phMpsEnc                    A pointer to a MPS handle to be allocated.
- * Initialized on return.
- *
- * \return
- *          - MPS_ENCODER_OK, on succes.
- *          - MPS_ENCODER_INVALID_HANDLE, MPS_ENCODER_MEMORY_ERROR, on failure.
- */
-MPS_ENCODER_ERROR FDK_MpegsEnc_Open(HANDLE_MPS_ENCODER *phMpsEnc);
-
-/**
- * \brief  Close the Mpeg Surround Encoder instance.
- *
- * Deallocate instance and free whole memory.
- *
- * \param phMpsEnc              Pointer to the MPS handle to be deallocated.
- *
- * \return
- *          - MPS_ENCODER_OK, on succes.
- *          - MPS_ENCODER_INVALID_HANDLE, on failure.
- */
-MPS_ENCODER_ERROR FDK_MpegsEnc_Close(HANDLE_MPS_ENCODER *phMpsEnc);
-
-/**
- * \brief  Initialize a Mpeg Surround Encoder instance.
- *
- * \param hMpsEnc                   MPS Encoder handle.
- * \param audioObjectType           Audio object type.
- * \param samplingrate              Sampling rate in Hz of audio input signal.
- * \param bitrate                   Encder target bitrate.
- * \param sbrRatio                  SBR sampling rate ratio.
- * \param framelength               Number of samples to be processes within one
- * frame.
- * \param inputBufferSizePerChannel Size of input buffer per channel.
- * \param coreCoderDelay            Core coder delay.
- *
- * \return
- *          - MPS_ENCODER_OK, on succes.
- *          - MPS_ENCODER_INVALID_HANDLE, MPS_ENCODER_ENCODE_ERROR, on failure.
- */
-MPS_ENCODER_ERROR FDK_MpegsEnc_Init(HANDLE_MPS_ENCODER hMpsEnc,
-                                    const AUDIO_OBJECT_TYPE audioObjectType,
-                                    const UINT samplingrate, const UINT bitrate,
-                                    const UINT sbrRatio, const UINT framelength,
-                                    const UINT inputBufferSizePerChannel,
-                                    const UINT coreCoderDelay);
-
-/**
- * \brief  Calculate Mpeg Surround processing.
- *
- * This fuction applies the MPS processing. The MPS side info will be written to
- * extension payload. The input audio data will be overwritten by the calculated
- * downmix.
- *
- * \param hMpsEnc               MPS Encoder handle.
- * \param pAudioSamples         Pointer to audio input/output data.
- * \param nAudioSamples         Number of input audio samples to be prcessed.
- * \param pMpsExtPayload        Pointer to extension payload to be filled on
- * return.
- *
- * \return
- *          - MPS_ENCODER_OK, on succes.
- *          - MPS_ENCODER_INVALID_HANDLE, MPS_ENCODER_ENCODE_ERROR, on failure.
- */
-MPS_ENCODER_ERROR FDK_MpegsEnc_Process(HANDLE_MPS_ENCODER hMpsEnc,
-                                       INT_PCM *const pAudioSamples,
-                                       const INT nAudioSamples,
-                                       AACENC_EXT_PAYLOAD *pMpsExtPayload);
-
-/**
- * \brief  Write Spatial Specific Config.
- *
- * This function can be called via call back from the transport library to write
- * the Spatial Specific Config to given bitstream buffer.
- *
- * \param hMpsEnc               MPS Encoder handle.
- * \param hBs                   Bitstream buffer handle.
- *
- * \return                      Number of written bits.
- */
-INT FDK_MpegsEnc_WriteSpatialSpecificConfig(HANDLE_MPS_ENCODER hMpsEnc,
-                                            HANDLE_FDK_BITSTREAM hBs);
-
-/**
- * \brief  Get closest valid bitrate supported by given config.
- *
- * \param audioObjectType       Audio object type.
- * \param channelMode           Encoder channel mode.
- * \param samplingrate          Sampling rate in Hz of audio input signal.
- * \param sbrRatio              SBR sampling rate ratio.
- * \param bitrate               The desired target bitrate.
- *
- * \return                      Closest valid bitrate to given bitrate..
- */
-INT FDK_MpegsEnc_GetClosestBitRate(const AUDIO_OBJECT_TYPE audioObjectType,
-                                   const CHANNEL_MODE channelMode,
-                                   const UINT samplingrate, const UINT sbrRatio,
-                                   const UINT bitrate);
-
-/**
- * \brief  Get codec delay.
- *
- * This function returns delay of the whole en-/decoded signal, including
- * corecoder delay.
- *
- * \param hMpsEnc               MPS Encoder handle.
- *
- * \return                      Codec delay in samples.
- */
-INT FDK_MpegsEnc_GetDelay(HANDLE_MPS_ENCODER hMpsEnc);
-
-/**
- * \brief  Get Mpeg Surround Decoder delay.
- *
- * This function returns delay of the Mpeg Surround decoder.
- *
- * \param hMpsEnc               MPS Encoder handle.
- *
- * \return                      Mpeg Surround Decoder delay in samples.
- */
-INT FDK_MpegsEnc_GetDecDelay(HANDLE_MPS_ENCODER hMpsEnc);
-
-/**
- * \brief  Get information about encoder library build.
- *
- * Fill a given LIB_INFO structure with library version information.
- *
- * \param info  Pointer to an allocated LIB_INFO struct.
- *
- * \return
- *          - MPS_ENCODER_OK, on succes.
- *          - MPS_ENCODER_INVALID_HANDLE, MPS_ENCODER_INIT_ERROR, on failure.
- */
-MPS_ENCODER_ERROR FDK_MpegsEnc_GetLibInfo(LIB_INFO *info);
-
-#endif /* MPS_MAIN_H */
--- a/libSACdec/include/sac_dec_errorcodes.h
+++ /dev/null
@@ -1,157 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround decoder library *************************
-
-   Author(s):
-
-   Description: error codes for mpeg surround decoder
-
-*******************************************************************************/
-
-#ifndef SAC_DEC_ERRORCODES_H
-#define SAC_DEC_ERRORCODES_H
-
-typedef enum {
-
-  __mps_error_start = -1000,
-
-  MPS_OK = 0,
-
-  /* generic/init errors */
-  MPS_NOTOK = __mps_error_start,
-
-  MPS_OUTOFMEMORY,
-  MPS_INVALID_HANDLE,
-  MPS_INVALID_PARAMETER,     /* SetParam not successfull */
-  MPS_UNSUPPORTED_HRTFMODEL, /* SetHRTFModel() not successfull */
-  MPS_UNSUPPORTED_HRTFFREQ,  /* SetHRTFModel() not successfull */
-
-  MPS_UNSUPPORTED_UPMIX_TYPE, /* CheckLevelTreeUpmixType() */
-  MPS_UNSUPPORTED_FORMAT, /* various functions; unknown aot or no_channels in
-                             filterbank */
-  MPS_OUTPUT_BUFFER_TOO_SMALL, /* Size of provided output time buffer is too
-                                  small */
-
-  /* ssc errors */
-  MPS_INVALID_PARAMETERBANDS, /* unsupported numParameterBands in
-                                 SpatialDecDecodeHeader() */
-  MPS_INVALID_TREECONFIG,
-  MPS_INVALID_HRTFSET,   /* SpatialDecDecodeHeader() */
-  MPS_INVALID_TTT,       /* SpatialDecDecodeHeader() */
-  MPS_INVALID_BOXIDX,    /* ecDataDec() */
-  MPS_INVALID_SETIDX,    /* ecDataDec() */
-  MPS_INVALID_QUANTMODE, /* SpatialDecParseSpecificConfig() */
-  MPS_UNEQUAL_SSC, /* FDK_SpatialDecCompareSpatialSpecificConfigHeader() */
-  MPS_UNSUPPORTED_CONFIG, /* number of core channels; 3DStereoInversion; */
-
-  /* parse errors */
-  MPS_PARSE_ERROR,
-  MPS_INVALID_TEMPSHAPE, /* SpatialDecParseFrameData() */
-
-  /* render errors */
-  MPS_WRONG_PARAMETERSETS,
-  MPS_WRONG_PARAMETERBANDS, /* decodeAndMapFrameSmg() */
-  MPS_WRONG_TREECONFIG,
-  MPS_WRONG_BLINDCONFIG,
-  MPS_WRONG_OTT,
-  MPS_WRONG_QUANTMODE,
-  MPS_RESDEC_ERROR,
-  MPS_APPLY_M2_ERROR, /* error in applyM2x()selection */
-
-  __mps_error_end
-
-} SACDEC_ERROR;
-
-#endif
--- a/libSACdec/include/sac_dec_lib.h
+++ /dev/null
@@ -1,477 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround decoder library *************************
-
-   Author(s):
-
-   Description: Space Decoder
-
-*******************************************************************************/
-
-#ifndef SAC_DEC_LIB_H
-#define SAC_DEC_LIB_H
-
-#include "common_fix.h"
-#include "FDK_audio.h"
-#include "sac_dec_errorcodes.h"
-#include "FDK_bitstream.h"
-#include "FDK_qmf_domain.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
-/**
- * \brief  MPEG Surround input data interface mode.
- **/
-typedef enum {
-  SAC_INTERFACE_QMF =
-      0, /*!< Use QMF domain interface for the input downmix audio.  */
-  SAC_INTERFACE_TIME, /*!< Use time domain interface for the input downmix
-                         audio. */
-  SAC_INTERFACE_AUTO  /*!<          */
-} SAC_INPUT_CONFIG;
-
-/**
- * \brief  MPEG Surround output mode.
- **/
-typedef enum {
-  SACDEC_OUT_MODE_NORMAL =
-      0, /*!< Normal multi channel processing without output restrictions. */
-  SACDEC_OUT_MODE_BINAURAL, /*!< Two channel output with binaural processsing.
-                             */
-  SACDEC_OUT_MODE_STEREO,   /*!< Always two channel output mode.   */
-  SACDEC_OUT_MODE_6CHANNEL  /*!< Always process with 5.1 channel output.  */
-} SAC_DEC_OUTPUT_MODE;
-
-/**
- * \brief  MPEG Surround binaural HRTF model.
- *         HRTF will be applied only in combination with upmixtype
- *SAC_UPMIX_TYPE_BINAURAL.
- **/
-typedef enum {
-  SAC_BINAURAL_HRTF_KEMAR = 0,
-  SAC_BINAURAL_HRTF_VAST,
-  SAC_BINAURAL_HRTF_MPSVT,
-  SAC_BINAURAL_SINGLE_HRTFS
-} SAC_BINAURAL_HRTF_MODEL;
-
-/**
- * \brief  MPEG Surround decoder instance available.
- **/
-typedef enum {
-  SAC_INSTANCE_NOT_FULL_AVAILABLE =
-      0, /*!< MPEG Surround decoder instance not full available. */
-  SAC_INSTANCE_FULL_AVAILABLE /*!< MPEG Surround decoder instance full
-                                 available. */
-} SAC_INSTANCE_AVAIL;
-
-/**
- * \brief  MPEG Surround decoder dynamic parameters.
- *
- * Use mpegSurroundDecoder_SetParam() function to configure internal status of
- * following parameters.
- */
-typedef enum {
-  SACDEC_OUTPUT_MODE = 0x0001, /*!< Set MPEG Surround decoder output mode. See
-                                  SAC_DEC_OUTPUT_MODE. */
-  SACDEC_BLIND_ENABLE =
-      0x0002, /*!< Multi channel output without MPEG Surround side info.    */
-  SACDEC_PARTIALLY_COMPLEX =
-      0x0003, /*!< Set partially complex flag for MPEG Surround.
-                    0: Use complex valued QMF data.
-                    1: Use real valued QMF data (low power mode) */
-  SACDEC_INTERFACE =
-      0x0004, /*!< Select signal input interface for MPEG Surround.
-                     Switch time interface off:  0
-                     Switch time interface on:   1 */
-  SACDEC_BS_DELAY = 0x0005, /*!< Select bit stream delay for MPEG Surround.
-                                   Switch bit stream delay off:  0
-                                   Switch bit stream delay on:   1 */
-  SACDEC_BINAURAL_QUALITY =
-      0x0102, /*!< Set binaural quality for MPEG Surround binaural mode.
-                   0: Low Complexity,
-                   1: High Quality */
-  SACDEC_BINAURAL_DISTANCE = 0x0103, /*!< Set perceived distance for binaural
-                                        playback (binaural mode only). The valid
-                                        values  range from 0 to 100. Where 100
-                                        corresponds to the farthest perceived
-                                        distance. */
-  SACDEC_BINAURAL_DIALOG_CLARITY =
-      0x0104, /*!< Set dialog clarity (for binaural playback).
-                   The valid values range from 0 to 100. */
-  SACDEC_BINAURAL_FRONT_ANGLE = 0x0105, /*!< Set angle between the virtual front
-                                           speaker pair (binaural mode only).
-                                             The valid range is from 0 to 180
-                                           angular degrees. */
-  SACDEC_BINAURAL_BACK_ANGLE = 0x0106,  /*!< Set angle between the virtual back
-                                           speaker pair (binaural mode only).  The
-                                           valid range is from 0 to 180 angular
-                                           degrees. */
-  SACDEC_BINAURAL_PRESET = 0x0107, /*!< Set a virtual speaker setup preset for
-                                      binaural playback (binaural mode only).
-                                      This meta-parameter implicitly modifies
-                                      the following parameters:
-                                          SACDEC_BINAURAL_DISTANCE,
-                                          SACDEC_BINAURAL_DIALOG_CLARITY,
-                                          SACDEC_BINAURAL_FRONT_ANGLE and
-                                          SACDEC_BINAURAL_BACK_ANGLE.
-                                        The following presets are available:
-                                          1: Dry room
-                                          2: Living room (default)
-                                          3: Cinema */
-
-  SACDEC_BS_INTERRUPTION =
-      0x0200, /*!< If the given value is unequal to 0 hint the MPEG Surround
-                 decoder that the next input data is discontinuous, because of
-                 frame loss, seeking, etc. Announce the decoder that the
-                 bitstream data was interrupted (fSync = 0). This will cause the
-                 surround decoder not to parse any new bitstream data until a
-                 new header with a valid Spatial Specific Config and a
-                 independently decodable frame is found. Specially important
-                 when the MPEG Surround data is split accross several frames
-                 (for example in the case of AAC-LC downmix with 1024
-                 framelength and 2048 surround frame length) and a discontinuity
-                 in the bitstream data occurs. If fSync is 1, assume that MPEG
-                 Surround data is in sync (out of band config for example). */
-  SACDEC_CLEAR_HISTORY = 0x0201, /*!< If the given value is unequal to 0 clear
-                                    all internal states (delay lines, QMF
-                                    states, ...) of the MPEG Surround decoder.
-                                    This will cause a discontinuity in the audio
-                                    output signal. */
-
-  SACDEC_CONCEAL_NUM_KEEP_FRAMES =
-      0x0301, /*!< Error concealment: The Number of frames the module keeps the
-                 last spatial image before fading to the particular spatial
-                 scenario starts. The default is 10 frames. */
-  SACDEC_CONCEAL_FADE_OUT_SLOPE_LENGTH =
-      0x0302, /*!< Error concealment: Length of the slope (in frames) the module
-                 creates to fade from the last spatial scenario to the
-                 particular default scenario (downmix) in case of consecutive
-                 errors. Default is 5. */
-  SACDEC_CONCEAL_FADE_IN_SLOPE_LENGTH =
-      0x0303, /*!< Error concealment: Length of the slope (in frames) the module
-                 creates to fade from the default spatial scenario (downmix) to
-                 the current scenario after fade-out. Default parameter value
-                 is 5. */
-  SACDEC_CONCEAL_NUM_RELEASE_FRAMES =
-      0x0304 /*!< Error concealment: The number of error free frames before the
-                module starts fading from default to the current spatial
-                scenario. Default parameter value is 3 frames. */
-} SACDEC_PARAM;
-
-#define PCM_MPS INT_PCM
-
-/**
- * \brief MPEG Surround decoder handle.
- */
-typedef struct MpegSurroundDecoder CMpegSurroundDecoder;
-
-/**
- * \brief  Check if the full MPEG Surround decoder instance is allocated.
- *
- * Check if the full MPEG Surround decoder instance is allocated.
- *
- * \param pMpegSurroundDecoder   A pointer to a decoder stucture.
- *
- * \return SACDEC_ERROR error code
- */
-SAC_INSTANCE_AVAIL
-mpegSurroundDecoder_IsFullMpegSurroundDecoderInstanceAvailable(
-    CMpegSurroundDecoder *pMpegSurroundDecoder);
-
-/**
- * \brief  Open one instance of the MPEG Surround decoder.
- *
- * Allocate one instance of decoder and input buffers.
- * - Allocate decoder structure
- * - Allocate input buffers (QMF/time/MPS data)
- *
- * \param pMpegSurroundDecoder   A pointer to a decoder handle; filled on
- * return.
- * \param splitMemoryAllocation  Allocate only outer layer of MPS decoder. Core
- * part is reallocated later if needed.
- * \param stereoConfigIndex      USAC: Save memory by opening the MPS decoder
- * for a specific stereoConfigIndex. (Needs optimization macros enabled.)
- * \param pQmfDomain             Pointer to QMF domain data structure.
- *
- * \return SACDEC_ERROR error code
- */
-SACDEC_ERROR mpegSurroundDecoder_Open(
-    CMpegSurroundDecoder **pMpegSurroundDecoder, int stereoConfigIndex,
-    HANDLE_FDK_QMF_DOMAIN pQmfDomain);
-
-/**
- * \brief  Init one instance of the MPEG Surround decoder.
- *
- * Init one instance of the MPEG Surround decoder
- *
- * \param pMpegSurroundDecoder  A pointer to a decoder handle;
- *
- * \return SACDEC_ERROR error code
- */
-SACDEC_ERROR mpegSurroundDecoder_Init(
-    CMpegSurroundDecoder *pMpegSurroundDecoder);
-
-/**
- * \brief Read and parse SpatialSpecificConfig.
- *
- * \param pMpegSurroundDecoder  A pointer to a decoder handle.
- * \param hBs bitstream handle config parsing data source.
- *
- * \return SACDEC_ERROR error code
- */
-SACDEC_ERROR mpegSurroundDecoder_Config(
-    CMpegSurroundDecoder *pMpegSurroundDecoder, HANDLE_FDK_BITSTREAM hBs,
-    AUDIO_OBJECT_TYPE coreCodec, INT samplingRate, INT frameSize,
-    INT stereoConfigIndex, INT coreSbrFrameLengthIndex, INT configBytes,
-    const UCHAR configMode, UCHAR *configChanged);
-
-SACDEC_ERROR
-mpegSurroundDecoder_ConfigureQmfDomain(
-    CMpegSurroundDecoder *pMpegSurroundDecoder,
-    SAC_INPUT_CONFIG sac_dec_interface, UINT coreSamplingRate,
-    AUDIO_OBJECT_TYPE coreCodec);
-
-/**
- * \brief Parse MPEG Surround data without header
- *
- * \param pMpegSurroundDecoder A MPEG Surrround decoder handle.
- * \param hBs                  Bit stream handle data input source
- * \param pMpsDataBits         Pointer to number of valid bits in extension
- * payload. Function updates mpsDataBits while parsing bitstream.
- * \param fGlobalIndependencyFlag Global independency flag of current frame.
- *
- * \return  Error code.
- */
-int mpegSurroundDecoder_ParseNoHeader(
-    CMpegSurroundDecoder *pMpegSurroundDecoder, HANDLE_FDK_BITSTREAM hBs,
-    int *pMpsDataBits, int fGlobalIndependencyFlag);
-
-/* #ifdef SACDEC_MPS_ENABLE */
-/**
- * \brief Parse MPEG Surround data with header. Header is ancType, ancStart,
- ancStop (4 bits total). Body is ancDataSegmentByte[i].
- *
- * \param pMpegSurroundDecoder A MPEG Surrround decoder handle.
- * \param hBs                  Bit stream handle data input source
- * \param pMpsDataBits         Pointer to number of valid bits in extension
- payload. Function updates mpsDataBits while parsing bitstream. Needs to be a
- multiple of 8 + 4 (4 bits header).
- * \param coreCodec            The audio object type of the core codec handling
- the downmix input signal.
- * \param sampleRate           Samplerate of input downmix data.
- * \param nChannels            Amount of input channels.
- * \param frameSize            Amount of input samples.
- * \param fGlobalIndependencyFlag Global independency flag of current frame.
- *
- * \return  Error code.
- */
-int mpegSurroundDecoder_Parse(CMpegSurroundDecoder *pMpegSurroundDecoder,
-                              HANDLE_FDK_BITSTREAM hBs, int *pMpsDataBits,
-                              AUDIO_OBJECT_TYPE coreCodec, int sampleRate,
-                              int frameSize, int fGlobalIndependencyFlag);
-/* #endif */
-
-/**
- * \brief Apply MPEG Surround upmix.
- *
- * Process one downmix audio frame and decode one surround frame if it applies.
- * Downmix framing can be different from surround framing, so depending on the
- * frame size of the downmix audio data and the framing being used by the MPEG
- * Surround decoder, it could be that only every second call, for example, of
- * this function actually surround data was decoded. The returned value of
- * frameSize will be zero, if no surround data was decoded.
- *
- * Decoding one MPEG Surround frame. Depending on interface configuration
- * mpegSurroundDecoder_SetParam(self, SACDEC_INTERFACE, value), the QMF or time
- * interface will be applied. External access to QMF buffer interface can be
- * achieved by mpegSurroundDecoder_GetQmfBuffer() call before decode frame.
- * While using time interface, pTimeData buffer will be shared as input and
- * output buffer.
- *
- * \param pMpegSurroundDecoder A MPEG Surrround decoder handle.
- * \param pTimeData            Pointer to time buffer. Depending on interface
- * configuration, the content of pTimeData is ignored, and the internal QMF
- * buffer will be used as input data source.
- * Otherwise, the MPEG Surround processing is applied to the timesignal
- * pTimeData. For both variants, the resulting MPEG
- * Surround signal is written into pTimeData.
- * \param timeDataSize         Size of pTimeData (available buffer size).
- * \param timeDataFrameSize    Frame size of input timedata
- * \param nChannels            Pointer where the amount of input channels is
- * given and amount of output channels is returned.
- * \param frameSize            Pointer where the amount of output samples is
- * returned into.
- * \param channelType          Array were the corresponding channel type for
- * each output audio channel is stored into.
- * \param channelIndices       Array were the corresponding channel type index
- * for each output audio channel is stored into.
- * \param mapDescr             Channep map descriptor for output channel mapping
- * to be used (From MPEG PCE ordering to whatever is required).
- *
- * \return  Error code.
- */
-int mpegSurroundDecoder_Apply(CMpegSurroundDecoder *pMpegSurroundDecoder,
-                              INT_PCM *input, PCM_MPS *pTimeData,
-                              const int timeDataSize, int timeDataFrameSize,
-                              int *nChannels, int *frameSize, int sampleRate,
-                              AUDIO_OBJECT_TYPE coreCodec,
-                              AUDIO_CHANNEL_TYPE channelType[],
-                              UCHAR channelIndices[],
-                              const FDK_channelMapDescr *const mapDescr);
-
-/**
- * \brief                       Deallocate a MPEG Surround decoder instance.
- * \param pMpegSurroundDecoder  A decoder handle.
- * \return                      No return value.
- */
-void mpegSurroundDecoder_Close(CMpegSurroundDecoder *pMpegSurroundDecoder);
-
-/**
- * \brief                       Free config dependent MPEG Surround memory.
- * \param pMpegSurroundDecoder  A decoder handle.
- * \return                      error.
- */
-SACDEC_ERROR mpegSurroundDecoder_FreeMem(
-    CMpegSurroundDecoder *pMpegSurroundDecoder);
-
-/**
- * \brief  Set one single MPEG Surround decoder parameter.
- *
- * \param pMpegSurroundDecoder  A MPEG Surrround decoder handle. Must not be
- * NULL pointer.
- * \param param                 Parameter to be set. See SACDEC_PARAM.
- * \param value                 Parameter value. See SACDEC_PARAM.
- *
- * \return  0 on sucess, and non-zero on failure.
- */
-SACDEC_ERROR mpegSurroundDecoder_SetParam(
-    CMpegSurroundDecoder *pMpegSurroundDecoder, const SACDEC_PARAM param,
-    const INT value);
-
-/**
- * \brief          Retrieve MPEG Surround decoder library info and fill info list with all depending library infos.
- * \param libInfo  Pointer to library info list to be filled.
- * \return         0 on sucess, and non-zero on failure.
- **/
-int mpegSurroundDecoder_GetLibInfo(LIB_INFO *libInfo);
-
-/**
- * \brief  Set one single MPEG Surround decoder parameter.
- *
- * \param pMpegSurroundDecoder  A valid MPEG Surrround decoder handle.
- *
- * \return  The additional signal delay caused by the module.
- */
-UINT mpegSurroundDecoder_GetDelay(const CMpegSurroundDecoder *self);
-
-/**
- * \brief  Get info on whether the USAC pseudo LR feature is active.
- *
- * \param pMpegSurroundDecoder  A valid MPEG Surrround decoder handle.
- * \param bsPseudoLr            Pointer to return wether pseudo LR USAC feature
- * is used.
- *
- * \return  0 on sucess, and non-zero on failure.
- */
-SACDEC_ERROR mpegSurroundDecoder_IsPseudoLR(
-    CMpegSurroundDecoder *pMpegSurroundDecoder, int *bsPseudoLr);
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
-#endif /* #ifndef SAC_DEC_LIB_H */
--- a/libSACdec/src/sac_bitdec.cpp
+++ /dev/null
@@ -1,2167 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround decoder library *************************
-
-   Author(s):
-
-   Description: SAC Dec bitstream decoder
-
-*******************************************************************************/
-
-#include "sac_bitdec.h"
-
-#include "sac_dec_errorcodes.h"
-#include "nlc_dec.h"
-#include "sac_rom.h"
-#include "FDK_matrixCalloc.h"
-#include "sac_tsd.h"
-
-enum {
-  ottVsTotInactiv = 0,
-  ottVsTotDb1Activ = 1,
-  ottVsTotDb2Activ = 2,
-  ottVsTotDb1Db2Activ = 3
-};
-
-static SACDEC_ERROR SpatialDecDecodeHelperInfo(
-    SPATIAL_SPECIFIC_CONFIG *pSpatialSpecificConfig, UPMIXTYPE upmixType) {
-  int i;
-  UINT syntaxFlags;
-
-  /* Determine bit stream syntax */
-  syntaxFlags = 0;
-  switch (pSpatialSpecificConfig->coreCodec) {
-    case AOT_ER_AAC_ELD:
-    case AOT_ER_AAC_LD:
-      syntaxFlags |= SACDEC_SYNTAX_LD;
-      break;
-    case AOT_USAC:
-      syntaxFlags |= SACDEC_SYNTAX_USAC;
-      break;
-    case AOT_NONE:
-    default:
-      return MPS_UNSUPPORTED_FORMAT;
-  }
-
-  pSpatialSpecificConfig->syntaxFlags = syntaxFlags;
-
-  switch (pSpatialSpecificConfig->treeConfig) {
-    case TREE_212: {
-      pSpatialSpecificConfig->ottCLDdefault[0] = 0;
-    } break;
-    default:
-      return MPS_INVALID_TREECONFIG;
-  }
-
-  if (syntaxFlags & SACDEC_SYNTAX_USAC) {
-    if (pSpatialSpecificConfig->bsOttBandsPhasePresent) {
-      pSpatialSpecificConfig->numOttBandsIPD =
-          pSpatialSpecificConfig->bsOttBandsPhase;
-    } else {
-      int numParameterBands;
-
-      numParameterBands = pSpatialSpecificConfig->freqRes;
-      switch (numParameterBands) {
-        case 4:
-        case 5:
-          pSpatialSpecificConfig->numOttBandsIPD = 2;
-          break;
-        case 7:
-          pSpatialSpecificConfig->numOttBandsIPD = 3;
-          break;
-        case 10:
-          pSpatialSpecificConfig->numOttBandsIPD = 5;
-          break;
-        case 14:
-          pSpatialSpecificConfig->numOttBandsIPD = 7;
-          break;
-        case 20:
-        case 28:
-          pSpatialSpecificConfig->numOttBandsIPD = 10;
-          break;
-        default:
-          return MPS_INVALID_PARAMETERBANDS;
-      }
-    }
-  } else {
-    pSpatialSpecificConfig->numOttBandsIPD = 0;
-  }
-  for (i = 0; i < pSpatialSpecificConfig->nOttBoxes; i++) {
-    {
-      pSpatialSpecificConfig->bitstreamOttBands[i] =
-          pSpatialSpecificConfig->freqRes;
-    }
-    {
-      pSpatialSpecificConfig->numOttBands[i] =
-          pSpatialSpecificConfig->bitstreamOttBands[i];
-      if (syntaxFlags & SACDEC_SYNTAX_USAC &&
-          !pSpatialSpecificConfig->bsOttBandsPhasePresent) {
-        if (pSpatialSpecificConfig->bResidualCoding &&
-            pSpatialSpecificConfig->ResidualConfig[i].bResidualPresent &&
-            (pSpatialSpecificConfig->numOttBandsIPD <
-             pSpatialSpecificConfig->ResidualConfig[i].nResidualBands)) {
-          pSpatialSpecificConfig->numOttBandsIPD =
-              pSpatialSpecificConfig->ResidualConfig[i].nResidualBands;
-        }
-      }
-    }
-  } /* i */
-
-  return MPS_OK;
-}
-
-/*******************************************************************************
- Functionname: SpatialDecParseExtensionConfig
- *******************************************************************************
-
- Description:
-
- Arguments:
-
- Return:
-
-*******************************************************************************/
-
-static SACDEC_ERROR SpatialDecParseExtensionConfig(
-    HANDLE_FDK_BITSTREAM bitstream, SPATIAL_SPECIFIC_CONFIG *config,
-    int numOttBoxes, int numTttBoxes, int numOutChan, int bitsAvailable) {
-  SACDEC_ERROR err = MPS_OK;
-  INT ba = bitsAvailable;
-
-  config->sacExtCnt = 0;
-  config->bResidualCoding = 0;
-
-  ba = fMin((int)FDKgetValidBits(bitstream), ba);
-
-  while ((ba >= 8) && (config->sacExtCnt < MAX_NUM_EXT_TYPES)) {
-    int bitsRead, nFillBits;
-    INT tmp;
-    UINT sacExtLen;
-
-    config->sacExtType[config->sacExtCnt] = FDKreadBits(bitstream, 4);
-    ba -= 4;
-
-    sacExtLen = FDKreadBits(bitstream, 4);
-    ba -= 4;
-
-    if (sacExtLen == 15) {
-      sacExtLen += FDKreadBits(bitstream, 8);
-      ba -= 8;
-      if (sacExtLen == 15 + 255) {
-        sacExtLen += FDKreadBits(bitstream, 16);
-        ba -= 16;
-      }
-    }
-
-    tmp = (INT)FDKgetValidBits(
-        bitstream); /* Extension config payload start anchor. */
-    if ((tmp <= 0) || (tmp < (INT)sacExtLen * 8) || (ba < (INT)sacExtLen * 8)) {
-      err = MPS_PARSE_ERROR;
-      goto bail;
-    }
-
-    switch (config->sacExtType[config->sacExtCnt]) {
-      default:; /* unknown extension data => do nothing */
-    }
-
-    /* skip remaining extension data */
-    bitsRead = tmp - FDKgetValidBits(bitstream);
-    nFillBits = 8 * sacExtLen - bitsRead;
-
-    if (nFillBits < 0) {
-      err = MPS_PARSE_ERROR;
-      goto bail;
-    } else {
-      /* Skip fill bits or an unkown extension. */
-      FDKpushFor(bitstream, nFillBits);
-    }
-
-    ba -= 8 * sacExtLen;
-    config->sacExtCnt++;
-  }
-
-bail:
-  return err;
-}
-
-SACDEC_ERROR SpatialDecParseSpecificConfigHeader(
-    HANDLE_FDK_BITSTREAM bitstream,
-    SPATIAL_SPECIFIC_CONFIG *pSpatialSpecificConfig,
-    AUDIO_OBJECT_TYPE coreCodec, SPATIAL_DEC_UPMIX_TYPE upmixType) {
-  SACDEC_ERROR err = MPS_OK;
-  INT numFillBits;
-  int sacHeaderLen = 0;
-  int sacTimeAlignFlag = 0;
-
-  sacTimeAlignFlag = FDKreadBits(bitstream, 1);
-  sacHeaderLen = FDKreadBits(bitstream, 7);
-
-  if (sacHeaderLen == 127) {
-    sacHeaderLen += FDKreadBits(bitstream, 16);
-  }
-  numFillBits = (INT)FDKgetValidBits(bitstream);
-
-  err = SpatialDecParseSpecificConfig(bitstream, pSpatialSpecificConfig,
-                                      sacHeaderLen, coreCodec);
-
-  numFillBits -=
-      (INT)FDKgetValidBits(bitstream); /* the number of read bits (tmpBits) */
-  numFillBits = (8 * sacHeaderLen) - numFillBits;
-  if (numFillBits < 0) {
-    /* Parsing went wrong */
-    err = MPS_PARSE_ERROR;
-  }
-  /* Move to the very end of the SSC */
-  FDKpushBiDirectional(bitstream, numFillBits);
-
-  if ((err == MPS_OK) && sacTimeAlignFlag) {
-    /* not supported */
-    FDKreadBits(bitstream, 16);
-    err = MPS_UNSUPPORTED_CONFIG;
-  }
-
-  /* Derive additional helper variables */
-  SpatialDecDecodeHelperInfo(pSpatialSpecificConfig, (UPMIXTYPE)upmixType);
-
-  return err;
-}
-
-SACDEC_ERROR SpatialDecParseMps212Config(
-    HANDLE_FDK_BITSTREAM bitstream,
-    SPATIAL_SPECIFIC_CONFIG *pSpatialSpecificConfig, int samplingRate,
-    AUDIO_OBJECT_TYPE coreCodec, INT stereoConfigIndex,
-    INT coreSbrFrameLengthIndex) {
-  int i;
-
-  FDKmemclear(pSpatialSpecificConfig, sizeof(SPATIAL_SPECIFIC_CONFIG));
-
-  pSpatialSpecificConfig->stereoConfigIndex = stereoConfigIndex;
-  pSpatialSpecificConfig->coreSbrFrameLengthIndex = coreSbrFrameLengthIndex;
-  pSpatialSpecificConfig->freqRes =
-      (SPATIALDEC_FREQ_RES)freqResTable[FDKreadBits(bitstream, 3)];
-  if (pSpatialSpecificConfig->freqRes == 0) {
-    return MPS_PARSE_ERROR; /* reserved value */
-  }
-
-  switch (coreCodec) {
-    case AOT_DRM_USAC:
-      pSpatialSpecificConfig->bsFixedGainDMX =
-          (SPATIALDEC_FIXED_GAINS)FDKreadBits(bitstream, 3);
-      /* tempShapeConfig = (bsTempShapeConfigDrm == 1) ? 3 : 0 */
-      pSpatialSpecificConfig->tempShapeConfig =
-          (SPATIALDEC_TS_CONF)(FDKreadBits(bitstream, 1) * 3);
-      pSpatialSpecificConfig->decorrConfig = (SPATIALDEC_DECORR_CONF)0;
-      pSpatialSpecificConfig->bsDecorrType = 0;
-      break;
-    case AOT_USAC:
-      pSpatialSpecificConfig->bsFixedGainDMX =
-          (SPATIALDEC_FIXED_GAINS)FDKreadBits(bitstream, 3);
-      pSpatialSpecificConfig->tempShapeConfig =
-          (SPATIALDEC_TS_CONF)FDKreadBits(bitstream, 2);
-      pSpatialSpecificConfig->decorrConfig =
-          (SPATIALDEC_DECORR_CONF)FDKreadBits(bitstream, 2);
-      if (pSpatialSpecificConfig->decorrConfig > 2) {
-        return MPS_PARSE_ERROR; /* reserved value */
-      }
-      pSpatialSpecificConfig->bsDecorrType = 0;
-      break;
-    default:
-      return MPS_UNSUPPORTED_FORMAT;
-  }
-  pSpatialSpecificConfig->nTimeSlots = (coreSbrFrameLengthIndex == 4) ? 64 : 32;
-  pSpatialSpecificConfig->bsHighRateMode = (UCHAR)FDKreadBits(bitstream, 1);
-
-  {
-    pSpatialSpecificConfig->bsPhaseCoding = (UCHAR)FDKreadBits(bitstream, 1);
-    pSpatialSpecificConfig->bsOttBandsPhasePresent =
-        (UCHAR)FDKreadBits(bitstream, 1);
-    if (pSpatialSpecificConfig->bsOttBandsPhasePresent) {
-      if (MAX_PARAMETER_BANDS < (pSpatialSpecificConfig->bsOttBandsPhase =
-                                     FDKreadBits(bitstream, 5))) {
-        return MPS_PARSE_ERROR;
-      }
-    } else {
-      pSpatialSpecificConfig->bsOttBandsPhase = 0;
-    }
-  }
-
-  if (stereoConfigIndex > 1) { /* do residual coding */
-    pSpatialSpecificConfig->bResidualCoding = 1;
-    pSpatialSpecificConfig->ResidualConfig->bResidualPresent = 1;
-    if (pSpatialSpecificConfig->freqRes <
-        (pSpatialSpecificConfig->ResidualConfig->nResidualBands =
-             FDKreadBits(bitstream, 5))) {
-      return MPS_PARSE_ERROR;
-    }
-    pSpatialSpecificConfig->bsOttBandsPhase =
-        fMax(pSpatialSpecificConfig->bsOttBandsPhase,
-             pSpatialSpecificConfig->ResidualConfig->nResidualBands);
-    pSpatialSpecificConfig->bsPseudoLr = (UCHAR)FDKreadBits(bitstream, 1);
-
-    if (pSpatialSpecificConfig->bsPhaseCoding) {
-      pSpatialSpecificConfig->bsPhaseCoding = 3;
-    }
-  } else {
-    pSpatialSpecificConfig->bResidualCoding = 0;
-    pSpatialSpecificConfig->ResidualConfig->bResidualPresent = 0;
-  }
-
-  if (pSpatialSpecificConfig->tempShapeConfig == 2) {
-    switch (coreCodec) {
-      case AOT_USAC:
-        pSpatialSpecificConfig->envQuantMode = FDKreadBits(bitstream, 1);
-        break;
-      default: /* added to avoid compiler warning */
-        break; /* added to avoid compiler warning */
-    }
-  }
-
-  /* Static parameters */
-
-  pSpatialSpecificConfig->samplingFreq =
-      samplingRate; /* wrong for stereoConfigIndex == 3 but value is unused */
-  pSpatialSpecificConfig->treeConfig = SPATIALDEC_MODE_RSVD7;
-  pSpatialSpecificConfig->nOttBoxes =
-      treePropertyTable[pSpatialSpecificConfig->treeConfig].numOttBoxes;
-  pSpatialSpecificConfig->nInputChannels =
-      treePropertyTable[pSpatialSpecificConfig->treeConfig].numInputChannels;
-  pSpatialSpecificConfig->nOutputChannels =
-      treePropertyTable[pSpatialSpecificConfig->treeConfig].numOutputChannels;
-
-  pSpatialSpecificConfig->bArbitraryDownmix = 0;
-
-  for (i = 0; i < pSpatialSpecificConfig->nOttBoxes; i++) {
-    pSpatialSpecificConfig->OttConfig[i].nOttBands = 0;
-  }
-
-  if (coreCodec == AOT_DRM_USAC) {
-    /* MPS payload is MPEG conform -> no need for pseudo DRM AOT */
-    coreCodec = AOT_USAC;
-  }
-  pSpatialSpecificConfig->coreCodec = coreCodec;
-
-  /* Derive additional helper variables */
-  SpatialDecDecodeHelperInfo(pSpatialSpecificConfig, UPMIXTYPE_NORMAL);
-
-  return MPS_OK;
-}
-
-SACDEC_ERROR SpatialDecParseSpecificConfig(
-    HANDLE_FDK_BITSTREAM bitstream,
-    SPATIAL_SPECIFIC_CONFIG *pSpatialSpecificConfig, int sacHeaderLen,
-    AUDIO_OBJECT_TYPE coreCodec) {
-  SACDEC_ERROR err = MPS_OK;
-  int i;
-  int bsSamplingFreqIndex;
-  int bsFreqRes, b3DaudioMode = 0;
-  int numHeaderBits;
-  int cfgStartPos, bitsAvailable;
-
-  FDKmemclear(pSpatialSpecificConfig, sizeof(SPATIAL_SPECIFIC_CONFIG));
-
-  cfgStartPos = FDKgetValidBits(bitstream);
-  /* It might be that we do not know the SSC length beforehand. */
-  if (sacHeaderLen == 0) {
-    bitsAvailable = cfgStartPos;
-  } else {
-    bitsAvailable = 8 * sacHeaderLen;
-    if (bitsAvailable > cfgStartPos) {
-      err = MPS_PARSE_ERROR;
-      goto bail;
-    }
-  }
-
-  bsSamplingFreqIndex = FDKreadBits(bitstream, 4);
-
-  if (bsSamplingFreqIndex == 15) {
-    pSpatialSpecificConfig->samplingFreq = FDKreadBits(bitstream, 24);
-  } else {
-    pSpatialSpecificConfig->samplingFreq =
-        samplingFreqTable[bsSamplingFreqIndex];
-    if (pSpatialSpecificConfig->samplingFreq == 0) {
-      err = MPS_PARSE_ERROR;
-      goto bail;
-    }
-  }
-
-  pSpatialSpecificConfig->nTimeSlots = FDKreadBits(bitstream, 5) + 1;
-  if ((pSpatialSpecificConfig->nTimeSlots < 1) ||
-      (pSpatialSpecificConfig->nTimeSlots > MAX_TIME_SLOTS)) {
-    err = MPS_PARSE_ERROR;
-    goto bail;
-  }
-
-  bsFreqRes = FDKreadBits(bitstream, 3);
-
-  pSpatialSpecificConfig->freqRes =
-      (SPATIALDEC_FREQ_RES)freqResTable_LD[bsFreqRes];
-
-  pSpatialSpecificConfig->treeConfig =
-      (SPATIALDEC_TREE_CONFIG)FDKreadBits(bitstream, 4);
-
-  if (pSpatialSpecificConfig->treeConfig != SPATIALDEC_MODE_RSVD7) {
-    err = MPS_UNSUPPORTED_CONFIG;
-    goto bail;
-  }
-
-  {
-    pSpatialSpecificConfig->nOttBoxes =
-        treePropertyTable[pSpatialSpecificConfig->treeConfig].numOttBoxes;
-    pSpatialSpecificConfig->nTttBoxes =
-        treePropertyTable[pSpatialSpecificConfig->treeConfig].numTttBoxes;
-    pSpatialSpecificConfig->nInputChannels =
-        treePropertyTable[pSpatialSpecificConfig->treeConfig].numInputChannels;
-    pSpatialSpecificConfig->nOutputChannels =
-        treePropertyTable[pSpatialSpecificConfig->treeConfig].numOutputChannels;
-  }
-
-  pSpatialSpecificConfig->quantMode =
-      (SPATIALDEC_QUANT_MODE)FDKreadBits(bitstream, 2);
-
-  pSpatialSpecificConfig->bArbitraryDownmix = FDKreadBits(bitstream, 1);
-
-  pSpatialSpecificConfig->bsFixedGainDMX =
-      (SPATIALDEC_FIXED_GAINS)FDKreadBits(bitstream, 3);
-
-  pSpatialSpecificConfig->tempShapeConfig =
-      (SPATIALDEC_TS_CONF)FDKreadBits(bitstream, 2);
-  if (pSpatialSpecificConfig->tempShapeConfig > 2) {
-    return MPS_PARSE_ERROR; /* reserved value */
-  }
-
-  pSpatialSpecificConfig->decorrConfig =
-      (SPATIALDEC_DECORR_CONF)FDKreadBits(bitstream, 2);
-  if (pSpatialSpecificConfig->decorrConfig > 2) {
-    return MPS_PARSE_ERROR; /* reserved value */
-  }
-
-  for (i = 0; i < pSpatialSpecificConfig->nOttBoxes; i++) {
-    pSpatialSpecificConfig->OttConfig[i].nOttBands = 0;
-  }
-
-  for (i = 0; i < pSpatialSpecificConfig->nTttBoxes; i++) {
-    int bTttDualMode = FDKreadBits(bitstream, 1);
-    FDKreadBits(bitstream, 3); /* not supported */
-
-    if (bTttDualMode) {
-      FDKreadBits(bitstream, 8); /* not supported */
-    }
-  }
-
-  if (pSpatialSpecificConfig->tempShapeConfig == 2) {
-    pSpatialSpecificConfig->envQuantMode = FDKreadBits(bitstream, 1);
-  }
-
-  if (b3DaudioMode) {
-    if (FDKreadBits(bitstream, 2) == 0) { /* b3DaudioHRTFset ? */
-      int hc;
-      int HRTFnumBand;
-      int HRTFfreqRes = FDKreadBits(bitstream, 3);
-      int HRTFnumChan = FDKreadBits(bitstream, 4);
-      int HRTFasymmetric = FDKreadBits(bitstream, 1);
-
-      HRTFnumBand = freqResTable_LD[HRTFfreqRes];
-
-      for (hc = 0; hc < HRTFnumChan; hc++) {
-        FDKpushFor(bitstream, HRTFnumBand * 6); /* HRTFlevelLeft[hc][hb] */
-        if (HRTFasymmetric) {
-          FDKpushFor(bitstream, HRTFnumBand * 6); /* HRTFlevelRight[hc][hb] */
-        }
-        if (FDKreadBits(bitstream, 1)) {          /* HRTFphase[hc] ? */
-          FDKpushFor(bitstream, HRTFnumBand * 6); /* HRTFphaseLR[hc][hb] */
-        }
-        if (FDKreadBits(bitstream, 1)) {          /* HRTFicc[hc] ? */
-          FDKpushFor(bitstream, HRTFnumBand * 6); /* HRTFiccLR[hc][hb] */
-        }
-      }
-    }
-  }
-
-  FDKbyteAlign(bitstream,
-               cfgStartPos); /* ISO/IEC FDIS 23003-1: 5.2. ... byte alignment
-                                with respect to the beginning of the syntactic
-                                element in which ByteAlign() occurs. */
-
-  numHeaderBits = cfgStartPos - (INT)FDKgetValidBits(bitstream);
-  bitsAvailable -= numHeaderBits;
-  if (bitsAvailable < 0) {
-    err = MPS_PARSE_ERROR;
-    goto bail;
-  }
-
-  pSpatialSpecificConfig->sacExtCnt = 0;
-  pSpatialSpecificConfig->bResidualCoding = 0;
-
-  err = SpatialDecParseExtensionConfig(
-      bitstream, pSpatialSpecificConfig, pSpatialSpecificConfig->nOttBoxes,
-      pSpatialSpecificConfig->nTttBoxes,
-      pSpatialSpecificConfig->nOutputChannels, bitsAvailable);
-
-  FDKbyteAlign(
-      bitstream,
-      cfgStartPos); /* Same alignment anchor as above because
-                       SpatialExtensionConfig() always reads full bytes */
-
-  pSpatialSpecificConfig->coreCodec = coreCodec;
-
-  SpatialDecDecodeHelperInfo(pSpatialSpecificConfig, UPMIXTYPE_NORMAL);
-
-bail:
-  if (sacHeaderLen > 0) {
-    /* If the config is of known length then assure that the
-       bitbuffer is exactly at its end when leaving the function. */
-    FDKpushBiDirectional(
-        bitstream,
-        (sacHeaderLen * 8) - (cfgStartPos - (INT)FDKgetValidBits(bitstream)));
-  }
-
-  return err;
-}
-
-int SpatialDecDefaultSpecificConfig(
-    SPATIAL_SPECIFIC_CONFIG *pSpatialSpecificConfig,
-    AUDIO_OBJECT_TYPE coreCodec, int samplingFreq, int nTimeSlots,
-    int sacDecoderLevel, int isBlind, int numCoreChannels)
-
-{
-  int err = MPS_OK;
-  int i;
-
-  FDK_ASSERT(coreCodec != AOT_NONE);
-  FDK_ASSERT(nTimeSlots > 0);
-  FDK_ASSERT(samplingFreq > 0);
-
-  pSpatialSpecificConfig->coreCodec = coreCodec;
-  pSpatialSpecificConfig->samplingFreq = samplingFreq;
-  pSpatialSpecificConfig->nTimeSlots = nTimeSlots;
-  if ((pSpatialSpecificConfig->coreCodec == AOT_ER_AAC_ELD) ||
-      (pSpatialSpecificConfig->coreCodec == AOT_ER_AAC_LD))
-    pSpatialSpecificConfig->freqRes = SPATIALDEC_FREQ_RES_23;
-  else
-    pSpatialSpecificConfig->freqRes = SPATIALDEC_FREQ_RES_28;
-
-  {
-    pSpatialSpecificConfig->treeConfig =
-        SPATIALDEC_MODE_RSVD7; /* 212  configuration */
-  }
-
-  {
-    pSpatialSpecificConfig->nOttBoxes =
-        treePropertyTable[pSpatialSpecificConfig->treeConfig].numOttBoxes;
-    pSpatialSpecificConfig->nInputChannels =
-        treePropertyTable[pSpatialSpecificConfig->treeConfig].numInputChannels;
-    pSpatialSpecificConfig->nOutputChannels =
-        treePropertyTable[pSpatialSpecificConfig->treeConfig].numOutputChannels;
-  }
-
-  pSpatialSpecificConfig->quantMode = SPATIALDEC_QUANT_FINE_DEF;
-  pSpatialSpecificConfig->bArbitraryDownmix = 0;
-  pSpatialSpecificConfig->bResidualCoding = 0;
-  if ((pSpatialSpecificConfig->coreCodec == AOT_ER_AAC_ELD) ||
-      (pSpatialSpecificConfig->coreCodec == AOT_ER_AAC_LD))
-    pSpatialSpecificConfig->bsFixedGainDMX = SPATIALDEC_GAIN_RSVD2;
-  else
-    pSpatialSpecificConfig->bsFixedGainDMX = SPATIALDEC_GAIN_MODE0;
-
-  pSpatialSpecificConfig->tempShapeConfig = SPATIALDEC_TS_TPNOWHITE;
-  pSpatialSpecificConfig->decorrConfig = SPATIALDEC_DECORR_MODE0;
-
-  for (i = 0; i < pSpatialSpecificConfig->nOttBoxes; i++) {
-    pSpatialSpecificConfig->OttConfig[i].nOttBands = 0;
-  }
-
-  return err;
-}
-
-/*******************************************************************************
- Functionname: coarse2fine
- *******************************************************************************
-
- Description:
-   Parameter index mapping from coarse to fine quantization
-
- Arguments:
-
-Input:
-
-Output:
-
-*******************************************************************************/
-static void coarse2fine(SCHAR *data, DATA_TYPE dataType, int startBand,
-                        int numBands) {
-  int i;
-
-  for (i = startBand; i < startBand + numBands; i++) {
-    data[i] <<= 1;
-  }
-
-  if (dataType == t_CLD) {
-    for (i = startBand; i < startBand + numBands; i++) {
-      if (data[i] == -14)
-        data[i] = -15;
-      else if (data[i] == 14)
-        data[i] = 15;
-    }
-  }
-}
-
-/*******************************************************************************
- Functionname: fine2coarse
- *******************************************************************************
-
- Description:
-   Parameter index mapping from fine to coarse quantization
-
- Arguments:
-
-Input:
-
-Output:
-
-*******************************************************************************/
-static void fine2coarse(SCHAR *data, DATA_TYPE dataType, int startBand,
-                        int numBands) {
-  int i;
-
-  for (i = startBand; i < startBand + numBands; i++) {
-    /* Note: the if cases below actually make a difference (negative values) */
-    if (dataType == t_CLD)
-      data[i] /= 2;
-    else
-      data[i] >>= 1;
-  }
-}
-
-/*******************************************************************************
- Functionname: getStrideMap
- *******************************************************************************
-
- Description:
-   Index Mapping accroding to pbStrides
-
- Arguments:
-
-Input:
-
-Output:
-
-*******************************************************************************/
-static int getStrideMap(int freqResStride, int startBand, int stopBand,
-                        int *aStrides) {
-  int i, pb, pbStride, dataBands, strOffset;
-
-  pbStride = pbStrideTable[freqResStride];
-  dataBands = (stopBand - startBand - 1) / pbStride + 1;
-
-  aStrides[0] = startBand;
-  for (pb = 1; pb <= dataBands; pb++) {
-    aStrides[pb] = aStrides[pb - 1] + pbStride;
-  }
-  strOffset = 0;
-  while (aStrides[dataBands] > stopBand) {
-    if (strOffset < dataBands) strOffset++;
-    for (i = strOffset; i <= dataBands; i++) {
-      aStrides[i]--;
-    }
-  }
-
-  return dataBands;
-}
-
-/*******************************************************************************
- Functionname: ecDataDec
- *******************************************************************************
-
- Description:
-   Do delta decoding and dequantization
-
- Arguments:
-
-Input:
-
-Output:
-
-
-*******************************************************************************/
-
-static SACDEC_ERROR ecDataDec(
-    const SPATIAL_BS_FRAME *frame, UINT syntaxFlags,
-    HANDLE_FDK_BITSTREAM bitstream, LOSSLESSDATA *const llData,
-    SCHAR (*data)[MAX_PARAMETER_SETS][MAX_PARAMETER_BANDS], SCHAR **lastdata,
-    int datatype, int boxIdx, int startBand, int stopBand, SCHAR defaultValue) {
-  SACDEC_ERROR err = MPS_OK;
-  int i, j, pb, dataSets, setIdx, bsDataPair, dataBands, oldQuantCoarseXXX;
-  INT aStrides[MAX_PARAMETER_BANDS + 1] = {0};
-
-  dataSets = 0;
-  for (i = 0; i < frame->numParameterSets; i++) {
-    llData->bsXXXDataMode[i] = (SCHAR)FDKreadBits(bitstream, 2);
-
-    if ((frame->bsIndependencyFlag == 1) && (i == 0) &&
-        (llData->bsXXXDataMode[i] == 1 ||
-         llData->bsXXXDataMode[i] == 2)) { /* This check catches bitstreams
-                                              generated by older encoder that
-                                              cause trouble */
-      return MPS_PARSE_ERROR;
-    }
-    if ((i >= frame->numParameterSets - 1) &&
-        (llData->bsXXXDataMode[i] ==
-         2)) { /* The interpolation mode must not be active for the last
-                  parameter set */
-      return MPS_PARSE_ERROR;
-    }
-
-    if (llData->bsXXXDataMode[i] == 3) {
-      dataSets++;
-    }
-  }
-
-  setIdx = 0;
-  bsDataPair = 0;
-  oldQuantCoarseXXX = llData->state->bsQuantCoarseXXXprevParse;
-
-  for (i = 0; i < frame->numParameterSets; i++) {
-    if (llData->bsXXXDataMode[i] == 0) {
-      for (pb = startBand; pb < stopBand; pb++) {
-        lastdata[boxIdx][pb] = defaultValue;
-      }
-
-      oldQuantCoarseXXX = 0;
-    }
-
-    if (llData->bsXXXDataMode[i] == 3) {
-      if (bsDataPair) {
-        bsDataPair = 0;
-      } else {
-        bsDataPair = FDKreadBits(bitstream, 1);
-        llData->bsQuantCoarseXXX[setIdx] = (UCHAR)FDKreadBits(bitstream, 1);
-        llData->bsFreqResStrideXXX[setIdx] = (UCHAR)FDKreadBits(bitstream, 2);
-
-        if (llData->bsQuantCoarseXXX[setIdx] != oldQuantCoarseXXX) {
-          if (oldQuantCoarseXXX) {
-            coarse2fine(lastdata[boxIdx], (DATA_TYPE)datatype, startBand,
-                        stopBand - startBand);
-          } else {
-            fine2coarse(lastdata[boxIdx], (DATA_TYPE)datatype, startBand,
-                        stopBand - startBand);
-          }
-        }
-
-        dataBands = getStrideMap(llData->bsFreqResStrideXXX[setIdx], startBand,
-                                 stopBand, aStrides);
-
-        for (pb = 0; pb < dataBands; pb++) {
-          lastdata[boxIdx][startBand + pb] = lastdata[boxIdx][aStrides[pb]];
-        }
-
-        if (boxIdx > MAX_NUM_OTT) return MPS_INVALID_BOXIDX;
-        if ((setIdx + bsDataPair) > MAX_PARAMETER_SETS)
-          return MPS_INVALID_SETIDX;
-
-        /* DECODER_TYPE defined in FDK_tools */
-        DECODER_TYPE this_decoder_type = SAC_DECODER;
-        if (syntaxFlags & (SACDEC_SYNTAX_USAC | SACDEC_SYNTAX_RSVD50)) {
-          this_decoder_type = USAC_DECODER;
-        } else if (syntaxFlags & SACDEC_SYNTAX_LD) {
-          this_decoder_type = SAOC_DECODER;
-        }
-
-        err = (SACDEC_ERROR)EcDataPairDec(
-            this_decoder_type, bitstream, data[boxIdx][setIdx + 0],
-            data[boxIdx][setIdx + 1], lastdata[boxIdx], (DATA_TYPE)datatype,
-            startBand, dataBands, bsDataPair, llData->bsQuantCoarseXXX[setIdx],
-            !(frame->bsIndependencyFlag && (i == 0)) || (setIdx > 0));
-        if (err != MPS_OK) goto bail;
-
-        if (datatype == t_IPD) {
-          const SCHAR mask = (llData->bsQuantCoarseXXX[setIdx]) ? 7 : 15;
-          for (pb = 0; pb < dataBands; pb++) {
-            for (j = aStrides[pb]; j < aStrides[pb + 1]; j++) {
-              lastdata[boxIdx][j] =
-                  data[boxIdx][setIdx + bsDataPair][startBand + pb] & mask;
-            }
-          }
-        } else {
-          for (pb = 0; pb < dataBands; pb++) {
-            for (j = aStrides[pb]; j < aStrides[pb + 1]; j++) {
-              lastdata[boxIdx][j] =
-                  data[boxIdx][setIdx + bsDataPair][startBand + pb];
-            }
-          }
-        }
-
-        oldQuantCoarseXXX = llData->bsQuantCoarseXXX[setIdx];
-
-        if (bsDataPair) {
-          llData->bsQuantCoarseXXX[setIdx + 1] =
-              llData->bsQuantCoarseXXX[setIdx];
-          llData->bsFreqResStrideXXX[setIdx + 1] =
-              llData->bsFreqResStrideXXX[setIdx];
-        }
-        setIdx += bsDataPair + 1;
-      } /* !bsDataPair */
-    }   /* llData->bsXXXDataMode[i] == 3 */
-  }
-
-  llData->state->bsQuantCoarseXXXprevParse = oldQuantCoarseXXX;
-
-bail:
-  return err;
-}
-
-/*******************************************************************************
- Functionname: parseArbitraryDownmixData
- *******************************************************************************
-
- Description:
-
- Arguments:
-
- Return:
-
-*******************************************************************************/
-static SACDEC_ERROR parseArbitraryDownmixData(
-    spatialDec *self, const SPATIAL_SPECIFIC_CONFIG *pSSC,
-    const UINT syntaxFlags, const SPATIAL_BS_FRAME *frame,
-    HANDLE_FDK_BITSTREAM bitstream) {
-  SACDEC_ERROR err = MPS_OK;
-  int ch;
-  int offset = pSSC->nOttBoxes;
-
-  /* CLD (arbitrary down-mix gains) */
-  for (ch = 0; ch < pSSC->nInputChannels; ch++) {
-    err = ecDataDec(frame, syntaxFlags, bitstream,
-                    &frame->CLDLosslessData[offset + ch],
-                    frame->cmpArbdmxGainIdx, self->cmpArbdmxGainIdxPrev, t_CLD,
-                    ch, 0, pSSC->freqRes, arbdmxGainDefault);
-    if (err != MPS_OK) return err;
-  }
-
-  return err;
-
-} /* parseArbitraryDownmixData */
-
-/*******************************************************************************
- Functionname: SpatialDecParseFrame
- *******************************************************************************
-
- Description:
-
- Arguments:
-
- Input:
-
- Output:
-
-*******************************************************************************/
-
-static int nBitsParamSlot(int i) {
-  int bitsParamSlot;
-
-  bitsParamSlot = fMax(0, DFRACT_BITS - 1 - fNormz((FIXP_DBL)i));
-  if ((1 << bitsParamSlot) < i) {
-    bitsParamSlot++;
-  }
-  FDK_ASSERT((bitsParamSlot >= 0) && (bitsParamSlot <= 32));
-
-  return bitsParamSlot;
-}
-
-SACDEC_ERROR SpatialDecParseFrameData(
-    spatialDec_struct *self, SPATIAL_BS_FRAME *frame,
-    HANDLE_FDK_BITSTREAM bitstream,
-    const SPATIAL_SPECIFIC_CONFIG *pSpatialSpecificConfig, UPMIXTYPE upmixType,
-    int fGlobalIndependencyFlag) {
-  SACDEC_ERROR err = MPS_OK;
-  int bsFramingType, dataBands, ps, pg, i;
-  int pb;
-  int numTempShapeChan = 0;
-  int bsNumOutputChannels =
-      treePropertyTable[pSpatialSpecificConfig->treeConfig]
-          .numOutputChannels; /* CAUTION: Maybe different to
-                                 pSpatialSpecificConfig->treeConfig in some
-                                 modes! */
-  int paramSetErr = 0;
-  UINT alignAnchor = FDKgetValidBits(
-      bitstream); /* Anchor for ByteAlign() function. See comment below. */
-  UINT syntaxFlags;
-
-  syntaxFlags = pSpatialSpecificConfig->syntaxFlags;
-
-  if ((syntaxFlags & (SACDEC_SYNTAX_USAC | SACDEC_SYNTAX_RSVD50)) &&
-      pSpatialSpecificConfig->bsHighRateMode == 0) {
-    bsFramingType = 0; /* fixed framing */
-    frame->numParameterSets = 1;
-  } else {
-    bsFramingType = FDKreadBits(bitstream, 1);
-    if (syntaxFlags & SACDEC_SYNTAX_LD)
-      frame->numParameterSets = FDKreadBits(bitstream, 1) + 1;
-    else
-      frame->numParameterSets = FDKreadBits(bitstream, 3) + 1;
-  }
-
-  /* Any error after this line shall trigger parameter invalidation at bail
-   * label. */
-  paramSetErr = 1;
-
-  if (frame->numParameterSets >= MAX_PARAMETER_SETS) {
-    goto bail;
-  }
-
-  /* Basic config check. */
-  if (pSpatialSpecificConfig->nInputChannels <= 0 ||
-      pSpatialSpecificConfig->nOutputChannels <= 0) {
-    err = MPS_UNSUPPORTED_CONFIG;
-    goto bail;
-  }
-
-  if (bsFramingType) {
-    int prevParamSlot = -1;
-    int bitsParamSlot;
-
-    {
-      bitsParamSlot = nBitsParamSlot(pSpatialSpecificConfig->nTimeSlots);
-
-      for (i = 0; i < frame->numParameterSets; i++) {
-        frame->paramSlot[i] = FDKreadBits(bitstream, bitsParamSlot);
-        /* Sanity check */
-        if ((frame->paramSlot[i] <= prevParamSlot) ||
-            (frame->paramSlot[i] >= pSpatialSpecificConfig->nTimeSlots)) {
-          err = MPS_PARSE_ERROR;
-          goto bail;
-        }
-        prevParamSlot = frame->paramSlot[i];
-      }
-    }
-  } else {
-    for (i = 0; i < frame->numParameterSets; i++) {
-      frame->paramSlot[i] = ((pSpatialSpecificConfig->nTimeSlots * (i + 1)) /
-                             frame->numParameterSets) -
-                            1;
-    }
-  }
-
-  if ((syntaxFlags & (SACDEC_SYNTAX_USAC | SACDEC_SYNTAX_RSVD50)) &&
-      fGlobalIndependencyFlag) {
-    frame->bsIndependencyFlag = 1;
-  } else {
-    frame->bsIndependencyFlag = (UCHAR)FDKreadBits(bitstream, 1);
-  }
-
-  /*
-   * OttData()
-   */
-  for (i = 0; i < pSpatialSpecificConfig->nOttBoxes; i++) {
-    err = ecDataDec(frame, syntaxFlags, bitstream, &frame->CLDLosslessData[i],
-                    frame->cmpOttCLDidx, self->cmpOttCLDidxPrev, t_CLD, i, 0,
-                    pSpatialSpecificConfig->bitstreamOttBands[i],
-                    pSpatialSpecificConfig->ottCLDdefault[i]);
-    if (err != MPS_OK) {
-      goto bail;
-    }
-  } /* i < numOttBoxes */
-
-  {
-    for (i = 0; i < pSpatialSpecificConfig->nOttBoxes; i++) {
-      err = ecDataDec(frame, syntaxFlags, bitstream, &frame->ICCLosslessData[i],
-                      frame->cmpOttICCidx, self->cmpOttICCidxPrev, t_ICC, i, 0,
-                      pSpatialSpecificConfig->bitstreamOttBands[i], ICCdefault);
-      if (err != MPS_OK) {
-        goto bail;
-      }
-    } /* i < numOttBoxes */
-  }   /* !oneICC */
-
-  if ((pSpatialSpecificConfig->treeConfig == SPATIALDEC_MODE_RSVD7) &&
-      (pSpatialSpecificConfig->bsPhaseCoding)) {
-    frame->phaseMode = FDKreadBits(bitstream, 1);
-
-    if (frame->phaseMode == 0) {
-      for (pb = 0; pb < pSpatialSpecificConfig->numOttBandsIPD; pb++) {
-        self->cmpOttIPDidxPrev[0][pb] = 0;
-        for (i = 0; i < frame->numParameterSets; i++) {
-          frame->cmpOttIPDidx[0][i][pb] = 0;
-          // frame->ottIPDidx[0][i][pb] = 0;
-        }
-        /* self->ottIPDidxPrev[0][pb] = 0; */
-      }
-      frame->OpdSmoothingMode = 0;
-    } else {
-      frame->OpdSmoothingMode = FDKreadBits(bitstream, 1);
-      err = ecDataDec(frame, syntaxFlags, bitstream, &frame->IPDLosslessData[0],
-                      frame->cmpOttIPDidx, self->cmpOttIPDidxPrev, t_IPD, 0, 0,
-                      pSpatialSpecificConfig->numOttBandsIPD, IPDdefault);
-      if (err != MPS_OK) {
-        goto bail;
-      }
-    }
-  }
-
-  /*
-   * SmgData()
-   */
-
-  {
-    if (!pSpatialSpecificConfig->bsHighRateMode &&
-        (syntaxFlags & SACDEC_SYNTAX_USAC)) {
-      for (ps = 0; ps < frame->numParameterSets; ps++) {
-        frame->bsSmoothMode[ps] = 0;
-      }
-    } else {
-      for (ps = 0; ps < frame->numParameterSets; ps++) {
-        frame->bsSmoothMode[ps] = (UCHAR)FDKreadBits(bitstream, 2);
-        if (frame->bsSmoothMode[ps] >= 2) {
-          frame->bsSmoothTime[ps] = (UCHAR)FDKreadBits(bitstream, 2);
-        }
-        if (frame->bsSmoothMode[ps] == 3) {
-          frame->bsFreqResStrideSmg[ps] = (UCHAR)FDKreadBits(bitstream, 2);
-          dataBands = (pSpatialSpecificConfig->freqRes - 1) /
-                          pbStrideTable[frame->bsFreqResStrideSmg[ps]] +
-                      1;
-          for (pg = 0; pg < dataBands; pg++) {
-            frame->bsSmgData[ps][pg] = (UCHAR)FDKreadBits(bitstream, 1);
-          }
-        }
-      } /* ps < numParameterSets */
-    }
-  }
-
-  /*
-   * TempShapeData()
-   */
-  if ((pSpatialSpecificConfig->tempShapeConfig == 3) &&
-      (syntaxFlags & SACDEC_SYNTAX_USAC)) {
-    int TsdErr;
-    TsdErr = TsdRead(bitstream, pSpatialSpecificConfig->nTimeSlots,
-                     &frame->TsdData[0]);
-    if (TsdErr) {
-      err = MPS_PARSE_ERROR;
-      goto bail;
-    }
-  } else {
-    frame->TsdData[0].bsTsdEnable = 0;
-  }
-
-  for (i = 0; i < bsNumOutputChannels; i++) {
-    frame->tempShapeEnableChannelSTP[i] = 0;
-    frame->tempShapeEnableChannelGES[i] = 0;
-  }
-
-  if ((pSpatialSpecificConfig->tempShapeConfig == 1) ||
-      (pSpatialSpecificConfig->tempShapeConfig == 2)) {
-    int bsTempShapeEnable = FDKreadBits(bitstream, 1);
-    if (bsTempShapeEnable) {
-      numTempShapeChan =
-          tempShapeChanTable[pSpatialSpecificConfig->tempShapeConfig - 1]
-                            [pSpatialSpecificConfig->treeConfig];
-      switch (pSpatialSpecificConfig->tempShapeConfig) {
-        case 1: /* STP */
-          for (i = 0; i < numTempShapeChan; i++) {
-            int stpEnable = FDKreadBits(bitstream, 1);
-            frame->tempShapeEnableChannelSTP[i] = stpEnable;
-          }
-          break;
-        case 2: /* GES */
-        {
-          UCHAR gesChannelEnable[MAX_OUTPUT_CHANNELS];
-
-          for (i = 0; i < numTempShapeChan; i++) {
-            gesChannelEnable[i] = (UCHAR)FDKreadBits(bitstream, 1);
-            frame->tempShapeEnableChannelGES[i] = gesChannelEnable[i];
-          }
-          for (i = 0; i < numTempShapeChan; i++) {
-            if (gesChannelEnable[i]) {
-              int envShapeData_tmp[MAX_TIME_SLOTS];
-              if (huff_dec_reshape(bitstream, envShapeData_tmp,
-                                   pSpatialSpecificConfig->nTimeSlots) != 0) {
-                err = MPS_PARSE_ERROR;
-                goto bail;
-              }
-              for (int ts = 0; ts < pSpatialSpecificConfig->nTimeSlots; ts++) {
-                if (!(envShapeData_tmp[ts] >= 0) &&
-                    (envShapeData_tmp[ts] <= 4)) {
-                  err = MPS_PARSE_ERROR;
-                  goto bail;
-                }
-                frame->bsEnvShapeData[i][ts] = (UCHAR)envShapeData_tmp[ts];
-              }
-            }
-          }
-        } break;
-        default:
-          err = MPS_INVALID_TEMPSHAPE;
-          goto bail;
-      }
-    } /* bsTempShapeEnable */
-  }   /* pSpatialSpecificConfig->tempShapeConfig != 0 */
-
-  if (pSpatialSpecificConfig->bArbitraryDownmix != 0) {
-    err = parseArbitraryDownmixData(self, pSpatialSpecificConfig, syntaxFlags,
-                                    frame, bitstream);
-    if (err != MPS_OK) goto bail;
-  }
-
-  if (1 && (!(syntaxFlags & (SACDEC_SYNTAX_USAC)))) {
-    FDKbyteAlign(bitstream,
-                 alignAnchor); /* ISO/IEC FDIS 23003-1: 5.2. ... byte alignment
-                                  with respect to the beginning of the syntactic
-                                  element in which ByteAlign() occurs. */
-  }
-
-bail:
-  if (err != MPS_OK && paramSetErr != 0) {
-    /* Since the parameter set data has already been written to the instance we
-     * need to ... */
-    frame->numParameterSets = 0; /* ... signal that it is corrupt ... */
-  }
-
-  return err;
-
-} /* SpatialDecParseFrame */
-
-/*******************************************************************************
- Functionname: createMapping
- *******************************************************************************
-
- Description:
-
- Arguments:
-
- Return:
-
-*******************************************************************************/
-static void createMapping(int aMap[MAX_PARAMETER_BANDS + 1], int startBand,
-                          int stopBand, int stride) {
-  int inBands, outBands, bandsAchived, bandsDiff, incr, k, i;
-  int vDk[MAX_PARAMETER_BANDS + 1];
-  inBands = stopBand - startBand;
-  outBands = (inBands - 1) / stride + 1;
-
-  if (outBands < 1) {
-    outBands = 1;
-  }
-
-  bandsAchived = outBands * stride;
-  bandsDiff = inBands - bandsAchived;
-  for (i = 0; i < outBands; i++) {
-    vDk[i] = stride;
-  }
-
-  if (bandsDiff > 0) {
-    incr = -1;
-    k = outBands - 1;
-  } else {
-    incr = 1;
-    k = 0;
-  }
-
-  while (bandsDiff != 0) {
-    vDk[k] = vDk[k] - incr;
-    k = k + incr;
-    bandsDiff = bandsDiff + incr;
-    if (k >= outBands) {
-      if (bandsDiff > 0) {
-        k = outBands - 1;
-      } else if (bandsDiff < 0) {
-        k = 0;
-      }
-    }
-  }
-  aMap[0] = startBand;
-  for (i = 0; i < outBands; i++) {
-    aMap[i + 1] = aMap[i] + vDk[i];
-  }
-} /* createMapping */
-
-/*******************************************************************************
- Functionname: mapFrequency
- *******************************************************************************
-
- Description:
-
- Arguments:
-
- Return:
-
-*******************************************************************************/
-static void mapFrequency(const SCHAR *pInput, /* Input */
-                         SCHAR *pOutput,      /* Output */
-                         int *pMap,           /* Mapping function */
-                         int dataBands)       /* Number of data Bands */
-{
-  int i, j;
-  int startBand0 = pMap[0];
-
-  for (i = 0; i < dataBands; i++) {
-    int startBand, stopBand, value;
-
-    value = pInput[i + startBand0];
-
-    startBand = pMap[i];
-    stopBand = pMap[i + 1];
-    for (j = startBand; j < stopBand; j++) {
-      pOutput[j] = value;
-    }
-  }
-}
-
-/*******************************************************************************
- Functionname: deq
- *******************************************************************************
-
- Description:
-
- Arguments:
-
- Return:
-
-*******************************************************************************/
-static int deqIdx(int value, int paramType) {
-  int idx = -1;
-
-  switch (paramType) {
-    case t_CLD:
-      if (((value + 15) >= 0) && ((value + 15) < 31)) {
-        idx = (value + 15);
-      }
-      break;
-
-    case t_ICC:
-      if ((value >= 0) && (value < 8)) {
-        idx = value;
-      }
-      break;
-
-    case t_IPD:
-      /* (+/-)15 * MAX_PARAMETER_BANDS for differential coding in frequency
-       * domain (according to rbl) */
-      if ((value >= -420) && (value <= 420)) {
-        idx = (value & 0xf);
-      }
-      break;
-
-    default:
-      FDK_ASSERT(0);
-  }
-
-  return idx;
-}
-
-  /*******************************************************************************
-   Functionname: factorFunct
-   *******************************************************************************
-
-   Description:
-
-   Arguments:
-
-   Return:
-
-  *******************************************************************************/
-
-#define SF_IDX (7)
-#define SF_FACTOR (3)
-#define SCALE_FACTOR (1 << SF_FACTOR)
-#define SCALE_CLD_C1C2 (1 << SF_CLD_C1C2)
-
-static FIXP_DBL factorFunct(FIXP_DBL ottVsTotDb, INT quantMode) {
-  FIXP_DBL factor;
-
-  if (ottVsTotDb > FL2FXCONST_DBL(0.0)) {
-    ottVsTotDb = FL2FXCONST_DBL(0.0);
-  }
-
-  ottVsTotDb = -ottVsTotDb;
-
-  switch (quantMode) {
-    case 0:
-      factor = FL2FXCONST_DBL(1.0f / SCALE_FACTOR);
-      break;
-    case 1:
-      if (ottVsTotDb >= FL2FXCONST_DBL(21.0f / SCALE_CLD_C1C2))
-        factor = FL2FXCONST_DBL(5.0f / SCALE_FACTOR);
-      else if (ottVsTotDb <= FL2FXCONST_DBL(1.0f / SCALE_CLD_C1C2))
-        factor = FL2FXCONST_DBL(1.0f / SCALE_FACTOR);
-      else
-        factor = (fMult(FL2FXCONST_DBL(0.2f), ottVsTotDb) +
-                  FL2FXCONST_DBL(0.8f / SCALE_CLD_C1C2))
-                 << (SF_CLD_C1C2 - SF_FACTOR);
-      break;
-    case 2:
-      if (ottVsTotDb >= FL2FXCONST_DBL(25.0f / SCALE_CLD_C1C2)) {
-        FDK_ASSERT(SF_FACTOR == 3);
-        factor = (FIXP_DBL)
-            MAXVAL_DBL; /* avoid warning: FL2FXCONST_DBL(8.0f/SCALE_FACTOR) */
-      } else if (ottVsTotDb <= FL2FXCONST_DBL(1.0f / SCALE_CLD_C1C2))
-        factor = FL2FXCONST_DBL(1.0f / SCALE_FACTOR);
-      else
-        factor = (fMult(FL2FXCONST_DBL(7.0f / 24.0f), ottVsTotDb) +
-                  FL2FXCONST_DBL((17.0f / 24.0f) / SCALE_CLD_C1C2))
-                 << (SF_CLD_C1C2 - SF_FACTOR);
-      break;
-    default:
-      factor = FL2FXCONST_DBL(0.0f);
-  }
-
-  return (factor);
-}
-
-/*******************************************************************************
- Functionname: factorCLD
- *******************************************************************************
-
- Description:
-
- Arguments:
-
- Return:
-
-*******************************************************************************/
-static void factorCLD(SCHAR *idx, FIXP_DBL ottVsTotDb, FIXP_DBL *ottVsTotDb1,
-                      FIXP_DBL *ottVsTotDb2, SCHAR ottVsTotDbMode,
-                      INT quantMode) {
-  FIXP_DBL factor;
-  FIXP_DBL cldIdxFract;
-  INT cldIdx;
-
-  factor = factorFunct(ottVsTotDb, quantMode);
-
-  cldIdxFract =
-      fMult((FIXP_DBL)((*idx) << ((DFRACT_BITS - 1) - SF_IDX)), factor);
-  cldIdxFract += FL2FXCONST_DBL(15.5f / (1 << (SF_FACTOR + SF_IDX)));
-  cldIdx = fixp_truncateToInt(cldIdxFract, SF_FACTOR + SF_IDX);
-
-  cldIdx = fMin(cldIdx, 30);
-  cldIdx = fMax(cldIdx, 0);
-
-  *idx = cldIdx - 15;
-
-  if (ottVsTotDbMode & ottVsTotDb1Activ)
-    (*ottVsTotDb1) = ottVsTotDb + dequantCLD_c1[cldIdx];
-
-  if (ottVsTotDbMode & ottVsTotDb2Activ)
-    (*ottVsTotDb2) = ottVsTotDb + dequantCLD_c1[30 - cldIdx];
-}
-
-/*******************************************************************************
- Functionname: mapIndexData
- *******************************************************************************
-
- Description:
-
- Arguments:
-
- Return:
-
-*******************************************************************************/
-static SACDEC_ERROR mapIndexData(
-    LOSSLESSDATA *llData, SCHAR ***outputDataIdx, SCHAR ***outputIdxData,
-    const SCHAR (*cmpIdxData)[MAX_PARAMETER_SETS][MAX_PARAMETER_BANDS],
-    SCHAR ***diffIdxData, SCHAR xttIdx, SCHAR **idxPrev, int paramIdx,
-    int paramType, int startBand, int stopBand, SCHAR defaultValue,
-    int numParameterSets, const int *paramSlot, int extendFrame, int quantMode,
-    SpatialDecConcealmentInfo *concealmentInfo, SCHAR ottVsTotDbMode,
-    FIXP_DBL (*pOttVsTotDbIn)[MAX_PARAMETER_SETS][MAX_PARAMETER_BANDS],
-    FIXP_DBL (*pOttVsTotDb1)[MAX_PARAMETER_SETS][MAX_PARAMETER_BANDS],
-    FIXP_DBL (*pOttVsTotDb2)[MAX_PARAMETER_SETS][MAX_PARAMETER_BANDS]) {
-  int aParamSlots[MAX_PARAMETER_SETS];
-  int aInterpolate[MAX_PARAMETER_SETS];
-
-  int dataSets;
-  int aMap[MAX_PARAMETER_BANDS + 1];
-
-  int setIdx, i, band, parmSlot;
-  int dataBands;
-  int ps, pb;
-  int i1;
-
-  if (numParameterSets > MAX_PARAMETER_SETS) return MPS_WRONG_PARAMETERSETS;
-
-  dataSets = 0;
-  for (i = 0; i < numParameterSets; i++) {
-    if (llData->bsXXXDataMode[i] == 3) {
-      aParamSlots[dataSets] = i;
-      dataSets++;
-    }
-  }
-
-  setIdx = 0;
-
-  /* Main concealment stage is here: */
-  SpatialDecConcealment_Apply(
-      concealmentInfo, cmpIdxData[xttIdx],
-      (diffIdxData != NULL) ? diffIdxData[xttIdx] : NULL, idxPrev[xttIdx],
-      llData->bsXXXDataMode, startBand, stopBand, defaultValue, paramType,
-      numParameterSets);
-
-  /* Prepare data */
-  for (i = 0; i < numParameterSets; i++) {
-    if (llData->bsXXXDataMode[i] == 0) {
-      llData->nocmpQuantCoarseXXX[i] = 0;
-      for (band = startBand; band < stopBand; band++) {
-        outputIdxData[xttIdx][i][band] = defaultValue;
-      }
-      for (band = startBand; band < stopBand; band++) {
-        idxPrev[xttIdx][band] = outputIdxData[xttIdx][i][band];
-      }
-      /* Because the idxPrev are also set to the defaultValue -> signalize fine
-       */
-      llData->state->bsQuantCoarseXXXprev = 0;
-    }
-
-    if (llData->bsXXXDataMode[i] == 1) {
-      for (band = startBand; band < stopBand; band++) {
-        outputIdxData[xttIdx][i][band] = idxPrev[xttIdx][band];
-      }
-      llData->nocmpQuantCoarseXXX[i] = llData->state->bsQuantCoarseXXXprev;
-    }
-
-    if (llData->bsXXXDataMode[i] == 2) {
-      for (band = startBand; band < stopBand; band++) {
-        outputIdxData[xttIdx][i][band] = idxPrev[xttIdx][band];
-      }
-      llData->nocmpQuantCoarseXXX[i] = llData->state->bsQuantCoarseXXXprev;
-      aInterpolate[i] = 1;
-    } else {
-      aInterpolate[i] = 0;
-    }
-
-    if (llData->bsXXXDataMode[i] == 3) {
-      int stride;
-
-      parmSlot = aParamSlots[setIdx];
-      stride = pbStrideTable[llData->bsFreqResStrideXXX[setIdx]];
-      dataBands = (stopBand - startBand - 1) / stride + 1;
-      createMapping(aMap, startBand, stopBand, stride);
-      mapFrequency(&cmpIdxData[xttIdx][setIdx][0],
-                   &outputIdxData[xttIdx][parmSlot][0], aMap, dataBands);
-      for (band = startBand; band < stopBand; band++) {
-        idxPrev[xttIdx][band] = outputIdxData[xttIdx][parmSlot][band];
-      }
-      llData->state->bsQuantCoarseXXXprev = llData->bsQuantCoarseXXX[setIdx];
-      llData->nocmpQuantCoarseXXX[i] = llData->bsQuantCoarseXXX[setIdx];
-
-      setIdx++;
-    }
-    if (diffIdxData != NULL) {
-      for (band = startBand; band < stopBand; band++) {
-        outputIdxData[xttIdx][i][band] += diffIdxData[xttIdx][i][band];
-      }
-    }
-  } /* for( i = 0 ; i < numParameterSets; i++ ) */
-
-  /* Map all coarse data to fine */
-  for (i = 0; i < numParameterSets; i++) {
-    if (llData->nocmpQuantCoarseXXX[i] == 1) {
-      coarse2fine(outputIdxData[xttIdx][i], (DATA_TYPE)paramType, startBand,
-                  stopBand - startBand);
-      llData->nocmpQuantCoarseXXX[i] = 0;
-    }
-  }
-
-  /* Interpolate */
-  i1 = 0;
-  for (i = 0; i < numParameterSets; i++) {
-    int xi, i2, x1, x2;
-
-    if (aInterpolate[i] != 1) {
-      i1 = i;
-    }
-    i2 = i;
-    while (aInterpolate[i2] == 1) {
-      i2++;
-    }
-    x1 = paramSlot[i1];
-    xi = paramSlot[i];
-    x2 = paramSlot[i2];
-
-    if (aInterpolate[i] == 1) {
-      if (i2 >= numParameterSets) return MPS_WRONG_PARAMETERSETS;
-      for (band = startBand; band < stopBand; band++) {
-        int yi, y1, y2;
-        y1 = outputIdxData[xttIdx][i1][band];
-        y2 = outputIdxData[xttIdx][i2][band];
-        if (x1 != x2) {
-          yi = y1 + (xi - x1) * (y2 - y1) / (x2 - x1);
-        } else {
-          yi = y1 /*+ (xi-x1)*(y2-y1)/1e-12*/;
-        }
-        outputIdxData[xttIdx][i][band] = yi;
-      }
-    }
-  } /* for( i = 0 ; i < numParameterSets; i++ ) */
-
-  /* Dequantize data and apply factorCLD if necessary */
-  for (ps = 0; ps < numParameterSets; ps++) {
-    if (quantMode && (paramType == t_CLD)) {
-      if (pOttVsTotDbIn == 0) return MPS_WRONG_OTT;
-      if ((pOttVsTotDb1 == 0) && (ottVsTotDbMode == ottVsTotDb1Activ))
-        return MPS_WRONG_OTT;
-      if ((pOttVsTotDb2 == 0) && (ottVsTotDbMode == ottVsTotDb2Activ))
-        return MPS_WRONG_OTT;
-
-      for (pb = startBand; pb < stopBand; pb++) {
-        factorCLD(&(outputIdxData[xttIdx][ps][pb]), (*pOttVsTotDbIn)[ps][pb],
-                  (pOttVsTotDb1 != NULL) ? &((*pOttVsTotDb1)[ps][pb]) : NULL,
-                  (pOttVsTotDb2 != NULL) ? &((*pOttVsTotDb2)[ps][pb]) : NULL,
-                  ottVsTotDbMode, quantMode);
-      }
-    }
-
-    /* Dequantize data */
-    for (band = startBand; band < stopBand; band++) {
-      outputDataIdx[xttIdx][ps][band] =
-          deqIdx(outputIdxData[xttIdx][ps][band], paramType);
-      if (outputDataIdx[xttIdx][ps][band] == -1) {
-        outputDataIdx[xttIdx][ps][band] = defaultValue;
-      }
-    }
-  } /* for( i = 0 ; i < numParameterSets; i++ ) */
-
-  if (extendFrame) {
-    for (band = startBand; band < stopBand; band++) {
-      outputDataIdx[xttIdx][numParameterSets][band] =
-          outputDataIdx[xttIdx][numParameterSets - 1][band];
-    }
-  }
-
-  return MPS_OK;
-}
-
-/*******************************************************************************
- Functionname: decodeAndMapFrameOtt
- *******************************************************************************
-
- Description:
-   Do delta decoding and dequantization
-
- Arguments:
-
-Input:
-
-Output:
-
-*******************************************************************************/
-static SACDEC_ERROR decodeAndMapFrameOtt(HANDLE_SPATIAL_DEC self,
-                                         SPATIAL_BS_FRAME *pCurBs) {
-  int i, ottIdx;
-  int numOttBoxes;
-
-  SACDEC_ERROR err = MPS_OK;
-
-  numOttBoxes = self->numOttBoxes;
-
-  switch (self->treeConfig) {
-    default: {
-      if (self->quantMode != 0) {
-        goto bail;
-      }
-    }
-      for (i = 0; i < numOttBoxes; i++) {
-        err = mapIndexData(
-            &pCurBs->CLDLosslessData[i], /* LOSSLESSDATA *llData,*/
-            self->ottCLD__FDK, self->outIdxData,
-            pCurBs
-                ->cmpOttCLDidx, /* int
-                                   cmpIdxData[MAX_NUM_OTT][MAX_PARAMETER_SETS][MAX_PARAMETER_BANDS],
-                                 */
-            NULL,               /* no differential data */
-            i, /*  int   xttIdx,  Which ott/ttt index to use for input and
-                  output buffers */
-            self->ottCLDidxPrev,                        /* int
-                                                           idxPrev[MAX_NUM_OTT][MAX_PARAMETER_BANDS],
-                                                         */
-            i, t_CLD, 0,                                /* int   startBand, */
-            self->pConfigCurrent->bitstreamOttBands[i], /*  int   stopBand, */
-            self->pConfigCurrent->ottCLDdefault[i], /* int   defaultValue, */
-            pCurBs->numParameterSets, /* int   numParameterSets) */
-            pCurBs->paramSlot, self->extendFrame, self->quantMode,
-            &(self->concealInfo), ottVsTotInactiv, NULL, NULL, NULL);
-        if (err != MPS_OK) goto bail;
-
-      } /* for(i = 0; i < numOttBoxes ; i++ ) */
-      break;
-  } /* case */
-
-  for (ottIdx = 0; ottIdx < numOttBoxes; ottIdx++) {
-    /* Read ICC */
-    err = mapIndexData(
-        &pCurBs->ICCLosslessData[ottIdx], /* LOSSLESSDATA *llData,*/
-        self->ottICC__FDK, self->outIdxData,
-        pCurBs
-            ->cmpOttICCidx,  /* int
-                                cmpIdxData[MAX_NUM_OTT][MAX_PARAMETER_SETS][MAX_PARAMETER_BANDS],
-                              */
-        self->ottICCdiffidx, /* differential data */
-        ottIdx, /* int   xttIdx,  Which ott/ttt index to use for input and
-                   output buffers */
-        self->ottICCidxPrev, /* int   idxPrev[MAX_NUM_OTT][MAX_PARAMETER_BANDS],
-                              */
-        ottIdx, t_ICC, 0,    /* int   startBand, */
-        self->pConfigCurrent->bitstreamOttBands[ottIdx], /* int   stopBand, */
-        ICCdefault,               /* int   defaultValue, */
-        pCurBs->numParameterSets, /* int   numParameterSets) */
-        pCurBs->paramSlot, self->extendFrame, self->quantMode,
-        &(self->concealInfo), ottVsTotInactiv, NULL, NULL, NULL);
-    if (err != MPS_OK) goto bail;
-  } /* ottIdx */
-
-  if ((self->treeConfig == TREE_212) && (self->phaseCoding)) {
-    if (pCurBs->phaseMode == 0) {
-      for (int pb = 0; pb < self->pConfigCurrent->numOttBandsIPD; pb++) {
-        self->ottIPDidxPrev[0][pb] = 0;
-      }
-    }
-    for (ottIdx = 0; ottIdx < numOttBoxes; ottIdx++) {
-      err = mapIndexData(
-          &pCurBs->IPDLosslessData[ottIdx], self->ottIPD__FDK, self->outIdxData,
-          pCurBs->cmpOttIPDidx, NULL, ottIdx, self->ottIPDidxPrev, ottIdx,
-          t_IPD, 0, self->numOttBandsIPD, IPDdefault, pCurBs->numParameterSets,
-          pCurBs->paramSlot, self->extendFrame, self->quantMode,
-          &(self->concealInfo), ottVsTotInactiv, NULL, NULL, NULL);
-    }
-  }
-
-bail:
-
-  return MPS_OK;
-
-} /* decodeAndMapFrameOtt */
-
-/*******************************************************************************
- Functionname: decodeAndMapFrameSmg
- *******************************************************************************
-
- Description:
-   Decode smoothing flags
-
- Arguments:
-
-Input:
-
-Output:
-
-
-*******************************************************************************/
-static SACDEC_ERROR decodeAndMapFrameSmg(HANDLE_SPATIAL_DEC self,
-                                         const SPATIAL_BS_FRAME *frame) {
-  int ps, pb, pg, pbStride, dataBands, pbStart, pbStop,
-      aGroupToBand[MAX_PARAMETER_BANDS + 1];
-
-  if (frame->numParameterSets > MAX_PARAMETER_SETS)
-    return MPS_WRONG_PARAMETERSETS;
-  if (self->bitstreamParameterBands > MAX_PARAMETER_BANDS)
-    return MPS_WRONG_PARAMETERBANDS;
-
-  for (ps = 0; ps < frame->numParameterSets; ps++) {
-    switch (frame->bsSmoothMode[ps]) {
-      case 0:
-        self->smgTime[ps] = 256;
-        FDKmemclear(self->smgData[ps],
-                    self->bitstreamParameterBands * sizeof(UCHAR));
-        break;
-
-      case 1:
-        if (ps > 0) {
-          self->smgTime[ps] = self->smgTime[ps - 1];
-          FDKmemcpy(self->smgData[ps], self->smgData[ps - 1],
-                    self->bitstreamParameterBands * sizeof(UCHAR));
-        } else {
-          self->smgTime[ps] = self->smoothState->prevSmgTime;
-          FDKmemcpy(self->smgData[ps], self->smoothState->prevSmgData,
-                    self->bitstreamParameterBands * sizeof(UCHAR));
-        }
-        break;
-
-      case 2:
-        self->smgTime[ps] = smgTimeTable[frame->bsSmoothTime[ps]];
-        for (pb = 0; pb < self->bitstreamParameterBands; pb++) {
-          self->smgData[ps][pb] = 1;
-        }
-        break;
-
-      case 3:
-        self->smgTime[ps] = smgTimeTable[frame->bsSmoothTime[ps]];
-        pbStride = pbStrideTable[frame->bsFreqResStrideSmg[ps]];
-        dataBands = (self->bitstreamParameterBands - 1) / pbStride + 1;
-        createMapping(aGroupToBand, 0, self->bitstreamParameterBands, pbStride);
-        for (pg = 0; pg < dataBands; pg++) {
-          pbStart = aGroupToBand[pg];
-          pbStop = aGroupToBand[pg + 1];
-          for (pb = pbStart; pb < pbStop; pb++) {
-            self->smgData[ps][pb] = frame->bsSmgData[ps][pg];
-          }
-        }
-        break;
-    }
-  }
-
-  self->smoothState->prevSmgTime = self->smgTime[frame->numParameterSets - 1];
-  FDKmemcpy(self->smoothState->prevSmgData,
-            self->smgData[frame->numParameterSets - 1],
-            self->bitstreamParameterBands * sizeof(UCHAR));
-
-  if (self->extendFrame) {
-    self->smgTime[frame->numParameterSets] =
-        self->smgTime[frame->numParameterSets - 1];
-    FDKmemcpy(self->smgData[frame->numParameterSets],
-              self->smgData[frame->numParameterSets - 1],
-              self->bitstreamParameterBands * sizeof(UCHAR));
-  }
-
-  return MPS_OK;
-}
-
-/*******************************************************************************
- Functionname: decodeAndMapFrameArbdmx
- *******************************************************************************
-
- Description:
-   Do delta decoding and dequantization
-
- Arguments:
-
-Input:
-
-Output:
-
-*******************************************************************************/
-static SACDEC_ERROR decodeAndMapFrameArbdmx(HANDLE_SPATIAL_DEC self,
-                                            const SPATIAL_BS_FRAME *frame) {
-  SACDEC_ERROR err = MPS_OK;
-  int ch;
-  int offset = self->numOttBoxes;
-
-  for (ch = 0; ch < self->numInputChannels; ch++) {
-    err = mapIndexData(&frame->CLDLosslessData[offset + ch],
-                       self->arbdmxGain__FDK, self->outIdxData,
-                       frame->cmpArbdmxGainIdx, NULL, /* no differential data */
-                       ch, self->arbdmxGainIdxPrev, offset + ch, t_CLD, 0,
-                       self->bitstreamParameterBands,
-                       0 /*self->arbdmxGainDefault*/, frame->numParameterSets,
-                       frame->paramSlot, self->extendFrame, 0,
-                       &(self->concealInfo), ottVsTotInactiv, NULL, NULL, NULL);
-    if (err != MPS_OK) goto bail;
-  }
-
-bail:
-  return err;
-} /* decodeAndMapFrameArbdmx */
-
-/*******************************************************************************
- Functionname: SpatialDecDecodeFrame
- *******************************************************************************
-
- Description:
-
- Arguments:
-
- Return:
-
-*******************************************************************************/
-SACDEC_ERROR SpatialDecDecodeFrame(spatialDec *self, SPATIAL_BS_FRAME *frame) {
-  SACDEC_ERROR err = MPS_OK;
-
-  self->extendFrame = 0;
-  if (frame->paramSlot[frame->numParameterSets - 1] != self->timeSlots - 1) {
-    self->extendFrame = 1;
-  }
-
-  self->TsdTs = 0;
-
-  /****** DTDF and MAP DATA ********/
-  if ((err = decodeAndMapFrameOtt(self, frame)) != MPS_OK) goto bail;
-
-  if ((err = decodeAndMapFrameSmg(self, frame)) != MPS_OK) goto bail;
-
-  if (self->arbitraryDownmix != 0) {
-    if ((err = decodeAndMapFrameArbdmx(self, frame)) != MPS_OK) goto bail;
-  }
-
-  if (self->extendFrame) {
-    frame->numParameterSets =
-        fixMin(MAX_PARAMETER_SETS, frame->numParameterSets + 1);
-    frame->paramSlot[frame->numParameterSets - 1] = self->timeSlots - 1;
-
-    for (int p = 0; p < frame->numParameterSets; p++) {
-      if (frame->paramSlot[p] > self->timeSlots - 1) {
-        frame->paramSlot[p] = self->timeSlots - 1;
-        err = MPS_PARSE_ERROR;
-      }
-    }
-    if (err != MPS_OK) {
-      goto bail;
-    }
-  }
-
-bail:
-  return err;
-} /* SpatialDecDecodeFrame() */
-
-/*******************************************************************************
- Functionname: SpatialDecodeHeader
- *******************************************************************************
-
- Description:
-
- Arguments:
-
- Return:
-
-*******************************************************************************/
-
-SACDEC_ERROR SpatialDecDecodeHeader(
-    spatialDec *self, SPATIAL_SPECIFIC_CONFIG *pSpatialSpecificConfig) {
-  SACDEC_ERROR err = MPS_OK;
-  int i;
-
-  self->samplingFreq = pSpatialSpecificConfig->samplingFreq;
-  self->timeSlots = pSpatialSpecificConfig->nTimeSlots;
-  self->frameLength = self->timeSlots * self->qmfBands;
-  self->bitstreamParameterBands = pSpatialSpecificConfig->freqRes;
-
-  if (self->pConfigCurrent->syntaxFlags & SACDEC_SYNTAX_LD)
-    self->hybridBands = self->qmfBands;
-  else
-    self->hybridBands = SacGetHybridSubbands(self->qmfBands);
-  self->tp_hybBandBorder = 12;
-
-  self->numParameterBands = self->bitstreamParameterBands;
-
-  if (self->pConfigCurrent->syntaxFlags & SACDEC_SYNTAX_LD) {
-    switch (self->numParameterBands) {
-      case 4:
-        self->kernels = kernels_4_to_64;
-        break;
-      case 5:
-        self->kernels = kernels_5_to_64;
-        break;
-      case 7:
-        self->kernels = kernels_7_to_64;
-        break;
-      case 9:
-        self->kernels = kernels_9_to_64;
-        break;
-      case 12:
-        self->kernels = kernels_12_to_64;
-        break;
-      case 15:
-        self->kernels = kernels_15_to_64;
-        break;
-      case 23:
-        self->kernels = kernels_23_to_64;
-        break;
-      default:
-        return MPS_INVALID_PARAMETERBANDS; /* unsupported numParameterBands */
-    }
-  } else {
-    switch (self->numParameterBands) {
-      case 4:
-        self->kernels = kernels_4_to_71;
-        break;
-      case 5:
-        self->kernels = kernels_5_to_71;
-        break;
-      case 7:
-        self->kernels = kernels_7_to_71;
-        break;
-      case 10:
-        self->kernels = kernels_10_to_71;
-        break;
-      case 14:
-        self->kernels = kernels_14_to_71;
-        break;
-      case 20:
-        self->kernels = kernels_20_to_71;
-        break;
-      case 28:
-        self->kernels = kernels_28_to_71;
-        break;
-      default:
-        return MPS_INVALID_PARAMETERBANDS; /* unsupported numParameterBands */
-    }
-  }
-
-  /* create param to hyb band table */
-  FDKmemclear(self->param2hyb, (MAX_PARAMETER_BANDS + 1) * sizeof(int));
-  for (i = 0; i < self->hybridBands; i++) {
-    self->param2hyb[self->kernels[i] + 1] = i + 1;
-  }
-  {
-    int pb = self->kernels[i - 1] + 2;
-    for (; pb < (MAX_PARAMETER_BANDS + 1); pb++) {
-      self->param2hyb[pb] = i;
-    }
-    for (pb = 0; pb < MAX_PARAMETER_BANDS; pb += 1) {
-      self->kernels_width[pb] = self->param2hyb[pb + 1] - self->param2hyb[pb];
-    }
-  }
-
-  self->treeConfig = pSpatialSpecificConfig->treeConfig;
-
-  self->numOttBoxes = pSpatialSpecificConfig->nOttBoxes;
-
-  self->numInputChannels = pSpatialSpecificConfig->nInputChannels;
-
-  self->numOutputChannels = pSpatialSpecificConfig->nOutputChannels;
-
-  self->quantMode = pSpatialSpecificConfig->quantMode;
-
-  self->arbitraryDownmix = pSpatialSpecificConfig->bArbitraryDownmix;
-
-  self->numM2rows = self->numOutputChannels;
-
-  {
-    self->residualCoding = 0;
-    if (self->arbitraryDownmix == 2)
-      self->arbitraryDownmix = 1; /* no arbitrary downmix residuals */
-  }
-  if ((self->pConfigCurrent->syntaxFlags & SACDEC_SYNTAX_USAC)) {
-    self->residualCoding = pSpatialSpecificConfig->bResidualCoding;
-  }
-
-  self->clipProtectGain__FDK =
-      FX_CFG2FX_DBL(clipGainTable__FDK[pSpatialSpecificConfig->bsFixedGainDMX]);
-  self->clipProtectGainSF__FDK =
-      clipGainSFTable__FDK[pSpatialSpecificConfig->bsFixedGainDMX];
-
-  self->tempShapeConfig = pSpatialSpecificConfig->tempShapeConfig;
-
-  self->decorrConfig = pSpatialSpecificConfig->decorrConfig;
-
-  if (self->upmixType == UPMIXTYPE_BYPASS) {
-    self->numOutputChannels = self->numInputChannels;
-  }
-
-  self->numOutputChannelsAT = self->numOutputChannels;
-
-  self->numOttBandsIPD = pSpatialSpecificConfig->numOttBandsIPD;
-  self->phaseCoding = pSpatialSpecificConfig->bsPhaseCoding;
-  for (i = 0; i < self->numOttBoxes; i++) {
-    {
-      self->pConfigCurrent->bitstreamOttBands[i] =
-          self->bitstreamParameterBands;
-    }
-    self->numOttBands[i] = self->pConfigCurrent->bitstreamOttBands[i];
-  } /* i */
-
-  if (self->residualCoding) {
-    int numBoxes = self->numOttBoxes;
-    for (i = 0; i < numBoxes; i++) {
-      self->residualPresent[i] =
-          pSpatialSpecificConfig->ResidualConfig[i].bResidualPresent;
-
-      if (self->residualPresent[i]) {
-        self->residualBands[i] =
-            pSpatialSpecificConfig->ResidualConfig[i].nResidualBands;
-        /* conversion from hybrid bands to qmf bands */
-        self->residualQMFBands[i] =
-            fMax(self->param2hyb[self->residualBands[i]] + 3 - 10,
-                 3); /* simplification for the lowest 10 hybrid bands */
-      } else {
-        self->residualBands[i] = 0;
-        self->residualQMFBands[i] = 0;
-      }
-    }
-  } /* self->residualCoding */
-  else {
-    int boxes = self->numOttBoxes;
-    for (i = 0; i < boxes; i += 1) {
-      self->residualPresent[i] = 0;
-      self->residualBands[i] = 0;
-    }
-  }
-
-  switch (self->treeConfig) {
-    case TREE_212:
-      self->numDirektSignals = 1;
-      self->numDecorSignals = 1;
-      self->numXChannels = 1;
-      if (self->arbitraryDownmix == 2) {
-        self->numXChannels += 1;
-      }
-      self->numVChannels = self->numDirektSignals + self->numDecorSignals;
-      break;
-    default:
-      return MPS_INVALID_TREECONFIG;
-  }
-
-  self->highRateMode = pSpatialSpecificConfig->bsHighRateMode;
-  self->decorrType = pSpatialSpecificConfig->bsDecorrType;
-
-  SpatialDecDecodeHelperInfo(pSpatialSpecificConfig, UPMIXTYPE_NORMAL);
-
-  return err;
-}
-
-/*******************************************************************************
- Functionname: SpatialDecCreateBsFrame
- *******************************************************************************
-
- Description: Create spatial bitstream structure
-
- Arguments:   spatialDec* self
-              const SPATIAL_BS_FRAME **bsFrame
-
- Return:      -
-
-*******************************************************************************/
-SACDEC_ERROR SpatialDecCreateBsFrame(SPATIAL_BS_FRAME *bsFrame,
-                                     BS_LL_STATE *llState) {
-  SPATIAL_BS_FRAME *pBs = bsFrame;
-
-  const int maxNumOtt = MAX_NUM_OTT;
-  const int maxNumInputChannels = MAX_INPUT_CHANNELS;
-
-  FDK_ALLOCATE_MEMORY_1D_P(
-      pBs->cmpOttIPDidx, maxNumOtt * MAX_PARAMETER_SETS * MAX_PARAMETER_BANDS,
-      SCHAR, SCHAR(*)[MAX_PARAMETER_SETS][MAX_PARAMETER_BANDS])
-
-  /* Arbitrary Downmix */
-  FDK_ALLOCATE_MEMORY_1D_P(
-      pBs->cmpArbdmxGainIdx,
-      maxNumInputChannels * MAX_PARAMETER_SETS * MAX_PARAMETER_BANDS, SCHAR,
-      SCHAR(*)[MAX_PARAMETER_SETS][MAX_PARAMETER_BANDS])
-
-  /* Lossless control */
-  FDK_ALLOCATE_MEMORY_1D(pBs->CLDLosslessData, MAX_NUM_PARAMETERS, LOSSLESSDATA)
-  FDK_ALLOCATE_MEMORY_1D(pBs->ICCLosslessData, MAX_NUM_PARAMETERS, LOSSLESSDATA)
-
-  FDK_ALLOCATE_MEMORY_1D(pBs->IPDLosslessData, MAX_NUM_PARAMETERS, LOSSLESSDATA)
-
-  pBs->newBsData = 0;
-  pBs->numParameterSets = 1;
-
-  /* Link lossless states */
-  for (int x = 0; x < MAX_NUM_PARAMETERS; x++) {
-    pBs->CLDLosslessData[x].state = &llState->CLDLosslessState[x];
-    pBs->ICCLosslessData[x].state = &llState->ICCLosslessState[x];
-
-    pBs->IPDLosslessData[x].state = &llState->IPDLosslessState[x];
-  }
-
-  return MPS_OK;
-
-bail:
-  return MPS_OUTOFMEMORY;
-}
-
-/*******************************************************************************
- Functionname: SpatialDecCloseBsFrame
- *******************************************************************************
-
- Description: Close spatial bitstream structure
-
- Arguments:   spatialDec* self
-
- Return:      -
-
-*******************************************************************************/
-void SpatialDecCloseBsFrame(SPATIAL_BS_FRAME *pBs) {
-  if (pBs != NULL) {
-    /* These arrays contain the compact indices, only one value per pbstride,
-     * only paramsets actually containing data. */
-
-    FDK_FREE_MEMORY_1D(pBs->cmpOttIPDidx);
-
-    /* Arbitrary Downmix */
-    FDK_FREE_MEMORY_1D(pBs->cmpArbdmxGainIdx);
-
-    /* Lossless control */
-    FDK_FREE_MEMORY_1D(pBs->IPDLosslessData);
-    FDK_FREE_MEMORY_1D(pBs->CLDLosslessData);
-    FDK_FREE_MEMORY_1D(pBs->ICCLosslessData);
-  }
-}
--- a/libSACdec/src/sac_bitdec.h
+++ /dev/null
@@ -1,161 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround decoder library *************************
-
-   Author(s):
-
-   Description: SAC Dec bitstream decoder
-
-*******************************************************************************/
-
-/*!
-  \file
-  \brief  Spatial Audio bitstream decoder
-*/
-
-#ifndef SAC_BITDEC_H
-#define SAC_BITDEC_H
-
-#include "sac_dec.h"
-
-typedef struct {
-  SCHAR numInputChannels;
-  SCHAR numOutputChannels;
-  SCHAR numOttBoxes;
-  SCHAR numTttBoxes;
-  SCHAR ottModeLfe[MAX_NUM_OTT];
-} TREEPROPERTIES;
-
-enum { TREE_212 = 7, TREE_DUMMY = 255 };
-
-enum { QUANT_FINE = 0, QUANT_EBQ1 = 1, QUANT_EBQ2 = 2 };
-
-SACDEC_ERROR SpatialDecParseSpecificConfigHeader(
-    HANDLE_FDK_BITSTREAM bitstream,
-    SPATIAL_SPECIFIC_CONFIG *pSpatialSpecificConfig,
-    AUDIO_OBJECT_TYPE coreCodec, SPATIAL_DEC_UPMIX_TYPE upmixType);
-
-SACDEC_ERROR SpatialDecParseMps212Config(
-    HANDLE_FDK_BITSTREAM bitstream,
-    SPATIAL_SPECIFIC_CONFIG *pSpatialSpecificConfig, int samplingRate,
-    AUDIO_OBJECT_TYPE coreCodec, INT stereoConfigIndex,
-    INT coreSbrFrameLengthIndex);
-
-SACDEC_ERROR SpatialDecParseSpecificConfig(
-    HANDLE_FDK_BITSTREAM bitstream,
-    SPATIAL_SPECIFIC_CONFIG *pSpatialSpecificConfig, int sacHeaderLen,
-    AUDIO_OBJECT_TYPE coreCodec);
-
-int SpatialDecDefaultSpecificConfig(
-    SPATIAL_SPECIFIC_CONFIG *pSpatialSpecificConfig,
-    AUDIO_OBJECT_TYPE coreCodec, int samplingFreq, int nTimeSlots,
-    int sacDecoderLevel, int isBlind, int coreChannels);
-
-SACDEC_ERROR SpatialDecCreateBsFrame(SPATIAL_BS_FRAME *bsFrame,
-                                     BS_LL_STATE *llState);
-
-void SpatialDecCloseBsFrame(SPATIAL_BS_FRAME *bsFrame);
-
-SACDEC_ERROR SpatialDecParseFrameData(
-    spatialDec *self, SPATIAL_BS_FRAME *frame, HANDLE_FDK_BITSTREAM bitstream,
-    const SPATIAL_SPECIFIC_CONFIG *pSpatialSpecificConfig, UPMIXTYPE upmixType,
-    int fGlobalIndependencyFlag);
-
-SACDEC_ERROR SpatialDecDecodeFrame(spatialDec *self, SPATIAL_BS_FRAME *frame);
-
-SACDEC_ERROR SpatialDecDecodeHeader(
-    spatialDec *self, SPATIAL_SPECIFIC_CONFIG *pSpatialSpecificConfig);
-
-#endif
--- a/libSACdec/src/sac_calcM1andM2.cpp
+++ /dev/null
@@ -1,848 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround decoder library *************************
-
-   Author(s):
-
-   Description: SAC Dec M1 and M2 calculation
-
-*******************************************************************************/
-
-#include "sac_calcM1andM2.h"
-#include "sac_bitdec.h"
-#include "sac_process.h"
-#include "sac_rom.h"
-#include "sac_smoothing.h"
-#include "FDK_trigFcts.h"
-
-/* assorted definitions and constants */
-
-#define ABS_THR2 1.0e-9
-#define SQRT2_FDK \
-  ((FIXP_DBL)FL2FXCONST_DBL(0.70710678118f)) /* FDKsqrt(2.0) scaled by 0.5 */
-
-static void param2UMX_PS__FDK(spatialDec* self,
-                              FIXP_DBL H11[MAX_PARAMETER_BANDS],
-                              FIXP_DBL H12[MAX_PARAMETER_BANDS],
-                              FIXP_DBL H21[MAX_PARAMETER_BANDS],
-                              FIXP_DBL H22[MAX_PARAMETER_BANDS],
-                              FIXP_DBL c_l[MAX_PARAMETER_BANDS],
-                              FIXP_DBL c_r[MAX_PARAMETER_BANDS], int ottBoxIndx,
-                              int parameterSetIndx, int resBands);
-
-static void param2UMX_PS_Core__FDK(
-    const SCHAR cld[MAX_PARAMETER_BANDS], const SCHAR icc[MAX_PARAMETER_BANDS],
-    const int numOttBands, const int resBands,
-    FIXP_DBL H11[MAX_PARAMETER_BANDS], FIXP_DBL H12[MAX_PARAMETER_BANDS],
-    FIXP_DBL H21[MAX_PARAMETER_BANDS], FIXP_DBL H22[MAX_PARAMETER_BANDS],
-    FIXP_DBL c_l[MAX_PARAMETER_BANDS], FIXP_DBL c_r[MAX_PARAMETER_BANDS]);
-
-static void param2UMX_PS_IPD_OPD__FDK(
-    spatialDec* self, const SPATIAL_BS_FRAME* frame,
-    FIXP_DBL H11re[MAX_PARAMETER_BANDS], FIXP_DBL H12re[MAX_PARAMETER_BANDS],
-    FIXP_DBL H21re[MAX_PARAMETER_BANDS], FIXP_DBL H22re[MAX_PARAMETER_BANDS],
-    FIXP_DBL c_l[MAX_PARAMETER_BANDS], FIXP_DBL c_r[MAX_PARAMETER_BANDS],
-    int ottBoxIndx, int parameterSetIndx, int residualBands);
-
-static void param2UMX_Prediction__FDK(
-    spatialDec* self, FIXP_DBL H11re[MAX_PARAMETER_BANDS],
-    FIXP_DBL H11im[MAX_PARAMETER_BANDS], FIXP_DBL H12re[MAX_PARAMETER_BANDS],
-    FIXP_DBL H12im[MAX_PARAMETER_BANDS], FIXP_DBL H21re[MAX_PARAMETER_BANDS],
-    FIXP_DBL H21im[MAX_PARAMETER_BANDS], FIXP_DBL H22re[MAX_PARAMETER_BANDS],
-    FIXP_DBL H22im[MAX_PARAMETER_BANDS], int ottBoxIndx, int parameterSetIndx,
-    int resBands);
-
-/* static void SpatialDecCalculateM0(spatialDec* self,int ps); */
-static SACDEC_ERROR SpatialDecCalculateM1andM2_212(
-    spatialDec* self, int ps, const SPATIAL_BS_FRAME* frame);
-
-/*******************************************************************************
- Functionname: SpatialDecGetResidualIndex
- *******************************************************************************
-
- Description:
-
- Arguments:
-
- Input:
-
- Output:
-
-*******************************************************************************/
-int SpatialDecGetResidualIndex(spatialDec* self, int row) {
-  return row2residual[self->treeConfig][row];
-}
-
-/*******************************************************************************
- Functionname: UpdateAlpha
- *******************************************************************************
-
- Description:
-
- Arguments:
-
- Input:
-
- Output:
-
-*******************************************************************************/
-static void updateAlpha(spatialDec* self) {
-  int nChIn = self->numInputChannels;
-  int ch;
-
-  for (ch = 0; ch < nChIn; ch++) {
-    FIXP_DBL alpha = /* FL2FXCONST_DBL(1.0f) */ (FIXP_DBL)MAXVAL_DBL;
-
-    self->arbdmxAlphaPrev__FDK[ch] = self->arbdmxAlpha__FDK[ch];
-
-    self->arbdmxAlpha__FDK[ch] = alpha;
-  }
-}
-
-/*******************************************************************************
- Functionname: SpatialDecCalculateM1andM2
- *******************************************************************************
- Description:
- Arguments:
-*******************************************************************************/
-SACDEC_ERROR SpatialDecCalculateM1andM2(spatialDec* self, int ps,
-                                        const SPATIAL_BS_FRAME* frame) {
-  SACDEC_ERROR err = MPS_OK;
-
-  if ((self->arbitraryDownmix != 0) && (ps == 0)) {
-    updateAlpha(self);
-  }
-
-  self->pActivM2ParamBands = NULL;
-
-  switch (self->upmixType) {
-    case UPMIXTYPE_BYPASS:
-    case UPMIXTYPE_NORMAL:
-      switch (self->treeConfig) {
-        case TREE_212:
-          err = SpatialDecCalculateM1andM2_212(self, ps, frame);
-          break;
-        default:
-          err = MPS_WRONG_TREECONFIG;
-      };
-      break;
-
-    default:
-      err = MPS_WRONG_TREECONFIG;
-  }
-
-  if (err != MPS_OK) {
-    goto bail;
-  }
-
-bail:
-  return err;
-}
-
-/*******************************************************************************
- Functionname: SpatialDecCalculateM1andM2_212
- *******************************************************************************
-
- Description:
-
- Arguments:
-
- Return:
-
-*******************************************************************************/
-static SACDEC_ERROR SpatialDecCalculateM1andM2_212(
-    spatialDec* self, int ps, const SPATIAL_BS_FRAME* frame) {
-  SACDEC_ERROR err = MPS_OK;
-  int pb;
-
-  FIXP_DBL H11re[MAX_PARAMETER_BANDS] = {FL2FXCONST_DBL(0.0f)};
-  FIXP_DBL H12re[MAX_PARAMETER_BANDS] = {FL2FXCONST_DBL(0.0f)};
-  FIXP_DBL H21re[MAX_PARAMETER_BANDS] = {FL2FXCONST_DBL(0.0f)};
-  FIXP_DBL H22re[MAX_PARAMETER_BANDS] = {FL2FXCONST_DBL(0.0f)};
-  FIXP_DBL H11im[MAX_PARAMETER_BANDS] = {FL2FXCONST_DBL(0.0f)};
-  FIXP_DBL H21im[MAX_PARAMETER_BANDS] = {FL2FXCONST_DBL(0.0f)};
-
-  INT phaseCoding = self->phaseCoding;
-
-  switch (phaseCoding) {
-    case 1:
-      /* phase coding: yes; residuals: no */
-      param2UMX_PS_IPD_OPD__FDK(self, frame, H11re, H12re, H21re, H22re, NULL,
-                                NULL, 0, ps, self->residualBands[0]);
-      break;
-    case 3:
-      /* phase coding: yes; residuals: yes */
-      param2UMX_Prediction__FDK(self, H11re, H11im, H12re, NULL, H21re, H21im,
-                                H22re, NULL, 0, ps, self->residualBands[0]);
-      break;
-    default:
-      if (self->residualCoding) {
-        /* phase coding: no; residuals: yes */
-        param2UMX_Prediction__FDK(self, H11re, NULL, H12re, NULL, H21re, NULL,
-                                  H22re, NULL, 0, ps, self->residualBands[0]);
-      } else {
-        /* phase coding: no; residuals: no */
-        param2UMX_PS__FDK(self, H11re, H12re, H21re, H22re, NULL, NULL, 0, ps,
-                          0);
-      }
-      break;
-  }
-
-  for (pb = 0; pb < self->numParameterBands; pb++) {
-    self->M2Real__FDK[0][0][pb] = (H11re[pb]);
-    self->M2Real__FDK[0][1][pb] = (H12re[pb]);
-
-    self->M2Real__FDK[1][0][pb] = (H21re[pb]);
-    self->M2Real__FDK[1][1][pb] = (H22re[pb]);
-  }
-  if (phaseCoding == 3) {
-    for (pb = 0; pb < self->numParameterBands; pb++) {
-      self->M2Imag__FDK[0][0][pb] = (H11im[pb]);
-      self->M2Imag__FDK[1][0][pb] = (H21im[pb]);
-      self->M2Imag__FDK[0][1][pb] = (FIXP_DBL)0;  // H12im[pb];
-      self->M2Imag__FDK[1][1][pb] = (FIXP_DBL)0;  // H22im[pb];
-    }
-  }
-
-  if (self->phaseCoding == 1) {
-    SpatialDecSmoothOPD(
-        self, frame,
-        ps); /* INPUT: PhaseLeft, PhaseRight, (opdLeftState, opdRightState) */
-  }
-
-  return err;
-}
-
-/*******************************************************************************
- Functionname: param2UMX_PS_Core
- *******************************************************************************
-
- Description:
-
- Arguments:
-
- Return:
-
-*******************************************************************************/
-static void param2UMX_PS_Core__FDK(
-    const SCHAR cld[MAX_PARAMETER_BANDS], const SCHAR icc[MAX_PARAMETER_BANDS],
-    const int numOttBands, const int resBands,
-    FIXP_DBL H11[MAX_PARAMETER_BANDS], FIXP_DBL H12[MAX_PARAMETER_BANDS],
-    FIXP_DBL H21[MAX_PARAMETER_BANDS], FIXP_DBL H22[MAX_PARAMETER_BANDS],
-    FIXP_DBL c_l[MAX_PARAMETER_BANDS], FIXP_DBL c_r[MAX_PARAMETER_BANDS]) {
-  int band;
-
-  if ((c_l != NULL) && (c_r != NULL)) {
-    for (band = 0; band < numOttBands; band++) {
-      SpatialDequantGetCLDValues(cld[band], &c_l[band], &c_r[band]);
-    }
-  }
-
-  band = 0;
-  FDK_ASSERT(resBands == 0);
-  for (; band < numOttBands; band++) {
-    /* compute mixing variables: */
-    const int idx1 = cld[band];
-    const int idx2 = icc[band];
-    H11[band] = FX_CFG2FX_DBL(H11_nc[idx1][idx2]);
-    H21[band] = FX_CFG2FX_DBL(H11_nc[30 - idx1][idx2]);
-    H12[band] = FX_CFG2FX_DBL(H12_nc[idx1][idx2]);
-    H22[band] = FX_CFG2FX_DBL(-H12_nc[30 - idx1][idx2]);
-  }
-}
-
-/*******************************************************************************
- Functionname: param2UMX_PS
- *******************************************************************************
-
- Description:
-
- Arguments:
-
- Return:
-
-*******************************************************************************/
-static void param2UMX_PS__FDK(spatialDec* self,
-                              FIXP_DBL H11[MAX_PARAMETER_BANDS],
-                              FIXP_DBL H12[MAX_PARAMETER_BANDS],
-                              FIXP_DBL H21[MAX_PARAMETER_BANDS],
-                              FIXP_DBL H22[MAX_PARAMETER_BANDS],
-                              FIXP_DBL c_l[MAX_PARAMETER_BANDS],
-                              FIXP_DBL c_r[MAX_PARAMETER_BANDS], int ottBoxIndx,
-                              int parameterSetIndx, int residualBands) {
-  int band;
-  param2UMX_PS_Core__FDK(self->ottCLD__FDK[ottBoxIndx][parameterSetIndx],
-                         self->ottICC__FDK[ottBoxIndx][parameterSetIndx],
-                         self->numOttBands[ottBoxIndx], residualBands, H11, H12,
-                         H21, H22, c_l, c_r);
-
-  for (band = self->numOttBands[ottBoxIndx]; band < self->numParameterBands;
-       band++) {
-    H11[band] = H21[band] = H12[band] = H22[band] = FL2FXCONST_DBL(0.f);
-  }
-}
-
-#define N_CLD (31)
-#define N_IPD (16)
-
-static const FIXP_DBL sinIpd_tab[N_IPD] = {
-    FIXP_DBL(0x00000000), FIXP_DBL(0x30fbc54e), FIXP_DBL(0x5a827999),
-    FIXP_DBL(0x7641af3d), FIXP_DBL(0x7fffffff), FIXP_DBL(0x7641af3d),
-    FIXP_DBL(0x5a82799a), FIXP_DBL(0x30fbc54d), FIXP_DBL(0xffffffff),
-    FIXP_DBL(0xcf043ab3), FIXP_DBL(0xa57d8666), FIXP_DBL(0x89be50c3),
-    FIXP_DBL(0x80000000), FIXP_DBL(0x89be50c3), FIXP_DBL(0xa57d8666),
-    FIXP_DBL(0xcf043ab2),
-};
-
-/* cosIpd[i] = sinIpd[(i+4)&15] */
-#define SIN_IPD(a) (sinIpd_tab[(a)])
-#define COS_IPD(a) (sinIpd_tab[((a) + 4) & 15])  //(cosIpd_tab[(a)])
-
-static const FIXP_SGL sqrt_one_minus_ICC2[8] = {
-    FL2FXCONST_SGL(0.0f),
-    FL2FXCONST_SGL(0.349329357483736f),
-    FL2FXCONST_SGL(0.540755219669676f),
-    FL2FXCONST_SGL(0.799309172723546f),
-    FL2FXCONST_SGL(0.929968187843004f),
-    FX_DBL2FXCONST_SGL(MAXVAL_DBL),
-    FL2FXCONST_SGL(0.80813303360276f),
-    FL2FXCONST_SGL(0.141067359796659f),
-};
-
-/* exponent of sqrt(CLD) */
-static const SCHAR sqrt_CLD_e[N_CLD] = {
-    -24, -7, -6, -5, -4, -4, -3, -3, -2, -2, -1, -1, 0, 0, 0, 1,
-    1,   1,  1,  2,  2,  3,  3,  4,  4,  5,  5,  6,  7, 8, 25};
-
-static const FIXP_DBL sqrt_CLD_m[N_CLD] = {
-    FL2FXCONST_DBL(0.530542153566195f),
-    FL2FXCONST_DBL(0.719796896243647f),
-    FL2FXCONST_DBL(0.64f),
-    FL2FXCONST_DBL(0.569049411212455f),
-    FL2FXCONST_DBL(0.505964425626941f),
-    FL2FXCONST_DBL(0.899746120304559f),
-    FL2FXCONST_DBL(0.635462587779425f),
-    FL2FXCONST_DBL(0.897614763441571f),
-    FL2FXCONST_DBL(0.633957276984445f),
-    FL2FXCONST_DBL(0.895488455427336f),
-    FL2FXCONST_DBL(0.632455532033676f),
-    FL2FXCONST_DBL(0.796214341106995f),
-    FL2FXCONST_DBL(0.501187233627272f),
-    FL2FXCONST_DBL(0.630957344480193f),
-    FL2FXCONST_DBL(0.794328234724281f),
-    FL2FXCONST_DBL(0.5f),
-    FL2FXCONST_DBL(0.629462705897084f),
-    FL2FXCONST_DBL(0.792446596230557f),
-    FL2FXCONST_DBL(0.99763115748444f),
-    FL2FXCONST_DBL(0.627971607877395f),
-    FL2FXCONST_DBL(0.790569415042095f),
-    FL2FXCONST_DBL(0.558354490188704f),
-    FL2FXCONST_DBL(0.788696680600242f),
-    FL2FXCONST_DBL(0.557031836333591f),
-    FL2FXCONST_DBL(0.786828382371355f),
-    FL2FXCONST_DBL(0.555712315637163f),
-    FL2FXCONST_DBL(0.988211768802619f),
-    FL2FXCONST_DBL(0.87865832060992f),
-    FL2FXCONST_DBL(0.78125f),
-    FL2FXCONST_DBL(0.694640394546454f),
-    FL2FXCONST_DBL(0.942432183077448f),
-};
-
-static const FIXP_DBL CLD_m[N_CLD] = {
-    FL2FXCONST_DBL(0.281474976710656f),
-    FL2FXCONST_DBL(0.518107571841987f),
-    FL2FXCONST_DBL(0.4096f),
-    FL2FXCONST_DBL(0.323817232401242f),
-    FL2FXCONST_DBL(0.256f),
-    FL2FXCONST_DBL(0.809543081003105f),
-    FL2FXCONST_DBL(0.403812700467324f),
-    FL2FXCONST_DBL(0.805712263548267f),
-    FL2FXCONST_DBL(0.401901829041533f),
-    FL2FXCONST_DBL(0.801899573803636f),
-    FL2FXCONST_DBL(0.4f),
-    FL2FXCONST_DBL(0.633957276984445f),
-    FL2FXCONST_DBL(0.251188643150958f),
-    FL2FXCONST_DBL(0.398107170553497f),
-    FL2FXCONST_DBL(0.630957344480193f),
-    FL2FXCONST_DBL(0.25f),
-    FL2FXCONST_DBL(0.396223298115278f),
-    FL2FXCONST_DBL(0.627971607877395f),
-    FL2FXCONST_DBL(0.995267926383743f),
-    FL2FXCONST_DBL(0.394348340300121f),
-    FL2FXCONST_DBL(0.625f),
-    FL2FXCONST_DBL(0.311759736713887f),
-    FL2FXCONST_DBL(0.62204245398984f),
-    FL2FXCONST_DBL(0.310284466689172f),
-    FL2FXCONST_DBL(0.619098903305123f),
-    FL2FXCONST_DBL(0.308816177750818f),
-    FL2FXCONST_DBL(0.9765625f),
-    FL2FXCONST_DBL(0.772040444377046f),
-    FL2FXCONST_DBL(0.6103515625f),
-    FL2FXCONST_DBL(0.482525277735654f),
-    FL2FXCONST_DBL(0.888178419700125),
-};
-
-static FIXP_DBL dequantIPD_CLD_ICC_splitAngle__FDK_Function(INT ipdIdx,
-                                                            INT cldIdx,
-                                                            INT iccIdx) {
-  FIXP_DBL cld;
-  SpatialDequantGetCLD2Values(cldIdx, &cld);
-
-  /*const FIXP_DBL one_m = (FIXP_DBL)MAXVAL_DBL;
-  const int one_e = 0;*/
-  const FIXP_DBL one_m = FL2FXCONST_DBL(0.5f);
-  const int one_e = 1;
-  /* iidLin = sqrt(cld); */
-  FIXP_DBL iidLin_m = sqrt_CLD_m[cldIdx];
-  int iidLin_e = sqrt_CLD_e[cldIdx];
-  /* iidLin2 = cld; */
-  FIXP_DBL iidLin2_m = CLD_m[cldIdx];
-  int iidLin2_e = sqrt_CLD_e[cldIdx] << 1;
-  /* iidLin21 = iidLin2 + 1.0f; */
-  int iidLin21_e;
-  FIXP_DBL iidLin21_m =
-      fAddNorm(iidLin2_m, iidLin2_e, one_m, one_e, &iidLin21_e);
-  /* iidIcc2 = iidLin * icc * 2.0f; */
-  FIXP_CFG icc = dequantICC__FDK[iccIdx];
-  FIXP_DBL temp1_m, temp1c_m;
-  int temp1_e, temp1c_e;
-  temp1_m = fMult(iidLin_m, icc);
-  temp1_e = iidLin_e + 1;
-
-  FIXP_DBL cosIpd, sinIpd;
-  cosIpd = COS_IPD(ipdIdx);
-  sinIpd = SIN_IPD(ipdIdx);
-
-  temp1c_m = fMult(temp1_m, cosIpd);
-  temp1c_e = temp1_e;  //+cosIpd_e;
-
-  int temp2_e, temp3_e, inv_temp3_e, ratio_e;
-  FIXP_DBL temp2_m =
-      fAddNorm(iidLin21_m, iidLin21_e, temp1c_m, temp1c_e, &temp2_e);
-  FIXP_DBL temp3_m =
-      fAddNorm(iidLin21_m, iidLin21_e, temp1_m, temp1_e, &temp3_e);
-  /* calculate 1/temp3 needed later */
-  inv_temp3_e = temp3_e;
-  FIXP_DBL inv_temp3_m = invFixp(temp3_m, &inv_temp3_e);
-  FIXP_DBL ratio_m =
-      fAddNorm(fMult(inv_temp3_m, temp2_m), (inv_temp3_e + temp2_e),
-               FL2FXCONST_DBL(1e-9f), 0, &ratio_e);
-
-  int weight2_e, tempb_atan2_e;
-  FIXP_DBL weight2_m =
-      fPow(ratio_m, ratio_e, FL2FXCONST_DBL(0.5f), -1, &weight2_e);
-  /* atan2(w2*sinIpd, w1*iidLin + w2*cosIpd) = atan2(w2*sinIpd, (2 - w2)*iidLin
-   * + w2*cosIpd) = atan2(w2*sinIpd, 2*iidLin + w2*(cosIpd - iidLin)); */
-  /* tmpa_atan2 = w2*sinIpd; tmpb_atan2 = 2*iidLin + w2*(cosIpd - iidLin); */
-  FIXP_DBL tempb_atan2_m = iidLin_m;
-  tempb_atan2_e = iidLin_e + 1;
-  int add_tmp1_e = 0;
-  FIXP_DBL add_tmp1_m = fAddNorm(cosIpd, 0, -iidLin_m, iidLin_e, &add_tmp1_e);
-  FIXP_DBL add_tmp2_m = fMult(add_tmp1_m, weight2_m);
-  int add_tmp2_e = add_tmp1_e + weight2_e;
-  tempb_atan2_m = fAddNorm(tempb_atan2_m, tempb_atan2_e, add_tmp2_m, add_tmp2_e,
-                           &tempb_atan2_e);
-
-  FIXP_DBL tempa_atan2_m = fMult(weight2_m, sinIpd);
-  int tempa_atan2_e = weight2_e;  // + sinIpd_e;
-
-  if (tempa_atan2_e > tempb_atan2_e) {
-    tempb_atan2_m = (tempb_atan2_m >> (tempa_atan2_e - tempb_atan2_e));
-    tempb_atan2_e = tempa_atan2_e;
-  } else if (tempb_atan2_e > tempa_atan2_e) {
-    tempa_atan2_m = (tempa_atan2_m >> (tempb_atan2_e - tempa_atan2_e));
-  }
-
-  return fixp_atan2(tempa_atan2_m, tempb_atan2_m);
-}
-
-static void calculateOpd(spatialDec* self, INT ottBoxIndx, INT parameterSetIndx,
-                         FIXP_DBL opd[MAX_PARAMETER_BANDS]) {
-  INT band;
-
-  for (band = 0; band < self->numOttBandsIPD; band++) {
-    INT idxCld = self->ottCLD__FDK[ottBoxIndx][parameterSetIndx][band];
-    INT idxIpd = self->ottIPD__FDK[ottBoxIndx][parameterSetIndx][band];
-    INT idxIcc = self->ottICC__FDK[ottBoxIndx][parameterSetIndx][band];
-    FIXP_DBL cld, ipd;
-
-    ipd = FX_CFG2FX_DBL(dequantIPD__FDK[idxIpd]);
-
-    SpatialDequantGetCLD2Values(idxCld, &cld);
-
-    /* ipd(idxIpd==8) == PI */
-    if ((cld == FL2FXCONST_DBL(0.0f)) && (idxIpd == 8)) {
-      opd[2 * band] = FL2FXCONST_DBL(0.0f);
-    } else {
-      opd[2 * band] = (dequantIPD_CLD_ICC_splitAngle__FDK_Function(
-                           idxIpd, idxCld, idxIcc) >>
-                       (IPD_SCALE - AT2O_SF));
-    }
-    opd[2 * band + 1] = opd[2 * band] - ipd;
-  }
-}
-
-/* wrap phase in rad to the range of 0 <= x < 2*pi */
-static FIXP_DBL wrapPhase(FIXP_DBL phase) {
-  while (phase < (FIXP_DBL)0) phase += PIx2__IPD;
-  while (phase >= PIx2__IPD) phase -= PIx2__IPD;
-  FDK_ASSERT((phase >= (FIXP_DBL)0) && (phase < PIx2__IPD));
-
-  return phase;
-}
-
-/*******************************************************************************
- Functionname: param2UMX_PS_IPD
- *******************************************************************************
-
- Description:
-
- Arguments:
-
- Return:
-
-*******************************************************************************/
-static void param2UMX_PS_IPD_OPD__FDK(
-    spatialDec* self, const SPATIAL_BS_FRAME* frame,
-    FIXP_DBL H11[MAX_PARAMETER_BANDS], FIXP_DBL H12[MAX_PARAMETER_BANDS],
-    FIXP_DBL H21[MAX_PARAMETER_BANDS], FIXP_DBL H22[MAX_PARAMETER_BANDS],
-    FIXP_DBL c_l[MAX_PARAMETER_BANDS], FIXP_DBL c_r[MAX_PARAMETER_BANDS],
-    int ottBoxIndx, int parameterSetIndx, int residualBands) {
-  INT band;
-  FIXP_DBL opd[2 * MAX_PARAMETER_BANDS];
-  INT numOttBands = self->numOttBands[ottBoxIndx];
-  INT numIpdBands;
-
-  numIpdBands = frame->phaseMode ? self->numOttBandsIPD : 0;
-
-  FDK_ASSERT(self->residualCoding == 0);
-
-  param2UMX_PS_Core__FDK(self->ottCLD__FDK[ottBoxIndx][parameterSetIndx],
-                         self->ottICC__FDK[ottBoxIndx][parameterSetIndx],
-                         self->numOttBands[ottBoxIndx], residualBands, H11, H12,
-                         H21, H22, c_l, c_r);
-
-  for (band = self->numOttBands[ottBoxIndx]; band < self->numParameterBands;
-       band++) {
-    H11[band] = H21[band] = H12[band] = H22[band] = FL2FXCONST_DBL(0.f);
-  }
-
-  if (frame->phaseMode) {
-    calculateOpd(self, ottBoxIndx, parameterSetIndx, opd);
-
-    for (band = 0; band < numIpdBands; band++) {
-      self->PhaseLeft__FDK[band] = wrapPhase(opd[2 * band]);
-      self->PhaseRight__FDK[band] = wrapPhase(opd[2 * band + 1]);
-    }
-  }
-
-  for (band = numIpdBands; band < numOttBands; band++) {
-    self->PhaseLeft__FDK[band] = FL2FXCONST_DBL(0.0f);
-    self->PhaseRight__FDK[band] = FL2FXCONST_DBL(0.0f);
-  }
-}
-
-FDK_INLINE void param2UMX_Prediction_Core__FDK(
-    FIXP_DBL* H11re, FIXP_DBL* H11im, FIXP_DBL* H12re, FIXP_DBL* H12im,
-    FIXP_DBL* H21re, FIXP_DBL* H21im, FIXP_DBL* H22re, FIXP_DBL* H22im,
-    int cldIdx, int iccIdx, int ipdIdx, int band, int numOttBandsIPD,
-    int resBands) {
-#define MAX_WEIGHT (1.2f)
-  FDK_ASSERT((H12im == NULL) && (H22im == NULL)); /* always == 0 */
-
-  if ((band < numOttBandsIPD) && (cldIdx == 15) && (iccIdx == 0) &&
-      (ipdIdx == 8)) {
-    const FIXP_DBL gain =
-        FL2FXCONST_DBL(0.5f / MAX_WEIGHT) >> SCALE_PARAM_M2_212_PRED;
-
-    *H11re = gain;
-    if (band < resBands) {
-      *H21re = gain;
-      *H12re = gain;
-      *H22re = -gain;
-    } else {
-      *H21re = -gain;
-      *H12re = (FIXP_DBL)0;
-      *H22re = (FIXP_DBL)0;
-    }
-    if ((H11im != NULL) &&
-        (H21im != NULL) /*&& (H12im!=NULL) && (H22im!=NULL)*/) {
-      *H11im = (FIXP_DBL)0;
-      *H21im = (FIXP_DBL)0;
-      /* *H12im = (FIXP_DBL)0; */
-      /* *H22im = (FIXP_DBL)0; */
-    }
-  } else {
-    const FIXP_DBL one_m = (FIXP_DBL)MAXVAL_DBL;
-    const int one_e = 0;
-    /* iidLin = sqrt(cld); */
-    FIXP_DBL iidLin_m = sqrt_CLD_m[cldIdx];
-    int iidLin_e = sqrt_CLD_e[cldIdx];
-    /* iidLin2 = cld; */
-    FIXP_DBL iidLin2_m = CLD_m[cldIdx];
-    int iidLin2_e = sqrt_CLD_e[cldIdx] << 1;
-    /* iidLin21 = iidLin2 + 1.0f; */
-    int iidLin21_e;
-    FIXP_DBL iidLin21_m =
-        fAddNorm(iidLin2_m, iidLin2_e, one_m, one_e, &iidLin21_e);
-    /* iidIcc2 = iidLin * icc * 2.0f; */
-    FIXP_CFG icc = dequantICC__FDK[iccIdx];
-    int iidIcc2_e = iidLin_e + 1;
-    FIXP_DBL iidIcc2_m = fMult(iidLin_m, icc);
-    FIXP_DBL temp_m, sqrt_temp_m, inv_temp_m, weight_m;
-    int temp_e, sqrt_temp_e, inv_temp_e, weight_e, scale;
-    FIXP_DBL cosIpd, sinIpd;
-
-    cosIpd = COS_IPD((band < numOttBandsIPD) ? ipdIdx : 0);
-    sinIpd = SIN_IPD((band < numOttBandsIPD) ? ipdIdx : 0);
-
-    /* temp    = iidLin21 + iidIcc2 * cosIpd; */
-    temp_m = fAddNorm(iidLin21_m, iidLin21_e, fMult(iidIcc2_m, cosIpd),
-                      iidIcc2_e, &temp_e);
-
-    /* calculate 1/temp needed later */
-    inv_temp_e = temp_e;
-    inv_temp_m = invFixp(temp_m, &inv_temp_e);
-
-    /* 1/weight = sqrt(temp) * 1/sqrt(iidLin21) */
-    if (temp_e & 1) {
-      sqrt_temp_m = temp_m >> 1;
-      sqrt_temp_e = (temp_e + 1) >> 1;
-    } else {
-      sqrt_temp_m = temp_m;
-      sqrt_temp_e = temp_e >> 1;
-    }
-    sqrt_temp_m = sqrtFixp(sqrt_temp_m);
-    if (iidLin21_e & 1) {
-      iidLin21_e += 1;
-      iidLin21_m >>= 1;
-    }
-    /* weight_[m,e] is actually 1/weight in the next few lines */
-    weight_m = invSqrtNorm2(iidLin21_m, &weight_e);
-    weight_e -= iidLin21_e >> 1;
-    weight_m = fMult(sqrt_temp_m, weight_m);
-    weight_e += sqrt_temp_e;
-    scale = fNorm(weight_m);
-    weight_m = scaleValue(weight_m, scale);
-    weight_e -= scale;
-    /* weight = 0.5 * max(1/weight, 1/maxWeight) */
-    if ((weight_e < 0) ||
-        ((weight_e == 0) && (weight_m < FL2FXCONST_DBL(1.f / MAX_WEIGHT)))) {
-      weight_m = FL2FXCONST_DBL(1.f / MAX_WEIGHT);
-      weight_e = 0;
-    }
-    weight_e -= 1;
-
-    {
-      FIXP_DBL alphaRe_m, alphaIm_m, accu_m;
-      int alphaRe_e, alphaIm_e, accu_e;
-      /* alphaRe = (1.0f - iidLin2) / temp; */
-      alphaRe_m = fAddNorm(one_m, one_e, -iidLin2_m, iidLin2_e, &alphaRe_e);
-      alphaRe_m = fMult(alphaRe_m, inv_temp_m);
-      alphaRe_e += inv_temp_e;
-
-      /* H11re = weight - alphaRe * weight; */
-      /* H21re = weight + alphaRe * weight; */
-      accu_m = fMult(alphaRe_m, weight_m);
-      accu_e = alphaRe_e + weight_e;
-      {
-        int accu2_e;
-        FIXP_DBL accu2_m;
-        accu2_m = fAddNorm(weight_m, weight_e, -accu_m, accu_e, &accu2_e);
-        *H11re = scaleValue(accu2_m, accu2_e - SCALE_PARAM_M2_212_PRED);
-        accu2_m = fAddNorm(weight_m, weight_e, accu_m, accu_e, &accu2_e);
-        *H21re = scaleValue(accu2_m, accu2_e - SCALE_PARAM_M2_212_PRED);
-      }
-
-      if ((H11im != NULL) &&
-          (H21im != NULL) /*&& (H12im != NULL) && (H22im != NULL)*/) {
-        /* alphaIm = -iidIcc2 * sinIpd / temp; */
-        alphaIm_m = fMult(-iidIcc2_m, sinIpd);
-        alphaIm_m = fMult(alphaIm_m, inv_temp_m);
-        alphaIm_e = iidIcc2_e + inv_temp_e;
-        /* H11im = -alphaIm * weight; */
-        /* H21im =  alphaIm * weight; */
-        accu_m = fMult(alphaIm_m, weight_m);
-        accu_e = alphaIm_e + weight_e;
-        accu_m = scaleValue(accu_m, accu_e - SCALE_PARAM_M2_212_PRED);
-        *H11im = -accu_m;
-        *H21im = accu_m;
-
-        /* *H12im = (FIXP_DBL)0; */
-        /* *H22im = (FIXP_DBL)0; */
-      }
-    }
-    if (band < resBands) {
-      FIXP_DBL weight =
-          scaleValue(weight_m, weight_e - SCALE_PARAM_M2_212_PRED);
-      *H12re = weight;
-      *H22re = -weight;
-    } else {
-      /* beta = 2.0f * iidLin * (float) sqrt(1.0f - icc * icc) * weight / temp;
-       */
-      FIXP_DBL beta_m;
-      int beta_e;
-      beta_m = FX_SGL2FX_DBL(sqrt_one_minus_ICC2[iccIdx]);
-      beta_e = 1; /* multipication with 2.0f */
-      beta_m = fMult(beta_m, weight_m);
-      beta_e += weight_e;
-      beta_m = fMult(beta_m, iidLin_m);
-      beta_e += iidLin_e;
-      beta_m = fMult(beta_m, inv_temp_m);
-      beta_e += inv_temp_e;
-
-      beta_m = scaleValue(beta_m, beta_e - SCALE_PARAM_M2_212_PRED);
-      *H12re = beta_m;
-      *H22re = -beta_m;
-    }
-  }
-}
-
-static void param2UMX_Prediction__FDK(spatialDec* self, FIXP_DBL* H11re,
-                                      FIXP_DBL* H11im, FIXP_DBL* H12re,
-                                      FIXP_DBL* H12im, FIXP_DBL* H21re,
-                                      FIXP_DBL* H21im, FIXP_DBL* H22re,
-                                      FIXP_DBL* H22im, int ottBoxIndx,
-                                      int parameterSetIndx, int resBands) {
-  int band;
-  FDK_ASSERT((H12im == NULL) && (H22im == NULL)); /* always == 0 */
-
-  for (band = 0; band < self->numParameterBands; band++) {
-    int cldIdx = self->ottCLD__FDK[ottBoxIndx][parameterSetIndx][band];
-    int iccIdx = self->ottICC__FDK[ottBoxIndx][parameterSetIndx][band];
-    int ipdIdx = self->ottIPD__FDK[ottBoxIndx][parameterSetIndx][band];
-
-    param2UMX_Prediction_Core__FDK(
-        &H11re[band], (H11im ? &H11im[band] : NULL), &H12re[band], NULL,
-        &H21re[band], (H21im ? &H21im[band] : NULL), &H22re[band], NULL, cldIdx,
-        iccIdx, ipdIdx, band, self->numOttBandsIPD, resBands);
-  }
-}
-
-/*******************************************************************************
- Functionname:  initM1andM2
- *******************************************************************************
-
- Description:
-
- Arguments:
-
- Return:
-
-*******************************************************************************/
-
-SACDEC_ERROR initM1andM2(spatialDec* self, int initStatesFlag,
-                         int configChanged) {
-  SACDEC_ERROR err = MPS_OK;
-
-  self->bOverwriteM1M2prev = (configChanged && !initStatesFlag) ? 1 : 0;
-
-  { self->numM2rows = self->numOutputChannels; }
-
-  if (initStatesFlag) {
-    int i, j, k;
-
-    for (i = 0; i < self->numM2rows; i++) {
-      for (j = 0; j < self->numVChannels; j++) {
-        for (k = 0; k < MAX_PARAMETER_BANDS; k++) {
-          self->M2Real__FDK[i][j][k] = FL2FXCONST_DBL(0);
-          self->M2RealPrev__FDK[i][j][k] = FL2FXCONST_DBL(0);
-        }
-      }
-    }
-  }
-
-  return err;
-}
--- a/libSACdec/src/sac_calcM1andM2.h
+++ /dev/null
@@ -1,129 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround decoder library *************************
-
-   Author(s):
-
-   Description: SAC Dec M1 and M2 calculation
-
-*******************************************************************************/
-
-/* sa_calcM1andM2.h */
-
-#ifndef SAC_CALCM1ANDM2_H
-#define SAC_CALCM1ANDM2_H
-
-#include "sac_dec.h"
-
-#define SCALE_PARAM_M1 3
-
-/* Scaling of M2 matrix, but only for binaural upmix type. */
-#define SCALE_PARAM_CALC_M2 (3)
-#define SCALE_PARAM_M2_515X (3)
-#define SCALE_PARAM_M2_525 (SCALE_PARAM_M1 + HRG_SF + 1 - SCALE_PARAM_CALC_M2)
-#define SCALE_PARAM_M2_212_PRED (3)
-/* Scaling of spectral data after applying M2 matrix, but only for binaural
-   upmix type Scaling is compensated later in synthesis qmf filterbank */
-#define SCALE_DATA_APPLY_M2 (1)
-
-SACDEC_ERROR initM1andM2(spatialDec* self, int initStatesFlag,
-                         int configChanged);
-
-int SpatialDecGetResidualIndex(spatialDec* self, int row);
-
-SACDEC_ERROR SpatialDecCalculateM1andM2(spatialDec* self, int ps,
-                                        const SPATIAL_BS_FRAME* frame);
-
-#endif /* SAC_CALCM1ANDM2_H */
--- a/libSACdec/src/sac_dec.cpp
+++ /dev/null
@@ -1,1509 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround decoder library *************************
-
-   Author(s):
-
-   Description: SAC Decoder Library
-
-*******************************************************************************/
-
-#include "sac_dec_errorcodes.h"
-#include "sac_dec.h"
-
-#include "sac_process.h"
-#include "sac_bitdec.h"
-#include "sac_smoothing.h"
-#include "sac_calcM1andM2.h"
-#include "sac_reshapeBBEnv.h"
-#include "sac_stp.h"
-#include "sac_rom.h"
-
-#include "FDK_decorrelate.h"
-
-#include "FDK_trigFcts.h"
-#include "FDK_matrixCalloc.h"
-
-/* static int pbStrideTable[] = {1, 2, 5, 28}; see sac_rom.cpp */
-
-enum {
-  APPLY_M2_NONE = 0,    /* init value */
-  APPLY_M2 = 1,         /* apply m2 fallback implementation */
-  APPLY_M2_MODE212 = 2, /* apply m2 for 212 mode */
-  APPLY_M2_MODE212_Res_PhaseCoding =
-      3 /* apply m2 for 212 mode with residuals and phase coding */
-};
-
-/******************************************************************************************/
-/* function: FDK_SpatialDecInitDefaultSpatialSpecificConfig */
-/* output:   struct of type SPATIAL_SPECIFIC_CONFIG */
-/* input:    core coder audio object type */
-/* input:    nr of core channels */
-/* input:    sampling rate */
-/* input:    nr of time slots */
-/* input:    decoder level */
-/* input:    flag indicating upmix type blind */
-/*                                                                                        */
-/* returns:  error code */
-/******************************************************************************************/
-int FDK_SpatialDecInitDefaultSpatialSpecificConfig(
-    SPATIAL_SPECIFIC_CONFIG *pSpatialSpecificConfig,
-    AUDIO_OBJECT_TYPE coreCodec, int coreChannels, int samplingFreq,
-    int nTimeSlots, int decoderLevel, int isBlind) {
-  return SpatialDecDefaultSpecificConfig(pSpatialSpecificConfig, coreCodec,
-                                         samplingFreq, nTimeSlots, decoderLevel,
-                                         isBlind, coreChannels);
-}
-
-/******************************************************************************************/
-/* function: FDK_SpatialDecCompareSpatialSpecificConfigHeader */
-/* input:    2 pointers to a ssc */
-/*                                                                                        */
-/* output:   - */
-/* returns:  error code (0 = equal, <>0 unequal) */
-/******************************************************************************************/
-int FDK_SpatialDecCompareSpatialSpecificConfigHeader(
-    SPATIAL_SPECIFIC_CONFIG *pSsc1, SPATIAL_SPECIFIC_CONFIG *pSsc2) {
-  int result = MPS_OK;
-
-  /* we assume: every bit must be equal */
-  if (FDKmemcmp(pSsc1, pSsc2, sizeof(SPATIAL_SPECIFIC_CONFIG)) != 0) {
-    result = MPS_UNEQUAL_SSC;
-  }
-  return result;
-}
-
-/*******************************************************************************
- Functionname: SpatialDecClearFrameData
- *******************************************************************************
-
- Description: Clear/Fake frame data to avoid misconfiguration and allow proper
-              error concealment.
- Arguments:
- Input:       self (frame data)
- Output:      No return value.
-
-*******************************************************************************/
-static void SpatialDecClearFrameData(
-    spatialDec *self, /* Shall be removed */
-    SPATIAL_BS_FRAME *bsFrame, const SACDEC_CREATION_PARAMS *const setup) {
-  int i;
-
-  FDK_ASSERT(self != NULL);
-  FDK_ASSERT(bsFrame != NULL);
-  FDK_ASSERT(setup != NULL);
-
-  /* do not apply shaping tools (GES or STP) */
-  for (i = 0; i < setup->maxNumOutputChannels;
-       i += 1) { /* MAX_OUTPUT_CHANNELS */
-    bsFrame->tempShapeEnableChannelSTP[i] = 0;
-    bsFrame->tempShapeEnableChannelGES[i] = 0;
-  }
-
-  bsFrame->TsdData->bsTsdEnable = 0;
-
-  /* use only 1 parameter set at the end of the frame */
-  bsFrame->numParameterSets = 1;
-  bsFrame->paramSlot[0] = self->timeSlots - 1;
-
-  /* parameter smoothing tool set to off */
-  bsFrame->bsSmoothMode[0] = 0;
-
-  /* reset residual data */
-  {
-    int resQmfBands, resTimeSlots = (1);
-
-    resQmfBands = setup->maxNumQmfBands;
-
-    for (i = 0; i < setup->bProcResidual
-                    ? fMin(setup->maxNumResChannels,
-                           setup->maxNumOttBoxes + setup->maxNumInputChannels)
-                    : 0;
-         i += 1) {
-      for (int j = 0; j < resTimeSlots; j += 1) {
-        for (int k = 0; k < resQmfBands; k += 1) {
-          self->qmfResidualReal__FDK[i][j][k] = FL2FXCONST_DBL(0.0f);
-          self->qmfResidualImag__FDK[i][j][k] = FL2FXCONST_DBL(0.0f);
-        }
-      }
-    }
-  }
-
-  return;
-}
-
-/*******************************************************************************
- Functionname: FDK_SpatialDecOpen
- *******************************************************************************
-
- Description:
-
- Arguments:
-
- Return:
-
-*******************************************************************************/
-spatialDec *FDK_SpatialDecOpen(const SPATIAL_DEC_CONFIG *config,
-                               int stereoConfigIndex) {
-  int i;
-  int lfSize, hfSize;
-  spatialDec *self = NULL;
-  SACDEC_CREATION_PARAMS setup;
-
-  switch (config->decoderLevel) {
-    case DECODER_LEVEL_0: /* 212 maxNumOutputChannels== 2 */
-      setup.maxNumInputChannels = 1;
-      setup.maxNumOutputChannels = 2;
-      setup.maxNumQmfBands = 64;
-      setup.maxNumXChannels = 2;
-      setup.maxNumVChannels = 2;
-      setup.maxNumDecorChannels = 1;
-      setup.bProcResidual = 1;
-      setup.maxNumResidualChannels = 0;
-      setup.maxNumOttBoxes = 1;
-      setup.maxNumParams = setup.maxNumInputChannels + setup.maxNumOttBoxes;
-      break;
-    default:
-      return NULL;
-  }
-
-  setup.maxNumResChannels = 1;
-
-  {
-    switch (config->maxNumOutputChannels) {
-      case OUTPUT_CHANNELS_2_0:
-        setup.maxNumOutputChannels = fMin(setup.maxNumOutputChannels, 2);
-        break;
-      case OUTPUT_CHANNELS_DEFAULT:
-      default:
-        break;
-    }
-  }
-
-  setup.maxNumHybridBands = SacGetHybridSubbands(setup.maxNumQmfBands);
-
-  switch (config->decoderMode) {
-    case EXT_HQ_ONLY:
-      setup.maxNumCmplxQmfBands = setup.maxNumQmfBands;
-      setup.maxNumCmplxHybBands = setup.maxNumHybridBands;
-      break;
-    default:
-      setup.maxNumCmplxQmfBands = fixMax(PC_NUM_BANDS, setup.maxNumQmfBands);
-      setup.maxNumCmplxHybBands =
-          fixMax(PC_NUM_HYB_BANDS, setup.maxNumHybridBands);
-      break;
-  } /* switch config->decoderMode */
-
-  FDK_ALLOCATE_MEMORY_1D_INT(self, 1, spatialDec, SECT_DATA_L2)
-
-  self->createParams = setup;
-
-  FDK_ALLOCATE_MEMORY_1D(self->param2hyb, MAX_PARAMETER_BANDS + 1, int)
-
-  FDK_ALLOCATE_MEMORY_1D(self->numOttBands, setup.maxNumOttBoxes, int)
-
-  /* allocate arrays */
-
-  FDK_ALLOCATE_MEMORY_1D(self->smgTime, MAX_PARAMETER_SETS, int)
-  FDK_ALLOCATE_MEMORY_2D(self->smgData, MAX_PARAMETER_SETS, MAX_PARAMETER_BANDS,
-                         UCHAR)
-
-  FDK_ALLOCATE_MEMORY_3D(self->ottCLD__FDK, setup.maxNumOttBoxes,
-                         MAX_PARAMETER_SETS, MAX_PARAMETER_BANDS, SCHAR)
-  FDK_ALLOCATE_MEMORY_3D(self->ottICC__FDK, setup.maxNumOttBoxes,
-                         MAX_PARAMETER_SETS, MAX_PARAMETER_BANDS, SCHAR)
-  FDK_ALLOCATE_MEMORY_3D(self->ottIPD__FDK, setup.maxNumOttBoxes,
-                         MAX_PARAMETER_SETS, MAX_PARAMETER_BANDS, SCHAR)
-
-  /* Last parameters from prev frame */
-  FDK_ALLOCATE_MEMORY_2D(self->ottCLDidxPrev, setup.maxNumOttBoxes,
-                         MAX_PARAMETER_BANDS, SCHAR)
-  FDK_ALLOCATE_MEMORY_2D(self->ottICCidxPrev, setup.maxNumOttBoxes,
-                         MAX_PARAMETER_BANDS, SCHAR)
-  FDK_ALLOCATE_MEMORY_3D(self->ottICCdiffidx, setup.maxNumOttBoxes,
-                         MAX_PARAMETER_SETS, MAX_PARAMETER_BANDS, SCHAR)
-  FDK_ALLOCATE_MEMORY_2D(self->ottIPDidxPrev, setup.maxNumOttBoxes,
-                         MAX_PARAMETER_BANDS, SCHAR)
-  FDK_ALLOCATE_MEMORY_2D(self->arbdmxGainIdxPrev, setup.maxNumInputChannels,
-                         MAX_PARAMETER_BANDS, SCHAR)
-  FDK_ALLOCATE_MEMORY_2D(self->cmpOttCLDidxPrev, setup.maxNumOttBoxes,
-                         MAX_PARAMETER_BANDS, SCHAR)
-  FDK_ALLOCATE_MEMORY_2D(self->cmpOttICCidxPrev, setup.maxNumOttBoxes,
-                         MAX_PARAMETER_BANDS, SCHAR)
-  FDK_ALLOCATE_MEMORY_3D(self->outIdxData, setup.maxNumOttBoxes,
-                         MAX_PARAMETER_SETS, MAX_PARAMETER_BANDS, SCHAR)
-
-  FDK_ALLOCATE_MEMORY_3D(self->arbdmxGain__FDK, setup.maxNumInputChannels,
-                         MAX_PARAMETER_SETS, MAX_PARAMETER_BANDS, SCHAR)
-  FDK_ALLOCATE_MEMORY_1D(self->arbdmxAlpha__FDK, setup.maxNumInputChannels,
-                         FIXP_DBL)
-  FDK_ALLOCATE_MEMORY_1D(self->arbdmxAlphaPrev__FDK, setup.maxNumInputChannels,
-                         FIXP_DBL)
-  FDK_ALLOCATE_MEMORY_2D(self->cmpArbdmxGainIdxPrev, setup.maxNumInputChannels,
-                         MAX_PARAMETER_BANDS, SCHAR)
-
-  FDK_ALLOCATE_MEMORY_2D(self->cmpOttIPDidxPrev, setup.maxNumOttBoxes,
-                         MAX_PARAMETER_BANDS, SCHAR)
-
-  FDK_ALLOCATE_MEMORY_3D_INT(self->M2Real__FDK, setup.maxNumOutputChannels,
-                             setup.maxNumVChannels, MAX_PARAMETER_BANDS,
-                             FIXP_DBL, SECT_DATA_L2)
-  FDK_ALLOCATE_MEMORY_3D(self->M2Imag__FDK, setup.maxNumOutputChannels,
-                         setup.maxNumVChannels, MAX_PARAMETER_BANDS, FIXP_DBL)
-
-  FDK_ALLOCATE_MEMORY_3D_INT(self->M2RealPrev__FDK, setup.maxNumOutputChannels,
-                             setup.maxNumVChannels, MAX_PARAMETER_BANDS,
-                             FIXP_DBL, SECT_DATA_L2)
-  FDK_ALLOCATE_MEMORY_3D(self->M2ImagPrev__FDK, setup.maxNumOutputChannels,
-                         setup.maxNumVChannels, MAX_PARAMETER_BANDS, FIXP_DBL)
-
-  FDK_ALLOCATE_MEMORY_2D_INT_ALIGNED(
-      self->qmfInputReal__FDK, setup.maxNumInputChannels, setup.maxNumQmfBands,
-      FIXP_DBL, SECT_DATA_L2)
-  FDK_ALLOCATE_MEMORY_2D_INT_ALIGNED(
-      self->qmfInputImag__FDK, setup.maxNumInputChannels,
-      setup.maxNumCmplxQmfBands, FIXP_DBL, SECT_DATA_L2)
-
-  FDK_ALLOCATE_MEMORY_2D_INT(self->hybInputReal__FDK, setup.maxNumInputChannels,
-                             setup.maxNumHybridBands, FIXP_DBL, SECT_DATA_L2)
-  FDK_ALLOCATE_MEMORY_2D_INT(self->hybInputImag__FDK, setup.maxNumInputChannels,
-                             setup.maxNumCmplxHybBands, FIXP_DBL, SECT_DATA_L2)
-
-  if (setup.bProcResidual) {
-    FDK_ALLOCATE_MEMORY_1D(self->qmfResidualReal__FDK, setup.maxNumResChannels,
-                           FIXP_DBL **)
-    FDK_ALLOCATE_MEMORY_1D(self->qmfResidualImag__FDK, setup.maxNumResChannels,
-                           FIXP_DBL **)
-
-    FDK_ALLOCATE_MEMORY_1D(self->hybResidualReal__FDK, setup.maxNumResChannels,
-                           FIXP_DBL *)
-    FDK_ALLOCATE_MEMORY_1D(self->hybResidualImag__FDK, setup.maxNumResChannels,
-                           FIXP_DBL *)
-
-    for (i = 0; i < setup.maxNumResChannels; i++) {
-      int resQmfBands = (config->decoderMode == EXT_LP_ONLY)
-                            ? PC_NUM_BANDS
-                            : setup.maxNumQmfBands;
-      int resHybBands = (config->decoderMode == EXT_LP_ONLY)
-                            ? PC_NUM_HYB_BANDS
-                            : setup.maxNumHybridBands;
-      /* Alignment is needed for USAC residuals because QMF analysis directly
-       * writes to this buffer. */
-      FDK_ALLOCATE_MEMORY_2D_INT_ALIGNED(self->qmfResidualReal__FDK[i], (1),
-                                         resQmfBands, FIXP_DBL, SECT_DATA_L1)
-      FDK_ALLOCATE_MEMORY_2D_INT_ALIGNED(self->qmfResidualImag__FDK[i], (1),
-                                         resQmfBands, FIXP_DBL, SECT_DATA_L1)
-
-      FDK_ALLOCATE_MEMORY_1D(self->hybResidualReal__FDK[i],
-                             setup.maxNumHybridBands, FIXP_DBL)
-      FDK_ALLOCATE_MEMORY_1D(self->hybResidualImag__FDK[i], resHybBands,
-                             FIXP_DBL)
-    }
-  } /* if (setup.bProcResidual) */
-
-  FDK_ALLOCATE_MEMORY_2D_INT(self->wReal__FDK, setup.maxNumVChannels,
-                             setup.maxNumHybridBands, FIXP_DBL, SECT_DATA_L2)
-  FDK_ALLOCATE_MEMORY_2D_INT(self->wImag__FDK, setup.maxNumVChannels,
-                             setup.maxNumCmplxHybBands, FIXP_DBL, SECT_DATA_L2)
-
-  FDK_ALLOCATE_MEMORY_2D_INT(self->hybOutputRealDry__FDK,
-                             setup.maxNumOutputChannels,
-                             setup.maxNumHybridBands, FIXP_DBL, SECT_DATA_L2)
-  FDK_ALLOCATE_MEMORY_2D_INT(self->hybOutputImagDry__FDK,
-                             setup.maxNumOutputChannels,
-                             setup.maxNumCmplxHybBands, FIXP_DBL, SECT_DATA_L2)
-
-  FDK_ALLOCATE_MEMORY_2D_INT(self->hybOutputRealWet__FDK,
-                             setup.maxNumOutputChannels,
-                             setup.maxNumHybridBands, FIXP_DBL, SECT_DATA_L2)
-  FDK_ALLOCATE_MEMORY_2D_INT(self->hybOutputImagWet__FDK,
-                             setup.maxNumOutputChannels,
-                             setup.maxNumCmplxHybBands, FIXP_DBL, SECT_DATA_L2)
-
-  FDK_ALLOCATE_MEMORY_1D(self->hybridSynthesis, setup.maxNumOutputChannels,
-                         FDK_SYN_HYB_FILTER)
-
-  FDK_ALLOCATE_MEMORY_1D(
-      self->hybridAnalysis,
-      setup.bProcResidual ? setup.maxNumInputChannels + setup.maxNumResChannels
-                          : setup.maxNumInputChannels,
-      FDK_ANA_HYB_FILTER)
-
-  lfSize = 2 * BUFFER_LEN_LF * MAX_QMF_BANDS_TO_HYBRID;
-  {
-    hfSize =
-        BUFFER_LEN_HF * ((setup.maxNumQmfBands - MAX_QMF_BANDS_TO_HYBRID) +
-                         (setup.maxNumCmplxQmfBands - MAX_QMF_BANDS_TO_HYBRID));
-  }
-
-  FDK_ALLOCATE_MEMORY_2D_INT(self->pHybridAnaStatesLFdmx,
-                             setup.maxNumInputChannels, lfSize, FIXP_DBL,
-                             SECT_DATA_L2) {
-    FDK_ALLOCATE_MEMORY_2D(self->pHybridAnaStatesHFdmx,
-                           setup.maxNumInputChannels, hfSize, FIXP_DBL)
-  }
-
-  for (i = 0; i < setup.maxNumInputChannels; i++) {
-    FIXP_DBL *pHybridAnaStatesHFdmx;
-
-    pHybridAnaStatesHFdmx = self->pHybridAnaStatesHFdmx[i];
-
-    FDKhybridAnalysisOpen(&self->hybridAnalysis[i],
-                          self->pHybridAnaStatesLFdmx[i],
-                          lfSize * sizeof(FIXP_DBL), pHybridAnaStatesHFdmx,
-                          hfSize * sizeof(FIXP_DBL));
-  }
-  if (setup.bProcResidual) {
-    lfSize = 2 * BUFFER_LEN_LF * MAX_QMF_BANDS_TO_HYBRID;
-    hfSize = BUFFER_LEN_HF *
-             ((((config->decoderMode == EXT_LP_ONLY) ? PC_NUM_BANDS
-                                                     : setup.maxNumQmfBands) -
-               MAX_QMF_BANDS_TO_HYBRID) +
-              (setup.maxNumCmplxQmfBands - MAX_QMF_BANDS_TO_HYBRID));
-
-    FDK_ALLOCATE_MEMORY_2D_INT(self->pHybridAnaStatesLFres,
-                               setup.maxNumResChannels, lfSize, FIXP_DBL,
-                               SECT_DATA_L2)
-    FDK_ALLOCATE_MEMORY_2D(self->pHybridAnaStatesHFres, setup.maxNumResChannels,
-                           hfSize, FIXP_DBL)
-
-    for (i = setup.maxNumInputChannels;
-         i < (setup.maxNumInputChannels + setup.maxNumResChannels); i++) {
-      FDKhybridAnalysisOpen(
-          &self->hybridAnalysis[i],
-          self->pHybridAnaStatesLFres[i - setup.maxNumInputChannels],
-          lfSize * sizeof(FIXP_DBL),
-          self->pHybridAnaStatesHFres[i - setup.maxNumInputChannels],
-          hfSize * sizeof(FIXP_DBL));
-    }
-  }
-
-  FDK_ALLOCATE_MEMORY_1D(self->smoothState, 1, SMOOTHING_STATE)
-  FDK_ALLOCATE_MEMORY_1D(self->reshapeBBEnvState, 1, RESHAPE_BBENV_STATE)
-
-  FDK_ALLOCATE_MEMORY_1D(self->apDecor, setup.maxNumDecorChannels, DECORR_DEC)
-  FDK_ALLOCATE_MEMORY_2D_INT(self->pDecorBufferCplx, setup.maxNumDecorChannels,
-                             (2 * ((825) + (373))), FIXP_DBL, SECT_DATA_L2)
-
-  for (i = 0; i < setup.maxNumDecorChannels; i++) {
-    if (FDKdecorrelateOpen(&self->apDecor[i], self->pDecorBufferCplx[i],
-                           (2 * ((825) + (373))))) {
-      goto bail;
-    }
-  }
-
-  if (subbandTPCreate(&self->hStpDec) != MPS_OK) {
-    goto bail;
-  }
-
-  /* save general decoder configuration */
-  self->decoderLevel = config->decoderLevel;
-  self->decoderMode = config->decoderMode;
-  self->binauralMode = config->binauralMode;
-
-  /* preinitialize configuration */
-  self->partiallyComplex = (config->decoderMode != EXT_HQ_ONLY) ? 1 : 0;
-
-  /* Set to default state */
-  SpatialDecConcealment_Init(&self->concealInfo, MPEGS_CONCEAL_RESET_ALL);
-
-  /* Everything is fine so return the handle */
-  return self;
-
-bail:
-  /* Collector for all errors.
-     Deallocate all memory and return a invalid handle. */
-  FDK_SpatialDecClose(self);
-
-  return NULL;
-}
-
-/*******************************************************************************
- Functionname: isValidConfig
- *******************************************************************************
-
- Description: Validate if configuration is supported in present instance
-
- Arguments:
-
- Return: 1: all okay
-         0: configuration not supported
-*******************************************************************************/
-static int isValidConfig(spatialDec const *const self,
-                         const SPATIAL_DEC_UPMIX_TYPE upmixType,
-                         SPATIALDEC_PARAM const *const pUserParams,
-                         const AUDIO_OBJECT_TYPE coreAot) {
-  UPMIXTYPE nUpmixType;
-
-  FDK_ASSERT(self != NULL);
-  FDK_ASSERT(pUserParams != NULL);
-
-  nUpmixType = (UPMIXTYPE)upmixType;
-
-  switch (nUpmixType) {
-    case UPMIXTYPE_BYPASS: /* UPMIX_TYPE_BYPASS */
-      break;
-    case UPMIXTYPE_NORMAL: /* UPMIX_TYPE_NORMAL */
-      break;
-    default:
-      return 0; /* unsupported upmixType */
-  }
-
-  return 1; /* upmixType supported */
-}
-
-static SACDEC_ERROR CheckLevelTreeUpmixType(
-    const SACDEC_CREATION_PARAMS *const pCreateParams,
-    const SPATIAL_SPECIFIC_CONFIG *const pSsc, const int decoderLevel,
-    const UPMIXTYPE upmixType) {
-  SACDEC_ERROR err = MPS_OK;
-  int nOutputChannels, treeConfig;
-
-  FDK_ASSERT(pCreateParams != NULL);
-  FDK_ASSERT(pSsc != NULL);
-
-  treeConfig = pSsc->treeConfig;
-
-  switch (decoderLevel) {
-    case 0: {
-      if (treeConfig != SPATIALDEC_MODE_RSVD7) {
-        err = MPS_INVALID_TREECONFIG;
-        goto bail;
-      }
-      break;
-    }
-    default:
-      err = MPS_INVALID_PARAMETER /* MPS_UNIMPLEMENTED */;
-      goto bail;
-  }
-
-  switch (upmixType) {
-    case UPMIXTYPE_BYPASS:
-      nOutputChannels = pSsc->nInputChannels;
-      break;
-    default:
-      nOutputChannels = pSsc->nOutputChannels;
-      break;
-  }
-
-  /* Is sufficient memory allocated. */
-  if ((pSsc->nInputChannels > pCreateParams->maxNumInputChannels) ||
-      (nOutputChannels > pCreateParams->maxNumOutputChannels) ||
-      (pSsc->nOttBoxes > pCreateParams->maxNumOttBoxes)) {
-    err = MPS_INVALID_PARAMETER;
-  }
-
-bail:
-  return err;
-}
-
-void SpatialDecInitParserContext(spatialDec *self) {
-  int i, j;
-
-  for (i = 0; i < self->createParams.maxNumOttBoxes; i += 1) {
-    for (j = 0; j < MAX_PARAMETER_BANDS; j++) {
-      self->ottCLDidxPrev[i][j] = 0;
-      self->ottICCidxPrev[i][j] = 0;
-      self->cmpOttCLDidxPrev[i][j] = 0;
-      self->cmpOttICCidxPrev[i][j] = 0;
-    }
-  }
-  for (i = 0; i < self->createParams.maxNumInputChannels; i++) {
-    for (j = 0; j < MAX_PARAMETER_BANDS; j++) {
-      self->arbdmxGainIdxPrev[i][j] = 0;
-      self->cmpArbdmxGainIdxPrev[i][j] = 0;
-    }
-  }
-}
-
-/*******************************************************************************
- Functionname: FDK_SpatialDecInit
- *******************************************************************************
-
- Description:
-
- Arguments:
-
- Return:
-
-*******************************************************************************/
-
-SACDEC_ERROR FDK_SpatialDecInit(spatialDec *self, SPATIAL_BS_FRAME *frame,
-                                SPATIAL_SPECIFIC_CONFIG *pSpatialSpecificConfig,
-                                int nQmfBands,
-                                SPATIAL_DEC_UPMIX_TYPE const upmixType,
-                                SPATIALDEC_PARAM *pUserParams, UINT initFlags) {
-  SACDEC_ERROR err = MPS_OK;
-  int nCh, i, j, k;
-  int maxQmfBands;
-  int bypassMode = 0;
-
-  self->useFDreverb = 0;
-
-  /* check configuration parameter */
-  if (!isValidConfig(self, upmixType, pUserParams,
-                     pSpatialSpecificConfig->coreCodec)) {
-    return MPS_INVALID_PARAMETER;
-  }
-
-  /* check tree configuration */
-  err = CheckLevelTreeUpmixType(&self->createParams, pSpatialSpecificConfig,
-                                self->decoderLevel, (UPMIXTYPE)upmixType);
-  if (err != MPS_OK) {
-    goto bail;
-  }
-
-  /* Store and update instance after all checks passed successfully: */
-  self->upmixType = (UPMIXTYPE)upmixType;
-
-  if (initFlags & MPEGS_INIT_PARAMS_ERROR_CONCEALMENT) { /* At least one error
-                                                            concealment
-                                                            parameter changed */
-    err = SpatialDecConcealment_SetParam(
-        &self->concealInfo, SAC_DEC_CONCEAL_METHOD, pUserParams->concealMethod);
-    if (err != MPS_OK) {
-      goto bail;
-    }
-    err = SpatialDecConcealment_SetParam(&self->concealInfo,
-                                         SAC_DEC_CONCEAL_NUM_KEEP_FRAMES,
-                                         pUserParams->concealNumKeepFrames);
-    if (err != MPS_OK) {
-      goto bail;
-    }
-    err = SpatialDecConcealment_SetParam(
-        &self->concealInfo, SAC_DEC_CONCEAL_FADE_OUT_SLOPE_LENGTH,
-        pUserParams->concealFadeOutSlopeLength);
-    if (err != MPS_OK) {
-      goto bail;
-    }
-    err = SpatialDecConcealment_SetParam(&self->concealInfo,
-                                         SAC_DEC_CONCEAL_FADE_IN_SLOPE_LENGTH,
-                                         pUserParams->concealFadeInSlopeLength);
-    if (err != MPS_OK) {
-      goto bail;
-    }
-    err = SpatialDecConcealment_SetParam(&self->concealInfo,
-                                         SAC_DEC_CONCEAL_NUM_RELEASE_FRAMES,
-                                         pUserParams->concealNumReleaseFrames);
-    if (err != MPS_OK) {
-      goto bail;
-    }
-  }
-
-  if (initFlags &
-      MPEGS_INIT_STATES_ERROR_CONCEALMENT) { /* Set to default state */
-    SpatialDecConcealment_Init(&self->concealInfo, MPEGS_CONCEAL_RESET_STATE);
-  }
-
-  /* determine bypass mode */
-  bypassMode |= pUserParams->bypassMode;
-  bypassMode |= ((self->upmixType == UPMIXTYPE_BYPASS) ? 1 : 0);
-
-  /* static decoder scale depends on number of qmf bands */
-  switch (nQmfBands) {
-    case 16:
-    case 24:
-    case 32:
-      self->staticDecScale = 21;
-      break;
-    case 64:
-      self->staticDecScale = 22;
-      break;
-    default:
-      return MPS_INVALID_PARAMETER;
-  }
-
-  self->numParameterSetsPrev = 1;
-
-  self->qmfBands = nQmfBands;
-  /* self->hybridBands will be updated in SpatialDecDecodeHeader() below. */
-
-  self->bShareDelayWithSBR = 0;
-
-  err = SpatialDecDecodeHeader(self, pSpatialSpecificConfig);
-  if (err != MPS_OK) {
-    goto bail;
-  }
-
-  self->stereoConfigIndex = pSpatialSpecificConfig->stereoConfigIndex;
-
-  if (initFlags & MPEGS_INIT_STATES_ANA_QMF_FILTER) {
-    self->qmfInputDelayBufPos = 0;
-    self->pc_filterdelay = 1; /* Division by 0 not possible */
-  }
-
-  maxQmfBands = self->qmfBands;
-
-  /* init residual decoder */
-
-  /* init tonality smoothing */
-  if (initFlags & MPEGS_INIT_STATES_PARAM) {
-    initParameterSmoothing(self);
-  }
-
-  /* init GES */
-  initBBEnv(self, (initFlags & MPEGS_INIT_STATES_GES) ? 1 : 0);
-
-  /* Clip protection is applied only for normal processing. */
-  if (!isTwoChMode(self->upmixType) && !bypassMode) {
-    self->staticDecScale += self->clipProtectGainSF__FDK;
-  }
-
-  {
-    UINT flags = 0;
-    INT initStatesFlag = (initFlags & MPEGS_INIT_STATES_ANA_QMF_FILTER) ? 1 : 0;
-    INT useLdFilter =
-        (self->pConfigCurrent->syntaxFlags & SACDEC_SYNTAX_LD) ? 1 : 0;
-
-    flags = self->pQmfDomain->globalConf.flags_requested;
-    flags &= (~(UINT)QMF_FLAG_LP);
-
-    if (initStatesFlag)
-      flags &= ~QMF_FLAG_KEEP_STATES;
-    else
-      flags |= QMF_FLAG_KEEP_STATES;
-
-    if (useLdFilter)
-      flags |= QMF_FLAG_MPSLDFB;
-    else
-      flags &= ~QMF_FLAG_MPSLDFB;
-
-    self->pQmfDomain->globalConf.flags_requested = flags;
-    FDK_QmfDomain_Configure(self->pQmfDomain);
-
-    /* output scaling */
-    for (nCh = 0; nCh < self->numOutputChannelsAT; nCh++) {
-      int outputScale = 0, outputGain_e = 0, scale = 0;
-      FIXP_DBL outputGain_m = getChGain(self, nCh, &outputGain_e);
-
-      if (!isTwoChMode(self->upmixType) && !bypassMode) {
-        outputScale +=
-            self->clipProtectGainSF__FDK; /* consider clip protection scaling at
-                                             synthesis qmf */
-      }
-
-      scale = outputScale;
-
-      qmfChangeOutScalefactor(&self->pQmfDomain->QmfDomainOut[nCh].fb, scale);
-      qmfChangeOutGain(&self->pQmfDomain->QmfDomainOut[nCh].fb, outputGain_m,
-                       outputGain_e);
-    }
-  }
-
-  for (nCh = 0; nCh < self->numOutputChannelsAT; nCh++) {
-    FDKhybridSynthesisInit(&self->hybridSynthesis[nCh], THREE_TO_TEN,
-                           self->qmfBands, maxQmfBands);
-  }
-
-  /* for input, residual channels and arbitrary down-mix residual channels */
-  for (nCh = 0; nCh < self->createParams.maxNumInputChannels; nCh++) {
-    FDKhybridAnalysisInit(
-        &self->hybridAnalysis[nCh], THREE_TO_TEN, self->qmfBands, maxQmfBands,
-        (initFlags & MPEGS_INIT_STATES_ANA_HYB_FILTER) ? 1 : 0);
-  }
-  for (; nCh < (self->createParams.bProcResidual
-                    ? (self->createParams.maxNumInputChannels +
-                       self->createParams.maxNumResChannels)
-                    : self->createParams.maxNumInputChannels);
-       nCh++) {
-    FDKhybridAnalysisInit(&self->hybridAnalysis[nCh], THREE_TO_TEN, maxQmfBands,
-                          maxQmfBands, 0);
-  }
-
-  {
-    for (k = 0; k < self->numDecorSignals; k++) {
-      int errCode, idec;
-      FDK_DECORR_TYPE decorrType = DECORR_PS;
-      decorrType = DECORR_LD;
-      if (self->pConfigCurrent->syntaxFlags &
-          (SACDEC_SYNTAX_USAC | SACDEC_SYNTAX_RSVD50)) {
-        decorrType =
-            ((self->treeConfig == TREE_212) && (self->decorrType == DECORR_PS))
-                ? DECORR_PS
-                : DECORR_USAC;
-      }
-      {
-        idec = k;
-        if (self->pConfigCurrent->syntaxFlags & SACDEC_SYNTAX_LD) {
-          if (self->treeConfig == TREE_212 && k == 0) {
-            idec = 2;
-          }
-        }
-      }
-      errCode = FDKdecorrelateInit(
-          &self->apDecor[k], self->hybridBands, decorrType, DUCKER_AUTOMATIC,
-          self->decorrConfig, idec, 0, /* self->partiallyComplex */
-          0, 0,                        /* isLegacyPS */
-          (initFlags & MPEGS_INIT_STATES_DECORRELATOR) ? 1 : 0);
-      if (errCode) return MPS_NOTOK;
-    }
-  } /* !self->partiallyComplex */
-
-  err = initM1andM2(self, (initFlags & MPEGS_INIT_STATES_M1M2) ? 1 : 0,
-                    (initFlags & MPEGS_INIT_CONFIG) ? 1 : 0);
-  if (err != MPS_OK) return err;
-
-  /* Initialization of previous frame data */
-  if (initFlags & MPEGS_INIT_STATES_PARAM) {
-    for (i = 0; i < self->createParams.maxNumOttBoxes; i += 1) {
-      /* reset icc diff data */
-      for (k = 0; k < MAX_PARAMETER_SETS; k += 1) {
-        for (j = 0; j < MAX_PARAMETER_BANDS; j += 1) {
-          self->ottICCdiffidx[i][k][j] = 0;
-        }
-      }
-    }
-    /* Parameter Smoothing */
-    /* robustness: init with one of the values of smgTimeTable[] = {64, 128,
-       256, 512} to avoid division by zero in calcFilterCoeff__FDK() */
-    self->smoothState->prevSmgTime = smgTimeTable[2]; /* == 256 */
-    FDKmemclear(self->smoothState->prevSmgData,
-                MAX_PARAMETER_BANDS * sizeof(UCHAR));
-    FDKmemclear(self->smoothState->opdLeftState__FDK,
-                MAX_PARAMETER_BANDS * sizeof(FIXP_DBL));
-    FDKmemclear(self->smoothState->opdRightState__FDK,
-                MAX_PARAMETER_BANDS * sizeof(FIXP_DBL));
-  }
-
-  self->prevTimeSlot = -1;
-  self->curTimeSlot =
-      MAX_TIME_SLOTS + 1; /* Initialize with a invalid value to trigger
-                             concealment if first frame has no valid data. */
-  self->curPs = 0;
-
-  subbandTPInit(self->hStpDec);
-
-bail:
-  return err;
-}
-
-void SpatialDecChannelProperties(spatialDec *self,
-                                 AUDIO_CHANNEL_TYPE channelType[],
-                                 UCHAR channelIndices[],
-                                 const FDK_channelMapDescr *const mapDescr) {
-  if ((self == NULL) || (channelType == NULL) || (channelIndices == NULL) ||
-      (mapDescr == NULL)) {
-    return; /* no extern buffer to be filled */
-  }
-
-  if (self->numOutputChannelsAT !=
-      treePropertyTable[self->treeConfig].numOutputChannels) {
-    int ch;
-    /* Declare all channels to be front channels: */
-    for (ch = 0; ch < self->numOutputChannelsAT; ch += 1) {
-      channelType[ch] = ACT_FRONT;
-      channelIndices[ch] = ch;
-    }
-  } else {
-    /* ISO/IEC FDIS 23003-1:2006(E), page 46, Table 40 bsTreeConfig */
-    switch (self->treeConfig) {
-      case TREE_212:
-        channelType[0] = ACT_FRONT;
-        channelIndices[0] = 0;
-        channelType[1] = ACT_FRONT;
-        channelIndices[1] = 1;
-        break;
-      default:;
-    }
-  }
-}
-
-/*******************************************************************************
- Functionname: FDK_SpatialDecClose
- *******************************************************************************
-
- Description:
-
- Arguments:
-
- Return:
-
-*******************************************************************************/
-
-void FDK_SpatialDecClose(spatialDec *self) {
-  if (self) {
-    int k;
-
-    if (self->apDecor != NULL) {
-      for (k = 0; k < self->createParams.maxNumDecorChannels; k++) {
-        FDKdecorrelateClose(&(self->apDecor[k]));
-      }
-      FDK_FREE_MEMORY_1D(self->apDecor);
-    }
-    if (self->pDecorBufferCplx != NULL) {
-      FDK_FREE_MEMORY_2D(self->pDecorBufferCplx);
-    }
-
-    subbandTPDestroy(&self->hStpDec);
-
-    FDK_FREE_MEMORY_1D(self->reshapeBBEnvState);
-    FDK_FREE_MEMORY_1D(self->smoothState);
-
-    FDK_FREE_MEMORY_2D(self->pHybridAnaStatesLFdmx);
-    FDK_FREE_MEMORY_2D(self->pHybridAnaStatesHFdmx);
-    FDK_FREE_MEMORY_2D(self->pHybridAnaStatesLFres);
-    FDK_FREE_MEMORY_2D(self->pHybridAnaStatesHFres);
-    FDK_FREE_MEMORY_1D(self->hybridAnalysis);
-
-    FDK_FREE_MEMORY_1D(self->hybridSynthesis);
-
-    /* The time buffer is passed to the decoder from outside to avoid copying
-     * (zero copy). */
-    /* FDK_FREE_MEMORY_2D(self->timeOut__FDK); */
-
-    FDK_FREE_MEMORY_2D(self->hybOutputImagWet__FDK);
-    FDK_FREE_MEMORY_2D(self->hybOutputRealWet__FDK);
-
-    FDK_FREE_MEMORY_2D(self->hybOutputImagDry__FDK);
-    FDK_FREE_MEMORY_2D(self->hybOutputRealDry__FDK);
-
-    FDK_FREE_MEMORY_2D(self->wImag__FDK);
-    FDK_FREE_MEMORY_2D(self->wReal__FDK);
-
-    if (self->createParams.bProcResidual) {
-      int i;
-
-      for (i = 0; i < self->createParams.maxNumResChannels; i++) {
-        if (self->hybResidualImag__FDK != NULL)
-          FDK_FREE_MEMORY_1D(self->hybResidualImag__FDK[i]);
-        if (self->hybResidualReal__FDK != NULL)
-          FDK_FREE_MEMORY_1D(self->hybResidualReal__FDK[i]);
-        if (self->qmfResidualImag__FDK != NULL)
-          FDK_FREE_MEMORY_2D_ALIGNED(self->qmfResidualImag__FDK[i]);
-        if (self->qmfResidualReal__FDK != NULL)
-          FDK_FREE_MEMORY_2D_ALIGNED(self->qmfResidualReal__FDK[i]);
-      }
-
-      FDK_FREE_MEMORY_1D(self->hybResidualImag__FDK);
-      FDK_FREE_MEMORY_1D(self->hybResidualReal__FDK);
-
-      FDK_FREE_MEMORY_1D(self->qmfResidualImag__FDK);
-      FDK_FREE_MEMORY_1D(self->qmfResidualReal__FDK);
-
-    } /* self->createParams.bProcResidual */
-
-    FDK_FREE_MEMORY_2D(self->hybInputImag__FDK);
-    FDK_FREE_MEMORY_2D(self->hybInputReal__FDK);
-
-    FDK_FREE_MEMORY_2D_ALIGNED(self->qmfInputImag__FDK);
-    FDK_FREE_MEMORY_2D_ALIGNED(self->qmfInputReal__FDK);
-
-    FDK_FREE_MEMORY_3D(self->M2ImagPrev__FDK);
-
-    FDK_FREE_MEMORY_3D(self->M2RealPrev__FDK);
-
-    FDK_FREE_MEMORY_3D(self->M2Imag__FDK);
-
-    FDK_FREE_MEMORY_3D(self->M2Real__FDK);
-
-    FDK_FREE_MEMORY_1D(self->arbdmxAlphaPrev__FDK);
-    FDK_FREE_MEMORY_1D(self->arbdmxAlpha__FDK);
-
-    FDK_FREE_MEMORY_3D(self->arbdmxGain__FDK);
-
-    FDK_FREE_MEMORY_3D(self->ottIPD__FDK);
-    FDK_FREE_MEMORY_3D(self->ottICC__FDK);
-    FDK_FREE_MEMORY_3D(self->ottCLD__FDK);
-
-    /* Last parameters from prev frame */
-    FDK_FREE_MEMORY_2D(self->ottCLDidxPrev);
-    FDK_FREE_MEMORY_2D(self->ottICCidxPrev);
-    FDK_FREE_MEMORY_3D(self->ottICCdiffidx);
-    FDK_FREE_MEMORY_2D(self->ottIPDidxPrev);
-    FDK_FREE_MEMORY_2D(self->arbdmxGainIdxPrev);
-
-    FDK_FREE_MEMORY_2D(self->cmpOttCLDidxPrev);
-    FDK_FREE_MEMORY_2D(self->cmpOttICCidxPrev);
-    FDK_FREE_MEMORY_3D(self->outIdxData);
-    FDK_FREE_MEMORY_2D(self->cmpOttIPDidxPrev);
-    FDK_FREE_MEMORY_2D(self->cmpArbdmxGainIdxPrev);
-
-    FDK_FREE_MEMORY_2D(self->smgData);
-    FDK_FREE_MEMORY_1D(self->smgTime);
-
-    FDK_FREE_MEMORY_1D(self->numOttBands);
-
-    FDK_FREE_MEMORY_1D(self->param2hyb);
-
-    FDK_FREE_MEMORY_1D(self);
-  }
-
-  return;
-}
-
-/**
- * \brief Apply Surround bypass buffer copies
- * \param self spatialDec handle
- * \param hybInputReal
- * \param hybInputImag
- * \param hybOutputReal
- * \param hybOutputImag
- * \param numInputChannels amount if input channels available in hybInputReal
- * and hybInputImag, which may differ from self->numInputChannels.
- */
-static void SpatialDecApplyBypass(spatialDec *self, FIXP_DBL **hybInputReal,
-                                  FIXP_DBL **hybInputImag,
-                                  FIXP_DBL **hybOutputReal,
-                                  FIXP_DBL **hybOutputImag,
-                                  const int numInputChannels) {
-  int complexHybBands;
-
-  complexHybBands = self->hybridBands;
-
-  {
-    int ch;
-    int rf = -1, lf = -1, cf = -1; /* Right Front, Left Front, Center Front */
-
-    /* Determine output channel indices according to tree config */
-    switch (self->treeConfig) {
-      case TREE_212: /* 212  */
-        lf = 0;
-        rf = 1;
-        break;
-      default:;
-    }
-
-    /* Note: numInputChannels might not match the tree config ! */
-    switch (numInputChannels) {
-      case 1:
-        if (cf > 0) {
-          FDKmemcpy(hybOutputReal[cf], hybInputReal[0],
-                    self->hybridBands * sizeof(FIXP_DBL));
-          FDKmemcpy(hybOutputImag[cf], hybInputImag[0],
-                    complexHybBands * sizeof(FIXP_DBL));
-        } else {
-          FDKmemcpy(hybOutputReal[lf], hybInputReal[0],
-                    self->hybridBands * sizeof(FIXP_DBL));
-          FDKmemcpy(hybOutputReal[rf], hybInputReal[0],
-                    self->hybridBands * sizeof(FIXP_DBL));
-          FDKmemcpy(hybOutputImag[lf], hybInputImag[0],
-                    complexHybBands * sizeof(FIXP_DBL));
-          FDKmemcpy(hybOutputImag[rf], hybInputImag[0],
-                    complexHybBands * sizeof(FIXP_DBL));
-        }
-        break;
-      case 2:
-        FDK_ASSERT(lf != -1);
-        FDK_ASSERT(rf != -1);
-        FDKmemcpy(hybOutputReal[lf], hybInputReal[0],
-                  self->hybridBands * sizeof(FIXP_DBL));
-        FDKmemcpy(hybOutputReal[rf], hybInputReal[1],
-                  self->hybridBands * sizeof(FIXP_DBL));
-        FDKmemcpy(hybOutputImag[lf], hybInputImag[0],
-                  complexHybBands * sizeof(FIXP_DBL));
-        FDKmemcpy(hybOutputImag[rf], hybInputImag[1],
-                  complexHybBands * sizeof(FIXP_DBL));
-        break;
-    }
-    for (ch = 0; ch < self->numOutputChannelsAT; ch++) {
-      if (ch == lf || ch == rf || ch == cf) {
-        continue; /* Skip bypassed channels */
-      }
-      FDKmemclear(hybOutputReal[ch], self->hybridBands * sizeof(FIXP_DBL));
-      FDKmemclear(hybOutputImag[ch], complexHybBands * sizeof(FIXP_DBL));
-    }
-  }
-}
-
-/*******************************************************************************
- Functionname: SpatialDecApplyParameterSets
- *******************************************************************************
-
- Description:
-
- Arguments:
-
- Return:
-
-*******************************************************************************/
-static SACDEC_ERROR SpatialDecApplyParameterSets(
-    spatialDec *self, const SPATIAL_BS_FRAME *frame, SPATIALDEC_INPUT_MODE mode,
-    PCM_MPS *inData,          /* Time domain input  */
-    FIXP_DBL **qmfInDataReal, /* QMF domain data l/r */
-    FIXP_DBL **qmfInDataImag, /* QMF domain data l/r */
-    UINT nSamples, UINT controlFlags, int numInputChannels,
-    const FDK_channelMapDescr *const mapDescr) {
-  SACDEC_ERROR err = MPS_OK;
-
-  FIXP_SGL alpha;
-
-  int ts;
-  int ch;
-  int hyb;
-
-  int prevSlot = self->prevTimeSlot;
-  int ps = self->curPs;
-  int ts_io = 0; /* i/o dependent slot */
-  int bypassMode = (controlFlags & MPEGS_BYPASSMODE) ? 1 : 0;
-
-  /* Bypass can be triggered by the upmixType, too. */
-  bypassMode |= ((self->upmixType == UPMIXTYPE_BYPASS) ? 1 : 0);
-
-  /*
-   * Decode available slots
-   */
-  for (ts = self->curTimeSlot;
-       ts <= fixMin(self->curTimeSlot + (int)nSamples / self->qmfBands - 1,
-                    self->timeSlots - 1);
-       ts++, ts_io++) {
-    int currSlot = frame->paramSlot[ps];
-
-    /*
-     * Get new parameter set
-     */
-    if (ts == prevSlot + 1) {
-      err = SpatialDecCalculateM1andM2(self, ps,
-                                       frame); /* input: ottCLD, ottICC, ... */
-      /* output: M1param(Real/Imag), M2(Real/Imag) */
-      if (err != MPS_OK) {
-        bypassMode = 1;
-        if (self->errInt == MPS_OK) {
-          /* store internal error befor it gets overwritten */
-          self->errInt = err;
-        }
-        err = MPS_OK;
-      }
-
-      if ((ps == 0) && (self->bOverwriteM1M2prev != 0)) {
-        /* copy matrix entries of M1/M2 of the first parameter set to the
-           previous matrices (of the last frame). This avoids the interpolation
-           of incompatible values. E.g. for residual bands the coefficients are
-           calculated differently compared to non-residual bands.
-         */
-        SpatialDecBufferMatrices(self); /* input: M(1/2)param(Real/Imag) */
-                                        /* output: M(1/2)param(Real/Imag)Prev */
-        self->bOverwriteM1M2prev = 0;
-      }
-
-      SpatialDecSmoothM1andM2(
-          self, frame,
-          ps); /* input: M1param(Real/Imag)(Prev), M2(Real/Imag)(Prev) */
-               /* output: M1param(Real/Imag), M2(Real/Imag) */
-    }
-
-    alpha = FX_DBL2FX_SGL(fDivNorm(ts - prevSlot, currSlot - prevSlot));
-
-    switch (mode) {
-      case INPUTMODE_QMF_SBR:
-        if (self->pConfigCurrent->syntaxFlags & SACDEC_SYNTAX_LD)
-          self->bShareDelayWithSBR = 0; /* We got no hybrid delay */
-        else
-          self->bShareDelayWithSBR = 1;
-        SpatialDecFeedQMF(self, qmfInDataReal, qmfInDataImag, ts_io, bypassMode,
-                          self->qmfInputReal__FDK, self->qmfInputImag__FDK,
-                          self->numInputChannels);
-        break;
-      case INPUTMODE_TIME:
-        self->bShareDelayWithSBR = 0;
-        SpatialDecQMFAnalysis(self, inData, ts_io, bypassMode,
-                              self->qmfInputReal__FDK, self->qmfInputImag__FDK,
-                              self->numInputChannels);
-        break;
-      default:
-        break;
-    }
-
-    if ((self->pConfigCurrent->syntaxFlags & SACDEC_SYNTAX_USAC) &&
-        self->residualCoding) {
-      int offset;
-      ch = 1;
-
-      offset = self->pQmfDomain->globalConf.nBandsSynthesis *
-               self->pQmfDomain->globalConf.nQmfTimeSlots;
-
-      {
-        const PCM_MPS *inSamples =
-            &inData[ts * self->pQmfDomain->globalConf.nBandsAnalysis];
-
-        CalculateSpaceAnalysisQmf(
-            &self->pQmfDomain->QmfDomainIn[ch].fb, inSamples + (ch * offset),
-            self->qmfResidualReal__FDK[0][0], self->qmfResidualImag__FDK[0][0]);
-
-        if (!isTwoChMode(self->upmixType) && !bypassMode) {
-          int i;
-          FIXP_DBL *RESTRICT self_qmfResidualReal__FDK_0_0 =
-              &self->qmfResidualReal__FDK[0][0][0];
-          FIXP_DBL *RESTRICT self_qmfResidualImag__FDK_0_0 =
-              &self->qmfResidualImag__FDK[0][0][0];
-
-          if ((self->pQmfDomain->globalConf.nBandsAnalysis == 24) &&
-              !(self->stereoConfigIndex == 3)) {
-            for (i = 0; i < self->qmfBands; i++) {
-              self_qmfResidualReal__FDK_0_0[i] =
-                  fMult(self_qmfResidualReal__FDK_0_0[i] << 1,
-                        self->clipProtectGain__FDK);
-              self_qmfResidualImag__FDK_0_0[i] =
-                  fMult(self_qmfResidualImag__FDK_0_0[i] << 1,
-                        self->clipProtectGain__FDK);
-            }
-          } else {
-            for (i = 0; i < self->qmfBands; i++) {
-              self_qmfResidualReal__FDK_0_0[i] = fMult(
-                  self_qmfResidualReal__FDK_0_0[i], self->clipProtectGain__FDK);
-              self_qmfResidualImag__FDK_0_0[i] = fMult(
-                  self_qmfResidualImag__FDK_0_0[i], self->clipProtectGain__FDK);
-            }
-          }
-        }
-      }
-    }
-
-    SpatialDecHybridAnalysis(
-        self, /* input: qmfInput(Real/Imag), qmfResidual(Real/Imag) */
-        self->qmfInputReal__FDK, self->qmfInputImag__FDK,
-        self->hybInputReal__FDK, self->hybInputImag__FDK, ts, numInputChannels);
-
-    if (bypassMode) {
-      SpatialDecApplyBypass(
-          self, self->hybInputReal__FDK, /* input: hybInput(Real/Imag) */
-          self->hybInputImag__FDK,
-          self->hybOutputRealDry__FDK, /* output: hybOutput(Real/Imag)Dry */
-          self->hybOutputImagDry__FDK, numInputChannels);
-    } else /* !bypassMode */
-    {
-      FIXP_DBL *pxReal[MAX_NUM_XCHANNELS] = {NULL};
-      FIXP_DBL *pxImag[MAX_NUM_XCHANNELS] = {NULL};
-
-      SpatialDecCreateX(self,
-                        self->hybInputReal__FDK, /* input: hybInput(Real/Imag),
-                                                    hybResidual(Real/Imag) */
-                        self->hybInputImag__FDK, pxReal, pxImag);
-
-      {
-        SpatialDecApplyM1_CreateW_Mode212(
-            self, frame, pxReal, pxImag,
-            self->wReal__FDK, /* output: w(Real/Imag) */
-            self->wImag__FDK);
-      }
-      if (err != MPS_OK) goto bail;
-
-      int applyM2Config = APPLY_M2_NONE;
-
-      applyM2Config = APPLY_M2;
-      if ((self->pConfigCurrent->syntaxFlags &
-           (SACDEC_SYNTAX_USAC | SACDEC_SYNTAX_RSVD50)) &&
-          (self->tempShapeConfig != 1) && (self->tempShapeConfig != 2)) {
-        if (self->phaseCoding == 3)
-          applyM2Config = APPLY_M2_MODE212_Res_PhaseCoding;
-        else
-          applyM2Config = APPLY_M2_MODE212;
-      }
-
-      switch (applyM2Config) {
-        case APPLY_M2_MODE212: {
-          err = SpatialDecApplyM2_Mode212(
-              self, ps, alpha, self->wReal__FDK, self->wImag__FDK,
-              self->hybOutputRealDry__FDK, self->hybOutputImagDry__FDK);
-        } break;
-        case APPLY_M2_MODE212_Res_PhaseCoding:
-          err = SpatialDecApplyM2_Mode212_ResidualsPlusPhaseCoding(
-              self, ps, alpha, self->wReal__FDK, self->wImag__FDK,
-              self->hybOutputRealDry__FDK, self->hybOutputImagDry__FDK);
-          break;
-        case APPLY_M2:
-          err = SpatialDecApplyM2(
-              self, ps, alpha, self->wReal__FDK, self->wImag__FDK,
-              self->hybOutputRealDry__FDK, self->hybOutputImagDry__FDK,
-              self->hybOutputRealWet__FDK, self->hybOutputImagWet__FDK);
-          break;
-        default:
-          err = MPS_APPLY_M2_ERROR;
-          goto bail;
-      }
-
-      if (err != MPS_OK) goto bail;
-
-      if ((self->tempShapeConfig == 2) && (!isTwoChMode(self->upmixType))) {
-        SpatialDecReshapeBBEnv(self, frame,
-                               ts); /* input: reshapeBBEnvState,
-                                       hybOutput(Real/Imag)(Dry/Wet),
-                                       hybInput(Real/Imag) */
-      }                             /* output: hybOutput(Real/Imag)Dry */
-
-      /* Merge parts of the dry and wet QMF buffers. */
-      if ((self->tempShapeConfig == 1) && (!isTwoChMode(self->upmixType))) {
-        for (ch = 0; ch < self->numOutputChannels; ch++) {
-          for (hyb = 0; hyb < self->tp_hybBandBorder; hyb++) {
-            self->hybOutputRealDry__FDK[ch][hyb] +=
-                self->hybOutputRealWet__FDK[ch][hyb];
-            self->hybOutputImagDry__FDK[ch][hyb] +=
-                self->hybOutputImagWet__FDK[ch][hyb];
-          } /* loop hyb */
-        }   /* loop ch */
-        err = subbandTPApply(
-            self, frame); /* input: hStpDec, hybOutput(Real/Imag)Dry/Wet */
-                          /* output: hStpDec, hybOutput(Real/Imag)Dry */
-        if (err != MPS_OK) goto bail;
-      } /* (self->tempShapeConfig == 1) */
-      else {
-        /* The wet signal is added to the dry signal in applyM2 if GES and STP
-         * are disabled */
-        if ((self->tempShapeConfig == 1) || (self->tempShapeConfig == 2)) {
-          int nHybBands;
-          nHybBands = self->hybridBands;
-
-          for (ch = 0; ch < self->numOutputChannels; ch++) {
-            FIXP_DBL *RESTRICT pRealDry = self->hybOutputRealDry__FDK[ch];
-            FIXP_DBL *RESTRICT pImagDry = self->hybOutputImagDry__FDK[ch];
-            FIXP_DBL *RESTRICT pRealWet = self->hybOutputRealWet__FDK[ch];
-            FIXP_DBL *RESTRICT pImagWet = self->hybOutputImagWet__FDK[ch];
-            for (hyb = 0; hyb < nHybBands; hyb++) {
-              pRealDry[hyb] += pRealWet[hyb];
-              pImagDry[hyb] += pImagWet[hyb];
-            } /* loop hyb */
-            for (; hyb < self->hybridBands; hyb++) {
-              pRealDry[hyb] += pRealWet[hyb];
-            } /* loop hyb */
-          }   /* loop ch */
-        } /* ( self->tempShapeConfig == 1 ) || ( self->tempShapeConfig == 2 ) */
-      }   /* !self->tempShapeConfig == 1 */
-    }     /*  !bypassMode */
-
-    if (self->phaseCoding == 1) {
-      /* only if bsPhaseCoding == 1 and bsResidualCoding == 0 */
-
-      SpatialDecApplyPhase(
-          self, alpha, (ts == currSlot) /* signal the last slot of the set */
-      );
-    }
-
-    /*
-     * Synthesis Filtering
-     */
-
-    err = SpatialDecSynthesis(
-        self, ts_io,
-        self->hybOutputRealDry__FDK, /* input: hybOutput(Real/Imag)Dry */
-        self->hybOutputImagDry__FDK, self->timeOut__FDK, /* output: timeOut */
-        numInputChannels, mapDescr);
-
-    if (err != MPS_OK) goto bail;
-
-    /*
-     * Update parameter buffer
-     */
-    if (ts == currSlot) {
-      SpatialDecBufferMatrices(self); /* input: M(1/2)param(Real/Imag) */
-                                      /* output: M(1/2)param(Real/Imag)Prev */
-
-      prevSlot = currSlot;
-      ps++;
-    } /* if (ts==currSlot) */
-
-  } /* ts loop */
-
-  /*
-   * Save parameter states
-   */
-  self->prevTimeSlot = prevSlot;
-  self->curTimeSlot = ts;
-  self->curPs = ps;
-
-bail:
-
-  return err;
-}
-
-SACDEC_ERROR SpatialDecApplyFrame(
-    spatialDec *self,
-    SPATIAL_BS_FRAME *frame, /* parsed frame data to be applied */
-    SPATIALDEC_INPUT_MODE inputMode, PCM_MPS *inData, /* Time domain input  */
-    FIXP_DBL **qmfInDataReal,                         /* QMF domain data l/r */
-    FIXP_DBL **qmfInDataImag,                         /* QMF domain data l/r */
-    PCM_MPS *pcmOutBuf, /* MAX_OUTPUT_CHANNELS*MAX_TIME_SLOTS*NUM_QMF_BANDS] */
-    UINT nSamples, UINT *pControlFlags, int numInputChannels,
-    const FDK_channelMapDescr *const mapDescr) {
-  SACDEC_ERROR err = MPS_OK;
-
-  int fDecAndMapFrameData;
-  int controlFlags;
-
-  FDK_ASSERT(self != NULL);
-  FDK_ASSERT(pControlFlags != NULL);
-  FDK_ASSERT(pcmOutBuf != NULL);
-
-  self->errInt = err; /* Init internal error */
-
-  controlFlags = *pControlFlags;
-
-  if ((self->pConfigCurrent->syntaxFlags & SACDEC_SYNTAX_USAC) &&
-      (self->stereoConfigIndex > 1)) {
-    numInputChannels =
-        1; /* Do not count residual channel as input channel. It is handled
-              seperately. */
-  }
-
-  /* Check if input amount of channels is consistent */
-  if (numInputChannels != self->numInputChannels) {
-    controlFlags |= MPEGS_CONCEAL;
-    if (numInputChannels > self->createParams.maxNumInputChannels) {
-      return MPS_INVALID_PARAMETER;
-    }
-  }
-
-  self->timeOut__FDK = pcmOutBuf;
-
-  /* Determine local function control flags */
-  fDecAndMapFrameData = frame->newBsData;
-
-  if (((fDecAndMapFrameData ==
-        0) /* assures that conceal flag will not be set for blind mode */
-       && (self->curTimeSlot + (int)nSamples / self->qmfBands >
-           self->timeSlots)) ||
-      (frame->numParameterSets ==
-       0)) { /* New input samples but missing side info */
-    fDecAndMapFrameData = 1;
-    controlFlags |= MPEGS_CONCEAL;
-  }
-
-  if ((fDecAndMapFrameData == 0) &&
-      (frame->paramSlot[fMax(0, frame->numParameterSets - 1)] !=
-           (self->timeSlots - 1) ||
-       self->curTimeSlot >
-           frame->paramSlot[self->curPs])) { /* Detected faulty parameter slot
-                                                data. */
-    fDecAndMapFrameData = 1;
-    controlFlags |= MPEGS_CONCEAL;
-  }
-
-  /* Update concealment state machine */
-  SpatialDecConcealment_UpdateState(
-      &self->concealInfo,
-      (controlFlags & MPEGS_CONCEAL)
-          ? 0
-          : 1); /* convert from conceal flag to frame ok flag */
-
-  if (fDecAndMapFrameData) {
-    /* Reset spatial framing control vars */
-    frame->newBsData = 0;
-    self->prevTimeSlot = -1;
-    self->curTimeSlot = 0;
-    self->curPs = 0;
-
-    if (controlFlags & MPEGS_CONCEAL) {
-      /* Reset frame data to avoid misconfiguration. */
-      SpatialDecClearFrameData(self, frame, &self->createParams);
-    }
-
-    {
-      err = SpatialDecDecodeFrame(self, frame); /* input: ... */
-      /* output: decodeAndMapFrameDATA */
-    }
-
-    if (err != MPS_OK) {
-      /* Rescue strategy is to apply bypass mode in order
-         to keep at least the downmix channels continuous. */
-      controlFlags |= MPEGS_CONCEAL;
-      if (self->errInt == MPS_OK) {
-        /* store internal error befor it gets overwritten */
-        self->errInt = err;
-      }
-    }
-  }
-
-  err = SpatialDecApplyParameterSets(
-      self, frame, inputMode, inData, qmfInDataReal, qmfInDataImag, nSamples,
-      controlFlags | ((err == MPS_OK) ? 0 : MPEGS_BYPASSMODE), numInputChannels,
-      mapDescr);
-  if (err != MPS_OK) {
-    goto bail;
-  }
-
-bail:
-
-  *pControlFlags = controlFlags;
-
-  return err;
-}
--- a/libSACdec/src/sac_dec.h
+++ /dev/null
@@ -1,539 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround decoder library *************************
-
-   Author(s):
-
-   Description: SAC Decoder Library structures
-
-*******************************************************************************/
-
-#ifndef SAC_DEC_H
-#define SAC_DEC_H
-
-#include "common_fix.h"
-
-#include "sac_dec_interface.h" /* library interface in ../include */
-
-#include "FDK_qmf_domain.h"
-#include "sac_qmf.h"
-#include "FDK_bitstream.h" /* mp4 bitbuffer */
-#include "sac_calcM1andM2.h"
-#include "FDK_hybrid.h"
-#include "FDK_decorrelate.h"
-#include "sac_reshapeBBEnv.h"
-
-#include "sac_dec_conceal.h"
-
-#include "sac_tsd.h"
-
-#ifndef MAX
-#define MAX(a, b) ((a) > (b) ? (a) : (b))
-#endif
-
-#define ICCdefault 0
-#define IPDdefault 0
-#define arbdmxGainDefault 0
-#define CPCdefault 10
-#define tttCLD1default 15
-#define tttCLD2default 0
-
-#define IS_HQ_ONLY(aot)                                                      \
-  ((aot) == AOT_ER_AAC_LD || (aot) == AOT_ER_AAC_ELD || (aot) == AOT_USAC || \
-   (aot) == AOT_RSVD50)
-
-#define SCONST(x) FL2FXCONST_DBL(x)
-
-#define PC_NUM_BANDS (8)
-#define PC_NUM_HYB_BANDS (PC_NUM_BANDS - 3 + 10)
-#define ABS_THR (1e-9f * 32768 * 32768)
-
-#define MAX_HYBRID_BANDS (MAX_NUM_QMF_BANDS - 3 + 10)
-#define HYBRID_FILTER_DELAY (6)
-
-#define MAX_RESIDUAL_FRAMES (4)
-#define MAX_RESIDUAL_BISTREAM \
-  (836) /*  48000 bps * 3 res / (8 * 44100 / 2048 ) */
-#define MAX_MDCT_COEFFS (1024)
-#define SACDEC_RESIDUAL_BS_BUF_SIZE \
-  (1024) /* used to setup and check residual bitstream buffer */
-
-#define MAX_NUM_PARAMS (MAX_NUM_OTT + 4 * MAX_NUM_TTT + MAX_INPUT_CHANNELS)
-#define MAX_NUM_PARAMETERS (MAX(MAX_NUM_PARAMS, MAX_NUM_OTT))
-
-#define MAX_PARAMETER_SETS (9)
-
-#define MAX_M2_INPUT (MAX_OUTPUT_CHANNELS) /* 3 direct + 5 diffuse */
-
-#define MAX_QMF_BANDS_TO_HYBRID \
-  (3) /* 3 bands are filtered again in "40 bands" case */
-#define PROTO_LEN (13)
-#define BUFFER_LEN_LF (PROTO_LEN)
-#define BUFFER_LEN_HF ((PROTO_LEN - 1) / 2)
-
-#define MAX_NO_DECORR_CHANNELS (MAX_OUTPUT_CHANNELS)
-#define HRTF_AZIMUTHS (5)
-
-#define MAX_NUM_OTT_AT 0
-
-/* left out */
-
-typedef enum {
-  UPMIXTYPE_BYPASS = -1, /*just bypass the input channels without processing*/
-  UPMIXTYPE_NORMAL = 0   /*multichannel loudspeaker upmix with spatial data*/
-} UPMIXTYPE;
-
-static inline int isTwoChMode(UPMIXTYPE upmixType) {
-  int retval = 0;
-  return retval;
-}
-
-  /* left out end */
-
-#define MPEGS_BYPASSMODE (0x00000001)
-#define MPEGS_CONCEAL (0x00000002)
-
-typedef struct STP_DEC *HANDLE_STP_DEC;
-
-typedef struct {
-  SCHAR bsQuantCoarseXXXprev;
-  SCHAR bsQuantCoarseXXXprevParse;
-} LOSSLESSSTATE;
-
-typedef struct {
-  SCHAR bsXXXDataMode[MAX_PARAMETER_SETS];
-  SCHAR bsQuantCoarseXXX[MAX_PARAMETER_SETS];
-  SCHAR bsFreqResStrideXXX[MAX_PARAMETER_SETS];
-  SCHAR nocmpQuantCoarseXXX[MAX_PARAMETER_SETS];
-  LOSSLESSSTATE *state; /* Link to persistent state information */
-} LOSSLESSDATA;
-
-struct SPATIAL_BS_FRAME_struct {
-  UCHAR bsIndependencyFlag;
-  UCHAR newBsData;
-  UCHAR numParameterSets;
-
-  /*
-  If bsFramingType == 0, then the paramSlot[ps] for 0 <= ps < numParamSets is
-  calculated as follows: paramSlot[ps] = ceil(numSlots*(ps+1)/numParamSets) - 1
-  Otherwise, it is
-    paramSlot[ps] = bsParamSlot[ps]
-  */
-  INT paramSlot[MAX_PARAMETER_SETS];
-
-  /* These arrays contain the compact indices, only one value per pbstride, only
-   * paramsets actually containing data. */
-  /* These values are written from the parser in ecDataDec() and read during
-   * decode in mapIndexData() */
-  SCHAR cmpOttCLDidx[MAX_NUM_OTT + MAX_NUM_OTT_AT][MAX_PARAMETER_SETS]
-                    [MAX_PARAMETER_BANDS];
-  SCHAR cmpOttICCidx[MAX_NUM_OTT][MAX_PARAMETER_SETS][MAX_PARAMETER_BANDS];
-
-  /* Smoothing */
-  UCHAR bsSmoothMode[MAX_PARAMETER_SETS];
-  UCHAR bsSmoothTime[MAX_PARAMETER_SETS];
-  UCHAR bsFreqResStrideSmg[MAX_PARAMETER_SETS];
-  UCHAR bsSmgData[MAX_PARAMETER_SETS]
-                 [MAX_PARAMETER_BANDS]; /* smoothing flags, one if band is
-                                           smoothed, otherwise zero */
-
-  /* Arbitrary Downmix */
-  SCHAR (*cmpArbdmxGainIdx)[MAX_PARAMETER_SETS][MAX_PARAMETER_BANDS];
-
-  /* Lossless control */
-  LOSSLESSDATA *CLDLosslessData;
-  LOSSLESSDATA *ICCLosslessData;
-  /* LOSSLESSDATA *ADGLosslessData; -> is stored in CLDLosslessData[offset] */
-
-  LOSSLESSDATA *IPDLosslessData;
-  SCHAR (*cmpOttIPDidx)[MAX_PARAMETER_SETS][MAX_PARAMETER_BANDS];
-  int phaseMode;
-  int OpdSmoothingMode;
-
-  UCHAR tempShapeEnableChannelGES[MAX_OUTPUT_CHANNELS]; /*!< GES side info. */
-  UCHAR bsEnvShapeData[MAX_OUTPUT_CHANNELS]
-                      [MAX_TIME_SLOTS]; /*!< GES side info (quantized). */
-
-  UCHAR tempShapeEnableChannelSTP[MAX_OUTPUT_CHANNELS]; /*!< STP side info. */
-
-  TSD_DATA TsdData[1]; /*!< TSD data structure. */
-};
-
-typedef struct {
-  /* Lossless state */
-  LOSSLESSSTATE CLDLosslessState[MAX_NUM_PARAMETERS];
-  LOSSLESSSTATE ICCLosslessState[MAX_NUM_PARAMETERS];
-  LOSSLESSSTATE IPDLosslessState[MAX_NUM_PARAMETERS];
-} BS_LL_STATE;
-
-typedef struct {
-  int prevParamSlot;
-  int prevSmgTime;
-  UCHAR prevSmgData[MAX_PARAMETER_BANDS];
-
-  FIXP_DBL opdLeftState__FDK[MAX_PARAMETER_BANDS];
-  FIXP_DBL opdRightState__FDK[MAX_PARAMETER_BANDS];
-
-} SMOOTHING_STATE;
-
-typedef struct {
-  FIXP_DBL alpha__FDK;
-  FIXP_DBL beta__FDK;
-  FIXP_DBL partNrgPrev__FDK[2 * MAX_OUTPUT_CHANNELS + MAX_INPUT_CHANNELS]
-                           [BB_ENV_SIZE];
-  FIXP_DBL normNrgPrev__FDK[2 * MAX_OUTPUT_CHANNELS + MAX_INPUT_CHANNELS];
-  FIXP_DBL frameNrgPrev__FDK[2 * MAX_OUTPUT_CHANNELS + MAX_INPUT_CHANNELS];
-  INT partNrgPrevSF[2 * MAX_OUTPUT_CHANNELS + MAX_INPUT_CHANNELS];
-  INT partNrgPrev2SF[2 * MAX_OUTPUT_CHANNELS + MAX_INPUT_CHANNELS];
-  INT normNrgPrevSF[2 * MAX_OUTPUT_CHANNELS + MAX_INPUT_CHANNELS];
-  INT frameNrgPrevSF[2 * MAX_OUTPUT_CHANNELS + MAX_INPUT_CHANNELS];
-} RESHAPE_BBENV_STATE;
-
-typedef struct {
-  int maxNumInputChannels;
-  int maxNumOutputChannels;
-  int maxNumQmfBands;
-  int maxNumHybridBands;
-  int maxNumXChannels;
-  int maxNumVChannels;
-  int maxNumDecorChannels;
-  int maxNumCmplxQmfBands;
-  int maxNumCmplxHybBands;
-  int maxNumResChannels;
-  int bProcResidual; /* process residual */
-  int maxNumResidualChannels;
-  int maxNumOttBoxes;
-  int maxNumParams;
-
-} SACDEC_CREATION_PARAMS;
-
-struct spatialDec_struct {
-  SACDEC_ERROR
-  errInt;             /* Field to store internal errors.
-                         Will be clear at the very beginning of each process call. */
-  int staticDecScale; /* static scale of decoder */
-
-  /* GENERAL */
-  int samplingFreq;       /* [Hz] */
-  CFG_LEVEL decoderLevel; /* 0..5 */
-  CFG_EXTENT decoderMode;
-  CFG_BINAURAL binauralMode;
-
-  SACDEC_CREATION_PARAMS createParams;
-
-  int numComplexProcessingBands;
-
-  int treeConfig; /* TREE_5151 = 5151, TREE_5152 = 5152, TREE_525 = 525, defined
-                     in sac_bitdec.h */
-
-  int numInputChannels;  /* 1 (M) or 2 (L,R) */
-  int numOutputChannels; /* 6 for 3/2.1 (FL,FR,FC,LF,BL,BR) */
-  int numOttBoxes;       /* number of ott boxes */
-  int numM2rows;
-
-  int numOutputChannelsAT; /* Number of output channels after arbitrary tree
-                              processing */
-
-  int quantMode; /* QUANT_FINE, QUANT_EBQ1, QUANT_EBQ2, defined in sac_bitdec.h
-                  */
-  int arbitraryDownmix; /* (arbitraryDownmix != 0) 1 arbitrary downmix data
-                           present, 2 arbitrary downmix residual data present*/
-  int residualCoding;   /* (residualCoding != 0) => residual coding data present
-                         */
-  UCHAR nrResidualFrame;
-  UCHAR nrArbDownmixResidualFrame;
-  FDK_BITSTREAM **hResidualBitstreams;
-  int tempShapeConfig; /* */
-  int decorrType;      /* Indicates to use PS or none PS decorrelator. */
-  int decorrConfig;    /* chosen decorrelator */
-  int envQuantMode;    /* quantization mode of envelope reshaping data */
-
-  FIXP_DBL clipProtectGain__FDK; /* global gain for upmix */
-  char clipProtectGainSF__FDK;   /* global gain for upmix */
-
-  /* Currently ignoring center decorr
-     numVChannels = numDirektSignals + numDecorSignals */
-  int numDirektSignals;  /* needed for W, Number of direkt signals 515 -> 1 525
-                            -> 3 */
-  int wStartResidualIdx; /* Where to start read residuals for W, = 0 for 515, =
-                            1 for 525 since one residual is used in V */
-  int numDecorSignals;   /* needed for W, Number of residual and decorrelated
-                            signals, = 2, 3 for center deccorelation*/
-  int numVChannels;      /* direct signals + decorelator signals */
-  int numXChannels;      /* direct input signals + TTT-residuals */
-
-  int timeSlots;    /* length of spatial frame in QMF samples */
-  int curTimeSlot;  /* pointer to the current time slot used for hyperframing */
-  int prevTimeSlot; /*  */
-  int curPs;
-  int frameLength; /* number of output waveform samples/channel/frame */
-  UPMIXTYPE upmixType;
-  int partiallyComplex;
-  int useFDreverb;
-
-  int bShareDelayWithSBR;
-
-  int tp_hybBandBorder; /* Hybrid band indicating the HP filter cut-off. */
-
-  /* FREQUENCY MAPPING */
-  int qmfBands;
-  int hybridBands;
-  const SCHAR *kernels; /* Mapping hybrid band to parameter band. */
-
-  int TsdTs; /**< TSD QMF slot counter 0<= ts < numSlots */
-
-  int *param2hyb; /* Mapping parameter bands to hybrid bands */
-  int kernels_width[MAX_PARAMETER_BANDS]; /* Mapping parmeter band to hybrid
-                                             band offsets. */
-
-  /* Residual coding */
-  int residualSamplingFreq;
-  UCHAR residualPresent[MAX_NUM_OTT + MAX_NUM_TTT];
-  UCHAR residualBands[MAX_NUM_OTT + MAX_NUM_TTT];    /* 0, if no residual data
-                                                        present for this box */
-  UCHAR residualQMFBands[MAX_NUM_OTT + MAX_NUM_TTT]; /* needed for optimized
-                                                        mdct2qmf calculation */
-  SPATIAL_SPECIFIC_CONFIG *pConfigCurrent;
-
-  int arbdmxFramesPerSpatialFrame;
-  int arbdmxUpdQMF;
-
-  int numParameterBands; /* Number of parameter bands 40, 28, 20, 14, 10, ...
-                            .*/
-  int bitstreamParameterBands;
-  int *numOttBands; /* number of bands for each ott, is != numParameterBands for
-                       LFEs */
-
-  /* 1 MAPPING */
-  UCHAR extendFrame;
-  UCHAR numParameterSetsPrev;
-
-  int *smgTime;
-  UCHAR **smgData;
-
-  /* PARAMETER DATA decoded and dequantized */
-
-  /* Last parameters from prev frame required during decode in mapIndexData()
-   * and not touched during parse */
-  SCHAR **ottCLDidxPrev;
-  SCHAR **ottICCidxPrev;
-  SCHAR **arbdmxGainIdxPrev;
-  SCHAR **ottIPDidxPrev;
-  SCHAR ***outIdxData; /* is this really persistent memory ? */
-
-  /* State mem required during parse in SpatialDecParseFrameData() */
-  SCHAR **cmpOttCLDidxPrev;
-  SCHAR **cmpOttICCidxPrev;
-  SCHAR ***ottICCdiffidx;
-  SCHAR **cmpOttIPDidxPrev;
-
-  /* State mem required in parseArbitraryDownmixData */
-  SCHAR **cmpArbdmxGainIdxPrev;
-
-  SCHAR ***ottCLD__FDK;
-  SCHAR ***ottICC__FDK;
-
-  SCHAR ***arbdmxGain__FDK; /* Holds the artistic downmix correction index.*/
-
-  FIXP_DBL *arbdmxAlpha__FDK;
-  FIXP_DBL *arbdmxAlphaPrev__FDK;
-
-  UCHAR stereoConfigIndex;
-  int highRateMode;
-
-  int phaseCoding;
-
-  SCHAR ***ottIPD__FDK;
-
-  FIXP_DBL PhaseLeft__FDK[MAX_PARAMETER_BANDS];
-  FIXP_DBL PhaseRight__FDK[MAX_PARAMETER_BANDS];
-  FIXP_DBL PhasePrevLeft__FDK[MAX_PARAMETER_BANDS];
-  FIXP_DBL PhasePrevRight__FDK[MAX_PARAMETER_BANDS];
-  int numOttBandsIPD;
-
-  /* GAIN MATRICIES FOR CURRENT and PREVIOUS PARMATER SET(s)*/
-  FIXP_DBL ***M2Real__FDK;
-  FIXP_DBL ***M2Imag__FDK;
-  FIXP_DBL ***M2RealPrev__FDK;
-  FIXP_DBL ***M2ImagPrev__FDK;
-
-  /* INPUT SIGNALS */
-  FIXP_DBL ***qmfInputRealDelayBuffer__FDK;
-  FIXP_DBL ***qmfInputImagDelayBuffer__FDK;
-
-  int pc_filterdelay; /* additional delay to align HQ with LP before hybird
-                         analysis */
-  int qmfInputDelayBufPos;
-  FIXP_DBL **qmfInputReal__FDK;
-  FIXP_DBL **qmfInputImag__FDK;
-
-  FIXP_DBL **hybInputReal__FDK;
-  FIXP_DBL **hybInputImag__FDK;
-
-  FIXP_DBL **binInputReverb;
-
-  FIXP_DBL binGain, reverbGain;
-  FIXP_DBL binCenterGain, reverbCenterGain;
-
-  /* RESIDUAL SIGNALS */
-
-  FIXP_DBL ***qmfResidualReal__FDK;
-  FIXP_DBL ***qmfResidualImag__FDK;
-
-  FIXP_DBL **hybResidualReal__FDK;
-  FIXP_DBL **hybResidualImag__FDK;
-
-  int qmfOutputRealDryDelayBufPos;
-  FIXP_DBL ***qmfOutputRealDryDelayBuffer__FDK;
-  FIXP_DBL ***qmfOutputImagDryFilterBuffer__FDK;
-  FIXP_DBL *qmfOutputImagDryFilterBufferBase__FDK;
-
-  /* TEMPORARY SIGNALS */
-
-  FIXP_DBL **wReal__FDK;
-  FIXP_DBL **wImag__FDK;
-
-  /* OUTPUT SIGNALS */
-  FIXP_DBL **hybOutputRealDry__FDK;
-  FIXP_DBL **hybOutputImagDry__FDK;
-  FIXP_DBL **hybOutputRealWet__FDK;
-  FIXP_DBL **hybOutputImagWet__FDK;
-  PCM_MPS *timeOut__FDK;
-
-  HANDLE_FDK_QMF_DOMAIN pQmfDomain;
-
-  FDK_ANA_HYB_FILTER
-  *hybridAnalysis; /*!< pointer Analysis hybrid filterbank array. */
-  FDK_SYN_HYB_FILTER
-  *hybridSynthesis; /*!< pointer Synthesis hybrid filterbank array. */
-  FIXP_DBL **
-      pHybridAnaStatesLFdmx; /*!< pointer to analysis hybrid filter states LF */
-  FIXP_DBL **
-      pHybridAnaStatesHFdmx; /*!< pointer to analysis hybrid filter states HF */
-  FIXP_DBL **
-      pHybridAnaStatesLFres; /*!< pointer to analysis hybrid filter states LF */
-  FIXP_DBL **
-      pHybridAnaStatesHFres; /*!< pointer to analysis hybrid filter states HF */
-
-  DECORR_DEC *apDecor; /*!< pointer decorrelator array. */
-  FIXP_DBL **pDecorBufferCplx;
-
-  SMOOTHING_STATE *smoothState; /*!< Pointer to smoothing states. */
-
-  RESHAPE_BBENV_STATE *reshapeBBEnvState; /*!< GES handle. */
-  SCHAR row2channelDmxGES[MAX_OUTPUT_CHANNELS];
-
-  HANDLE_STP_DEC hStpDec; /*!< STP handle. */
-
-  const UCHAR *pActivM2ParamBands;
-
-  int bOverwriteM1M2prev; /* Overwrite previous M2/M2 params with first set of
-                             new frame after SSC change (aka
-                             decodeAfterConfigHasChangedFlag). */
-  SpatialDecConcealmentInfo concealInfo;
-};
-
-#define SACDEC_SYNTAX_MPS 1
-#define SACDEC_SYNTAX_USAC 2
-#define SACDEC_SYNTAX_RSVD50 4
-#define SACDEC_SYNTAX_L2 8
-#define SACDEC_SYNTAX_L3 16
-#define SACDEC_SYNTAX_LD 32
-
-static inline int GetProcBand(spatialDec_struct *self, int qs) {
-  return self->kernels[qs];
-}
-
-#endif /* SAC_DEC_H */
--- a/libSACdec/src/sac_dec_conceal.cpp
+++ /dev/null
@@ -1,392 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround decoder library *************************
-
-   Author(s):   Christian Ertel, Christian Griebel
-
-   Description: SAC Dec error concealment
-
-*******************************************************************************/
-
-#include "sac_dec_conceal.h"
-
-void SpatialDecConcealment_Init(SpatialDecConcealmentInfo *info,
-                                const UINT resetFlags) {
-  FDK_ASSERT(info != NULL);
-
-  if (resetFlags & MPEGS_CONCEAL_RESET_STATE) {
-    info->concealState = SpatialDecConcealState_Init;
-    /* Frame counters will be initialized implicitely in function
-     * SpatialDecConcealment_UpdateState(). */
-  }
-
-  if (resetFlags & MPEGS_CONCEAL_RESET_PARAMETER) {
-    /* Set default params */
-    info->concealParams.method = MPEGS_CONCEAL_DEFAULT_METHOD;
-    info->concealParams.numKeepFrames = MPEGS_CONCEAL_DEFAULT_NUM_KEEP_FRAMES;
-    info->concealParams.numFadeOutFrames =
-        MPEGS_CONCEAL_DEFAULT_FADE_OUT_SLOPE_LENGTH;
-    info->concealParams.numFadeInFrames =
-        MPEGS_CONCEAL_DEFAULT_FADE_IN_SLOPE_LENGTH;
-    info->concealParams.numReleaseFrames =
-        MPEGS_CONCEAL_DEFAULT_NUM_RELEASE_FRAMES;
-  }
-
-  return;
-}
-
-int SpatialDecConcealment_Apply(
-    SpatialDecConcealmentInfo *info,
-    const SCHAR (*cmpIdxData)[MAX_PARAMETER_BANDS], SCHAR **diffIdxData,
-    SCHAR *
-        idxPrev, /* char
-                    idxPrev[SPATIALDEC_MAX_NUM_OTT][SPATIALDEC_MAX_PARAMETER_BANDS],
-                  */
-    SCHAR *bsXXXDataMode, const int startBand, const int stopBand,
-    const SCHAR defaultValue, const int paramType, const int numParamSets) {
-  int appliedProcessing = 0;
-  int band, dataMode = -1;
-
-  FDK_ASSERT(info != NULL);
-  FDK_ASSERT(cmpIdxData != NULL);
-  FDK_ASSERT(idxPrev != NULL);
-  FDK_ASSERT(bsXXXDataMode != NULL);
-
-  /* Processing depends only on the internal state */
-  switch (info->concealState) {
-    case SpatialDecConcealState_Init:
-      dataMode = 0; /* default */
-      break;
-
-    case SpatialDecConcealState_Ok:
-      /* Nothing to do */
-      break;
-
-    case SpatialDecConcealState_Keep:
-      dataMode = 1; /* keep */
-      break;
-
-    case SpatialDecConcealState_FadeToDefault: {
-      /* Start simple fade out */
-      FIXP_DBL fac = fDivNorm(info->cntStateFrames + 1,
-                              info->concealParams.numFadeOutFrames + 1);
-
-      for (band = startBand; band < stopBand; band += 1) {
-        /*            idxPrev = fac * defaultValue + (1-fac) * idxPrev; */
-        idxPrev[band] =
-            fMultI(fac, defaultValue - idxPrev[band]) + idxPrev[band];
-      }
-      dataMode = 1; /* keep */
-      appliedProcessing = 1;
-    } break;
-
-    case SpatialDecConcealState_Default:
-      for (band = startBand; band < stopBand; band += 1) {
-        idxPrev[band] = defaultValue;
-      }
-      dataMode = 1; /* keep */
-      appliedProcessing = 1;
-      break;
-
-    case SpatialDecConcealState_FadeFromDefault: {
-      FIXP_DBL fac = fDivNorm(info->cntValidFrames + 1,
-                              info->concealParams.numFadeInFrames + 1);
-
-      for (band = startBand; band < stopBand; band += 1) {
-        /*            idxPrev = fac * cmpIdxData + (1-fac) * defaultValue; */
-        idxPrev[band] =
-            fMultI(fac, cmpIdxData[numParamSets - 1][band] - defaultValue) +
-            defaultValue;
-      }
-      dataMode = 1; /* keep */
-      appliedProcessing = 1;
-    } break;
-
-    default:
-      FDK_ASSERT(0); /* All valid states shall be handled above. */
-      break;
-  }
-
-  if (dataMode >= 0) {
-    int i;
-    for (i = 0; i < numParamSets; i += 1) {
-      bsXXXDataMode[i] = dataMode;
-      if (diffIdxData != NULL) {
-        for (band = startBand; band < stopBand; band += 1) {
-          diffIdxData[i][band] = 0;
-        }
-      }
-    }
-  }
-
-  return appliedProcessing;
-}
-
-void SpatialDecConcealment_UpdateState(SpatialDecConcealmentInfo *info,
-                                       const int frameOk) {
-  FDK_ASSERT(info != NULL);
-
-  if (frameOk) {
-    info->cntValidFrames += 1;
-  } else {
-    info->cntValidFrames = 0;
-  }
-
-  switch (info->concealState) {
-    case SpatialDecConcealState_Init:
-      if (frameOk) {
-        /* NEXT STATE: Ok */
-        info->concealState = SpatialDecConcealState_Ok;
-        info->cntStateFrames = 0;
-      }
-      break;
-
-    case SpatialDecConcealState_Ok:
-      if (!frameOk) {
-        /* NEXT STATE: Keep */
-        info->concealState = SpatialDecConcealState_Keep;
-        info->cntStateFrames = 0;
-      }
-      break;
-
-    case SpatialDecConcealState_Keep:
-      info->cntStateFrames += 1;
-      if (frameOk) {
-        /* NEXT STATE: Ok */
-        info->concealState = SpatialDecConcealState_Ok;
-      } else {
-        if (info->cntStateFrames >= info->concealParams.numKeepFrames) {
-          if (info->concealParams.numFadeOutFrames == 0) {
-            /* NEXT STATE: Default */
-            info->concealState = SpatialDecConcealState_Default;
-          } else {
-            /* NEXT STATE: Fade to default */
-            info->concealState = SpatialDecConcealState_FadeToDefault;
-            info->cntStateFrames = 0;
-          }
-        }
-      }
-      break;
-
-    case SpatialDecConcealState_FadeToDefault:
-      info->cntStateFrames += 1;
-      if (info->cntValidFrames > 0) {
-        /* NEXT STATE: Fade in from default */
-        info->concealState = SpatialDecConcealState_FadeFromDefault;
-        info->cntStateFrames = 0;
-      } else {
-        if (info->cntStateFrames >= info->concealParams.numFadeOutFrames) {
-          /* NEXT STATE: Default */
-          info->concealState = SpatialDecConcealState_Default;
-        }
-      }
-      break;
-
-    case SpatialDecConcealState_Default:
-      if (info->cntValidFrames > 0) {
-        if (info->concealParams.numFadeInFrames == 0) {
-          /* NEXT STATE: Ok */
-          info->concealState = SpatialDecConcealState_Ok;
-        } else {
-          /* NEXT STATE: Fade in from default */
-          info->concealState = SpatialDecConcealState_FadeFromDefault;
-          info->cntValidFrames = 0;
-        }
-      }
-      break;
-
-    case SpatialDecConcealState_FadeFromDefault:
-      info->cntValidFrames += 1;
-      if (frameOk) {
-        if (info->cntValidFrames >= info->concealParams.numFadeInFrames) {
-          /* NEXT STATE: Ok */
-          info->concealState = SpatialDecConcealState_Ok;
-        }
-      } else {
-        /* NEXT STATE: Fade to default */
-        info->concealState = SpatialDecConcealState_FadeToDefault;
-        info->cntStateFrames = 0;
-      }
-      break;
-
-    default:
-      FDK_ASSERT(0); /* All valid states should be handled above! */
-      break;
-  }
-}
-
-SACDEC_ERROR SpatialDecConcealment_SetParam(SpatialDecConcealmentInfo *self,
-                                            const SAC_DEC_CONCEAL_PARAM param,
-                                            const INT value) {
-  SACDEC_ERROR err = MPS_OK;
-
-  switch (param) {
-    case SAC_DEC_CONCEAL_METHOD:
-      switch ((SpatialDecConcealmentMethod)value) {
-        case SAC_DEC_CONCEAL_WITH_ZERO_VALUED_OUTPUT:
-        case SAC_DEC_CONCEAL_BY_FADING_PARAMETERS:
-          break;
-        default:
-          err = MPS_INVALID_PARAMETER;
-          goto bail;
-      }
-      if (self != NULL) {
-        /* store parameter value */
-        self->concealParams.method = (SpatialDecConcealmentMethod)value;
-      } else {
-        err = MPS_INVALID_HANDLE;
-        goto bail;
-      }
-      break;
-    case SAC_DEC_CONCEAL_NUM_KEEP_FRAMES:
-      if (value < 0) {
-        err = MPS_INVALID_PARAMETER;
-        goto bail;
-      }
-      if (self != NULL) {
-        /* store parameter value */
-        self->concealParams.numKeepFrames = (UINT)value;
-      } else {
-        err = MPS_INVALID_HANDLE;
-        goto bail;
-      }
-      break;
-    case SAC_DEC_CONCEAL_FADE_OUT_SLOPE_LENGTH:
-      if (value < 0) {
-        err = MPS_INVALID_PARAMETER;
-        goto bail;
-      }
-      if (self != NULL) {
-        /* store parameter value */
-        self->concealParams.numFadeOutFrames = (UINT)value;
-      } else {
-        err = MPS_INVALID_HANDLE;
-        goto bail;
-      }
-      break;
-    case SAC_DEC_CONCEAL_FADE_IN_SLOPE_LENGTH:
-      if (value < 0) {
-        err = MPS_INVALID_PARAMETER;
-        goto bail;
-      }
-      if (self != NULL) {
-        /* store parameter value */
-        self->concealParams.numFadeInFrames = (UINT)value;
-      } else {
-        err = MPS_INVALID_HANDLE;
-        goto bail;
-      }
-      break;
-    case SAC_DEC_CONCEAL_NUM_RELEASE_FRAMES:
-      if (value < 0) {
-        err = MPS_INVALID_PARAMETER;
-        goto bail;
-      }
-      if (self != NULL) {
-        /* store parameter value */
-        self->concealParams.numReleaseFrames = (UINT)value;
-      } else {
-        err = MPS_INVALID_HANDLE;
-        goto bail;
-      }
-      break;
-    default:
-      err = MPS_INVALID_PARAMETER;
-      goto bail;
-  }
-
-bail:
-  return err;
-}
--- a/libSACdec/src/sac_dec_conceal.h
+++ /dev/null
@@ -1,187 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround decoder library *************************
-
-   Author(s):   Christian Ertel, Christian Griebel
-
-   Description: SAC Dec error concealment
-
-*******************************************************************************/
-
-#ifndef SAC_DEC_CONCEAL_H
-#define SAC_DEC_CONCEAL_H
-
-#include "sac_dec_interface.h"
-
-/* Modules dynamic parameters: */
-typedef enum {
-  SAC_DEC_CONCEAL_METHOD = 0,
-  SAC_DEC_CONCEAL_NUM_KEEP_FRAMES,
-  SAC_DEC_CONCEAL_FADE_OUT_SLOPE_LENGTH,
-  SAC_DEC_CONCEAL_FADE_IN_SLOPE_LENGTH,
-  SAC_DEC_CONCEAL_NUM_RELEASE_FRAMES
-
-} SAC_DEC_CONCEAL_PARAM;
-
-/* - - - - - - - - - - - - - - - - - - - - - - - - - - */
-/* sac_dec_interface.h                                 */
-/* - - - - - - - - - - - - - - - - - - - - - - - - - - */
-typedef enum {
-  SAC_DEC_CONCEAL_WITH_ZERO_VALUED_OUTPUT = 0,
-  SAC_DEC_CONCEAL_BY_FADING_PARAMETERS = 1
-
-} SpatialDecConcealmentMethod;
-/* - - - - - - - - - - - - - - - - - - - - - - - - - - */
-
-/* Default dynamic parameter values: */
-#define MPEGS_CONCEAL_DEFAULT_METHOD SAC_DEC_CONCEAL_BY_FADING_PARAMETERS
-#define MPEGS_CONCEAL_DEFAULT_NUM_KEEP_FRAMES (10)
-#define MPEGS_CONCEAL_DEFAULT_FADE_OUT_SLOPE_LENGTH (5)
-#define MPEGS_CONCEAL_DEFAULT_FADE_IN_SLOPE_LENGTH (5)
-#define MPEGS_CONCEAL_DEFAULT_NUM_RELEASE_FRAMES (3)
-
-typedef enum {
-  SpatialDecConcealState_Init = 0,
-  SpatialDecConcealState_Ok,
-  SpatialDecConcealState_Keep,
-  SpatialDecConcealState_FadeToDefault,
-  SpatialDecConcealState_Default,
-  SpatialDecConcealState_FadeFromDefault
-
-} SpatialDecConcealmentState;
-
-typedef struct {
-  SpatialDecConcealmentMethod method;
-
-  UINT numKeepFrames;
-  UINT numFadeOutFrames;
-  UINT numFadeInFrames;
-  UINT numReleaseFrames;
-
-} SpatialDecConcealmentParams;
-
-typedef struct {
-  SpatialDecConcealmentParams concealParams; /* User set params */
-  SpatialDecConcealmentState
-      concealState; /* State of internal state machine (fade-in/out etc) */
-
-  UINT cntStateFrames; /* Counter for fade-in/out handling */
-  UINT cntValidFrames; /* Counter for the number of consecutive good frames*/
-
-} SpatialDecConcealmentInfo;
-
-/* Module reset flags */
-#define MPEGS_CONCEAL_RESET_STATE (0x01)
-#define MPEGS_CONCEAL_RESET_PARAMETER (0x02)
-#define MPEGS_CONCEAL_RESET_ALL (0xFF)
-
-void SpatialDecConcealment_Init(SpatialDecConcealmentInfo *info,
-                                const UINT resetFlags);
-
-int SpatialDecConcealment_Apply(SpatialDecConcealmentInfo *info,
-                                const SCHAR (*cmpIdxData)[MAX_PARAMETER_BANDS],
-                                SCHAR **diffIdxData, SCHAR *idxPrev,
-                                SCHAR *bsXXXDataMode, const int startBand,
-                                const int stopBand, const SCHAR defaultValue,
-                                const int paramType, const int numParamSets);
-
-void SpatialDecConcealment_UpdateState(SpatialDecConcealmentInfo *info,
-                                       const int frameOk);
-
-SACDEC_ERROR SpatialDecConcealment_SetParam(SpatialDecConcealmentInfo *info,
-                                            const SAC_DEC_CONCEAL_PARAM param,
-                                            const INT value);
-
-#endif /* SAC_DEC_CONCEAL_H */
--- a/libSACdec/src/sac_dec_interface.h
+++ /dev/null
@@ -1,335 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround decoder library *************************
-
-   Author(s):
-
-   Description: SAC Decoder Library Interface
-
-*******************************************************************************/
-
-#ifndef SAC_DEC_INTERFACE_H
-#define SAC_DEC_INTERFACE_H
-
-#include "common_fix.h"
-#include "FDK_audio.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include "sac_dec_errorcodes.h"
-#include "sac_dec_ssc_struct.h"
-
-/**
- * \brief  Baseline MPEG-Surround profile Level 1-5.
- */
-typedef enum {
-  DECODER_LEVEL_0 = 0, /*!< Level 0: dummy level; 212 only */
-  DECODER_LEVEL_6 = 6  /*!< Level 6: no support */
-} CFG_LEVEL;
-
-/*
- * \brief  Number of output channels restriction.
- */
-typedef enum {
-  OUTPUT_CHANNELS_DEFAULT, /*!< Default configuration depending on Decoder Level
-                            */
-  OUTPUT_CHANNELS_2_0,     /*!< Limitation to stereo output */
-  OUTPUT_CHANNELS_5_1      /*!< Limitation to 5.1 output */
-} CFG_RESTRICTION;
-
-/*
- * \brief  Supported decoder mode.
- */
-typedef enum {
-  EXT_HQ_ONLY = 0,  /*!< High Quality processing only */
-  EXT_LP_ONLY = 1,  /*!< Low Power procesing only */
-  EXT_HQ_AND_LP = 2 /*!< Support both HQ and LP processing */
-} CFG_EXTENT;
-
-/*
- * \brief  Supported binaural mode.
- */
-typedef enum {
-  BINAURAL_NONE = -1 /*!< No binaural procesing supported */
-} CFG_BINAURAL;
-
-/**
- * \brief  Decoder configuration structure.
- *
- * These structure contains all parameters necessary for decoder open function.
- * The configuration specifies the functional range of the decoder instance.
- */
-typedef struct {
-  CFG_LEVEL decoderLevel;
-  CFG_EXTENT decoderMode;
-  CFG_RESTRICTION maxNumOutputChannels;
-  CFG_BINAURAL binauralMode;
-
-} SPATIAL_DEC_CONFIG;
-
-typedef enum {
-  INPUTMODE_QMF = 1000,
-  INPUTMODE_QMF_SBR = 1001,
-  INPUTMODE_TIME = 1002
-} SPATIALDEC_INPUT_MODE;
-
-/**
- * \brief  MPEG Surround upmix type mode.
- **/
-typedef enum {
-  UPMIX_TYPE_BYPASS =
-      -1, /*!< Bypass the downmix channels from the core decoder.    */
-  UPMIX_TYPE_NORMAL = 0 /*!< Multi channel output. */
-
-} SPATIAL_DEC_UPMIX_TYPE;
-
-/**
- * \brief  Dynamic decoder parameters.
- */
-typedef struct {
-  /* Basics */
-  UCHAR outputMode;
-  UCHAR blindEnable;
-  UCHAR bypassMode;
-
-  /* Error concealment */
-  UCHAR concealMethod;
-  UINT concealNumKeepFrames;
-  UINT concealFadeOutSlopeLength;
-  UINT concealFadeInSlopeLength;
-  UINT concealNumReleaseFrames;
-
-} SPATIALDEC_PARAM;
-
-/**
- * \brief Flags which control the initialization
- **/
-typedef enum {
-  MPEGS_INIT_NONE = 0x00000000, /*!< Indicates no initialization */
-
-  MPEGS_INIT_CONFIG = 0x00000010, /*!< Indicates a configuration change due to
-                                     SSC value changes */
-
-  MPEGS_INIT_STATES_ANA_QMF_FILTER =
-      0x00000100, /*!< Controls the initialization of the analysis qmf filter
-                     states */
-  MPEGS_INIT_STATES_SYN_QMF_FILTER =
-      0x00000200, /*!< Controls the initialization of the synthesis qmf filter
-                     states */
-  MPEGS_INIT_STATES_ANA_HYB_FILTER = 0x00000400, /*!< Controls the
-                                                    initialization of the
-                                                    analysis hybrid filter
-                                                    states */
-  MPEGS_INIT_STATES_DECORRELATOR =
-      0x00000800, /*!< Controls the initialization of the decorrelator states */
-  MPEGS_INIT_STATES_M1M2 = 0x00002000, /*!< Controls the initialization of the
-                                          history in m1 and m2 parameter
-                                          calculation */
-  MPEGS_INIT_STATES_GES = 0x00004000,  /*!< Controls the initialization of the
-                                          history in the ges calculation */
-  MPEGS_INIT_STATES_REVERB =
-      0x00008000, /*!< Controls the initialization of the reverb states */
-  MPEGS_INIT_STATES_PARAM =
-      0x00020000, /*!< Controls the initialization of the history of all other
-                     parameter */
-  MPEGS_INIT_STATES_ERROR_CONCEALMENT =
-      0x00080000, /*!< Controls the initialization of the error concealment
-                     module state */
-  MPEGS_INIT_PARAMS_ERROR_CONCEALMENT = 0x00200000 /*!< Controls the
-                                                      initialization of the
-                                                      whole error concealment
-                                                      parameter set */
-
-} MPEGS_INIT_CTRL_FLAGS;
-
-#define MASK_MPEGS_INIT_ALL_STATES (0x000FFF00)
-#define MASK_MPEGS_INIT_ALL_PARAMS (0x00F00000)
-
-typedef struct spatialDec_struct spatialDec, *HANDLE_SPATIAL_DEC;
-
-typedef struct SPATIAL_BS_FRAME_struct SPATIAL_BS_FRAME;
-
-typedef struct {
-  UINT sizePersistent;     /* persistent memory */
-  UINT sizeFastPersistent; /* fast persistent memory */
-
-} MEM_REQUIREMENTS;
-
-#define PCM_MPS INT_PCM
-#define PCM_MPSF FIXP_PCM
-
-#define FIXP_DBL2PCM_MPS(x) ((INT_PCM)FX_DBL2FX_PCM(x))
-
-/* exposed functions (library interface) */
-
-int FDK_SpatialDecCompareSpatialSpecificConfigHeader(
-    SPATIAL_SPECIFIC_CONFIG *pSsc1, SPATIAL_SPECIFIC_CONFIG *pSsc2);
-
-int FDK_SpatialDecInitDefaultSpatialSpecificConfig(
-    SPATIAL_SPECIFIC_CONFIG *pSpatialSpecificConfig,
-    AUDIO_OBJECT_TYPE coreCodec, int coreChannels, int samplingFreq,
-    int nTimeSlots, int decoderLevel, int isBlind);
-
-spatialDec *FDK_SpatialDecOpen(const SPATIAL_DEC_CONFIG *config,
-                               int stereoConfigIndex);
-
-/**
- * \brief Initialize state variables of the MPS parser
- */
-void SpatialDecInitParserContext(spatialDec *self);
-
-/**
- * \brief Initialize state of MPS decoder. This may happen after the first parse
- * operation.
- */
-SACDEC_ERROR FDK_SpatialDecInit(spatialDec *self, SPATIAL_BS_FRAME *frame,
-                                SPATIAL_SPECIFIC_CONFIG *pSpatialSpecificConfig,
-                                int nQmfBands,
-                                SPATIAL_DEC_UPMIX_TYPE const upmixType,
-                                SPATIALDEC_PARAM *pUserParams,
-                                UINT initFlags /* MPEGS_INIT_CTRL_FLAGS */
-);
-
-/**
- * \brief Apply decoded MPEG Surround parameters to time domain or QMF down mix
- * data.
- * \param self spatial decoder handle.
- * \param inData Pointer to time domain input down mix data if any.
- * \param qmfInDataReal Pointer array of QMF domain down mix input data (real
- * part).
- * \param qmfInDataImag Pointer array of QMF domain down mix input data
- * (imaginary part).
- * \param pcmOutBuf Pointer to a time domain buffer were the upmixed output data
- * will be stored into.
- * \param nSamples Amount of audio samples per channel of down mix input data
- * (frame length).
- * \param pControlFlags pointer to control flags field; input/output.
- * \param numInputChannels amount of down mix input channels. Might not match
- * the current tree config, useful for internal sanity checks and bypass mode.
- * \param channelMapping array containing the desired output channel ordering to
- * transform MPEG PCE style ordering to any other channel ordering. First
- * dimension is the total channel count.
- */
-SACDEC_ERROR SpatialDecApplyFrame(
-    spatialDec *self, SPATIAL_BS_FRAME *frame, SPATIALDEC_INPUT_MODE inputMode,
-    PCM_MPS *inData,          /* Time domain input  */
-    FIXP_DBL **qmfInDataReal, /* interleaved l/r */
-    FIXP_DBL **qmfInDataImag, /* interleaved l/r */
-    PCM_MPS *pcmOutBuf, /* MAX_OUTPUT_CHANNELS*MAX_TIME_SLOTS*NUM_QMF_BANDS] */
-    UINT nSamples, UINT *pControlFlags, int numInputChannels,
-    const FDK_channelMapDescr *const mapDescr);
-
-/**
- * \brief Fill given arrays with audio channel types and indices.
- * \param self spatial decoder handle.
- * \param channelType array where corresponding channel types fr each output
- * channels are stored into.
- * \param channelIndices array where corresponding channel type indices fr each
- * output channels are stored into.
- */
-void SpatialDecChannelProperties(spatialDec *self,
-                                 AUDIO_CHANNEL_TYPE channelType[],
-                                 UCHAR channelIndices[],
-                                 const FDK_channelMapDescr *const mapDescr);
-
-void FDK_SpatialDecClose(spatialDec *self);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* SAC_DEC_INTERFACE_H */
--- a/libSACdec/src/sac_dec_lib.cpp
+++ /dev/null
@@ -1,1995 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround decoder library *************************
-
-   Author(s):
-
-   Description: SAC Decoder Library Interface
-
-*******************************************************************************/
-
-#include "sac_dec_lib.h"
-#include "sac_dec_interface.h"
-#include "sac_dec.h"
-#include "sac_bitdec.h"
-#include "FDK_matrixCalloc.h"
-
-#define MPS_DATA_BUFFER_SIZE (2048)
-
-/**
- * \brief MPEG Surround data indication.
- **/
-typedef enum {
-  MPEGS_ANCTYPE_FRAME = 0, /*!< MPEG Surround frame, see ISO/IEC 23003-1 */
-  MPEGS_ANCTYPE_HEADER_AND_FRAME = 1, /*!< MPEG Surround header and MPEG
-                                         Surround frame, see ISO/IEC 23003-1 */
-  MPEGS_ANCTYPE_RESERVED_1 = 2,       /*!< reserved, see ISO/IEC 23003-1 */
-  MPEGS_ANCTYPE_RESERVED_2 = 3        /*!< reserved, see ISO/IEC 23003-1*/
-} MPEGS_ANCTYPE;
-
-/**
- * \brief MPEG Surround data segment indication.
- **/
-typedef enum {
-  MPEGS_CONTINUE = 0, /*!< Indicates if data segment continues a data block. */
-  MPEGS_STOP = 1,     /*!< Indicates if data segment ends a data block. */
-  MPEGS_START = 2,    /*!< Indicates if data segment begins a data block. */
-  MPEGS_START_STOP =
-      3 /*!< Indicates if data segment begins and ends a data block. */
-} MPEGS_ANCSTARTSTOP;
-
-/**
- * \brief MPEG Surround synchronizaiton state.
- *
- *  CAUTION: Changing the enumeration values can break the sync mechanism
- *because it is based on comparing the state values.
- **/
-typedef enum {
-  MPEGS_SYNC_LOST =
-      0, /*!< Indicates lost sync because of current discontinuity. */
-  MPEGS_SYNC_FOUND = 1,   /*!< Parsed a valid header and (re)intialization was
-                             successfully completed. */
-  MPEGS_SYNC_COMPLETE = 2 /*!< In sync and continuous. Found an independent
-                             frame in addition to MPEGS_SYNC_FOUND.
-                               Precondition: MPEGS_SYNC_FOUND. */
-} MPEGS_SYNCSTATE;
-
-/**
- * \brief MPEG Surround operation mode.
- **/
-typedef enum {
-  MPEGS_OPMODE_EMM = 0,           /*!< Mode: Enhanced Matrix Mode (Blind) */
-  MPEGS_OPMODE_MPS_PAYLOAD = 1,   /*!< Mode: Normal, Stereo or Binaural */
-  MPEGS_OPMODE_NO_MPS_PAYLOAD = 2 /*!< Mode: no MPEG Surround payload */
-} MPEGS_OPMODE;
-
-/**
- * \brief MPEG Surround init flags.
- **/
-typedef enum {
-  MPEGS_INIT_OK = 0x00000000, /*!< indicate correct initialization */
-  MPEGS_INIT_ENFORCE_REINIT =
-      0x00000001, /*!< indicate complete initialization */
-
-  MPEGS_INIT_CHANGE_OUTPUT_MODE =
-      0x00000010, /*!< indicate change of the output mode */
-  MPEGS_INIT_CHANGE_PARTIALLY_COMPLEX =
-      0x00000020, /*!< indicate change of low power/high quality */
-  MPEGS_INIT_CHANGE_TIME_FREQ_INTERFACE =
-      0x00000040, /*!< indicate change of qmf/time interface */
-  MPEGS_INIT_CHANGE_HEADER = 0x00000080, /*!< indicate change of header */
-
-  MPEGS_INIT_ERROR_PAYLOAD =
-      0x00000100, /*!< indicate payload/ancType/ancStartStop error */
-
-  MPEGS_INIT_BS_INTERRUPTION =
-      0x00001000, /*!< indicate bitstream interruption  */
-  MPEGS_INIT_CLEAR_HISTORY =
-      0x00002000, /*!< indicate that all states shall be cleared */
-
-  /* Re-initialization of submodules */
-
-  MPEGS_INIT_CHANGE_CONCEAL_PARAMS = 0x00100000, /*!< indicate a change of at
-                                                    least one error concealment
-                                                    param */
-
-  /* No re-initialization needed, currently not used */
-  MPEGS_INIT_CHANGE_BYPASS_MODE =
-      0x01000000, /*!< indicate change of bypass mode */
-
-  /* Re-initialization needed, currently not used */
-  MPEGS_INIT_ERROR_ANC_TYPE = 0x10000000, /*!< indicate ancType error*/
-  MPEGS_INIT_ERROR_ANC_STARTSTOP =
-      0x20000000 /*!< indicate ancStartStop error */
-} MPEGS_INIT_FLAGS;
-
-struct MpegSurroundDecoder {
-  HANDLE_FDK_QMF_DOMAIN pQmfDomain;
-  UCHAR mpsData[MPS_DATA_BUFFER_SIZE]; /* Buffer for MPS payload accross more
-                                          than one segment */
-  INT mpsDataBits;                     /* Amount of bits in mpsData */
-  /* MPEG Surround decoder */
-  SPATIAL_SPECIFIC_CONFIG spatialSpecificConfig[1]; /* SSC delay line which is
-                                                       used during decoding */
-  spatialDec *pSpatialDec;
-  SPATIAL_SPECIFIC_CONFIG
-  spatialSpecificConfigBackup; /* SSC used while parsing */
-
-  /* Creation parameter */
-  UCHAR mpegSurroundDecoderLevel;
-  /* Run-time parameter */
-  UCHAR mpegSurroundSscIsGlobalCfg; /* Flag telling that the SSC
-                                       (::spatialSpecificConfig) is a
-                                       out-of-band configuration. */
-  UCHAR mpegSurroundUseTimeInterface;
-
-  SPATIAL_BS_FRAME
-  bsFrames[1];         /* Bitstream Structs that contain data read from the
-                          SpatialFrame() bitstream element */
-  BS_LL_STATE llState; /* Bit stream parser state memory */
-  UCHAR bsFrameParse;  /* Current parse frame context index */
-  UCHAR bsFrameDecode; /* Current decode/apply frame context index */
-  UCHAR bsFrameDelay;  /* Amount of frames delay between parsing and processing.
-                          Required i.e. for interpolation error concealment. */
-
-  /* User prameters */
-  SPATIALDEC_PARAM mpegSurroundUserParams;
-
-  /* Internal flags */
-  SPATIAL_DEC_UPMIX_TYPE upmixType;
-  int initFlags[1];
-  MPEGS_ANCSTARTSTOP ancStartStopPrev;
-  MPEGS_SYNCSTATE fOnSync[1];
-
-  /* Inital decoder configuration */
-  SPATIAL_DEC_CONFIG decConfig;
-};
-
-SACDEC_ERROR
-static sscCheckOutOfBand(const SPATIAL_SPECIFIC_CONFIG *pSsc,
-                         const INT coreCodec, const INT sampleRate,
-                         const INT frameSize);
-
-static SACDEC_ERROR sscParseCheck(const SPATIAL_SPECIFIC_CONFIG *pSsc);
-
-/**
- * \brief Get the number of QMF bands from the sampling frequency (in Hz)
- **/
-static int mpegSurroundDecoder_GetNrOfQmfBands(
-    const SPATIAL_SPECIFIC_CONFIG *pSsc, UINT sampleRate) {
-  UINT samplingFrequency = sampleRate;
-  int qmfBands = 64;
-
-  if (pSsc != NULL) {
-    switch (pSsc->coreCodec) {
-      case AOT_USAC:
-        if ((pSsc->stereoConfigIndex == 3)) {
-          static const UCHAR mapIdx2QmfBands[3] = {24, 32, 16};
-          FDK_ASSERT((pSsc->coreSbrFrameLengthIndex >= 2) &&
-                     (pSsc->coreSbrFrameLengthIndex <= 4));
-          qmfBands = mapIdx2QmfBands[pSsc->coreSbrFrameLengthIndex - 2];
-        }
-        return qmfBands;
-      default:
-        samplingFrequency = pSsc->samplingFreq;
-        break;
-    }
-  }
-
-  /* number of QMF bands depend on sampling frequency, see FDIS 23003-1:2006
-   * Chapter 6.3.3 */
-  if (samplingFrequency < 27713) {
-    qmfBands = 32;
-  }
-  if (samplingFrequency > 55426) {
-    qmfBands = 128;
-  }
-
-  return qmfBands;
-}
-
-/**
- * \brief Analyse init flags
- **/
-static int mpegSurroundDecoder_CalcInitFlags(SPATIAL_SPECIFIC_CONFIG *pSsc1,
-                                             SPATIAL_SPECIFIC_CONFIG *pSsc2,
-                                             int upmixTypeFlag,
-                                             int binauralQualityFlag,
-                                             int partiallyComplexFlag,
-                                             int *ctrlFlags) {
-  /* Analyse core coder */
-  if (pSsc1->coreCodec != pSsc2->coreCodec) {
-    *ctrlFlags |= MASK_MPEGS_INIT_ALL_STATES;
-    *ctrlFlags |= MASK_MPEGS_INIT_ALL_PARAMS;
-  } else {
-    /* Analyse elements for initialization of space analysis qmf filterbank */
-    if ((partiallyComplexFlag) || (pSsc1->treeConfig != pSsc2->treeConfig) ||
-        (pSsc1->samplingFreq != pSsc2->samplingFreq)) {
-      *ctrlFlags |= MPEGS_INIT_STATES_ANA_QMF_FILTER;
-      *ctrlFlags |= MPEGS_INIT_STATES_ANA_HYB_FILTER;
-    }
-
-    /* Analyse elements for initialization of space synthesis qmf filterbank */
-    if ((upmixTypeFlag) || (partiallyComplexFlag) ||
-        (pSsc1->treeConfig != pSsc2->treeConfig) ||
-        (pSsc1->samplingFreq != pSsc2->samplingFreq) ||
-        (pSsc1->bsFixedGainDMX != pSsc2->bsFixedGainDMX)) {
-      *ctrlFlags |= MPEGS_INIT_STATES_SYN_QMF_FILTER;
-    }
-
-    /* Analyse elements for initialization of decorrelator */
-    if ((upmixTypeFlag) || (partiallyComplexFlag) ||
-        (pSsc1->treeConfig != pSsc2->treeConfig) ||
-        (pSsc1->samplingFreq != pSsc2->samplingFreq) ||
-        (pSsc1->decorrConfig != pSsc2->decorrConfig)) {
-      *ctrlFlags |= MPEGS_INIT_STATES_DECORRELATOR;
-    }
-
-    /* Analyse elements for initialization of m1 and m2 calculation */
-    if ((upmixTypeFlag) || (binauralQualityFlag) ||
-        (pSsc1->treeConfig != pSsc2->treeConfig) ||
-        (pSsc1->samplingFreq != pSsc2->samplingFreq))
-
-    {
-      *ctrlFlags |= MPEGS_INIT_STATES_M1M2;
-    }
-
-    /* Analyse elements for initialization of GES */
-    if ((upmixTypeFlag) || (pSsc1->treeConfig != pSsc2->treeConfig) ||
-        (pSsc1->tempShapeConfig != pSsc2->tempShapeConfig)) {
-      *ctrlFlags |= MPEGS_INIT_STATES_GES;
-    }
-
-    /* Analyse elements for initialization of FDreverb */
-    if ((upmixTypeFlag) || (binauralQualityFlag) || (partiallyComplexFlag) ||
-        (pSsc1->samplingFreq != pSsc2->samplingFreq) ||
-        (pSsc1->nTimeSlots != pSsc2->nTimeSlots)) {
-      *ctrlFlags |= MPEGS_INIT_STATES_REVERB;
-    }
-
-    /* Reset previous frame data whenever the config changes */
-    if (*ctrlFlags & MPEGS_INIT_CONFIG) {
-      *ctrlFlags |= MPEGS_INIT_STATES_PARAM;
-    }
-  }
-
-  return MPS_OK;
-}
-
-/**
- * \brief Reset MPEG Surround status info
- **/
-static void updateMpegSurroundDecoderStatus(
-    CMpegSurroundDecoder *pMpegSurroundDecoder, int initFlags,
-    MPEGS_SYNCSTATE fOnSync, MPEGS_ANCSTARTSTOP ancStartStopPrev) {
-  pMpegSurroundDecoder->initFlags[pMpegSurroundDecoder->bsFrameDecode] |=
-      initFlags;
-  if ((pMpegSurroundDecoder->mpegSurroundSscIsGlobalCfg != 0) &&
-      (pMpegSurroundDecoder->fOnSync[pMpegSurroundDecoder->bsFrameDecode] >=
-       MPEGS_SYNC_FOUND) &&
-      (fOnSync < MPEGS_SYNC_FOUND)) {
-    pMpegSurroundDecoder->fOnSync[pMpegSurroundDecoder->bsFrameDecode] =
-        MPEGS_SYNC_FOUND;
-  } else {
-    pMpegSurroundDecoder->fOnSync[pMpegSurroundDecoder->bsFrameDecode] =
-        fOnSync;
-  }
-  pMpegSurroundDecoder->ancStartStopPrev = ancStartStopPrev;
-}
-
-static SACDEC_ERROR mpegSurroundDecoder_Create(
-    CMpegSurroundDecoder **pMpegSurroundDecoder, int stereoConfigIndex,
-    HANDLE_FDK_QMF_DOMAIN pQmfDomain);
-
-SAC_INSTANCE_AVAIL
-mpegSurroundDecoder_IsFullMpegSurroundDecoderInstanceAvailable(
-    CMpegSurroundDecoder *pMpegSurroundDecoder) {
-  SAC_INSTANCE_AVAIL instanceAvailable = SAC_INSTANCE_NOT_FULL_AVAILABLE;
-
-  if (pMpegSurroundDecoder->pSpatialDec != NULL) {
-    instanceAvailable = SAC_INSTANCE_FULL_AVAILABLE;
-  }
-
-  return instanceAvailable;
-}
-
-SACDEC_ERROR mpegSurroundDecoder_Open(
-    CMpegSurroundDecoder **pMpegSurroundDecoder, int stereoConfigIndex,
-    HANDLE_FDK_QMF_DOMAIN pQmfDomain) {
-  SACDEC_ERROR error;
-
-  error = mpegSurroundDecoder_Create(pMpegSurroundDecoder, stereoConfigIndex,
-                                     pQmfDomain);
-
-  return error;
-}
-
-/**
- * \brief  Renamed function from getUpmixType to check_UParam_Build_DecConfig.
- *         This function checks if user params, decoder config and SSC are valid
- *         and if the decoder build can handle all this settings.
- *         The upmix type may be modified by this function.
- *         It is called in initMpegSurroundDecoder() after the ssc parse check,
- *         to have all checks in one place and to ensure these checks are always
- *         performed if config changes (inband and out-of-band).
- *
- * \param pUserParams  User data handle.
- * \param pDecConfig   decoder config handle.
- * \param pSsc         spatial specific config handle.
- * \param pUpmixType   upmix type which is set by this function
- *
- * \return  MPS_OK on sucess, and else on failure.
- */
-static SACDEC_ERROR check_UParam_Build_DecConfig(
-    SPATIALDEC_PARAM const *pUserParams, SPATIAL_DEC_CONFIG const *pDecConfig,
-    const SPATIAL_SPECIFIC_CONFIG *pSsc, SPATIAL_DEC_UPMIX_TYPE *pUpmixType) {
-  int dmxChannels, outChannels, maxNumOutChannels;
-
-  FDK_ASSERT(pUserParams != NULL);
-  FDK_ASSERT(pUpmixType != NULL);
-
-  /* checks if implementation can handle the Ssc */
-
-  switch (pSsc->treeConfig) {
-    case SPATIALDEC_MODE_RSVD7: /* 212 */
-      dmxChannels = 1;
-      outChannels = 2;
-      break;
-    default:
-      return MPS_UNSUPPORTED_CONFIG;
-  }
-
-  /* ------------------------------------------- */
-
-  /* Analyse pDecConfig params */
-  switch (pDecConfig->binauralMode) {
-    case BINAURAL_NONE:
-      break;
-    default:
-      return MPS_UNSUPPORTED_CONFIG;
-  }
-
-  switch (pDecConfig->decoderMode) {
-    case EXT_HQ_ONLY:
-      break;
-    default:
-      return MPS_UNSUPPORTED_CONFIG;
-  }
-
-  switch (pDecConfig->maxNumOutputChannels) {
-    case OUTPUT_CHANNELS_DEFAULT:
-      /* No special restrictions -> Get the level restriction: */
-      switch (pDecConfig->decoderLevel) {
-        case DECODER_LEVEL_0:
-          maxNumOutChannels = 2;
-          break;
-        default:
-          return MPS_UNSUPPORTED_CONFIG;
-      }
-      break;
-    case OUTPUT_CHANNELS_2_0:
-      maxNumOutChannels = 2;
-      break;
-    default:
-      return MPS_UNSUPPORTED_CONFIG;
-  }
-  /* ------------------------- */
-
-  /* check if we can handle user params */
-  if (pUserParams->blindEnable == 1) {
-    return MPS_UNSUPPORTED_CONFIG;
-  }
-  {
-    switch ((SAC_DEC_OUTPUT_MODE)pUserParams->outputMode) {
-      case SACDEC_OUT_MODE_NORMAL:
-        if (maxNumOutChannels >= outChannels) {
-          *pUpmixType = UPMIX_TYPE_NORMAL;
-        } else {
-          { *pUpmixType = UPMIX_TYPE_BYPASS; }
-        }
-        break;
-      case SACDEC_OUT_MODE_STEREO:
-        if (dmxChannels == 1) {
-          if (outChannels == 2) {
-            *pUpmixType = UPMIX_TYPE_NORMAL;
-          }
-        } else {
-          *pUpmixType = UPMIX_TYPE_BYPASS;
-        }
-        break;
-      case SACDEC_OUT_MODE_6CHANNEL:
-        if (outChannels > 6) {
-          { *pUpmixType = UPMIX_TYPE_BYPASS; }
-        } else {
-          *pUpmixType = UPMIX_TYPE_NORMAL;
-        }
-        break;
-      default:
-        return MPS_UNSUPPORTED_CONFIG;
-    }
-  }
-
-  return MPS_OK;
-}
-
-/**
- * \brief Init MPEG Surround decoder.
- **/
-static SACDEC_ERROR initMpegSurroundDecoder(
-    CMpegSurroundDecoder *pMpegSurroundDecoder) {
-  SACDEC_ERROR err;
-  int initFlags = MPEGS_INIT_NONE, initFlagsDec;
-  int upmixTypeCurr = pMpegSurroundDecoder->upmixType;
-
-  FDK_ASSERT(pMpegSurroundDecoder != NULL);
-
-  SPATIAL_SPECIFIC_CONFIG *const pSSCinput =
-      &pMpegSurroundDecoder->spatialSpecificConfigBackup;
-  SPATIAL_SPECIFIC_CONFIG *const pSSCtarget =
-      &pMpegSurroundDecoder
-           ->spatialSpecificConfig[pMpegSurroundDecoder->bsFrameDecode];
-  initFlagsDec =
-      pMpegSurroundDecoder->initFlags[pMpegSurroundDecoder->bsFrameDecode];
-
-  if (pSSCinput->coreCodec != AOT_USAC) {
-    /* here we check if we have a valid Ssc */
-    err = sscParseCheck(pSSCinput);
-    if (err != MPS_OK) goto bail;
-  }
-
-  /* here we check if Ssc matches build; also check UParams and DecConfig */
-  /* if desired upmixType is changes                                      */
-  err = check_UParam_Build_DecConfig(
-      &pMpegSurroundDecoder->mpegSurroundUserParams,
-      &pMpegSurroundDecoder->decConfig, pSSCinput,
-      &pMpegSurroundDecoder->upmixType);
-  if (err != MPS_OK) goto bail;
-
-  /* init config */
-  if (initFlagsDec & MPEGS_INIT_CHANGE_HEADER) {
-    initFlags |= MPEGS_INIT_CONFIG;
-  }
-  /* init all states */
-  if (initFlagsDec & MPEGS_INIT_CLEAR_HISTORY) {
-    initFlags |= MASK_MPEGS_INIT_ALL_STATES;
-  }
-  if (initFlagsDec & MPEGS_INIT_CHANGE_CONCEAL_PARAMS) {
-    initFlags |= MPEGS_INIT_PARAMS_ERROR_CONCEALMENT;
-  }
-
-  if (initFlagsDec & MPEGS_INIT_ENFORCE_REINIT) {
-    /* init all states */
-    initFlags |= MASK_MPEGS_INIT_ALL_STATES;
-    initFlags |= MASK_MPEGS_INIT_ALL_PARAMS;
-  } else {
-    /* analyse states which have to be initialized */
-    mpegSurroundDecoder_CalcInitFlags(
-        pSSCtarget, pSSCinput,
-        (upmixTypeCurr !=
-         pMpegSurroundDecoder->upmixType), /* upmixType changed */
-        0, (initFlagsDec & MPEGS_INIT_CHANGE_PARTIALLY_COMPLEX) ? 1 : 0,
-        &initFlags);
-  }
-
-  {
-    int nrOfQmfBands;
-    FDKmemcpy(pSSCtarget, pSSCinput, sizeof(SPATIAL_SPECIFIC_CONFIG));
-
-    nrOfQmfBands = mpegSurroundDecoder_GetNrOfQmfBands(
-        pSSCtarget, pSSCtarget->samplingFreq);
-    err = FDK_SpatialDecInit(
-        pMpegSurroundDecoder->pSpatialDec,
-        &pMpegSurroundDecoder->bsFrames[pMpegSurroundDecoder->bsFrameDecode],
-        pSSCtarget, nrOfQmfBands, pMpegSurroundDecoder->upmixType,
-        &pMpegSurroundDecoder->mpegSurroundUserParams, initFlags);
-
-    if (err != MPS_OK) goto bail;
-
-    /* Signal that we got a header and can go on decoding */
-    if (err == MPS_OK) {
-      initFlagsDec = MPEGS_INIT_OK;
-      {
-        pMpegSurroundDecoder->fOnSync[pMpegSurroundDecoder->bsFrameDecode] =
-            MPEGS_SYNC_FOUND;
-      }
-    }
-  }
-
-bail:
-  pMpegSurroundDecoder->initFlags[pMpegSurroundDecoder->bsFrameDecode] =
-      initFlagsDec;
-  return err;
-}
-
-/**
- * \brief Init MPEG Surround decoder.
- **/
-SACDEC_ERROR mpegSurroundDecoder_Init(
-    CMpegSurroundDecoder *pMpegSurroundDecoder) {
-  SACDEC_ERROR err = MPS_OK;
-
-  if (pMpegSurroundDecoder->initFlags[pMpegSurroundDecoder->bsFrameDecode]) {
-    err = initMpegSurroundDecoder(pMpegSurroundDecoder);
-  }
-  return err;
-}
-
-/**
- * \brief Open MPEG Surround decoder.
- **/
-static SACDEC_ERROR mpegSurroundDecoder_Create(
-    CMpegSurroundDecoder **pMpegSurroundDecoder, int stereoConfigIndex,
-    HANDLE_FDK_QMF_DOMAIN pQmfDomain) {
-  SACDEC_ERROR err = MPS_OK;
-  CMpegSurroundDecoder *sacDec = NULL;
-  spatialDec *self = NULL;
-
-  /* decoderLevel  decoderMode  maxNumOutputChannels  binauralMode */
-  static const SPATIAL_DEC_CONFIG decConfig = {
-      (CFG_LEVEL)(0), EXT_HQ_ONLY, OUTPUT_CHANNELS_DEFAULT, BINAURAL_NONE};
-
-  if (*pMpegSurroundDecoder == NULL) {
-    FDK_ALLOCATE_MEMORY_1D(*pMpegSurroundDecoder, 1, CMpegSurroundDecoder)
-
-    for (int i = 0; i < 1; i++) {
-      err = SpatialDecCreateBsFrame(&(*pMpegSurroundDecoder)->bsFrames[i],
-                                    &(*pMpegSurroundDecoder)->llState);
-      if (err != MPS_OK) {
-        sacDec = *pMpegSurroundDecoder;
-        goto bail;
-      }
-    }
-    (*pMpegSurroundDecoder)->pQmfDomain = pQmfDomain;
-
-    (*pMpegSurroundDecoder)->bsFrameDelay = 1;
-    (*pMpegSurroundDecoder)->bsFrameParse = 0;
-    (*pMpegSurroundDecoder)->bsFrameDecode = 0;
-
-    return err;
-  } else {
-    sacDec = *pMpegSurroundDecoder;
-  }
-
-  if (sacDec->pSpatialDec == NULL) {
-    if ((self = FDK_SpatialDecOpen(&decConfig, stereoConfigIndex)) == NULL) {
-      err = MPS_OUTOFMEMORY;
-      goto bail;
-    }
-  } else {
-    self = sacDec->pSpatialDec;
-  }
-
-  self->pQmfDomain = sacDec->pQmfDomain;
-
-  sacDec->pSpatialDec = self;
-
-  /* default parameter set */
-  sacDec->mpegSurroundUserParams.outputMode = SACDEC_OUT_MODE_NORMAL;
-  sacDec->mpegSurroundUserParams.blindEnable = 0;
-  sacDec->mpegSurroundUserParams.bypassMode = 0;
-  sacDec->mpegSurroundUserParams.concealMethod = 1;
-  sacDec->mpegSurroundUserParams.concealNumKeepFrames = 10;
-  sacDec->mpegSurroundUserParams.concealFadeOutSlopeLength = 5;
-  sacDec->mpegSurroundUserParams.concealFadeInSlopeLength = 5;
-  sacDec->mpegSurroundUserParams.concealNumReleaseFrames = 3;
-  sacDec->mpegSurroundSscIsGlobalCfg = 0;
-  sacDec->mpegSurroundUseTimeInterface = 1;
-  sacDec->mpegSurroundDecoderLevel = decConfig.decoderLevel;
-
-  sacDec->upmixType = UPMIX_TYPE_NORMAL;
-
-  /* signalize spatial decoder re-initalization */
-  updateMpegSurroundDecoderStatus(sacDec, MPEGS_INIT_ENFORCE_REINIT,
-                                  MPEGS_SYNC_LOST, MPEGS_STOP);
-
-  /* return decoder instance */
-  *pMpegSurroundDecoder = sacDec;
-  sacDec->decConfig = decConfig;
-
-  SpatialDecInitParserContext(sacDec->pSpatialDec);
-
-  return err;
-
-bail:
-  if (sacDec != NULL) {
-    mpegSurroundDecoder_Close(sacDec);
-  }
-  *pMpegSurroundDecoder = NULL;
-  if (err == MPS_OK) {
-    return MPS_OUTOFMEMORY;
-  } else {
-    return err;
-  }
-}
-
-/**
- * \brief Config MPEG Surround decoder.
- **/
-SACDEC_ERROR mpegSurroundDecoder_Config(
-    CMpegSurroundDecoder *pMpegSurroundDecoder, HANDLE_FDK_BITSTREAM hBs,
-    AUDIO_OBJECT_TYPE coreCodec, INT samplingRate, INT frameSize,
-    INT stereoConfigIndex, INT coreSbrFrameLengthIndex, INT configBytes,
-    const UCHAR configMode, UCHAR *configChanged) {
-  SACDEC_ERROR err = MPS_OK;
-  SPATIAL_SPECIFIC_CONFIG spatialSpecificConfig;
-  SPATIAL_SPECIFIC_CONFIG *pSsc =
-      &pMpegSurroundDecoder->spatialSpecificConfigBackup;
-
-  switch (coreCodec) {
-    case AOT_DRM_USAC:
-    case AOT_USAC:
-      if (configMode == AC_CM_DET_CFG_CHANGE) {
-        /* In config detection mode write spatial specific config parameters
-         * into temporarily allocated structure */
-        err = SpatialDecParseMps212Config(
-            hBs, &spatialSpecificConfig, samplingRate, coreCodec,
-            stereoConfigIndex, coreSbrFrameLengthIndex);
-        pSsc = &spatialSpecificConfig;
-      } else {
-        err = SpatialDecParseMps212Config(
-            hBs, &pMpegSurroundDecoder->spatialSpecificConfigBackup,
-            samplingRate, coreCodec, stereoConfigIndex,
-            coreSbrFrameLengthIndex);
-      }
-      break;
-    case AOT_ER_AAC_ELD:
-    case AOT_ER_AAC_LD:
-      if (configMode == AC_CM_DET_CFG_CHANGE) {
-        /* In config detection mode write spatial specific config parameters
-         * into temporarily allocated structure */
-        err = SpatialDecParseSpecificConfig(hBs, &spatialSpecificConfig,
-                                            configBytes, coreCodec);
-        pSsc = &spatialSpecificConfig;
-      } else {
-        err = SpatialDecParseSpecificConfig(
-            hBs, &pMpegSurroundDecoder->spatialSpecificConfigBackup,
-            configBytes, coreCodec);
-      }
-      break;
-    default:
-      err = MPS_UNSUPPORTED_FORMAT;
-      break;
-  }
-
-  if (err != MPS_OK) {
-    goto bail;
-  }
-
-  err = sscCheckOutOfBand(pSsc, coreCodec, samplingRate, frameSize);
-
-  if (err != MPS_OK) {
-    goto bail;
-  }
-
-  if (configMode & AC_CM_DET_CFG_CHANGE) {
-    return err;
-  }
-
-  if (configMode & AC_CM_ALLOC_MEM) {
-    if (*configChanged) {
-      err = mpegSurroundDecoder_Open(&pMpegSurroundDecoder, stereoConfigIndex,
-                                     NULL);
-      if (err) {
-        return err;
-      }
-    }
-  }
-
-  {
-    SPATIAL_SPECIFIC_CONFIG *sscParse =
-        &pMpegSurroundDecoder
-             ->spatialSpecificConfig[pMpegSurroundDecoder->bsFrameParse];
-
-    if (FDK_SpatialDecCompareSpatialSpecificConfigHeader(
-            &pMpegSurroundDecoder->spatialSpecificConfigBackup, sscParse)) {
-      pMpegSurroundDecoder->initFlags[pMpegSurroundDecoder->bsFrameParse] |=
-          MPEGS_INIT_CHANGE_HEADER;
-      /* Error resilience code */
-      if (pMpegSurroundDecoder->pSpatialDec == NULL) {
-        err = MPS_NOTOK;
-        goto bail;
-      }
-      SpatialDecInitParserContext(pMpegSurroundDecoder->pSpatialDec);
-      pMpegSurroundDecoder->pSpatialDec->pConfigCurrent =
-          &pMpegSurroundDecoder
-               ->spatialSpecificConfig[pMpegSurroundDecoder->bsFrameDecode];
-    }
-  }
-
-  if (err == MPS_OK) {
-    /* We got a valid out-of-band configuration so label it accordingly. */
-    pMpegSurroundDecoder->mpegSurroundSscIsGlobalCfg = 1;
-  }
-
-bail:
-  return err;
-}
-
-/**
- * \brief Determine MPEG Surround operation mode.
- **/
-static MPEGS_OPMODE mpegSurroundOperationMode(
-    CMpegSurroundDecoder *pMpegSurroundDecoder, int mpsDataBits) {
-  MPEGS_OPMODE mode;
-
-  {
-    if ((mpsDataBits > 0) &&
-        (pMpegSurroundDecoder->mpegSurroundUserParams.blindEnable == 0)) {
-      mode = MPEGS_OPMODE_MPS_PAYLOAD; /* Mode: Normal, Stereo or Binaural */
-    } else {
-      mode = MPEGS_OPMODE_NO_MPS_PAYLOAD; /* Mode: No MPEG Surround Payload */
-      updateMpegSurroundDecoderStatus(pMpegSurroundDecoder,
-                                      MPEGS_INIT_ERROR_PAYLOAD, MPEGS_SYNC_LOST,
-                                      MPEGS_STOP);
-    }
-  }
-
-  return (mode);
-}
-
-/**
- * \brief  Check ssc for parse errors.
- *         This one is called in initMpegSurroundDecoder()
- *         to ensure checking of inband and out-of-band mps configs.
- *         Only parse errors checked here! Check for valid config is done
- *         in check_UParam_Build_DecConfig()!
- *
- * \param pSsc         spatial specific config handle.
- *
- * \return  MPS_OK on sucess, and else on parse error.
- */
-static SACDEC_ERROR sscParseCheck(const SPATIAL_SPECIFIC_CONFIG *pSsc) {
-  if (pSsc->samplingFreq > 96000) return MPS_PARSE_ERROR;
-  if (pSsc->samplingFreq < 8000) return MPS_PARSE_ERROR;
-
-  if ((pSsc->treeConfig < 0) || (pSsc->treeConfig > 7)) {
-    return MPS_PARSE_ERROR;
-  }
-
-  if ((pSsc->quantMode < 0) || (pSsc->quantMode > 2)) {
-    return MPS_PARSE_ERROR;
-  }
-
-  /* now we are sure there were no parsing errors */
-
-  return MPS_OK;
-}
-
-/**
- * \brief  Check number of time slots
- *
- * Basically the mps frame length must be a multiple of the core coder frame
- * length. The below table shows all valid configurations in detail. See ISO/IEC
- * 23003-1: "Table 4A - Allowed values for bsFrameLength in the Baseline MPEG
- * Surround Profile"
- *
- * Downmix Coder        Downmix Code      Allowed values for bsFrameLength
- * Allowed frame sizes for normal, downsampled and upsampled MPS Framelength
- *                      (QMF Samples)
- *
- * AAC 1024                  16           15, 31, 47, 63 1024  2048  3072  4096
- * downsampled MPS           32           31, 63 1024  2048 upsampled MPS
- * 8            7, 15, 23, 31, 39, 47, 55, 63, 71    1024  2048  3072  4096
- * 5120  6144  7168  8192  9216
- *
- * AAC 960                   15           14, 29, 44, 59 960  1920  2880  3840
- * downsampled MPS           30           29, 59 960  1920 upsampled MPS
- * 7,5           14, 29, 44, 59                        1920  3840  5760  7680
- *
- * HE-AAC 1024/2048          32           31, 63 2048  4096 downsampled MPS
- * 64           63                                    2048 upsampled MPS
- * 16           15, 31, 47, 63                        2048  4096  6144  8192
- *
- * HE-AAC 960/1920           30           29, 59 1920  3840 downsampled MPS
- * 60           59                                    1920 upsampled MPS
- * 15           14, 29, 44, 59                        1920  3840  5760  7680
- *
- * BSAC                      16           15, 31, 47, 63 1024  2048  3072  4096
- * downsampled MPS           32           31, 63 1024  2048 upsampled MPS
- * 8            7, 15, 23, 31, 39, 47, 55, 63, 71    1024  2048  3072  4096
- * 5120  6144  7168  8192  9216
- *
- * BSAC with SBR             32           31, 63 2048  4096 downsampled MPS
- * 64           63                                    2048 upsampled MPS
- * 16           15, 31, 47, 63                        2048  4096  6144  8192
- *
- * AAC LD 512                 8            7, 15, 23, 31, 39, 47, 55, 63, 71
- * 512  1024  1536  2048  2560  3072  3584  4096  4608 downsampled MPS
- * 16           15, 31, 47, 63                         512  1024  1536  2048
- *
- * AAC ELD 512                8            7, 15, 23, 31, 39, 47, 55, 63, 71
- * 512  1024  1536  2048  2560  3072  3584  4096  4608 downsampled MPS
- * 16           15, 31, 47, 63                         512  1024  1536  2048
- *
- * AAC ELD with SBR 512/1024 16           15, 31, 47, 63 1024  2048  3072  4096
- * downsampled MPS           32           31, 63 1024  2048 upsampled MPS
- * 8            7, 15, 23, 31, 39, 47, 55, 63, 71    1024  2048  3072  4096
- * 5120  6144  7168  8192  9216
- *
- * MPEG1/2 Layer II          18           17, 35, 53, 71 1152  2304  3456  4608
- * downsampled MPS           36           35, 71 1152  2304
- *
- * MPEG1/2 Layer III         18           17, 35, 53, 71 1152  2304  3456  4608
- * downsampled MPS           36           35, 71 1152  2304
- *
- * \param frameLength
- * \param qmfBands
- * \param timeSlots
- *
- * \return  error code
- */
-SACDEC_ERROR checkTimeSlots(int frameLength, int qmfBands, int timeSlots) {
-  int len;
-  int maxFrameLength;
-
-  if (qmfBands == 64) {
-    /* normal MPEG Surround */
-    switch (frameLength) {
-      case 960:
-      case 1920:
-        maxFrameLength = 3840;
-        break;
-      case 1024:
-      case 2048:
-        maxFrameLength = 4096;
-        break;
-      case 512:
-      case 1152:
-        maxFrameLength = 4608;
-        break;
-      default:
-        return MPS_PARSE_ERROR;
-    }
-  } else if (qmfBands == 32) {
-    /* downsampled MPEG Surround */
-    switch (frameLength) {
-      case 960:
-      case 1920:
-        maxFrameLength = 1920;
-        break;
-      case 512:
-      case 1024:
-      case 2048:
-        maxFrameLength = 2048;
-        break;
-      case 1152:
-        maxFrameLength = 2304;
-        break;
-      default:
-        return MPS_PARSE_ERROR;
-    }
-  } else if (qmfBands == 128) {
-    /* upsampled MPEG Surround */
-    switch (frameLength) {
-      case 1920:
-        maxFrameLength = 7680;
-        break;
-      case 1024:
-        maxFrameLength = 9216;
-        break;
-      case 2048:
-        maxFrameLength = 8192;
-        break;
-      case 512:
-      case 960:
-      case 1152:
-      /* no break, no support for upsampled MPEG Surround */
-      default:
-        return MPS_PARSE_ERROR;
-    }
-  } else {
-    return MPS_PARSE_ERROR;
-  }
-
-  len = frameLength;
-
-  while (len <= maxFrameLength) {
-    if (len == timeSlots * qmfBands) {
-      return MPS_OK;
-    }
-    len += frameLength;
-  }
-  return MPS_PARSE_ERROR;
-}
-
-/**
- * \brief  Check ssc for consistency (e.g. bit errors could cause trouble)
- *         First of currently two ssc-checks.
- *         This (old) one is called in mpegSurroundDecoder_Apply()
- *         only if inband mps config is contained in stream.
- *
- *         New ssc check is split in two functions sscParseCheck() and
- * check_UParam_Build_DecConfig(). sscParseCheck() checks only for correct
- * parsing. check_UParam_Build_DecConfig() is used to check if we have a
- * valid config. Both are called in initMpegSurroundDecoder() to ensure
- * checking of inband and out-of-band mps configs.
- *
- *         If this function can be integrated into the new functions.
- *         We can remove this one.
- *
- * \param pSsc         spatial specific config handle.
- * \param frameLength
- * \param sampleRate
- *
- * \return  MPS_OK on sucess, and else on failure.
- */
-static SACDEC_ERROR sscCheckInBand(SPATIAL_SPECIFIC_CONFIG *pSsc,
-                                   int frameLength, int sampleRate) {
-  SACDEC_ERROR err = MPS_OK;
-  int qmfBands;
-
-  FDK_ASSERT(pSsc != NULL);
-
-  /* check ssc for parse errors */
-  if (sscParseCheck(pSsc) != MPS_OK) {
-    err = MPS_PARSE_ERROR;
-  }
-
-  /* core fs and mps fs must match */
-  if (pSsc->samplingFreq != sampleRate) {
-    err = MPS_PARSE_ERROR /* MPEGSDEC_SSC_PARSE_ERROR */;
-  }
-
-  qmfBands = mpegSurroundDecoder_GetNrOfQmfBands(pSsc, pSsc->samplingFreq);
-
-  if (checkTimeSlots(frameLength, qmfBands, pSsc->nTimeSlots) != MPS_OK) {
-    err = MPS_PARSE_ERROR;
-  }
-
-  return err;
-}
-
-SACDEC_ERROR
-mpegSurroundDecoder_ConfigureQmfDomain(
-    CMpegSurroundDecoder *pMpegSurroundDecoder,
-    SAC_INPUT_CONFIG sac_dec_interface, UINT coreSamplingRate,
-    AUDIO_OBJECT_TYPE coreCodec) {
-  SACDEC_ERROR err = MPS_OK;
-  FDK_QMF_DOMAIN_GC *pGC = NULL;
-
-  if (pMpegSurroundDecoder == NULL) {
-    return MPS_INVALID_HANDLE;
-  }
-
-  FDK_ASSERT(pMpegSurroundDecoder->pSpatialDec);
-
-  pGC = &pMpegSurroundDecoder->pQmfDomain->globalConf;
-  if (pMpegSurroundDecoder->mpegSurroundSscIsGlobalCfg) {
-    SPATIAL_SPECIFIC_CONFIG *pSSC =
-        &pMpegSurroundDecoder->spatialSpecificConfigBackup;
-    if (sac_dec_interface == SAC_INTERFACE_TIME) {
-      /* For SAC_INTERFACE_QMF these parameters are set by SBR. */
-      pGC->nBandsAnalysis_requested = mpegSurroundDecoder_GetNrOfQmfBands(
-          pSSC, coreSamplingRate); /* coreSamplingRate == outputSamplingRate for
-                                      SAC_INTERFACE_TIME */
-      pGC->nBandsSynthesis_requested = pGC->nBandsAnalysis_requested;
-      pGC->nInputChannels_requested =
-          fMax((UINT)pSSC->nInputChannels, (UINT)pGC->nInputChannels_requested);
-    }
-    pGC->nOutputChannels_requested =
-        fMax((UINT)pSSC->nOutputChannels, (UINT)pGC->nOutputChannels_requested);
-  } else {
-    if (sac_dec_interface == SAC_INTERFACE_TIME) {
-      /* For SAC_INTERFACE_QMF these parameters are set by SBR. */
-      pGC->nBandsAnalysis_requested = mpegSurroundDecoder_GetNrOfQmfBands(
-          NULL, coreSamplingRate); /* coreSamplingRate == outputSamplingRate for
-                                      SAC_INTERFACE_TIME */
-      pGC->nBandsSynthesis_requested = pGC->nBandsAnalysis_requested;
-      pGC->nInputChannels_requested =
-          pMpegSurroundDecoder->pSpatialDec->createParams.maxNumInputChannels;
-    }
-    pGC->nOutputChannels_requested =
-        pMpegSurroundDecoder->pSpatialDec->createParams.maxNumOutputChannels;
-  }
-  pGC->nQmfProcBands_requested = 64;
-  pGC->nQmfProcChannels_requested =
-      fMin((INT)pGC->nInputChannels_requested,
-           pMpegSurroundDecoder->pSpatialDec->createParams.maxNumInputChannels);
-
-  if (coreCodec == AOT_ER_AAC_ELD) {
-    pGC->flags_requested |= QMF_FLAG_MPSLDFB;
-    pGC->flags_requested &= ~QMF_FLAG_CLDFB;
-  }
-
-  return err;
-}
-
-/**
- * \brief  Check out-of-band config
- *
- * \param pSsc         spatial specific config handle.
- * \param coreCodec    core codec.
- * \param sampleRate   sampling frequency.
- *
- * \return  errorStatus
- */
-SACDEC_ERROR
-sscCheckOutOfBand(const SPATIAL_SPECIFIC_CONFIG *pSsc, const INT coreCodec,
-                  const INT sampleRate, const INT frameSize) {
-  FDK_ASSERT(pSsc != NULL);
-  int qmfBands = 0;
-
-  /* check ssc for parse errors */
-  if (sscParseCheck(pSsc) != MPS_OK) {
-    return MPS_PARSE_ERROR;
-  }
-
-  switch (coreCodec) {
-    case AOT_USAC:
-    case AOT_DRM_USAC:
-      /* ISO/IEC 23003-1:2007(E), Chapter 6.3.3, Support for lower and higher
-       * sampling frequencies */
-      if (pSsc->samplingFreq >= 55426) {
-        return MPS_PARSE_ERROR;
-      }
-      break;
-    case AOT_ER_AAC_LD:
-    case AOT_ER_AAC_ELD:
-      /* core fs and mps fs must match */
-      if (pSsc->samplingFreq != sampleRate) {
-        return MPS_PARSE_ERROR;
-      }
-
-      /* ISO/IEC 14496-3:2009 FDAM 3: Chapter 1.5.2.3, Levels for the Low Delay
-       * AAC v2 profile */
-      if (pSsc->samplingFreq > 48000) {
-        return MPS_PARSE_ERROR;
-      }
-
-      qmfBands = mpegSurroundDecoder_GetNrOfQmfBands(pSsc, pSsc->samplingFreq);
-      switch (frameSize) {
-        case 480:
-          if (!((qmfBands == 32) && (pSsc->nTimeSlots == 15))) {
-            return MPS_PARSE_ERROR;
-          }
-          break;
-        case 960:
-          if (!((qmfBands == 64) && (pSsc->nTimeSlots == 15))) {
-            return MPS_PARSE_ERROR;
-          }
-          break;
-        case 512:
-          if (!(((qmfBands == 32) && (pSsc->nTimeSlots == 16)) ||
-                ((qmfBands == 64) && (pSsc->nTimeSlots == 8)))) {
-            return MPS_PARSE_ERROR;
-          }
-          break;
-        case 1024:
-          if (!((qmfBands == 64) && (pSsc->nTimeSlots == 16))) {
-            return MPS_PARSE_ERROR;
-          }
-          break;
-        default:
-          return MPS_PARSE_ERROR;
-      }
-      break;
-    default:
-      return MPS_PARSE_ERROR;
-      break;
-  }
-
-  return MPS_OK;
-}
-
-/**
- * \brief Decode MPEG Surround frame.
- **/
-int mpegSurroundDecoder_ParseNoHeader(
-    CMpegSurroundDecoder *pMpegSurroundDecoder, HANDLE_FDK_BITSTREAM hBs,
-    int *pMpsDataBits, int fGlobalIndependencyFlag) {
-  SACDEC_ERROR err = MPS_OK;
-  SPATIAL_SPECIFIC_CONFIG *sscParse;
-  int bitsAvail, numSacBits;
-
-  if (pMpegSurroundDecoder == NULL || hBs == NULL) {
-    return MPS_INVALID_HANDLE;
-  }
-
-  sscParse = &pMpegSurroundDecoder
-                  ->spatialSpecificConfig[pMpegSurroundDecoder->bsFrameParse];
-
-  bitsAvail = FDKgetValidBits(hBs);
-
-  /* First spatial specific config is parsed into spatialSpecificConfigBackup,
-   * second spatialSpecificConfigBackup is copied into
-   * spatialSpecificConfig[bsFrameDecode] */
-  if (pMpegSurroundDecoder->initFlags[pMpegSurroundDecoder->bsFrameParse]) {
-    FDKmemcpy(sscParse, &pMpegSurroundDecoder->spatialSpecificConfigBackup,
-              sizeof(SPATIAL_SPECIFIC_CONFIG));
-    pMpegSurroundDecoder->fOnSync[pMpegSurroundDecoder->bsFrameParse] =
-        MPEGS_SYNC_FOUND;
-  }
-
-  if (bitsAvail <= 0) {
-    err = MPS_PARSE_ERROR;
-  } else {
-    err = SpatialDecParseFrameData(
-        pMpegSurroundDecoder->pSpatialDec,
-        &pMpegSurroundDecoder->bsFrames[pMpegSurroundDecoder->bsFrameParse],
-        hBs, sscParse, (UPMIXTYPE)pMpegSurroundDecoder->upmixType,
-        fGlobalIndependencyFlag);
-    if (err == MPS_OK) {
-      pMpegSurroundDecoder->bsFrames[pMpegSurroundDecoder->bsFrameParse]
-          .newBsData = 1;
-    }
-  }
-
-  numSacBits = bitsAvail - (INT)FDKgetValidBits(hBs);
-
-  if (numSacBits > bitsAvail) {
-    pMpegSurroundDecoder->bsFrames[pMpegSurroundDecoder->bsFrameParse]
-        .newBsData = 0;
-    err = MPS_PARSE_ERROR;
-  }
-
-  *pMpsDataBits -= numSacBits;
-
-  return err;
-}
-
-/**
- * \brief Check, if ancType is valid.
- **/
-static int isValidAncType(CMpegSurroundDecoder *pMpegSurroundDecoder,
-                          int ancType) {
-  int ret = 1;
-
-  if ((ancType != MPEGS_ANCTYPE_HEADER_AND_FRAME) &&
-      (ancType != MPEGS_ANCTYPE_FRAME)) {
-    ret = 0;
-  }
-
-  if (ret == 0) {
-    updateMpegSurroundDecoderStatus(pMpegSurroundDecoder,
-                                    MPEGS_INIT_ERROR_PAYLOAD, MPEGS_SYNC_LOST,
-                                    MPEGS_STOP);
-  }
-
-  return (ret);
-}
-
-/**
- * \brief Check, if ancStartStop is valid.
- **/
-static int isValidAncStartStop(CMpegSurroundDecoder *pMpegSurroundDecoder,
-                               int ancStartStop) {
-  int ret = 1;
-
-  switch (ancStartStop) {
-    case MPEGS_START:
-      /* Sequence start - start and continue - start not allowed */
-      if ((pMpegSurroundDecoder->ancStartStopPrev == MPEGS_START) ||
-          (pMpegSurroundDecoder->ancStartStopPrev == MPEGS_CONTINUE)) {
-        ret = 0;
-      }
-      break;
-
-    case MPEGS_STOP:
-      /* MPS payload of the previous frame must be valid if current type is stop
-         Sequence startstop - stop and stop - stop not allowed
-         Sequence startstop - continue and stop - continue are allowed */
-      if ((pMpegSurroundDecoder->ancStartStopPrev == MPEGS_STOP) ||
-          (pMpegSurroundDecoder->ancStartStopPrev == MPEGS_START_STOP)) {
-        ret = 0;
-      }
-      break;
-
-    case MPEGS_CONTINUE:
-    case MPEGS_START_STOP:
-      /* No error detection possible for this states */
-      break;
-  }
-
-  if (ret == 0) {
-    updateMpegSurroundDecoderStatus(pMpegSurroundDecoder,
-                                    MPEGS_INIT_ERROR_PAYLOAD, MPEGS_SYNC_LOST,
-                                    MPEGS_STOP);
-  } else {
-    pMpegSurroundDecoder->ancStartStopPrev = (MPEGS_ANCSTARTSTOP)ancStartStop;
-  }
-
-  return (ret);
-}
-
-int mpegSurroundDecoder_Parse(CMpegSurroundDecoder *pMpegSurroundDecoder,
-                              HANDLE_FDK_BITSTREAM hBs, int *pMpsDataBits,
-                              AUDIO_OBJECT_TYPE coreCodec, int sampleRate,
-                              int frameSize, int fGlobalIndependencyFlag) {
-  SACDEC_ERROR err = MPS_OK;
-  SPATIAL_SPECIFIC_CONFIG *sscParse;
-  SPATIAL_BS_FRAME *bsFrame;
-  HANDLE_FDK_BITSTREAM hMpsBsData = NULL;
-  FDK_BITSTREAM mpsBsData;
-  int mpsDataBits = *pMpsDataBits;
-  int mpsBsBits;
-  MPEGS_ANCTYPE ancType;
-  MPEGS_ANCSTARTSTOP ancStartStop;
-
-  if (pMpegSurroundDecoder == NULL) {
-    return MPS_INVALID_HANDLE;
-  }
-
-  FDK_ASSERT(pMpegSurroundDecoder->pSpatialDec);
-
-  mpsBsBits = (INT)FDKgetValidBits(hBs);
-
-  sscParse = &pMpegSurroundDecoder
-                  ->spatialSpecificConfig[pMpegSurroundDecoder->bsFrameParse];
-  bsFrame = &pMpegSurroundDecoder->bsFrames[pMpegSurroundDecoder->bsFrameParse];
-
-  /*
-     Find operation mode of mpeg surround decoder:
-     - MPEGS_OPMODE_EMM:            Mode: Enhanced Matrix Mode (Blind)
-     - MPEGS_OPMODE_MPS_PAYLOAD:    Mode: Normal, Stereo or Binaural
-     - MPEGS_OPMODE_NO_MPS_PAYLOAD: Mode: No MpegSurround Payload
-  */
-  {
-    /* Parse ancType and ancStartStop */
-    ancType = (MPEGS_ANCTYPE)FDKreadBits(hBs, 2);
-    ancStartStop = (MPEGS_ANCSTARTSTOP)FDKreadBits(hBs, 2);
-    mpsDataBits -= 4;
-
-    /* Set valid anc type flag, if ancType signals a payload with either header
-     * and frame or frame */
-    if (isValidAncType(pMpegSurroundDecoder, ancType)) {
-      /* Set valid anc startstop flag, if transmitted sequence is not illegal */
-      if (isValidAncStartStop(pMpegSurroundDecoder, ancStartStop)) {
-        switch (ancStartStop) {
-          case MPEGS_START:
-            /* Assuming that core coder frame size (AAC) is smaller than MPS
-               coder frame size. Save audio data for next frame. */
-            if (mpsDataBits > MPS_DATA_BUFFER_SIZE * 8) {
-              err = MPS_NOTOK;
-              goto bail;
-            }
-            for (int i = 0; i < mpsDataBits / 8; i++) {
-              pMpegSurroundDecoder->mpsData[i] = FDKreadBits(hBs, 8);
-            }
-            pMpegSurroundDecoder->mpsDataBits = mpsDataBits;
-            break;
-
-          case MPEGS_CONTINUE:
-          case MPEGS_STOP:
-            /* Assuming that core coder frame size (AAC) is smaller than MPS
-               coder frame size. Save audio data for next frame. */
-            if ((pMpegSurroundDecoder->mpsDataBits + mpsDataBits) >
-                MPS_DATA_BUFFER_SIZE * 8) {
-              err = MPS_NOTOK;
-              goto bail;
-            }
-            for (int i = 0; i < mpsDataBits / 8; i++) {
-              pMpegSurroundDecoder
-                  ->mpsData[(pMpegSurroundDecoder->mpsDataBits / 8) + i] =
-                  FDKreadBits(hBs, 8);
-            }
-            pMpegSurroundDecoder->mpsDataBits += mpsDataBits;
-            FDKinitBitStream(&mpsBsData, pMpegSurroundDecoder->mpsData,
-                             MAX_BUFSIZE_BYTES,
-                             pMpegSurroundDecoder->mpsDataBits, BS_READER);
-            hMpsBsData = &mpsBsData;
-            break;
-
-          case MPEGS_START_STOP:
-            pMpegSurroundDecoder->mpsDataBits = mpsDataBits;
-            hMpsBsData = hBs;
-            break;
-
-          default:
-            FDK_ASSERT(0);
-        }
-
-        if ((ancStartStop == MPEGS_STOP) ||
-            (ancStartStop == MPEGS_START_STOP)) {
-          switch (ancType) {
-            case MPEGS_ANCTYPE_HEADER_AND_FRAME: {
-              int parseResult, bitsRead;
-              SPATIAL_SPECIFIC_CONFIG spatialSpecificConfigTmp =
-                  pMpegSurroundDecoder->spatialSpecificConfigBackup;
-
-              /* Parse spatial specific config */
-              bitsRead = (INT)FDKgetValidBits(hMpsBsData);
-
-              err = SpatialDecParseSpecificConfigHeader(
-                  hMpsBsData,
-                  &pMpegSurroundDecoder->spatialSpecificConfigBackup, coreCodec,
-                  pMpegSurroundDecoder->upmixType);
-
-              bitsRead = (bitsRead - (INT)FDKgetValidBits(hMpsBsData));
-              parseResult = ((err == MPS_OK) ? bitsRead : -bitsRead);
-
-              if (parseResult < 0) {
-                parseResult = -parseResult;
-                err = MPS_PARSE_ERROR;
-              } else if (err == MPS_OK) {
-                /* Check SSC for consistency (e.g. bit errors could cause
-                 * trouble) */
-                err = sscCheckInBand(
-                    &pMpegSurroundDecoder->spatialSpecificConfigBackup,
-                    frameSize, sampleRate);
-              }
-              if (err != MPS_OK) {
-                pMpegSurroundDecoder->spatialSpecificConfigBackup =
-                    spatialSpecificConfigTmp;
-                break;
-              }
-
-              pMpegSurroundDecoder->mpsDataBits -= parseResult;
-
-              /* Initiate re-initialization, if header has changed */
-              if (FDK_SpatialDecCompareSpatialSpecificConfigHeader(
-                      &pMpegSurroundDecoder->spatialSpecificConfigBackup,
-                      sscParse) == MPS_UNEQUAL_SSC) {
-                pMpegSurroundDecoder
-                    ->initFlags[pMpegSurroundDecoder->bsFrameParse] |=
-                    MPEGS_INIT_CHANGE_HEADER;
-                SpatialDecInitParserContext(pMpegSurroundDecoder->pSpatialDec);
-                /* We found a valid in-band configuration. Therefore any
-                 * previous config is invalid now. */
-                pMpegSurroundDecoder->mpegSurroundSscIsGlobalCfg = 0;
-              }
-            }
-              FDK_FALLTHROUGH;
-            case MPEGS_ANCTYPE_FRAME:
-
-              if (pMpegSurroundDecoder
-                      ->initFlags[pMpegSurroundDecoder->bsFrameParse] &
-                  MPEGS_INIT_ERROR_PAYLOAD) {
-                err = MPS_PARSE_ERROR;
-                break;
-              }
-
-              /* First spatial specific config is parsed into
-               * spatialSpecificConfigBackup, second spatialSpecificConfigBackup
-               * is copied into spatialSpecificConfig[bsFrameDecode] */
-              if (pMpegSurroundDecoder
-                      ->initFlags[pMpegSurroundDecoder->bsFrameParse]) {
-                FDKmemcpy(sscParse,
-                          &pMpegSurroundDecoder->spatialSpecificConfigBackup,
-                          sizeof(SPATIAL_SPECIFIC_CONFIG));
-                pMpegSurroundDecoder
-                    ->fOnSync[pMpegSurroundDecoder->bsFrameParse] =
-                    MPEGS_SYNC_FOUND;
-              }
-
-              if (pMpegSurroundDecoder
-                      ->fOnSync[pMpegSurroundDecoder->bsFrameParse] >=
-                  MPEGS_SYNC_FOUND) {
-                int nbits = 0, bitsAvail;
-
-                if (err != MPS_OK) {
-                  break;
-                }
-
-                bitsAvail = FDKgetValidBits(hMpsBsData);
-
-                if (bitsAvail <= 0) {
-                  err = MPS_PARSE_ERROR;
-                } else {
-                  err = SpatialDecParseFrameData(
-                      pMpegSurroundDecoder->pSpatialDec, bsFrame, hMpsBsData,
-                      sscParse, (UPMIXTYPE)pMpegSurroundDecoder->upmixType,
-                      fGlobalIndependencyFlag);
-                  if (err == MPS_OK) {
-                    bsFrame->newBsData = 1;
-                  }
-                }
-
-                nbits = bitsAvail - (INT)FDKgetValidBits(hMpsBsData);
-
-                if ((nbits > bitsAvail) ||
-                    (nbits > pMpegSurroundDecoder->mpsDataBits) ||
-                    (pMpegSurroundDecoder->mpsDataBits > nbits + 7 &&
-                     !IS_LOWDELAY(coreCodec))) {
-                  bsFrame->newBsData = 0;
-                  err = MPS_PARSE_ERROR;
-                  break;
-                }
-                pMpegSurroundDecoder->mpsDataBits -= nbits;
-              }
-              break;
-
-            default: /* added to avoid compiler warning */
-              err = MPS_NOTOK;
-              break; /* added to avoid compiler warning */
-          }          /* switch (ancType) */
-
-          if (err == MPS_OK) {
-            pMpegSurroundDecoder->ancStartStopPrev = ancStartStop;
-          } else {
-            updateMpegSurroundDecoderStatus(pMpegSurroundDecoder,
-                                            MPEGS_INIT_ERROR_PAYLOAD,
-                                            MPEGS_SYNC_LOST, MPEGS_STOP);
-            pMpegSurroundDecoder->mpsDataBits = 0;
-          }
-        } /* (ancStartStop == MPEGS_STOP) || (ancStartStop == MPEGS_START_STOP)
-           */
-      }   /* validAncStartStop */
-    }     /* validAncType */
-  }
-
-bail:
-
-  *pMpsDataBits -= (mpsBsBits - (INT)FDKgetValidBits(hBs));
-
-  return err;
-}
-
-int mpegSurroundDecoder_Apply(CMpegSurroundDecoder *pMpegSurroundDecoder,
-                              INT_PCM *input, PCM_MPS *pTimeData,
-                              const int timeDataSize, int timeDataFrameSize,
-                              int *nChannels, int *frameSize, int sampleRate,
-                              AUDIO_OBJECT_TYPE coreCodec,
-                              AUDIO_CHANNEL_TYPE channelType[],
-                              UCHAR channelIndices[],
-                              const FDK_channelMapDescr *const mapDescr) {
-  SACDEC_ERROR err = MPS_OK;
-  PCM_MPS *pTimeOut = pTimeData;
-  UINT initControlFlags = 0, controlFlags = 0;
-  int timeDataRequiredSize = 0;
-  int newData;
-
-  if (pMpegSurroundDecoder == NULL) {
-    return MPS_INVALID_HANDLE;
-  }
-
-  FDK_ASSERT(pMpegSurroundDecoder->pSpatialDec);
-
-  if (!FDK_chMapDescr_isValid(mapDescr)) {
-    return MPS_INVALID_HANDLE;
-  }
-
-  if ((*nChannels <= 0) || (*nChannels > 2)) {
-    return MPS_NOTOK;
-  }
-
-  pMpegSurroundDecoder->pSpatialDec->pConfigCurrent =
-      &pMpegSurroundDecoder
-           ->spatialSpecificConfig[pMpegSurroundDecoder->bsFrameDecode];
-  newData = pMpegSurroundDecoder->bsFrames[pMpegSurroundDecoder->bsFrameParse]
-                .newBsData;
-
-  switch (mpegSurroundOperationMode(pMpegSurroundDecoder, 1000)) {
-    case MPEGS_OPMODE_MPS_PAYLOAD:
-      if (pMpegSurroundDecoder
-              ->initFlags[pMpegSurroundDecoder->bsFrameDecode]) {
-        err = initMpegSurroundDecoder(pMpegSurroundDecoder);
-      }
-
-      if (err == MPS_OK) {
-        if ((pMpegSurroundDecoder
-                 ->fOnSync[pMpegSurroundDecoder->bsFrameDecode] !=
-             MPEGS_SYNC_COMPLETE) &&
-            (pMpegSurroundDecoder->bsFrames[pMpegSurroundDecoder->bsFrameDecode]
-                 .bsIndependencyFlag == 1)) {
-          /* We got a valid header and independently decodeable frame data.
-              -> Go to the next sync level and start processing. */
-          pMpegSurroundDecoder->fOnSync[pMpegSurroundDecoder->bsFrameDecode] =
-              MPEGS_SYNC_COMPLETE;
-        }
-      } else {
-        /* We got a valid config header but found an error while parsing the
-           bitstream. Wait for the next independent frame and apply error
-           conealment in the meantime. */
-        pMpegSurroundDecoder->fOnSync[pMpegSurroundDecoder->bsFrameDecode] =
-            MPEGS_SYNC_FOUND;
-        controlFlags |= MPEGS_CONCEAL;
-        err = MPS_OK;
-      }
-      /*
-         Concealment:
-         - Bitstream is available, no sync found during bitstream processing
-         - Bitstream is available, sync lost due to corrupted bitstream
-         - Bitstream is available, sync found but no independent frame
-      */
-      if (pMpegSurroundDecoder->fOnSync[pMpegSurroundDecoder->bsFrameDecode] !=
-          MPEGS_SYNC_COMPLETE) {
-        controlFlags |= MPEGS_CONCEAL;
-      }
-      break;
-
-    case MPEGS_OPMODE_NO_MPS_PAYLOAD:
-      /* Concealment: No bitstream is available */
-      controlFlags |= MPEGS_CONCEAL;
-      break;
-
-    default:
-      err = MPS_NOTOK;
-  }
-
-  if (err != MPS_OK) {
-    goto bail;
-  }
-
-  /*
-   * Force BypassMode if choosen by user
-   */
-  if (pMpegSurroundDecoder->mpegSurroundUserParams.bypassMode) {
-    controlFlags |= MPEGS_BYPASSMODE;
-  }
-
-  if (pMpegSurroundDecoder->initFlags[pMpegSurroundDecoder->bsFrameDecode]) {
-    int startWithDfltCfg = 0;
-    /*
-     * Init with a default configuration if we came here and are still not
-     * initialized.
-     */
-    if (pMpegSurroundDecoder->initFlags[pMpegSurroundDecoder->bsFrameDecode] &
-        MPEGS_INIT_ENFORCE_REINIT) {
-      /* Get default spatial specific config */
-      if (FDK_SpatialDecInitDefaultSpatialSpecificConfig(
-              &pMpegSurroundDecoder->spatialSpecificConfigBackup, coreCodec,
-              *nChannels, sampleRate,
-              *frameSize /
-                  mpegSurroundDecoder_GetNrOfQmfBands(NULL, sampleRate),
-              pMpegSurroundDecoder->mpegSurroundDecoderLevel,
-              pMpegSurroundDecoder->mpegSurroundUserParams.blindEnable)) {
-        err = MPS_NOTOK;
-        goto bail;
-      }
-
-      /* Initiate re-initialization, if header has changed */
-      if (FDK_SpatialDecCompareSpatialSpecificConfigHeader(
-              &pMpegSurroundDecoder->spatialSpecificConfigBackup,
-              &pMpegSurroundDecoder->spatialSpecificConfig
-                   [pMpegSurroundDecoder->bsFrameDecode]) == MPS_UNEQUAL_SSC) {
-        pMpegSurroundDecoder->initFlags[pMpegSurroundDecoder->bsFrameDecode] |=
-            MPEGS_INIT_CHANGE_HEADER;
-        SpatialDecInitParserContext(pMpegSurroundDecoder->pSpatialDec);
-      }
-
-      startWithDfltCfg = 1;
-    }
-
-    /* First spatial specific config is parsed into spatialSpecificConfigBackup,
-     * second spatialSpecificConfigBackup is copied into spatialSpecificConfig
-     */
-    err = initMpegSurroundDecoder(pMpegSurroundDecoder);
-
-    if (startWithDfltCfg) {
-      /* initialized with default config, but no sync found */
-      /* maybe use updateMpegSurroundDecoderStatus later on */
-      pMpegSurroundDecoder->fOnSync[pMpegSurroundDecoder->bsFrameDecode] =
-          MPEGS_SYNC_LOST;
-    }
-
-    /* Since we do not have state MPEGS_SYNC_COMPLETE apply concealment */
-    controlFlags |= MPEGS_CONCEAL;
-
-    if (err != MPS_OK) {
-      goto bail;
-    }
-  }
-
-  /*
-   * Process MPEG Surround Audio
-   */
-  initControlFlags = controlFlags;
-
-  /* Check that provided output buffer is large enough. */
-  if (pMpegSurroundDecoder->pQmfDomain->globalConf.nBandsAnalysis == 0) {
-    err = MPS_UNSUPPORTED_FORMAT;
-    goto bail;
-  }
-  timeDataRequiredSize =
-      (timeDataFrameSize *
-       pMpegSurroundDecoder->pSpatialDec->numOutputChannelsAT *
-       pMpegSurroundDecoder->pQmfDomain->globalConf.nBandsSynthesis) /
-      pMpegSurroundDecoder->pQmfDomain->globalConf.nBandsAnalysis;
-  if (timeDataSize < timeDataRequiredSize) {
-    err = MPS_OUTPUT_BUFFER_TOO_SMALL;
-    goto bail;
-  }
-
-  if ((pMpegSurroundDecoder->pSpatialDec->pConfigCurrent->syntaxFlags &
-       SACDEC_SYNTAX_USAC) &&
-      (pMpegSurroundDecoder->pSpatialDec->stereoConfigIndex > 1)) {
-    FDK_ASSERT(timeDataRequiredSize >= timeDataFrameSize * *nChannels);
-    /* Place samples comprising QMF time slots spaced at QMF output Band raster
-     * to allow slot wise processing */
-    int timeDataFrameSizeOut =
-        (timeDataFrameSize *
-         pMpegSurroundDecoder->pQmfDomain->globalConf.nBandsSynthesis) /
-        pMpegSurroundDecoder->pQmfDomain->globalConf.nBandsAnalysis;
-    pMpegSurroundDecoder->pQmfDomain->globalConf.TDinput =
-        pTimeData + timeDataFrameSizeOut - timeDataFrameSize;
-    for (int i = *nChannels - 1; i >= 0; i--) {
-      FDKmemmove(pTimeData + (i + 1) * timeDataFrameSizeOut - timeDataFrameSize,
-                 pTimeData + timeDataFrameSize * i,
-                 sizeof(PCM_MPS) * timeDataFrameSize);
-      FDKmemclear(pTimeData + i * timeDataFrameSizeOut,
-                  sizeof(PCM_MPS) * (timeDataFrameSizeOut - timeDataFrameSize));
-    }
-  } else {
-    if (pMpegSurroundDecoder->mpegSurroundUseTimeInterface) {
-      FDKmemcpy(input, pTimeData,
-                sizeof(INT_PCM) * (*nChannels) * (*frameSize));
-      pMpegSurroundDecoder->pQmfDomain->globalConf.TDinput = input;
-    }
-  }
-
-  /*
-   * Process MPEG Surround Audio
-   */
-  err = SpatialDecApplyFrame(
-      pMpegSurroundDecoder->pSpatialDec,
-      &pMpegSurroundDecoder->bsFrames[pMpegSurroundDecoder->bsFrameDecode],
-      pMpegSurroundDecoder->mpegSurroundUseTimeInterface ? INPUTMODE_TIME
-                                                         : INPUTMODE_QMF_SBR,
-      pMpegSurroundDecoder->pQmfDomain->globalConf.TDinput, NULL, NULL,
-      pTimeOut, *frameSize, &controlFlags, *nChannels, mapDescr);
-  *nChannels = pMpegSurroundDecoder->pSpatialDec->numOutputChannelsAT;
-
-  if (err !=
-      MPS_OK) { /* A fatal error occured. Go back to start and try again: */
-    updateMpegSurroundDecoderStatus(pMpegSurroundDecoder,
-                                    MPEGS_INIT_ENFORCE_REINIT, MPEGS_SYNC_LOST,
-                                    MPEGS_STOP);
-    *frameSize =
-        0; /* Declare that framework can not use the data in pTimeOut. */
-  } else {
-    if (((controlFlags & MPEGS_CONCEAL) &&
-         !(initControlFlags & MPEGS_CONCEAL)) ||
-        (pMpegSurroundDecoder->pSpatialDec->errInt !=
-         MPS_OK)) { /* Account for errors that occured in
-                       SpatialDecApplyFrame(): */
-      updateMpegSurroundDecoderStatus(pMpegSurroundDecoder,
-                                      MPEGS_INIT_ERROR_PAYLOAD, MPEGS_SYNC_LOST,
-                                      MPEGS_STOP);
-    }
-  }
-
-  if ((err == MPS_OK) && !(controlFlags & MPEGS_BYPASSMODE) &&
-      !(pMpegSurroundDecoder->upmixType == UPMIX_TYPE_BYPASS)) {
-    SpatialDecChannelProperties(pMpegSurroundDecoder->pSpatialDec, channelType,
-                                channelIndices, mapDescr);
-  }
-
-bail:
-
-  if (newData) {
-    /* numParameterSetsPrev shall only be read in the decode process, because of
-       that we can update this state variable here */
-    pMpegSurroundDecoder->pSpatialDec->numParameterSetsPrev =
-        pMpegSurroundDecoder->bsFrames[pMpegSurroundDecoder->bsFrameDecode]
-            .numParameterSets;
-  }
-
-  return (err);
-}
-
-/**
- * \brief Free config dependent MPEG Surround memory.
- **/
-SACDEC_ERROR mpegSurroundDecoder_FreeMem(
-    CMpegSurroundDecoder *pMpegSurroundDecoder) {
-  SACDEC_ERROR err = MPS_OK;
-
-  if (pMpegSurroundDecoder != NULL) {
-    FDK_SpatialDecClose(pMpegSurroundDecoder->pSpatialDec);
-    pMpegSurroundDecoder->pSpatialDec = NULL;
-  }
-
-  return err;
-}
-
-/**
- * \brief Close MPEG Surround decoder.
- **/
-void mpegSurroundDecoder_Close(CMpegSurroundDecoder *pMpegSurroundDecoder) {
-  if (pMpegSurroundDecoder != NULL) {
-    FDK_SpatialDecClose(pMpegSurroundDecoder->pSpatialDec);
-    pMpegSurroundDecoder->pSpatialDec = NULL;
-
-    for (int i = 0; i < 1; i++) {
-      SpatialDecCloseBsFrame(&pMpegSurroundDecoder->bsFrames[i]);
-    }
-
-    FDK_FREE_MEMORY_1D(pMpegSurroundDecoder);
-  }
-}
-
-#define SACDEC_VL0 2
-#define SACDEC_VL1 0
-#define SACDEC_VL2 0
-
-int mpegSurroundDecoder_GetLibInfo(LIB_INFO *info) {
-  int i;
-
-  if (info == NULL) {
-    return -1;
-  }
-
-  /* search for next free tab */
-  for (i = 0; i < FDK_MODULE_LAST; i++) {
-    if (info[i].module_id == FDK_NONE) break;
-  }
-  if (i == FDK_MODULE_LAST) return -1;
-
-  info += i;
-
-  info->module_id = FDK_MPSDEC;
-#ifdef __ANDROID__
-  info->build_date = "";
-  info->build_time = "";
-#else
-  info->build_date = __DATE__;
-  info->build_time = __TIME__;
-#endif
-  info->title = "MPEG Surround Decoder";
-  info->version = LIB_VERSION(SACDEC_VL0, SACDEC_VL1, SACDEC_VL2);
-  LIB_VERSION_STRING(info);
-  info->flags = 0 | CAPF_MPS_LD | CAPF_MPS_USAC | CAPF_MPS_HQ |
-                CAPF_MPS_1CH_IN | CAPF_MPS_2CH_OUT; /* end flags */
-
-  return 0;
-}
-
-SACDEC_ERROR mpegSurroundDecoder_SetParam(
-    CMpegSurroundDecoder *pMpegSurroundDecoder, const SACDEC_PARAM param,
-    const INT value) {
-  SACDEC_ERROR err = MPS_OK;
-  SPATIALDEC_PARAM *pUserParams = NULL;
-
-  /* check decoder handle */
-  if (pMpegSurroundDecoder != NULL) {
-    /* init local shortcuts */
-    pUserParams = &pMpegSurroundDecoder->mpegSurroundUserParams;
-  } else {
-    err = MPS_INVALID_HANDLE;
-    /* check the parameter values before exiting. */
-  }
-
-  /* apply param value */
-  switch (param) {
-    case SACDEC_OUTPUT_MODE:
-      switch ((SAC_DEC_OUTPUT_MODE)value) {
-        case SACDEC_OUT_MODE_NORMAL:
-        case SACDEC_OUT_MODE_STEREO:
-          break;
-        default:
-          err = MPS_INVALID_PARAMETER;
-      }
-      if (err == MPS_OK) {
-        if (0) {
-          err = MPS_INVALID_PARAMETER;
-        } else if (pUserParams->outputMode != (UCHAR)value) {
-          pUserParams->outputMode = (UCHAR)value;
-          pMpegSurroundDecoder
-              ->initFlags[pMpegSurroundDecoder->bsFrameDecode] |=
-              MPEGS_INIT_CHANGE_OUTPUT_MODE;
-        }
-      }
-      break;
-
-    case SACDEC_INTERFACE:
-      if (value < 0 || value > 1) {
-        err = MPS_INVALID_PARAMETER;
-      }
-      if (err != MPS_OK) {
-        goto bail;
-      }
-      if (pMpegSurroundDecoder->mpegSurroundUseTimeInterface != (UCHAR)value) {
-        pMpegSurroundDecoder->mpegSurroundUseTimeInterface = (UCHAR)value;
-        pMpegSurroundDecoder->initFlags[pMpegSurroundDecoder->bsFrameDecode] |=
-            MPEGS_INIT_CHANGE_TIME_FREQ_INTERFACE;
-      }
-      break;
-
-    case SACDEC_BS_INTERRUPTION:
-      if ((err == MPS_OK) && (value != 0)) {
-        updateMpegSurroundDecoderStatus(pMpegSurroundDecoder,
-                                        MPEGS_INIT_BS_INTERRUPTION,
-                                        MPEGS_SYNC_LOST, MPEGS_STOP);
-      }
-      break;
-
-    case SACDEC_CLEAR_HISTORY:
-      if ((err == MPS_OK) && (value != 0)) {
-        /* Just reset the states and go on. */
-        updateMpegSurroundDecoderStatus(pMpegSurroundDecoder,
-                                        MPEGS_INIT_CLEAR_HISTORY,
-                                        MPEGS_SYNC_LOST, MPEGS_STOP);
-      }
-      break;
-
-    case SACDEC_CONCEAL_NUM_KEEP_FRAMES:
-      if (value < 0) { /* Check valid value range */
-        err = MPS_INVALID_PARAMETER;
-      }
-      if (err != MPS_OK) {
-        goto bail;
-      }
-      if (pUserParams->concealNumKeepFrames != (UINT)value) {
-        pUserParams->concealNumKeepFrames = (UINT)value;
-        pMpegSurroundDecoder->initFlags[pMpegSurroundDecoder->bsFrameDecode] |=
-            MPEGS_INIT_CHANGE_CONCEAL_PARAMS;
-      }
-      break;
-
-    case SACDEC_CONCEAL_FADE_OUT_SLOPE_LENGTH:
-      if (value < 0) { /* Check valid value range */
-        err = MPS_INVALID_PARAMETER;
-      }
-      if (err != MPS_OK) {
-        goto bail;
-      }
-      if (pUserParams->concealFadeOutSlopeLength != (UINT)value) {
-        pUserParams->concealFadeOutSlopeLength = (UINT)value;
-        pMpegSurroundDecoder->initFlags[pMpegSurroundDecoder->bsFrameDecode] |=
-            MPEGS_INIT_CHANGE_CONCEAL_PARAMS;
-      }
-      break;
-
-    case SACDEC_CONCEAL_FADE_IN_SLOPE_LENGTH:
-      if (value < 0) { /* Check valid value range */
-        err = MPS_INVALID_PARAMETER;
-      }
-      if (err != MPS_OK) {
-        goto bail;
-      }
-      if (pUserParams->concealFadeInSlopeLength != (UINT)value) {
-        pUserParams->concealFadeInSlopeLength = (UINT)value;
-        pMpegSurroundDecoder->initFlags[pMpegSurroundDecoder->bsFrameDecode] |=
-            MPEGS_INIT_CHANGE_CONCEAL_PARAMS;
-      }
-      break;
-
-    case SACDEC_CONCEAL_NUM_RELEASE_FRAMES:
-      if (value < 0) { /* Check valid value range */
-        err = MPS_INVALID_PARAMETER;
-      }
-      if (err != MPS_OK) {
-        goto bail;
-      }
-      if (pUserParams->concealNumReleaseFrames != (UINT)value) {
-        pUserParams->concealNumReleaseFrames = (UINT)value;
-        pMpegSurroundDecoder->initFlags[pMpegSurroundDecoder->bsFrameDecode] |=
-            MPEGS_INIT_CHANGE_CONCEAL_PARAMS;
-      }
-      break;
-
-    default:
-      err = MPS_INVALID_PARAMETER;
-      break;
-  } /* switch(param) */
-
-bail:
-  return err;
-}
-
-SACDEC_ERROR mpegSurroundDecoder_IsPseudoLR(
-    CMpegSurroundDecoder *pMpegSurroundDecoder, int *bsPseudoLr) {
-  if (pMpegSurroundDecoder != NULL) {
-    const SPATIAL_SPECIFIC_CONFIG *sscDecode =
-        &pMpegSurroundDecoder
-             ->spatialSpecificConfig[pMpegSurroundDecoder->bsFrameDecode];
-    *bsPseudoLr = (int)sscDecode->bsPseudoLr;
-    return MPS_OK;
-  } else
-    return MPS_INVALID_HANDLE;
-}
-
-/**
- * \brief Get the signal delay caused by the MPEG Surround decoder module.
- **/
-UINT mpegSurroundDecoder_GetDelay(const CMpegSurroundDecoder *self) {
-  INT outputDelay = 0;
-
-  if (self != NULL) {
-    const SPATIAL_SPECIFIC_CONFIG *sscDecode =
-        &self->spatialSpecificConfig[self->bsFrameDecode];
-    AUDIO_OBJECT_TYPE coreCodec = sscDecode->coreCodec;
-
-    /* See chapter 4.5 (delay and synchronization) of ISO/IEC FDIS 23003-1 and
-       chapter 5.4.3 of ISO/IEC FDIS 23003-2 for details on the following
-       figures. */
-
-    if (coreCodec > AOT_NULL_OBJECT) {
-      if (IS_LOWDELAY(coreCodec)) {
-        /* All low delay variants (ER-AAC-(E)LD): */
-        outputDelay += 256;
-      } else if (!IS_USAC(coreCodec)) {
-        /* By the method of elimination this is the GA (AAC-LC, HE-AAC, ...)
-         * branch: */
-        outputDelay += 320 + 257; /* cos to exp delay + QMF synthesis */
-        if (self->mpegSurroundUseTimeInterface) {
-          outputDelay += 320 + 384; /* QMF and hybrid analysis */
-        }
-      }
-    }
-  }
-
-  return (outputDelay);
-}
--- a/libSACdec/src/sac_dec_ssc_struct.h
+++ /dev/null
@@ -1,283 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround decoder library *************************
-
-   Author(s):
-
-   Description: interface - spatial specific config struct
-
-*******************************************************************************/
-
-#ifndef SAC_DEC_SSC_STRUCT_H
-#define SAC_DEC_SSC_STRUCT_H
-
-#include "FDK_audio.h"
-
-#define MAX_NUM_QMF_BANDS (128)
-#define MAX_TIME_SLOTS 64
-#define MAX_INPUT_CHANNELS 1
-#define MAX_OUTPUT_CHANNELS                                             \
-  2 /* CAUTION: This does NOT restrict the number of                    \
-                            output channels exclusively! In addition it \
-       affects the max number of bitstream and residual channels! */
-#define MAX_NUM_OTT (5)
-#define MAX_NUM_TTT (0)
-#define MAX_NUM_EXT_TYPES (8)
-#define MAX_PARAMETER_BANDS (28)
-#define MAX_PARAMETER_BANDS_LD (23)
-
-#define MAX_NUM_XCHANNELS (6)
-
-#define MAX_ARBITRARY_TREE_LEVELS (0)
-
-typedef enum {
-  /* CAUTION: Do not change enum values! */
-  SPATIALDEC_FREQ_RES_40 = 40,
-  SPATIALDEC_FREQ_RES_28 = 28,
-  SPATIALDEC_FREQ_RES_23 = 23,
-  SPATIALDEC_FREQ_RES_20 = 20,
-  SPATIALDEC_FREQ_RES_15 = 15,
-  SPATIALDEC_FREQ_RES_14 = 14,
-  SPATIALDEC_FREQ_RES_12 = 12,
-  SPATIALDEC_FREQ_RES_10 = 10,
-  SPATIALDEC_FREQ_RES_9 = 9,
-  SPATIALDEC_FREQ_RES_7 = 7,
-  SPATIALDEC_FREQ_RES_5 = 5,
-  SPATIALDEC_FREQ_RES_4 = 4
-
-} SPATIALDEC_FREQ_RES;
-
-typedef enum {
-
-  SPATIALDEC_QUANT_FINE_DEF = 0,
-  SPATIALDEC_QUANT_EDQ1 = 1,
-  SPATIALDEC_QUANT_EDQ2 = 2,
-  SPATIALDEC_QUANT_RSVD3 = 3,
-  SPATIALDEC_QUANT_RSVD4 = 4,
-  SPATIALDEC_QUANT_RSVD5 = 5,
-  SPATIALDEC_QUANT_RSVD6 = 6,
-  SPATIALDEC_QUANT_RSVD7 = 7
-
-} SPATIALDEC_QUANT_MODE;
-
-typedef enum { SPATIALDEC_MODE_RSVD7 = 7 } SPATIALDEC_TREE_CONFIG;
-
-typedef enum {
-
-  SPATIALDEC_GAIN_MODE0 = 0,
-  SPATIALDEC_GAIN_RSVD1 = 1,
-  SPATIALDEC_GAIN_RSVD2 = 2,
-  SPATIALDEC_GAIN_RSVD3 = 3,
-  SPATIALDEC_GAIN_RSVD4 = 4,
-  SPATIALDEC_GAIN_RSVD5 = 5,
-  SPATIALDEC_GAIN_RSVD6 = 6,
-  SPATIALDEC_GAIN_RSVD7 = 7,
-  SPATIALDEC_GAIN_RSVD8 = 8,
-  SPATIALDEC_GAIN_RSVD9 = 9,
-  SPATIALDEC_GAIN_RSVD10 = 10,
-  SPATIALDEC_GAIN_RSVD11 = 11,
-  SPATIALDEC_GAIN_RSVD12 = 12,
-  SPATIALDEC_GAIN_RSVD13 = 13,
-  SPATIALDEC_GAIN_RSVD14 = 14,
-  SPATIALDEC_GAIN_RSVD15 = 15
-
-} SPATIALDEC_FIXED_GAINS;
-
-typedef enum {
-
-  SPATIALDEC_TS_TPNOWHITE = 0,
-  SPATIALDEC_TS_TPWHITE = 1,
-  SPATIALDEC_TS_TES = 2,
-  SPATIALDEC_TS_NOTS = 3,
-  SPATIALDEC_TS_RSVD4 = 4,
-  SPATIALDEC_TS_RSVD5 = 5,
-  SPATIALDEC_TS_RSVD6 = 6,
-  SPATIALDEC_TS_RSVD7 = 7,
-  SPATIALDEC_TS_RSVD8 = 8,
-  SPATIALDEC_TS_RSVD9 = 9,
-  SPATIALDEC_TS_RSVD10 = 10,
-  SPATIALDEC_TS_RSVD11 = 11,
-  SPATIALDEC_TS_RSVD12 = 12,
-  SPATIALDEC_TS_RSVD13 = 13,
-  SPATIALDEC_TS_RSVD14 = 14,
-  SPATIALDEC_TS_RSVD15 = 15
-
-} SPATIALDEC_TS_CONF;
-
-typedef enum {
-
-  SPATIALDEC_DECORR_MODE0 = 0,
-  SPATIALDEC_DECORR_MODE1 = 1,
-  SPATIALDEC_DECORR_MODE2 = 2,
-  SPATIALDEC_DECORR_RSVD3 = 3,
-  SPATIALDEC_DECORR_RSVD4 = 4,
-  SPATIALDEC_DECORR_RSVD5 = 5,
-  SPATIALDEC_DECORR_RSVD6 = 6,
-  SPATIALDEC_DECORR_RSVD7 = 7,
-  SPATIALDEC_DECORR_RSVD8 = 8,
-  SPATIALDEC_DECORR_RSVD9 = 9,
-  SPATIALDEC_DECORR_RSVD10 = 10,
-  SPATIALDEC_DECORR_RSVD11 = 11,
-  SPATIALDEC_DECORR_RSVD12 = 12,
-  SPATIALDEC_DECORR_RSVD13 = 13,
-  SPATIALDEC_DECORR_RSVD14 = 14,
-  SPATIALDEC_DECORR_RSVD15 = 15
-
-} SPATIALDEC_DECORR_CONF;
-
-typedef struct T_SPATIALDEC_OTT_CONF {
-  int nOttBands;
-
-} SPATIALDEC_OTT_CONF;
-
-typedef struct T_SPATIALDEC_RESIDUAL_CONF {
-  int bResidualPresent;
-  int nResidualBands;
-
-} SPATIALDEC_RESIDUAL_CONF;
-
-typedef struct T_SPATIAL_SPECIFIC_CONFIG {
-  UINT syntaxFlags;
-  int samplingFreq;
-  int nTimeSlots;
-  SPATIALDEC_FREQ_RES freqRes;
-  SPATIALDEC_TREE_CONFIG treeConfig;
-  SPATIALDEC_QUANT_MODE quantMode;
-  int bArbitraryDownmix;
-
-  int bResidualCoding;
-  SPATIALDEC_FIXED_GAINS bsFixedGainDMX;
-
-  SPATIALDEC_TS_CONF tempShapeConfig;
-  SPATIALDEC_DECORR_CONF decorrConfig;
-
-  int nInputChannels;  /* derived from  treeConfig */
-  int nOutputChannels; /* derived from  treeConfig */
-
-  /* ott config */
-  int nOttBoxes;                              /* derived from  treeConfig */
-  SPATIALDEC_OTT_CONF OttConfig[MAX_NUM_OTT]; /* dimension nOttBoxes */
-
-  /* ttt config */
-  int nTttBoxes; /* derived from  treeConfig */
-
-  /* residual config */
-  SPATIALDEC_RESIDUAL_CONF
-  ResidualConfig[MAX_NUM_OTT +
-                 MAX_NUM_TTT]; /* dimension (nOttBoxes + nTttBoxes) */
-
-  int sacExtCnt;
-  int sacExtType[MAX_NUM_EXT_TYPES];
-  int envQuantMode;
-
-  AUDIO_OBJECT_TYPE coreCodec;
-
-  UCHAR stereoConfigIndex;
-  UCHAR coreSbrFrameLengthIndex; /* Table 70 in ISO/IEC FDIS 23003-3:2011 */
-  UCHAR bsHighRateMode;
-  UCHAR bsDecorrType;
-  UCHAR bsPseudoLr;
-  UCHAR bsPhaseCoding;
-  UCHAR bsOttBandsPhasePresent;
-  int bsOttBandsPhase;
-
-  SCHAR ottCLDdefault[MAX_NUM_OTT];
-  UCHAR numOttBandsIPD;
-  UCHAR bitstreamOttBands[MAX_NUM_OTT];
-  UCHAR numOttBands[MAX_NUM_OTT];
-
-} SPATIAL_SPECIFIC_CONFIG;
-
-#endif
--- a/libSACdec/src/sac_process.cpp
+++ /dev/null
@@ -1,1066 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround decoder library *************************
-
-   Author(s):
-
-   Description: SAC Processing
-
-*******************************************************************************/
-
-/* data structures and interfaces for spatial audio reference software */
-#include "sac_process.h"
-
-#include "sac_bitdec.h"
-#include "sac_calcM1andM2.h"
-#include "sac_smoothing.h"
-#include "sac_rom.h"
-
-#include "sac_dec_errorcodes.h"
-
-#include "FDK_trigFcts.h"
-#include "FDK_decorrelate.h"
-
-/**
- * \brief  Linear interpolation between two parameter values.
- *         a*alpha + b*(1-alpha)
- *       = a*alpha + b - b*alpha
- *
- * \param alpha               Weighting factor.
- * \param a                   Parameter a.
- * \param b                   Parameter b.
- *
- * \return Interpolated parameter value.
- */
-FDK_INLINE FIXP_DBL interpolateParameter(const FIXP_SGL alpha, const FIXP_DBL a,
-                                         const FIXP_DBL b) {
-  return (b - fMult(alpha, b) + fMult(alpha, a));
-}
-
-/**
- * \brief Map MPEG Surround channel indices to MPEG 4 PCE like channel indices.
- * \param self Spatial decoder handle.
- * \param ch MPEG Surround channel index.
- * \return MPEG 4 PCE style channel index, corresponding to the given MPEG
- * Surround channel index.
- */
-static UINT mapChannel(spatialDec *self, UINT ch) {
-  static const UCHAR chanelIdx[][8] = {
-      {0, 1, 2, 3, 4, 5, 6, 7}, /*  binaural, TREE_212, arbitrary tree */
-  };
-
-  int idx = 0;
-
-  return (chanelIdx[idx][ch]);
-}
-
-FIXP_DBL getChGain(spatialDec *self, UINT ch, INT *scale) {
-  /* init no gain modifier */
-  FIXP_DBL gain = 0x80000000;
-  *scale = 0;
-
-  if ((!isTwoChMode(self->upmixType)) &&
-      (self->upmixType != UPMIXTYPE_BYPASS)) {
-    if ((ch == 0) || (ch == 1) || (ch == 2)) {
-      /* no modifier */
-    }
-  }
-
-  return gain;
-}
-
-SACDEC_ERROR SpatialDecQMFAnalysis(spatialDec *self, const PCM_MPS *inData,
-                                   const INT ts, const INT bypassMode,
-                                   FIXP_DBL **qmfReal, FIXP_DBL **qmfImag,
-                                   const int numInputChannels) {
-  SACDEC_ERROR err = MPS_OK;
-  int ch, offset;
-
-  offset = self->pQmfDomain->globalConf.nBandsSynthesis *
-           self->pQmfDomain->globalConf.nQmfTimeSlots;
-
-  {
-    for (ch = 0; ch < numInputChannels; ch++) {
-      const PCM_MPS *inSamples =
-          &inData[ts * self->pQmfDomain->globalConf.nBandsAnalysis];
-      FIXP_DBL *pQmfRealAnalysis = qmfReal[ch]; /* no delay in blind mode */
-      FIXP_DBL *pQmfImagAnalysis = qmfImag[ch];
-
-      CalculateSpaceAnalysisQmf(&self->pQmfDomain->QmfDomainIn[ch].fb,
-                                inSamples + (ch * offset), pQmfRealAnalysis,
-                                pQmfImagAnalysis);
-
-      if (!isTwoChMode(self->upmixType) && !bypassMode) {
-        int i;
-        for (i = 0; i < self->qmfBands; i++) {
-          qmfReal[ch][i] = fMult(qmfReal[ch][i], self->clipProtectGain__FDK);
-          qmfImag[ch][i] = fMult(qmfImag[ch][i], self->clipProtectGain__FDK);
-        }
-      }
-    }
-  }
-
-  self->qmfInputDelayBufPos =
-      (self->qmfInputDelayBufPos + 1) % self->pc_filterdelay;
-
-  return err;
-}
-
-SACDEC_ERROR SpatialDecFeedQMF(spatialDec *self, FIXP_DBL **qmfInDataReal,
-                               FIXP_DBL **qmfInDataImag, const INT ts,
-                               const INT bypassMode, FIXP_DBL **qmfReal__FDK,
-                               FIXP_DBL **qmfImag__FDK,
-                               const INT numInputChannels) {
-  SACDEC_ERROR err = MPS_OK;
-  int ch;
-
-  {
-    for (ch = 0; ch < numInputChannels; ch++) {
-      FIXP_DBL *pQmfRealAnalysis =
-          qmfReal__FDK[ch]; /* no delay in blind mode */
-      FIXP_DBL *pQmfImagAnalysis = qmfImag__FDK[ch];
-
-      /* Write Input data to pQmfRealAnalysis. */
-      if (self->bShareDelayWithSBR) {
-        FDK_QmfDomain_GetSlot(
-            &self->pQmfDomain->QmfDomainIn[ch], ts + HYBRID_FILTER_DELAY, 0,
-            MAX_QMF_BANDS_TO_HYBRID, pQmfRealAnalysis, pQmfImagAnalysis, 15);
-        FDK_QmfDomain_GetSlot(&self->pQmfDomain->QmfDomainIn[ch], ts,
-                              MAX_QMF_BANDS_TO_HYBRID, self->qmfBands,
-                              pQmfRealAnalysis, pQmfImagAnalysis, 15);
-      } else {
-        FDK_QmfDomain_GetSlot(&self->pQmfDomain->QmfDomainIn[ch], ts, 0,
-                              self->qmfBands, pQmfRealAnalysis,
-                              pQmfImagAnalysis, 15);
-      }
-      if (ts == self->pQmfDomain->globalConf.nQmfTimeSlots - 1) {
-        /* Is currently also needed in case we dont have any overlap. We need to
-         * save lb_scale to ov_lb_scale */
-        FDK_QmfDomain_SaveOverlap(&self->pQmfDomain->QmfDomainIn[ch], 0);
-      }
-
-      /* Apply clip protection to output. */
-      if (!isTwoChMode(self->upmixType) && !bypassMode) {
-        int i;
-        for (i = 0; i < self->qmfBands; i++) {
-          qmfReal__FDK[ch][i] =
-              fMult(qmfReal__FDK[ch][i], self->clipProtectGain__FDK);
-          qmfImag__FDK[ch][i] =
-              fMult(qmfImag__FDK[ch][i], self->clipProtectGain__FDK);
-        }
-      }
-
-    } /* End of loop over numInputChannels */
-  }
-
-  self->qmfInputDelayBufPos =
-      (self->qmfInputDelayBufPos + 1) % self->pc_filterdelay;
-
-  return err;
-}
-
-/*******************************************************************************
- Functionname: SpatialDecHybridAnalysis
- *******************************************************************************
-
- Description:
-
- Arguments:
-
- Input:
-  float** pointers[4] leftReal, leftIm, rightReal, rightIm
-
- Output:
-  float self->qmfInputReal[MAX_INPUT_CHANNELS][MAX_TIME_SLOTS][MAX_QMF_BANDS];
-  float self->qmfInputImag[MAX_INPUT_CHANNELS][MAX_TIME_SLOTS][MAX_QMF_BANDS];
-
-  float
-self->hybInputReal[MAX_INPUT_CHANNELS][MAX_TIME_SLOTS][MAX_HYBRID_BANDS]; float
-self->hybInputImag[MAX_INPUT_CHANNELS][MAX_TIME_SLOTS][MAX_HYBRID_BANDS];
-
-
-*******************************************************************************/
-SACDEC_ERROR SpatialDecHybridAnalysis(spatialDec *self, FIXP_DBL **qmfInputReal,
-                                      FIXP_DBL **qmfInputImag,
-                                      FIXP_DBL **hybOutputReal,
-                                      FIXP_DBL **hybOutputImag, const INT ts,
-                                      const INT numInputChannels) {
-  SACDEC_ERROR err = MPS_OK;
-  int ch;
-
-  for (ch = 0; ch < numInputChannels;
-       ch++) /* hybrid filtering for down-mix signals */
-  {
-    if (self->pConfigCurrent->syntaxFlags & SACDEC_SYNTAX_LD) {
-      int k;
-      /* No hybrid filtering. Just copy the QMF data. */
-      for (k = 0; k < self->hybridBands; k += 1) {
-        hybOutputReal[ch][k] = qmfInputReal[ch][k];
-        hybOutputImag[ch][k] = qmfInputImag[ch][k];
-      }
-    } else {
-      self->hybridAnalysis[ch].hfMode = self->bShareDelayWithSBR;
-
-      if (self->stereoConfigIndex == 3)
-        FDK_ASSERT(self->hybridAnalysis[ch].hfMode == 0);
-      FDKhybridAnalysisApply(&self->hybridAnalysis[ch], qmfInputReal[ch],
-                             qmfInputImag[ch], hybOutputReal[ch],
-                             hybOutputImag[ch]);
-    }
-  }
-
-  if ((self->pConfigCurrent->syntaxFlags & SACDEC_SYNTAX_USAC) &&
-      self->residualCoding) {
-    self->hybridAnalysis[numInputChannels].hfMode = 0;
-    FDKhybridAnalysisApply(
-        &self->hybridAnalysis[numInputChannels],
-        self->qmfResidualReal__FDK[0][0], self->qmfResidualImag__FDK[0][0],
-        self->hybResidualReal__FDK[0], self->hybResidualImag__FDK[0]);
-  }
-
-  return err;
-}
-
-SACDEC_ERROR SpatialDecCreateX(spatialDec *self, FIXP_DBL **hybInputReal,
-                               FIXP_DBL **hybInputImag, FIXP_DBL **pxReal,
-                               FIXP_DBL **pxImag) {
-  SACDEC_ERROR err = MPS_OK;
-  int row;
-
-  /* Creating wDry */
-  for (row = 0; row < self->numInputChannels; row++) {
-    /* pointer to direct signals */
-    pxReal[row] = hybInputReal[row];
-    pxImag[row] = hybInputImag[row];
-  }
-
-  return err;
-}
-
-static void M2ParamToKernelMult(FIXP_SGL *RESTRICT pKernel,
-                                FIXP_DBL *RESTRICT Mparam,
-                                FIXP_DBL *RESTRICT MparamPrev,
-                                int *RESTRICT pWidth, FIXP_SGL alpha__FDK,
-                                int nBands) {
-  int pb;
-
-  for (pb = 0; pb < nBands; pb++) {
-    FIXP_SGL tmp = FX_DBL2FX_SGL(
-        interpolateParameter(alpha__FDK, Mparam[pb], MparamPrev[pb]));
-
-    int i = pWidth[pb];
-    if (i & 1) *pKernel++ = tmp;
-    if (i & 2) {
-      *pKernel++ = tmp;
-      *pKernel++ = tmp;
-    }
-    for (i >>= 2; i--;) {
-      *pKernel++ = tmp;
-      *pKernel++ = tmp;
-      *pKernel++ = tmp;
-      *pKernel++ = tmp;
-    }
-  }
-}
-
-SACDEC_ERROR SpatialDecApplyM1_CreateW_Mode212(
-    spatialDec *self, const SPATIAL_BS_FRAME *frame, FIXP_DBL **xReal,
-    FIXP_DBL **xImag, FIXP_DBL **vReal, FIXP_DBL **vImag) {
-  SACDEC_ERROR err = MPS_OK;
-  int res;
-  FIXP_DBL *decorrInReal = vReal[0];
-  FIXP_DBL *decorrInImag = vImag[0];
-
-  /* M1 does not do anything in 212 mode, so use simplified processing */
-  FDK_ASSERT(self->numVChannels == 2);
-  FDK_ASSERT(self->numDirektSignals == 1);
-  FDK_ASSERT(self->numDecorSignals == 1);
-  FDKmemcpy(vReal[0], xReal[0], self->hybridBands * sizeof(FIXP_DBL));
-  FDKmemcpy(vImag[0], xImag[0], self->hybridBands * sizeof(FIXP_DBL));
-
-  if (isTsdActive(frame->TsdData)) {
-    /* Generate v_{x,nonTr} as input for allpass based decorrelator */
-    TsdGenerateNonTr(self->hybridBands, frame->TsdData, self->TsdTs, vReal[0],
-                     vImag[0], vReal[1], vImag[1], &decorrInReal,
-                     &decorrInImag);
-  }
-  /* - Decorrelate */
-  res = SpatialDecGetResidualIndex(self, 1);
-  if (FDKdecorrelateApply(&self->apDecor[0], decorrInReal, decorrInImag,
-                          vReal[1], vImag[1],
-                          self->param2hyb[self->residualBands[res]])) {
-    return MPS_NOTOK;
-  }
-  if (isTsdActive(frame->TsdData)) {
-    /* Generate v_{x,Tr}, apply transient decorrelator and add to allpass based
-     * decorrelator output */
-    TsdApply(self->hybridBands, frame->TsdData, &self->TsdTs,
-             vReal[0], /* input: v_x */
-             vImag[0],
-             vReal[1], /* input: d_{x,nonTr}; output: d_{x,nonTr} + d_{x,Tr} */
-             vImag[1]);
-  }
-
-  /* Write residual signal in approriate parameter bands */
-  if (self->residualBands[res] > 0) {
-    int stopBand = self->param2hyb[self->residualBands[res]];
-    FDKmemcpy(vReal[1], self->hybResidualReal__FDK[res],
-              fixMin(stopBand, self->hybridBands) * sizeof(FIXP_DBL));
-    FDKmemcpy(vImag[1], self->hybResidualImag__FDK[res],
-              fixMin(stopBand, self->hybridBands) * sizeof(FIXP_DBL));
-  } /* (self->residualBands[res]>0) */
-
-  return err;
-}
-
-SACDEC_ERROR SpatialDecApplyM2_Mode212(spatialDec *self, INT ps,
-                                       const FIXP_SGL alpha, FIXP_DBL **wReal,
-                                       FIXP_DBL **wImag,
-                                       FIXP_DBL **hybOutputRealDry,
-                                       FIXP_DBL **hybOutputImagDry) {
-  SACDEC_ERROR err = MPS_OK;
-  INT row;
-
-  INT *pWidth = self->kernels_width;
-  /* for stereoConfigIndex == 3 case hybridBands is < 71 */
-  INT pb_max = self->kernels[self->hybridBands - 1] + 1;
-  INT max_row = self->numOutputChannels;
-
-  INT M2_exp = 0;
-  if (self->residualCoding) M2_exp = 3;
-
-  for (row = 0; row < max_row; row++)  // 2 times
-  {
-    FIXP_DBL *Mparam0 = self->M2Real__FDK[row][0];
-    FIXP_DBL *Mparam1 = self->M2Real__FDK[row][1];
-    FIXP_DBL *MparamPrev0 = self->M2RealPrev__FDK[row][0];
-    FIXP_DBL *MparamPrev1 = self->M2RealPrev__FDK[row][1];
-
-    FIXP_DBL *RESTRICT pHybOutRealDry = hybOutputRealDry[row];
-    FIXP_DBL *RESTRICT pHybOutImagDry = hybOutputImagDry[row];
-
-    FIXP_DBL *RESTRICT pWReal0 = wReal[0];
-    FIXP_DBL *RESTRICT pWReal1 = wReal[1];
-    FIXP_DBL *RESTRICT pWImag0 = wImag[0];
-    FIXP_DBL *RESTRICT pWImag1 = wImag[1];
-    for (INT pb = 0; pb < pb_max; pb++) {
-      FIXP_DBL tmp0, tmp1;
-
-      tmp0 = interpolateParameter(alpha, Mparam0[pb], MparamPrev0[pb]);
-      tmp1 = interpolateParameter(alpha, Mparam1[pb], MparamPrev1[pb]);
-
-      INT i = pWidth[pb];
-
-      do  // about 3-4 times
-      {
-        FIXP_DBL var0, var1, real, imag;
-
-        var0 = *pWReal0++;
-        var1 = *pWReal1++;
-        real = fMultDiv2(var0, tmp0);
-        var0 = *pWImag0++;
-        real = fMultAddDiv2(real, var1, tmp1);
-        var1 = *pWImag1++;
-        imag = fMultDiv2(var0, tmp0);
-        *pHybOutRealDry++ = real << (1 + M2_exp);
-        imag = fMultAddDiv2(imag, var1, tmp1);
-        *pHybOutImagDry++ = imag << (1 + M2_exp);
-      } while (--i != 0);
-    }
-  }
-  return err;
-}
-
-SACDEC_ERROR SpatialDecApplyM2_Mode212_ResidualsPlusPhaseCoding(
-    spatialDec *self, INT ps, const FIXP_SGL alpha, FIXP_DBL **wReal,
-    FIXP_DBL **wImag, FIXP_DBL **hybOutputRealDry,
-    FIXP_DBL **hybOutputImagDry) {
-  SACDEC_ERROR err = MPS_OK;
-  INT row;
-  INT scale_param_m2;
-  INT *pWidth = self->kernels_width;
-  INT pb_max = self->kernels[self->hybridBands - 1] + 1;
-
-  scale_param_m2 = SCALE_PARAM_M2_212_PRED + SCALE_DATA_APPLY_M2;
-
-  for (row = 0; row < self->numM2rows; row++) {
-    INT qs, pb;
-
-    FIXP_DBL *RESTRICT pWReal0 = wReal[0];
-    FIXP_DBL *RESTRICT pWImag0 = wImag[0];
-    FIXP_DBL *RESTRICT pWReal1 = wReal[1];
-    FIXP_DBL *RESTRICT pWImag1 = wImag[1];
-
-    FIXP_DBL *MReal0 = self->M2Real__FDK[row][0];
-    FIXP_DBL *MImag0 = self->M2Imag__FDK[row][0];
-    FIXP_DBL *MReal1 = self->M2Real__FDK[row][1];
-    FIXP_DBL *MRealPrev0 = self->M2RealPrev__FDK[row][0];
-    FIXP_DBL *MImagPrev0 = self->M2ImagPrev__FDK[row][0];
-    FIXP_DBL *MRealPrev1 = self->M2RealPrev__FDK[row][1];
-
-    FIXP_DBL *RESTRICT pHybOutRealDry = hybOutputRealDry[row];
-    FIXP_DBL *RESTRICT pHybOutImagDry = hybOutputImagDry[row];
-
-    FDK_ASSERT(!(self->pConfigCurrent->syntaxFlags & SACDEC_SYNTAX_LD));
-    FDK_ASSERT((pWidth[0] + pWidth[1]) >= 3);
-
-    for (pb = 0, qs = 3; pb < 2; pb++) {
-      INT s;
-      FIXP_DBL maxVal;
-      FIXP_SGL mReal1;
-      FIXP_SGL mReal0, mImag0;
-      FIXP_DBL iReal0, iImag0, iReal1;
-
-      iReal0 = interpolateParameter(alpha, MReal0[pb], MRealPrev0[pb]);
-      iImag0 = -interpolateParameter(alpha, MImag0[pb], MImagPrev0[pb]);
-      iReal1 = interpolateParameter(alpha, MReal1[pb], MRealPrev1[pb]);
-
-      maxVal = fAbs(iReal0) | fAbs(iImag0);
-      maxVal |= fAbs(iReal1);
-
-      s = fMax(CntLeadingZeros(maxVal) - 1, 0);
-      s = fMin(s, scale_param_m2);
-
-      mReal0 = FX_DBL2FX_SGL(iReal0 << s);
-      mImag0 = FX_DBL2FX_SGL(iImag0 << s);
-      mReal1 = FX_DBL2FX_SGL(iReal1 << s);
-
-      s = scale_param_m2 - s;
-
-      INT i = pWidth[pb];
-
-      do {
-        FIXP_DBL real, imag, wReal0, wImag0, wReal1, wImag1;
-
-        wReal0 = *pWReal0++;
-        wImag0 = *pWImag0++;
-        wReal1 = *pWReal1++;
-        wImag1 = *pWImag1++;
-
-        cplxMultDiv2(&real, &imag, wReal0, wImag0, mReal0, mImag0);
-
-        *pHybOutRealDry++ = fMultAddDiv2(real, wReal1, mReal1) << s;
-        *pHybOutImagDry++ = fMultAddDiv2(imag, wImag1, mReal1) << s;
-
-        if (qs > 0) {
-          mImag0 = -mImag0;
-          qs--;
-        }
-      } while (--i != 0);
-    }
-
-    for (; pb < pb_max; pb++) {
-      INT s;
-      FIXP_DBL maxVal;
-      FIXP_SGL mReal1;
-      FIXP_SGL mReal0, mImag0;
-      FIXP_DBL iReal0, iImag0, iReal1;
-
-      iReal0 = interpolateParameter(alpha, MReal0[pb], MRealPrev0[pb]);
-      iImag0 = interpolateParameter(alpha, MImag0[pb], MImagPrev0[pb]);
-      iReal1 = interpolateParameter(alpha, MReal1[pb], MRealPrev1[pb]);
-
-      maxVal = fAbs(iReal0) | fAbs(iImag0);
-      maxVal |= fAbs(iReal1);
-
-      s = fMax(CntLeadingZeros(maxVal) - 1, 0);
-      s = fMin(s, scale_param_m2);
-
-      mReal0 = FX_DBL2FX_SGL(iReal0 << s);
-      mImag0 = FX_DBL2FX_SGL(iImag0 << s);
-      mReal1 = FX_DBL2FX_SGL(iReal1 << s);
-
-      s = scale_param_m2 - s;
-
-      INT i = pWidth[pb];
-
-      do {
-        FIXP_DBL real, imag, wReal0, wImag0, wReal1, wImag1;
-
-        wReal0 = *pWReal0++;
-        wImag0 = *pWImag0++;
-        wReal1 = *pWReal1++;
-        wImag1 = *pWImag1++;
-
-        cplxMultDiv2(&real, &imag, wReal0, wImag0, mReal0, mImag0);
-
-        *pHybOutRealDry++ = fMultAddDiv2(real, wReal1, mReal1) << s;
-        *pHybOutImagDry++ = fMultAddDiv2(imag, wImag1, mReal1) << s;
-      } while (--i != 0);
-    }
-  }
-
-  return err;
-}
-
-SACDEC_ERROR SpatialDecApplyM2(spatialDec *self, INT ps, const FIXP_SGL alpha,
-                               FIXP_DBL **wReal, FIXP_DBL **wImag,
-                               FIXP_DBL **hybOutputRealDry,
-                               FIXP_DBL **hybOutputImagDry,
-                               FIXP_DBL **hybOutputRealWet,
-                               FIXP_DBL **hybOutputImagWet) {
-  SACDEC_ERROR err = MPS_OK;
-
-  {
-    int qs, row, col;
-    int complexHybBands;
-    int complexParBands;
-    int scale_param_m2 = 0;
-    int toolsDisabled;
-
-    UCHAR activParamBands;
-    FIXP_DBL *RESTRICT pWReal, *RESTRICT pWImag, *RESTRICT pHybOutRealDry,
-        *RESTRICT pHybOutImagDry, *RESTRICT pHybOutRealWet,
-        *RESTRICT pHybOutImagWet;
-    C_ALLOC_SCRATCH_START(pKernel, FIXP_SGL, MAX_HYBRID_BANDS);
-
-    /* The wet signal is added to the dry signal directly in applyM2 if GES and
-     * STP are disabled */
-    toolsDisabled =
-        ((self->tempShapeConfig == 1) || (self->tempShapeConfig == 2)) ? 0 : 1;
-
-    {
-      complexHybBands = self->hybridBands;
-      complexParBands = self->numParameterBands;
-    }
-
-    FDKmemclear(hybOutputImagDry[0],
-                self->createParams.maxNumOutputChannels *
-                    self->createParams.maxNumCmplxHybBands * sizeof(FIXP_DBL));
-    FDKmemclear(hybOutputRealDry[0], self->createParams.maxNumOutputChannels *
-                                         self->createParams.maxNumHybridBands *
-                                         sizeof(FIXP_DBL));
-
-    if (!toolsDisabled) {
-      FDKmemclear(hybOutputRealWet[0],
-                  self->createParams.maxNumOutputChannels *
-                      self->createParams.maxNumHybridBands * sizeof(FIXP_DBL));
-      FDKmemclear(hybOutputImagWet[0],
-                  self->createParams.maxNumOutputChannels *
-                      self->createParams.maxNumCmplxHybBands *
-                      sizeof(FIXP_DBL));
-    }
-
-    if (self->phaseCoding == 3) {
-      /* + SCALE_DATA_APPLY_M2 to compensate for Div2 below ?! */
-      scale_param_m2 = SCALE_PARAM_M2_212_PRED + SCALE_DATA_APPLY_M2;
-    }
-
-    for (row = 0; row < self->numM2rows; row++) {
-      pHybOutRealDry = hybOutputRealDry[row];
-      pHybOutImagDry = hybOutputImagDry[row];
-
-      if (toolsDisabled) {
-        pHybOutRealWet = hybOutputRealDry[row];
-        pHybOutImagWet = hybOutputImagDry[row];
-      } else {
-        pHybOutRealWet = hybOutputRealWet[row];
-        pHybOutImagWet = hybOutputImagWet[row];
-      }
-
-      for (col = 0; col < self->numDirektSignals; col++) {
-        if (self->pActivM2ParamBands ==
-            0) { /* default setting, calculate all rows and columns */
-          activParamBands = 1;
-        } else {
-          if (self->pActivM2ParamBands[MAX_M2_INPUT * row +
-                                       col]) /* table with activ and inactiv
-                                                bands exists for current
-                                                configuration */
-            activParamBands = 1;
-          else
-            activParamBands = 0;
-        }
-        if (activParamBands) {
-          pWReal = wReal[col];
-          pWImag = wImag[col];
-
-          M2ParamToKernelMult(pKernel, self->M2Real__FDK[row][col],
-                              self->M2RealPrev__FDK[row][col],
-                              self->kernels_width, alpha,
-                              self->numParameterBands);
-
-          if (1 && (self->phaseCoding != 3)) {
-            /* direct signals */
-            {
-              /* only one sample will be assigned to each row, hence
-               * accumulation is not neccessary; that is valid for all
-               * configurations */
-              for (qs = 0; qs < complexHybBands; qs++) {
-                pHybOutRealDry[qs] = fMult(pWReal[qs], pKernel[qs]);
-                pHybOutImagDry[qs] = fMult(pWImag[qs], pKernel[qs]);
-              }
-            }
-          } else { /*  isBinauralMode(self->upmixType)  */
-
-            for (qs = 0; qs < complexHybBands; qs++) {
-              pHybOutRealDry[qs] += fMultDiv2(pWReal[qs], pKernel[qs])
-                                    << (scale_param_m2);
-              pHybOutImagDry[qs] += fMultDiv2(pWImag[qs], pKernel[qs])
-                                    << (scale_param_m2);
-            }
-
-            M2ParamToKernelMult(pKernel, self->M2Imag__FDK[row][col],
-                                self->M2ImagPrev__FDK[row][col],
-                                self->kernels_width, alpha, complexParBands);
-
-            /* direct signals sign is -1 for qs = 0,2 */
-            pHybOutRealDry[0] += fMultDiv2(pWImag[0], pKernel[0])
-                                 << (scale_param_m2);
-            pHybOutImagDry[0] -= fMultDiv2(pWReal[0], pKernel[0])
-                                 << (scale_param_m2);
-
-            pHybOutRealDry[2] += fMultDiv2(pWImag[2], pKernel[2])
-                                 << (scale_param_m2);
-            pHybOutImagDry[2] -= fMultDiv2(pWReal[2], pKernel[2])
-                                 << (scale_param_m2);
-
-            /* direct signals sign is +1 for qs = 1,3,4,5,...,complexHybBands */
-            pHybOutRealDry[1] -= fMultDiv2(pWImag[1], pKernel[1])
-                                 << (scale_param_m2);
-            pHybOutImagDry[1] += fMultDiv2(pWReal[1], pKernel[1])
-                                 << (scale_param_m2);
-
-            for (qs = 3; qs < complexHybBands; qs++) {
-              pHybOutRealDry[qs] -= fMultDiv2(pWImag[qs], pKernel[qs])
-                                    << (scale_param_m2);
-              pHybOutImagDry[qs] += fMultDiv2(pWReal[qs], pKernel[qs])
-                                    << (scale_param_m2);
-            }
-          } /* self->upmixType */
-        }   /* if (activParamBands) */
-      }     /* self->numDirektSignals */
-
-      for (; col < self->numVChannels; col++) {
-        if (self->pActivM2ParamBands ==
-            0) { /* default setting, calculate all rows and columns */
-          activParamBands = 1;
-        } else {
-          if (self->pActivM2ParamBands[MAX_M2_INPUT * row +
-                                       col]) /* table with activ and inactiv
-                                                bands exists for current
-                                                configuration */
-            activParamBands = 1;
-          else
-            activParamBands = 0;
-        }
-
-        if (activParamBands) {
-          int resBandIndex;
-          int resHybIndex;
-
-          resBandIndex =
-              self->residualBands[SpatialDecGetResidualIndex(self, col)];
-          resHybIndex = self->param2hyb[resBandIndex];
-
-          pWReal = wReal[col];
-          pWImag = wImag[col];
-
-          M2ParamToKernelMult(pKernel, self->M2Real__FDK[row][col],
-                              self->M2RealPrev__FDK[row][col],
-                              self->kernels_width, alpha,
-                              self->numParameterBands);
-
-          if (1 && (self->phaseCoding != 3)) {
-            /* residual signals */
-            for (qs = 0; qs < resHybIndex; qs++) {
-              pHybOutRealDry[qs] += fMult(pWReal[qs], pKernel[qs]);
-              pHybOutImagDry[qs] += fMult(pWImag[qs], pKernel[qs]);
-            }
-            /* decor signals */
-            for (; qs < complexHybBands; qs++) {
-              pHybOutRealWet[qs] += fMult(pWReal[qs], pKernel[qs]);
-              pHybOutImagWet[qs] += fMult(pWImag[qs], pKernel[qs]);
-            }
-          } else { /* self->upmixType */
-            /* residual signals */
-            FIXP_DBL *RESTRICT pHybOutReal;
-            FIXP_DBL *RESTRICT pHybOutImag;
-
-            for (qs = 0; qs < resHybIndex; qs++) {
-              pHybOutRealDry[qs] += fMultDiv2(pWReal[qs], pKernel[qs])
-                                    << (scale_param_m2);
-              pHybOutImagDry[qs] += fMultDiv2(pWImag[qs], pKernel[qs])
-                                    << (scale_param_m2);
-            }
-            /* decor signals */
-            for (; qs < complexHybBands; qs++) {
-              pHybOutRealWet[qs] += fMultDiv2(pWReal[qs], pKernel[qs])
-                                    << (scale_param_m2);
-              pHybOutImagWet[qs] += fMultDiv2(pWImag[qs], pKernel[qs])
-                                    << (scale_param_m2);
-            }
-
-            M2ParamToKernelMult(pKernel, self->M2Imag__FDK[row][col],
-                                self->M2ImagPrev__FDK[row][col],
-                                self->kernels_width, alpha, complexParBands);
-
-            /* direct signals sign is -1 for qs = 0,2 */
-            /* direct signals sign is +1 for qs = 1,3.. */
-            if (toolsDisabled) {
-              pHybOutRealDry[0] += fMultDiv2(pWImag[0], pKernel[0])
-                                   << (scale_param_m2);
-              pHybOutImagDry[0] -= fMultDiv2(pWReal[0], pKernel[0])
-                                   << (scale_param_m2);
-
-              pHybOutRealDry[1] -= fMultDiv2(pWImag[1], pKernel[1])
-                                   << (scale_param_m2);
-              pHybOutImagDry[1] += fMultDiv2(pWReal[1], pKernel[1])
-                                   << (scale_param_m2);
-
-              pHybOutRealDry[2] += fMultDiv2(pWImag[2], pKernel[2])
-                                   << (scale_param_m2);
-              pHybOutImagDry[2] -= fMultDiv2(pWReal[2], pKernel[2])
-                                   << (scale_param_m2);
-            } else {
-              pHybOutReal = &pHybOutRealDry[0];
-              pHybOutImag = &pHybOutImagDry[0];
-              if (0 == resHybIndex) {
-                pHybOutReal = &pHybOutRealWet[0];
-                pHybOutImag = &pHybOutImagWet[0];
-              }
-              pHybOutReal[0] += fMultDiv2(pWImag[0], pKernel[0])
-                                << (scale_param_m2);
-              pHybOutImag[0] -= fMultDiv2(pWReal[0], pKernel[0])
-                                << (scale_param_m2);
-
-              if (1 == resHybIndex) {
-                pHybOutReal = &pHybOutRealWet[0];
-                pHybOutImag = &pHybOutImagWet[0];
-              }
-              pHybOutReal[1] -= fMultDiv2(pWImag[1], pKernel[1])
-                                << (scale_param_m2);
-              pHybOutImag[1] += fMultDiv2(pWReal[1], pKernel[1])
-                                << (scale_param_m2);
-
-              if (2 == resHybIndex) {
-                pHybOutReal = &pHybOutRealWet[0];
-                pHybOutImag = &pHybOutImagWet[0];
-              }
-              pHybOutReal[2] += fMultDiv2(pWImag[2], pKernel[2])
-                                << (scale_param_m2);
-              pHybOutImag[2] -= fMultDiv2(pWReal[2], pKernel[2])
-                                << (scale_param_m2);
-            }
-
-            for (qs = 3; qs < resHybIndex; qs++) {
-              pHybOutRealDry[qs] -= fMultDiv2(pWImag[qs], pKernel[qs])
-                                    << (scale_param_m2);
-              pHybOutImagDry[qs] += fMultDiv2(pWReal[qs], pKernel[qs])
-                                    << (scale_param_m2);
-            }
-            /* decor signals */
-            for (; qs < complexHybBands; qs++) {
-              pHybOutRealWet[qs] -= fMultDiv2(pWImag[qs], pKernel[qs])
-                                    << (scale_param_m2);
-              pHybOutImagWet[qs] += fMultDiv2(pWReal[qs], pKernel[qs])
-                                    << (scale_param_m2);
-            }
-          } /* self->upmixType */
-        }   /* if (activParamBands) { */
-      }     /*  self->numVChannels */
-    }
-
-    C_ALLOC_SCRATCH_END(pKernel, FIXP_SGL, MAX_HYBRID_BANDS);
-  }
-
-  return err;
-}
-
-SACDEC_ERROR SpatialDecSynthesis(spatialDec *self, const INT ts,
-                                 FIXP_DBL **hybOutputReal,
-                                 FIXP_DBL **hybOutputImag, PCM_MPS *timeOut,
-                                 const INT numInputChannels,
-                                 const FDK_channelMapDescr *const mapDescr) {
-  SACDEC_ERROR err = MPS_OK;
-
-  int ch;
-  int stride, offset;
-
-  stride = self->numOutputChannelsAT;
-  offset = 1;
-
-  PCM_MPS *pTimeOut__FDK =
-      &timeOut[stride * self->pQmfDomain->globalConf.nBandsSynthesis * ts];
-  C_ALLOC_SCRATCH_START(pQmfReal, FIXP_DBL, QMF_MAX_SYNTHESIS_BANDS);
-  C_ALLOC_SCRATCH_START(pQmfImag, FIXP_DBL, QMF_MAX_SYNTHESIS_BANDS);
-
-  for (ch = 0; ch < self->numOutputChannelsAT; ch++) {
-    if (self->pConfigCurrent->syntaxFlags & SACDEC_SYNTAX_LD) {
-      int k;
-      /* No hybrid filtering. Just copy the QMF data. */
-      for (k = 0; k < self->hybridBands; k += 1) {
-        pQmfReal[k] = hybOutputReal[ch][k];
-        pQmfImag[k] = hybOutputImag[ch][k];
-      }
-    } else {
-      FDKhybridSynthesisApply(&self->hybridSynthesis[ch], hybOutputReal[ch],
-                              hybOutputImag[ch], pQmfReal, pQmfImag);
-    }
-
-    /* Map channel indices from MPEG Surround -> PCE style -> channelMapping[]
-     */
-    FDK_ASSERT(self->numOutputChannelsAT <= 6);
-    int outCh = FDK_chMapDescr_getMapValue(mapDescr, mapChannel(self, ch),
-                                           self->numOutputChannelsAT);
-
-    {
-      if (self->stereoConfigIndex == 3) {
-        /* MPS -> SBR */
-        int i;
-        FIXP_DBL *pWorkBufReal, *pWorkBufImag;
-        FDK_ASSERT((self->pQmfDomain->QmfDomainOut[outCh].fb.outGain_m ==
-                    (FIXP_DBL)0x80000000) &&
-                   (self->pQmfDomain->QmfDomainOut[outCh].fb.outGain_e == 0));
-        FDK_QmfDomain_GetWorkBuffer(&self->pQmfDomain->QmfDomainIn[outCh], ts,
-                                    &pWorkBufReal, &pWorkBufImag);
-        FDK_ASSERT(self->qmfBands <=
-                   self->pQmfDomain->QmfDomainIn[outCh].workBuf_nBands);
-        for (i = 0; i < self->qmfBands; i++) {
-          pWorkBufReal[i] = pQmfReal[i];
-          pWorkBufImag[i] = pQmfImag[i];
-        }
-        self->pQmfDomain->QmfDomainIn[outCh].scaling.lb_scale =
-            -7; /*-ALGORITHMIC_SCALING_IN_ANALYSIS_FILTERBANK;*/
-        self->pQmfDomain->QmfDomainIn[outCh].scaling.lb_scale -=
-            self->pQmfDomain->QmfDomainIn[outCh].fb.filterScale;
-        self->pQmfDomain->QmfDomainIn[outCh].scaling.lb_scale -=
-            self->clipProtectGainSF__FDK;
-
-      } else {
-        /* Call the QMF synthesis for dry. */
-        err = CalculateSpaceSynthesisQmf(&self->pQmfDomain->QmfDomainOut[outCh],
-                                         pQmfReal, pQmfImag, stride,
-                                         pTimeOut__FDK + (offset * outCh));
-      }
-      if (err != MPS_OK) goto bail;
-    }
-  } /* ch loop */
-
-bail:
-  C_ALLOC_SCRATCH_END(pQmfImag, FIXP_DBL, QMF_MAX_SYNTHESIS_BANDS);
-  C_ALLOC_SCRATCH_END(pQmfReal, FIXP_DBL, QMF_MAX_SYNTHESIS_BANDS);
-
-  return err;
-}
-
-void SpatialDecBufferMatrices(spatialDec *self) {
-  int row, col;
-  int complexParBands;
-  complexParBands = self->numParameterBands;
-
-  /*
-    buffer matrices M2
-  */
-  for (row = 0; row < self->numM2rows; row++) {
-    for (col = 0; col < self->numVChannels; col++) {
-      FDKmemcpy(self->M2RealPrev__FDK[row][col], self->M2Real__FDK[row][col],
-                self->numParameterBands * sizeof(FIXP_DBL));
-      if (0 || (self->phaseCoding == 3)) {
-        FDKmemcpy(self->M2ImagPrev__FDK[row][col], self->M2Imag__FDK[row][col],
-                  complexParBands * sizeof(FIXP_DBL));
-      }
-    }
-  }
-
-  /* buffer phase */
-  FDKmemcpy(self->PhasePrevLeft__FDK, self->PhaseLeft__FDK,
-            self->numParameterBands * sizeof(FIXP_DBL));
-  FDKmemcpy(self->PhasePrevRight__FDK, self->PhaseRight__FDK,
-            self->numParameterBands * sizeof(FIXP_DBL));
-}
-
-#define PHASE_SCALE 2
-
-#ifndef P_PI
-#define P_PI 3.1415926535897932
-#endif
-
-/* For better precision, PI (pi_x2) is already doubled */
-static FIXP_DBL interp_angle__FDK(FIXP_DBL angle1, FIXP_DBL angle2,
-                                  FIXP_SGL alpha, FIXP_DBL pi_x2) {
-  if (angle2 - angle1 > (pi_x2 >> 1)) angle2 -= pi_x2;
-
-  if (angle1 - angle2 > (pi_x2 >> 1)) angle1 -= pi_x2;
-
-  return interpolateParameter(alpha, angle2, angle1);
-}
-
-/*
- *
- */
-void SpatialDecApplyPhase(spatialDec *self, FIXP_SGL alpha__FDK,
-                          int lastSlotOfParamSet) {
-  int pb, qs;
-  FIXP_DBL ppb[MAX_PARAMETER_BANDS *
-               4]; /* left real, imag - right real, imag interleaved */
-
-  const FIXP_DBL pi_x2 = PIx2__IPD;
-  for (pb = 0; pb < self->numParameterBands; pb++) {
-    FIXP_DBL pl, pr;
-
-    pl = interp_angle__FDK(self->PhasePrevLeft__FDK[pb],
-                           self->PhaseLeft__FDK[pb], alpha__FDK, pi_x2);
-    pr = interp_angle__FDK(self->PhasePrevRight__FDK[pb],
-                           self->PhaseRight__FDK[pb], alpha__FDK, pi_x2);
-
-    inline_fixp_cos_sin(pl, pr, IPD_SCALE, &ppb[4 * pb]);
-  }
-
-  /* sign is -1 for qs = 0,2 and +1 for qs = 1 */
-
-  const SCHAR *kernels = &self->kernels[0];
-
-  FIXP_DBL *Dry_real0 = &self->hybOutputRealDry__FDK[0][0];
-  FIXP_DBL *Dry_imag0 = &self->hybOutputImagDry__FDK[0][0];
-  FIXP_DBL *Dry_real1 = &self->hybOutputRealDry__FDK[1][0];
-  FIXP_DBL *Dry_imag1 = &self->hybOutputImagDry__FDK[1][0];
-
-  for (qs = 2; qs >= 0; qs--) {
-    FIXP_DBL out_re, out_im;
-
-    pb = *kernels++;
-    if (qs == 1) /* sign[qs] >= 0 */
-    {
-      cplxMultDiv2(&out_re, &out_im, *Dry_real0, *Dry_imag0, ppb[4 * pb + 0],
-                   ppb[4 * pb + 1]);
-      out_re <<= PHASE_SCALE - 1;
-      out_im <<= PHASE_SCALE - 1;
-      *Dry_real0++ = out_re;
-      *Dry_imag0++ = out_im;
-
-      cplxMultDiv2(&out_re, &out_im, *Dry_real1, *Dry_imag1, ppb[4 * pb + 2],
-                   ppb[4 * pb + 3]);
-      out_re <<= PHASE_SCALE - 1;
-      out_im <<= PHASE_SCALE - 1;
-      *Dry_real1++ = out_re;
-      *Dry_imag1++ = out_im;
-    } else {
-      cplxMultDiv2(&out_re, &out_im, *Dry_real0, *Dry_imag0, ppb[4 * pb + 0],
-                   -ppb[4 * pb + 1]);
-      out_re <<= PHASE_SCALE - 1;
-      out_im <<= PHASE_SCALE - 1;
-      *Dry_real0++ = out_re;
-      *Dry_imag0++ = out_im;
-
-      cplxMultDiv2(&out_re, &out_im, *Dry_real1, *Dry_imag1, ppb[4 * pb + 2],
-                   -ppb[4 * pb + 3]);
-      out_re <<= PHASE_SCALE - 1;
-      out_im <<= PHASE_SCALE - 1;
-      *Dry_real1++ = out_re;
-      *Dry_imag1++ = out_im;
-    }
-  }
-
-  /* sign is +1 for qs >=3 */
-  for (qs = self->hybridBands - 3; qs--;) {
-    FIXP_DBL out_re, out_im;
-
-    pb = *kernels++;
-    cplxMultDiv2(&out_re, &out_im, *Dry_real0, *Dry_imag0, ppb[4 * pb + 0],
-                 ppb[4 * pb + 1]);
-    out_re <<= PHASE_SCALE - 1;
-    out_im <<= PHASE_SCALE - 1;
-    *Dry_real0++ = out_re;
-    *Dry_imag0++ = out_im;
-
-    cplxMultDiv2(&out_re, &out_im, *Dry_real1, *Dry_imag1, ppb[4 * pb + 2],
-                 ppb[4 * pb + 3]);
-    out_re <<= PHASE_SCALE - 1;
-    out_im <<= PHASE_SCALE - 1;
-    *Dry_real1++ = out_re;
-    *Dry_imag1++ = out_im;
-  }
-}
--- a/libSACdec/src/sac_process.h
+++ /dev/null
@@ -1,297 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround decoder library *************************
-
-   Author(s):
-
-   Description: SAC Processing
-
-*******************************************************************************/
-
-/*!
-  \file
-  \brief  Polyphase Filterbank
-*/
-
-#ifndef SAC_PROCESS_H
-#define SAC_PROCESS_H
-
-#include "sac_dec.h"
-
-void SpatialDecApplyPhase(spatialDec *self, FIXP_SGL alpha,
-                          int lastSlotOfParamSet);
-
-/**
- * \brief  Apply QMF Analysis Filterbank.
- *
- * Calculates qmf data on downmix input time data.
- * Delaylines will be applied if necessaray.
- *
- * \param self                A spatial decoder handle.
- * \param inData              Downmix channel time data as input.
- * \param ts                  Signals time slot offset for input buffer.
- * \param qmfReal             Downmix channel qmf output data.
- * \param qmfImag             Downmix channel qmf output data.
- *
- * \return  Error status.
- */
-SACDEC_ERROR SpatialDecQMFAnalysis(spatialDec *self, const PCM_MPS *inData,
-                                   const INT ts, const INT bypassMode,
-                                   FIXP_DBL **qmfReal, FIXP_DBL **qmfImag,
-                                   const int numInputChannels);
-
-/**
- * \brief  Feed spatial decoder with external qmf data.
- *
- * \param self                A spatial decoder handle.
- * \param qmfInDataReal       External qmf downmix data as input.
- * \param qmfInDataImag       External qmf downmix data as input.
- * \param ts                  Signals time slot in input buffer to process.
- * \param qmfReal             Downmix channel qmf output data.
- * \param qmfImag             Downmix channel qmf output data.
- * \param numInputChannels    Number of input channels. Might differ from
- * self->numInputChannels.
- *
- * \return  Error status.
- */
-SACDEC_ERROR SpatialDecFeedQMF(spatialDec *self, FIXP_DBL **qmfInDataReal,
-                               FIXP_DBL **qmfInDataImag, const INT ts,
-                               const INT bypassMode, FIXP_DBL **qmfReal,
-                               FIXP_DBL **qmfImag, const INT numInputChannels);
-
-/**
- * \brief  Apply Hybrdid Analysis Filterbank.
- *
- * Calculates hybrid data on downmix input data.
- * Residual hybrid signals will also be calculated on current slot if available.
- *
- * \param self                A spatial decoder handle.
- * \param qmfInputReal        Downmix channel qmf data as input.
- * \param qmfInputImag        Downmix channel qmf data as input.
- * \param hybOutputReal       Downmix channel hybrid output data.
- * \param hybOutputImag       Downmix channel hybrid output data.
- * \param ts                  Signals time slot in spatial frame to process.
- * \param numInputChannels    Number of input channels. Might differ from
- * self->numInputChannels.
- *
- * \return  Error status.
- */
-SACDEC_ERROR SpatialDecHybridAnalysis(spatialDec *self, FIXP_DBL **qmfInputReal,
-                                      FIXP_DBL **qmfInputImag,
-                                      FIXP_DBL **hybOutputReal,
-                                      FIXP_DBL **hybOutputImag, const INT ts,
-                                      const INT numInputChannels);
-
-/**
- * \brief  Create X data.
- *
- * Returns a pointer list over Xchannels pointing to downmix input channels
- * and to residual channels when provided.
- *
- * \param self                A spatial decoder handle.
- * \param hybInputReal        Downmix channel hybrid data as input.
- * \param hybInputImag        Downmix channel hybrid data as input.
- * \param pxReal              Pointer to hybrid and residual data as output.
- * \param pxImag              Pointer to hybrid and residual data as output.
- *
- * \return  Error status.
- */
-SACDEC_ERROR SpatialDecCreateX(spatialDec *self, FIXP_DBL **hybInputReal,
-                               FIXP_DBL **hybInputImag, FIXP_DBL **pxReal,
-                               FIXP_DBL **pxImag);
-
-/**
- * \brief  MPS212 combined version of apply M1 parameters and create wet signal
- *
- * \param self                A spatial decoder handle.
- * \param xReal               Downmix and residual X data as input.
- * \param xImag               Downmix and residual X data as input.
- * \param vReal               output data: [0] direct signal (V); [1] wet signal
- * (W).
- * \param vImag               output data: [0] direct signal (V); [1] wet signal
- * (W).
- *
- * \return  Error status.
- */
-SACDEC_ERROR SpatialDecApplyM1_CreateW_Mode212(
-    spatialDec *self, const SPATIAL_BS_FRAME *frame, FIXP_DBL **xReal,
-    FIXP_DBL **xImag, FIXP_DBL **vReal, FIXP_DBL **vImag);
-
-/**
- * \brief  Apply M2 parameters.
- *
- * \param self                A spatial decoder handle.
- * \param ps                  Signals parameter band from where M2 parameter to
- * use.
- * \param alpha               Smoothing factor between current and previous
- * parameter band. Rangeability between 0.f and 1.f.
- * \param wReal               Wet input data.
- * \param wImag               Wet input data.
- * \param hybOutputRealDry    Dry output data.
- * \param hybOutputImagDry    Dry output data.
- * \param hybOutputRealWet    Wet output data.
- * \param hybOutputImagWet    Wet output data.
- *
- * \return  Error status.
- */
-SACDEC_ERROR SpatialDecApplyM2(spatialDec *self, INT ps, const FIXP_SGL alpha,
-                               FIXP_DBL **wReal, FIXP_DBL **wImag,
-                               FIXP_DBL **hybOutputRealDry,
-                               FIXP_DBL **hybOutputImagDry,
-                               FIXP_DBL **hybOutputRealWet,
-                               FIXP_DBL **hybOutputImagWet);
-
-/**
- * \brief  Apply M2 parameter for 212 mode with residualCoding and phaseCoding.
- *
- * \param self                [i] A spatial decoder handle.
- * \param ps                  [i] Signals parameter band from where M2 parameter
- * to use.
- * \param alpha               [i] Smoothing factor between current and previous
- * parameter band. Rangeability between 0.f and 1.f.
- * \param wReal               [i] Wet input data.
- * \param wImag               [i] Wet input data.
- * \param hybOutputRealDry    [o] Dry output data.
- * \param hybOutputImagDry    [o] Dry output data.
- *
- * \return error
- */
-SACDEC_ERROR SpatialDecApplyM2_Mode212_ResidualsPlusPhaseCoding(
-    spatialDec *self, INT ps, const FIXP_SGL alpha, FIXP_DBL **wReal,
-    FIXP_DBL **wImag, FIXP_DBL **hybOutputRealDry, FIXP_DBL **hybOutputImagDry);
-
-/**
- * \brief  Apply M2 parameter for 212 mode, upmix from mono to stereo.
- *
- * \param self                [i] A spatial decoder handle.
- * \param ps                  [i] Signals parameter band from where M2 parameter
- * to use.
- * \param alpha               [i] Smoothing factor between current and previous
- * parameter band. Rangeability between 0.f and 1.f.
- * \param wReal               [i] Wet input data.
- * \param wImag               [i] Wet input data.
- * \param hybOutputRealDry    [o] Dry output data.
- * \param hybOutputImagDry    [o] Dry output data.
- *
- * \return error
- */
-SACDEC_ERROR SpatialDecApplyM2_Mode212(spatialDec *self, INT ps,
-                                       const FIXP_SGL alpha, FIXP_DBL **wReal,
-                                       FIXP_DBL **wImag,
-                                       FIXP_DBL **hybOutputRealDry,
-                                       FIXP_DBL **hybOutputImagDry);
-
-/**
- * \brief  Convert Hybrid input to output audio data.
- *
- * \param hSpaceSynthesisQmf  A spatial decoder handle.
- * \param ts                  Signals time slot in spatial frame to process.
- * \param hybOutputReal       Hybrid data as input.
- * \param hybOutputImag       Hybrid data as input.
- * \param timeOut             audio output data.
- *
- * \return  Error status.
- */
-SACDEC_ERROR SpatialDecSynthesis(spatialDec *self, const INT ts,
-                                 FIXP_DBL **hybOutputReal,
-                                 FIXP_DBL **hybOutputImag, PCM_MPS *timeOut,
-                                 const INT numInputChannels,
-                                 const FDK_channelMapDescr *const mapDescr);
-
-void SpatialDecBufferMatrices(spatialDec *self);
-
-FIXP_DBL getChGain(spatialDec *self, UINT ch, INT *scale);
-
-#endif
--- a/libSACdec/src/sac_qmf.cpp
+++ /dev/null
@@ -1,156 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround decoder library *************************
-
-   Author(s):
-
-   Description: SAC Dec QMF processing
-
-*******************************************************************************/
-
-#include "sac_qmf.h"
-
-#include "FDK_matrixCalloc.h"
-#include "sac_dec_interface.h"
-#include "sac_rom.h"
-
-#include "qmf.h"
-
-SACDEC_ERROR CalculateSpaceSynthesisQmf(
-    const HANDLE_FDK_QMF_DOMAIN_OUT hQmfDomainOutCh, const FIXP_DBL *Sr,
-    const FIXP_DBL *Si, const INT stride, INT_PCM *timeSig) {
-  SACDEC_ERROR err = MPS_OK;
-
-  if (hQmfDomainOutCh == NULL) {
-    err = MPS_INVALID_HANDLE;
-  } else {
-    HANDLE_SPACE_SYNTHESIS_QMF hSpaceSynthesisQmf = &hQmfDomainOutCh->fb;
-#if (QMF_MAX_SYNTHESIS_BANDS <= 64)
-    C_AALLOC_SCRATCH_START(pWorkBuffer, FIXP_DBL,
-                           (QMF_MAX_SYNTHESIS_BANDS << 1));
-#else
-    C_AALLOC_STACK_START(pWorkBuffer, FIXP_DBL, (QMF_MAX_SYNTHESIS_BANDS << 1));
-#endif
-
-    qmfSynthesisFilteringSlot(hSpaceSynthesisQmf, Sr, Si, 0, 0, timeSig, stride,
-                              pWorkBuffer);
-
-#if (QMF_MAX_SYNTHESIS_BANDS <= 64)
-    C_AALLOC_SCRATCH_END(pWorkBuffer, FIXP_DBL, (QMF_MAX_SYNTHESIS_BANDS << 1));
-#else
-    C_AALLOC_STACK_END(pWorkBuffer, FIXP_DBL, (QMF_MAX_SYNTHESIS_BANDS << 1));
-#endif
-  }
-
-  return err;
-}
-
-SACDEC_ERROR CalculateSpaceAnalysisQmf(
-    HANDLE_SPACE_ANALYSIS_QMF hSpaceAnalysisQmf, const PCM_MPS *timeSig,
-    FIXP_DBL *Sr, FIXP_DBL *Si) {
-  SACDEC_ERROR err = MPS_OK;
-
-  if (hSpaceAnalysisQmf == NULL) {
-    err = MPS_INVALID_HANDLE;
-  } else {
-    C_AALLOC_SCRATCH_START(pWorkBuffer, FIXP_DBL, (64 << 1));
-
-    qmfAnalysisFilteringSlot(hSpaceAnalysisQmf, Sr, Si, timeSig, 1,
-                             pWorkBuffer);
-    C_AALLOC_SCRATCH_END(pWorkBuffer, FIXP_DBL, (64 << 1));
-  }
-
-  return err;
-}
--- a/libSACdec/src/sac_qmf.h
+++ /dev/null
@@ -1,143 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround decoder library *************************
-
-   Author(s):
-
-   Description: SAC Dec QMF processing
-
-*******************************************************************************/
-
-#ifndef SAC_QMF_H
-#define SAC_QMF_H
-
-#include "common_fix.h"
-
-#include "sac_dec_interface.h"
-
-#include "FDK_qmf_domain.h"
-#define HANDLE_SPACE_ANALYSIS_QMF HANDLE_QMF_FILTER_BANK
-#define HANDLE_SPACE_SYNTHESIS_QMF HANDLE_QMF_FILTER_BANK
-
-/**
- * \brief  Convert Qmf input to output audio data.
- *
- * \param hSpaceSynthesisQmf  A Qmf Synthesis Filterbank handle.
- * \param Sr                  Pointer to Qmf input buffer.
- * \param Si                  Pointer to Qmf input buffer.
- * \param stride              Stride factor for output data, 1 if none.
- * \param timeSig             (None-)Interleaved audio output data.
- *
- * \return  Error status.
- */
-SACDEC_ERROR CalculateSpaceSynthesisQmf(
-    const HANDLE_FDK_QMF_DOMAIN_OUT hQmfDomainOutCh, const FIXP_DBL *Sr,
-    const FIXP_DBL *Si, const INT stride, INT_PCM *timeSig);
-
-/**
- * \brief  Convert audio input data to qmf representation.
- *
- * \param hSpaceAnalysisQmf   A Qmf Analysis Filterbank handle.
- * \param timeSig             (None-)Interleavd audio input data.
- * \param Sr                  Pointer to Qmf output buffer.
- * \param Si                  Pointer to Qmf output buffer.
- *
- * \return  Error status.
- */
-SACDEC_ERROR CalculateSpaceAnalysisQmf(
-    HANDLE_SPACE_ANALYSIS_QMF hSpaceAnalysisQmf, const PCM_MPS *timeSig,
-    FIXP_DBL *Sr, FIXP_DBL *Si);
-
-#endif /* SAC_QMF_H */
--- a/libSACdec/src/sac_reshapeBBEnv.cpp
+++ /dev/null
@@ -1,680 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround decoder library *************************
-
-   Author(s):
-
-   Description: SAC Dec guided envelope shaping
-
-*******************************************************************************/
-
-#include "sac_reshapeBBEnv.h"
-
-#include "sac_dec.h"
-#include "sac_bitdec.h"
-#include "sac_calcM1andM2.h"
-#include "sac_reshapeBBEnv.h"
-#include "sac_rom.h"
-
-#define INP_DRY_WET 0
-#define INP_DMX 1
-
-#define SF_SHAPE 1
-#define SF_DIV32 6
-#define SF_FACTOR_SLOT 5
-
-#define START_BB_ENV 0 /* 10 */
-#define END_BB_ENV 9   /* 18 */
-
-#define SF_ALPHA1 8
-#define SF_BETA1 4
-
-void initBBEnv(spatialDec *self, int initStatesFlag) {
-  INT ch, k;
-
-  for (ch = 0; ch < self->numOutputChannels; ch++) {
-    k = row2channelGES[self->treeConfig][ch];
-    self->row2channelDmxGES[ch] = k;
-    if (k == -1) continue;
-
-    switch (self->treeConfig) {
-      case TREE_212:
-        self->row2channelDmxGES[ch] = 0;
-        break;
-      default:;
-    }
-  }
-
-  if (initStatesFlag) {
-    for (k = 0; k < 2 * MAX_OUTPUT_CHANNELS + MAX_INPUT_CHANNELS; k++) {
-      self->reshapeBBEnvState->normNrgPrev__FDK[k] =
-          FL2FXCONST_DBL(0.5f); /* 32768.f*32768.f */
-      self->reshapeBBEnvState->normNrgPrevSF[k] = DFRACT_BITS - 1;
-      self->reshapeBBEnvState->partNrgPrevSF[k] = 0;
-      self->reshapeBBEnvState->partNrgPrev2SF[k] = 0;
-      self->reshapeBBEnvState->frameNrgPrevSF[k] = 0;
-    }
-  }
-
-  self->reshapeBBEnvState->alpha__FDK =
-      FL2FXCONST_DBL(0.99637845575f); /* FDKexp(-64 / (0.4f  * 44100)) */
-  self->reshapeBBEnvState->beta__FDK =
-      FL2FXCONST_DBL(0.96436909488f); /* FDKexp(-64 / (0.04f * 44100)) */
-}
-
-static inline void getSlotNrgHQ(FIXP_DBL *RESTRICT pReal,
-                                FIXP_DBL *RESTRICT pImag,
-                                FIXP_DBL *RESTRICT slotNrg, INT maxValSF,
-                                INT hybBands) {
-  INT qs;
-  FIXP_DBL nrg;
-
-  /* qs = 12, 13, 14 */
-  slotNrg[0] = ((fPow2Div2((*pReal++) << maxValSF) +
-                 fPow2Div2((*pImag++) << maxValSF)) >>
-                (SF_FACTOR_SLOT - 1));
-  slotNrg[1] = ((fPow2Div2((*pReal++) << maxValSF) +
-                 fPow2Div2((*pImag++) << maxValSF)) >>
-                (SF_FACTOR_SLOT - 1));
-  slotNrg[2] = ((fPow2Div2((*pReal++) << maxValSF) +
-                 fPow2Div2((*pImag++) << maxValSF)) >>
-                (SF_FACTOR_SLOT - 1));
-  /* qs = 15 */
-  slotNrg[3] = ((fPow2Div2((*pReal++) << maxValSF) +
-                 fPow2Div2((*pImag++) << maxValSF)) >>
-                (SF_FACTOR_SLOT - 1));
-  /* qs = 16, 17 */
-  nrg = ((fPow2Div2((*pReal++) << maxValSF) +
-          fPow2Div2((*pImag++) << maxValSF)) >>
-         (SF_FACTOR_SLOT - 1));
-  slotNrg[4] = nrg + ((fPow2Div2((*pReal++) << maxValSF) +
-                       fPow2Div2((*pImag++) << maxValSF)) >>
-                      (SF_FACTOR_SLOT - 1));
-  /* qs = 18, 19, 20 */
-  nrg = ((fPow2Div2((*pReal++) << maxValSF) +
-          fPow2Div2((*pImag++) << maxValSF)) >>
-         (SF_FACTOR_SLOT - 1));
-  nrg += ((fPow2Div2((*pReal++) << maxValSF) +
-           fPow2Div2((*pImag++) << maxValSF)) >>
-          (SF_FACTOR_SLOT - 1));
-  slotNrg[5] = nrg + ((fPow2Div2((*pReal++) << maxValSF) +
-                       fPow2Div2((*pImag++) << maxValSF)) >>
-                      (SF_FACTOR_SLOT - 1));
-  /* qs = 21, 22 */
-  nrg = ((fPow2Div2((*pReal++) << maxValSF) +
-          fPow2Div2((*pImag++) << maxValSF)) >>
-         (SF_FACTOR_SLOT - 1));
-  slotNrg[6] = nrg + ((fPow2Div2((*pReal++) << maxValSF) +
-                       fPow2Div2((*pImag++) << maxValSF)) >>
-                      (SF_FACTOR_SLOT - 1));
-  /* qs = 23, 24 */
-  if (hybBands > 23) {
-    slotNrg[6] += ((fPow2Div2((*pReal++) << maxValSF) +
-                    fPow2Div2((*pImag++) << maxValSF)) >>
-                   (SF_FACTOR_SLOT - 1));
-    slotNrg[6] += ((fPow2Div2((*pReal++) << maxValSF) +
-                    fPow2Div2((*pImag++) << maxValSF)) >>
-                   (SF_FACTOR_SLOT - 1));
-    /* qs = 25, 26, 29, 28, 29 */
-    nrg = ((fPow2Div2((*pReal++) << maxValSF) +
-            fPow2Div2((*pImag++) << maxValSF)) >>
-           (SF_FACTOR_SLOT - 1));
-    nrg += ((fPow2Div2((*pReal++) << maxValSF) +
-             fPow2Div2((*pImag++) << maxValSF)) >>
-            (SF_FACTOR_SLOT - 1));
-    nrg += ((fPow2Div2((*pReal++) << maxValSF) +
-             fPow2Div2((*pImag++) << maxValSF)) >>
-            (SF_FACTOR_SLOT - 1));
-    nrg += ((fPow2Div2((*pReal++) << maxValSF) +
-             fPow2Div2((*pImag++) << maxValSF)) >>
-            (SF_FACTOR_SLOT - 1));
-    slotNrg[7] = nrg + ((fPow2Div2((*pReal++) << maxValSF) +
-                         fPow2Div2((*pImag++) << maxValSF)) >>
-                        (SF_FACTOR_SLOT - 1));
-    /* qs = 30 ... min(41,hybBands-1) */
-    nrg = ((fPow2Div2((*pReal++) << maxValSF) +
-            fPow2Div2((*pImag++) << maxValSF)) >>
-           (SF_FACTOR_SLOT - 1));
-    for (qs = 31; qs < hybBands; qs++) {
-      nrg += ((fPow2Div2((*pReal++) << maxValSF) +
-               fPow2Div2((*pImag++) << maxValSF)) >>
-              (SF_FACTOR_SLOT - 1));
-    }
-    slotNrg[8] = nrg;
-  } else {
-    slotNrg[7] = (FIXP_DBL)0;
-    slotNrg[8] = (FIXP_DBL)0;
-  }
-}
-
-static inline INT getMaxValDmx(FIXP_DBL *RESTRICT pReal,
-                               FIXP_DBL *RESTRICT pImag, INT cplxBands,
-                               INT hybBands) {
-  INT qs, clz;
-  FIXP_DBL maxVal = FL2FXCONST_DBL(0.0f);
-
-  for (qs = 12; qs < cplxBands; qs++) {
-    maxVal |= fAbs(pReal[qs]);
-    maxVal |= fAbs(pImag[qs]);
-  }
-  for (; qs < hybBands; qs++) {
-    maxVal |= fAbs(pReal[qs]);
-  }
-
-  clz = fixMax(0, CntLeadingZeros(maxVal) - 1);
-
-  return (clz);
-}
-
-static inline INT getMaxValDryWet(FIXP_DBL *RESTRICT pReal,
-                                  FIXP_DBL *RESTRICT pImag,
-                                  FIXP_DBL *RESTRICT pHybOutputRealDry,
-                                  FIXP_DBL *RESTRICT pHybOutputImagDry,
-                                  FIXP_DBL *RESTRICT pHybOutputRealWet,
-                                  FIXP_DBL *RESTRICT pHybOutputImagWet,
-                                  INT cplxBands, INT hybBands) {
-  INT qs, clz;
-  FIXP_DBL maxVal = FL2FXCONST_DBL(0.0f);
-
-  for (qs = 12; qs < cplxBands; qs++) {
-    pReal[qs] = pHybOutputRealDry[qs] + pHybOutputRealWet[qs];
-    maxVal |= fAbs(pReal[qs]);
-    pImag[qs] = pHybOutputImagDry[qs] + pHybOutputImagWet[qs];
-    maxVal |= fAbs(pImag[qs]);
-  }
-  for (; qs < hybBands; qs++) {
-    pReal[qs] = pHybOutputRealDry[qs] + pHybOutputRealWet[qs];
-    maxVal |= fAbs(pReal[qs]);
-  }
-
-  clz = fixMax(0, CntLeadingZeros(maxVal) - 1);
-
-  return (clz);
-}
-
-static inline void slotAmp(FIXP_DBL *RESTRICT slotAmp_dry,
-                           FIXP_DBL *RESTRICT slotAmp_wet,
-                           FIXP_DBL *RESTRICT pHybOutputRealDry,
-                           FIXP_DBL *RESTRICT pHybOutputImagDry,
-                           FIXP_DBL *RESTRICT pHybOutputRealWet,
-                           FIXP_DBL *RESTRICT pHybOutputImagWet, INT cplxBands,
-                           INT hybBands) {
-  INT qs;
-  FIXP_DBL dry, wet;
-
-  dry = wet = FL2FXCONST_DBL(0.0f);
-  for (qs = 0; qs < cplxBands; qs++) {
-    dry = fAddSaturate(dry, fPow2Div2(pHybOutputRealDry[qs]) +
-                                fPow2Div2(pHybOutputImagDry[qs]));
-    wet = fAddSaturate(wet, fPow2Div2(pHybOutputRealWet[qs]) +
-                                fPow2Div2(pHybOutputImagWet[qs]));
-  }
-  for (; qs < hybBands; qs++) {
-    dry = fAddSaturate(dry, fPow2Div2(pHybOutputRealDry[qs]));
-    wet = fAddSaturate(wet, fPow2Div2(pHybOutputRealWet[qs]));
-  }
-  *slotAmp_dry = dry;
-  *slotAmp_wet = wet;
-}
-
-#if defined(__aarch64__)
-__attribute__((noinline))
-#endif
-static void
-shapeBBEnv(FIXP_DBL *pHybOutputRealDry, FIXP_DBL *pHybOutputImagDry,
-           FIXP_DBL dryFac, INT scale, INT cplxBands, INT hybBands) {
-  INT qs;
-
-  if (scale == 0) {
-    for (qs = 0; qs < cplxBands; qs++) {
-      pHybOutputRealDry[qs] = fMultDiv2(pHybOutputRealDry[qs], dryFac);
-      pHybOutputImagDry[qs] = fMultDiv2(pHybOutputImagDry[qs], dryFac);
-    }
-    for (; qs < hybBands; qs++) {
-      pHybOutputRealDry[qs] = fMultDiv2(pHybOutputRealDry[qs], dryFac);
-    }
-  } else {
-    for (qs = 0; qs < cplxBands; qs++) {
-      pHybOutputRealDry[qs] = fMultDiv2(pHybOutputRealDry[qs], dryFac) << scale;
-      pHybOutputImagDry[qs] = fMultDiv2(pHybOutputImagDry[qs], dryFac) << scale;
-    }
-    for (; qs < hybBands; qs++) {
-      pHybOutputRealDry[qs] = fMultDiv2(pHybOutputRealDry[qs], dryFac) << scale;
-    }
-  }
-}
-
-static void extractBBEnv(spatialDec *self, INT inp, INT start, INT channels,
-                         FIXP_DBL *pEnv, const SPATIAL_BS_FRAME *frame) {
-  INT ch, pb, prevChOffs;
-  INT clz, scale, scale_min, envSF;
-  INT scaleCur, scalePrev, commonScale;
-  INT slotNrgSF, partNrgSF, frameNrgSF;
-  INT *pPartNrgPrevSF, *pFrameNrgPrevSF;
-  INT *pNormNrgPrevSF, *pPartNrgPrev2SF;
-
-  FIXP_DBL maxVal, env, frameNrg, normNrg;
-  FIXP_DBL *pReal, *pImag;
-  FIXP_DBL *partNrg, *partNrgPrev;
-
-  C_ALLOC_SCRATCH_START(pScratchBuffer, FIXP_DBL,
-                        (2 * 42 + MAX_PARAMETER_BANDS));
-  C_ALLOC_SCRATCH_START(resPb, FIXP_DBL, (END_BB_ENV - START_BB_ENV));
-  C_ALLOC_SCRATCH_START(resPbSF, INT, (END_BB_ENV - START_BB_ENV));
-
-  FIXP_DBL *slotNrg = pScratchBuffer + (2 * 42);
-
-  RESHAPE_BBENV_STATE *pBBEnvState = self->reshapeBBEnvState;
-
-  FIXP_DBL alpha = pBBEnvState->alpha__FDK;
-  /*FIXP_DBL  alpha1 = (FL2FXCONST_DBL(1.0f) - alpha) << SF_ALPHA1;*/
-  FIXP_DBL alpha1 = ((FIXP_DBL)MAXVAL_DBL - alpha) << SF_ALPHA1;
-  FIXP_DBL beta = pBBEnvState->beta__FDK;
-  /*FIXP_DBL  beta1  = (FL2FXCONST_DBL(1.0f) - beta) << SF_BETA1;*/
-  FIXP_DBL beta1 = ((FIXP_DBL)MAXVAL_DBL - beta) << SF_BETA1;
-
-  INT shapeActiv = 1;
-  INT hybBands = fixMin(42, self->hybridBands);
-  INT staticScale = self->staticDecScale;
-  INT cplxBands;
-  cplxBands = fixMin(42, self->hybridBands);
-
-  for (ch = start; ch < channels; ch++) {
-    if (inp == INP_DRY_WET) {
-      INT ch2 = row2channelGES[self->treeConfig][ch];
-      if (ch2 == -1) {
-        continue;
-      } else {
-        if (frame->tempShapeEnableChannelGES[ch2]) {
-          shapeActiv = 1;
-        } else {
-          shapeActiv = 0;
-        }
-      }
-      prevChOffs = ch;
-      pReal = pScratchBuffer;
-      pImag = pScratchBuffer + 42;
-      clz = getMaxValDryWet(
-          pReal, pImag, self->hybOutputRealDry__FDK[ch],
-          self->hybOutputImagDry__FDK[ch], self->hybOutputRealWet__FDK[ch],
-          self->hybOutputImagWet__FDK[ch], cplxBands, hybBands);
-    } else {
-      prevChOffs = ch + self->numOutputChannels;
-      pReal = self->hybInputReal__FDK[ch];
-      pImag = self->hybInputImag__FDK[ch];
-      clz = getMaxValDmx(pReal, pImag, cplxBands, hybBands);
-    }
-
-    partNrg = partNrgPrev = pBBEnvState->partNrgPrev__FDK[prevChOffs];
-    pPartNrgPrevSF = &pBBEnvState->partNrgPrevSF[prevChOffs];
-    pFrameNrgPrevSF = &pBBEnvState->frameNrgPrevSF[prevChOffs];
-    pNormNrgPrevSF = &pBBEnvState->normNrgPrevSF[prevChOffs];
-    pPartNrgPrev2SF = &pBBEnvState->partNrgPrev2SF[prevChOffs];
-
-    /* calculate slot energy */
-    {
-      getSlotNrgHQ(&pReal[12], &pImag[12], slotNrg, clz,
-                   fixMin(42, self->hybridBands)); /* scale slotNrg:
-                                                      2*(staticScale-clz) +
-                                                      SF_FACTOR_SLOT */
-    }
-
-    slotNrgSF = 2 * (staticScale - clz) + SF_FACTOR_SLOT;
-    frameNrgSF = 2 * (staticScale - clz) + SF_FACTOR_SLOT;
-
-    partNrgSF = fixMax(slotNrgSF - SF_ALPHA1 + 1,
-                       pPartNrgPrevSF[0] - pPartNrgPrev2SF[0] + 1);
-    scalePrev = fixMax(fixMin(partNrgSF - pPartNrgPrevSF[0], DFRACT_BITS - 1),
-                       -(DFRACT_BITS - 1));
-    scaleCur =
-        fixMax(fixMin(partNrgSF - slotNrgSF + SF_ALPHA1, DFRACT_BITS - 1),
-               -(DFRACT_BITS - 1));
-
-    maxVal = FL2FXCONST_DBL(0.0f);
-    frameNrg = FL2FXCONST_DBL(0.0f);
-    if ((scaleCur < 0) && (scalePrev < 0)) {
-      scaleCur = -scaleCur;
-      scalePrev = -scalePrev;
-      for (pb = START_BB_ENV; pb < END_BB_ENV; pb++) {
-        partNrg[pb] = ((fMultDiv2(alpha1, slotNrg[pb]) << scaleCur) +
-                       (fMultDiv2(alpha, partNrgPrev[pb]) << scalePrev))
-                      << 1;
-        maxVal |= partNrg[pb];
-        frameNrg += slotNrg[pb] >> 3;
-      }
-    } else if ((scaleCur >= 0) && (scalePrev >= 0)) {
-      for (pb = START_BB_ENV; pb < END_BB_ENV; pb++) {
-        partNrg[pb] = ((fMultDiv2(alpha1, slotNrg[pb]) >> scaleCur) +
-                       (fMultDiv2(alpha, partNrgPrev[pb]) >> scalePrev))
-                      << 1;
-        maxVal |= partNrg[pb];
-        frameNrg += slotNrg[pb] >> 3;
-      }
-    } else if ((scaleCur < 0) && (scalePrev >= 0)) {
-      scaleCur = -scaleCur;
-      for (pb = START_BB_ENV; pb < END_BB_ENV; pb++) {
-        partNrg[pb] = ((fMultDiv2(alpha1, slotNrg[pb]) << scaleCur) +
-                       (fMultDiv2(alpha, partNrgPrev[pb]) >> scalePrev))
-                      << 1;
-        maxVal |= partNrg[pb];
-        frameNrg += slotNrg[pb] >> 3;
-      }
-    } else { /* if ( (scaleCur >= 0) && (scalePrev < 0) ) */
-      scalePrev = -scalePrev;
-      for (pb = START_BB_ENV; pb < END_BB_ENV; pb++) {
-        partNrg[pb] = ((fMultDiv2(alpha1, slotNrg[pb]) >> scaleCur) +
-                       (fMultDiv2(alpha, partNrgPrev[pb]) << scalePrev))
-                      << 1;
-        maxVal |= partNrg[pb];
-        frameNrg += slotNrg[pb] >> 3;
-      }
-    }
-
-    /* frameNrg /= (END_BB_ENV - START_BB_ENV); 0.88888888888f =
-     * (1/(END_BB_ENV-START_BB_ENV)<<3; shift with 3 is compensated in loop
-     * above */
-    frameNrg = fMult(frameNrg, FL2FXCONST_DBL(0.88888888888f));
-
-    /* store scalefactor and headroom for part nrg prev */
-    pPartNrgPrevSF[0] = partNrgSF;
-    pPartNrgPrev2SF[0] = fixMax(0, CntLeadingZeros(maxVal) - 1);
-
-    commonScale = fixMax(frameNrgSF - SF_ALPHA1 + 1, pFrameNrgPrevSF[0] + 1);
-    scalePrev = fixMin(commonScale - pFrameNrgPrevSF[0], DFRACT_BITS - 1);
-    scaleCur = fixMin(commonScale - frameNrgSF + SF_ALPHA1, DFRACT_BITS - 1);
-    frameNrgSF = commonScale;
-
-    frameNrg = ((fMultDiv2(alpha1, frameNrg) >> scaleCur) +
-                (fMultDiv2(alpha, pBBEnvState->frameNrgPrev__FDK[prevChOffs]) >>
-                 scalePrev))
-               << 1;
-
-    clz = fixMax(0, CntLeadingZeros(frameNrg) - 1);
-    pBBEnvState->frameNrgPrev__FDK[prevChOffs] = frameNrg << clz;
-    pFrameNrgPrevSF[0] = frameNrgSF - clz;
-
-    env = FL2FXCONST_DBL(0.0f);
-    scale = clz + partNrgSF - frameNrgSF;
-    scale_min = DFRACT_BITS - 1;
-    for (pb = START_BB_ENV; pb < END_BB_ENV; pb++) {
-      if ((partNrg[pb] | slotNrg[pb]) != FL2FXCONST_DBL(0.0f)) {
-        INT s;
-        INT sc = 0;
-        INT sn = fixMax(0, CntLeadingZeros(slotNrg[pb]) - 1);
-        FIXP_DBL inv_sqrt = invSqrtNorm2(partNrg[pb], &sc);
-        FIXP_DBL res = fMult(slotNrg[pb] << sn, fPow2(inv_sqrt));
-
-        s = fixMax(0, CntLeadingZeros(res) - 1);
-        res = res << s;
-
-        sc = scale - (2 * sc - sn - s);
-        scale_min = fixMin(scale_min, sc);
-
-        resPb[pb] = res;
-        resPbSF[pb] = sc;
-      } else {
-        resPb[pb] = (FIXP_DBL)0;
-        resPbSF[pb] = 0;
-      }
-    }
-
-    scale_min = 4 - scale_min;
-
-    for (pb = START_BB_ENV; pb < END_BB_ENV; pb++) {
-      INT sc = fixMax(fixMin(resPbSF[pb] + scale_min, DFRACT_BITS - 1),
-                      -(DFRACT_BITS - 1));
-
-      if (sc < 0) {
-        env += resPb[pb] << (-sc);
-      } else {
-        env += resPb[pb] >> (sc);
-      }
-    }
-
-    env = fMultDiv2(env, pBBEnvState->frameNrgPrev__FDK[prevChOffs]);
-    envSF = slotNrgSF + scale_min + 1;
-
-    commonScale = fixMax(envSF - SF_BETA1 + 1, pNormNrgPrevSF[0] + 1);
-    scalePrev = fixMin(commonScale - pNormNrgPrevSF[0], DFRACT_BITS - 1);
-    scaleCur = fixMin(commonScale - envSF + SF_BETA1, DFRACT_BITS - 1);
-
-    normNrg = ((fMultDiv2(beta1, env) >> scaleCur) +
-               (fMultDiv2(beta, pBBEnvState->normNrgPrev__FDK[prevChOffs]) >>
-                scalePrev))
-              << 1;
-
-    clz = fixMax(0, CntLeadingZeros(normNrg) - 1);
-    pBBEnvState->normNrgPrev__FDK[prevChOffs] = normNrg << clz;
-    pNormNrgPrevSF[0] = commonScale - clz;
-
-    if (shapeActiv) {
-      if ((env | normNrg) != FL2FXCONST_DBL(0.0f)) {
-        INT sc, se, sn;
-        se = fixMax(0, CntLeadingZeros(env) - 1);
-        sc = commonScale + SF_DIV32 - envSF + se;
-        env = fMult(sqrtFixp((env << se) >> (sc & 0x1)),
-                    invSqrtNorm2(normNrg, &sn));
-
-        sc = fixMin((sc >> 1) - sn, DFRACT_BITS - 1);
-        if (sc < 0) {
-          env <<= (-sc);
-        } else {
-          env >>= (sc);
-        }
-      }
-      /* env is scaled by SF_DIV32/2 bits */
-    }
-    pEnv[ch] = env;
-  }
-
-  C_ALLOC_SCRATCH_END(resPbSF, INT, (END_BB_ENV - START_BB_ENV));
-  C_ALLOC_SCRATCH_END(resPb, FIXP_DBL, (END_BB_ENV - START_BB_ENV));
-  C_ALLOC_SCRATCH_END(pScratchBuffer, FIXP_DBL, (2 * 42 + MAX_PARAMETER_BANDS));
-}
-
-void SpatialDecReshapeBBEnv(spatialDec *self, const SPATIAL_BS_FRAME *frame,
-                            INT ts) {
-  INT ch, scale;
-  INT dryFacSF, slotAmpSF;
-  FIXP_DBL tmp, dryFac, envShape;
-  FIXP_DBL slotAmp_dry, slotAmp_wet, slotAmp_ratio;
-  FIXP_DBL envDry[MAX_OUTPUT_CHANNELS], envDmx[2];
-
-  INT cplxBands;
-  INT hybBands = self->hybridBands - 6;
-
-  cplxBands = self->hybridBands - 6;
-
-  /* extract downmix envelope(s) */
-  switch (self->treeConfig) {
-    default:
-      extractBBEnv(self, INP_DMX, 0, fMin(self->numInputChannels, 2), envDmx,
-                   frame);
-  }
-
-  /* extract dry and wet envelopes */
-  extractBBEnv(self, INP_DRY_WET, 0, self->numOutputChannels, envDry, frame);
-
-  for (ch = 0; ch < self->numOutputChannels; ch++) {
-    INT ch2;
-
-    ch2 = row2channelGES[self->treeConfig][ch];
-
-    if (ch2 == -1) continue;
-
-    if (frame->tempShapeEnableChannelGES[ch2]) {
-      INT sc;
-
-      /* reshape dry and wet signals according to transmitted envelope */
-
-      /* De-quantize GES data */
-      FDK_ASSERT((frame->bsEnvShapeData[ch2][ts] >= 0) &&
-                 (frame->bsEnvShapeData[ch2][ts] <= 4));
-      FDK_ASSERT((self->envQuantMode == 0) || (self->envQuantMode == 1));
-      envShape =
-          FX_CFG2FX_DBL(envShapeDataTable__FDK[frame->bsEnvShapeData[ch2][ts]]
-                                              [self->envQuantMode]);
-
-      /* get downmix channel */
-      ch2 = self->row2channelDmxGES[ch];
-
-      /* multiply ratio with dmx envelope; tmp is scaled by SF_DIV32/2+SF_SHAPE
-       * bits */
-      if (ch2 == 2) {
-        tmp = fMultDiv2(envShape, envDmx[0]) + fMultDiv2(envShape, envDmx[1]);
-      } else {
-        tmp = fMult(envShape, envDmx[ch2]);
-      }
-
-      /* weighting factors */
-      dryFacSF = slotAmpSF = 0;
-      dryFac = slotAmp_ratio = FL2FXCONST_DBL(0.0f);
-
-      /* dryFac will be scaled by dryFacSF bits */
-      if (envDry[ch] != FL2FXCONST_DBL(0.0f)) {
-        envDry[ch] = invSqrtNorm2(envDry[ch], &dryFacSF);
-        dryFac = fMultDiv2(tmp, fPow2Div2(envDry[ch])) << 2;
-        dryFacSF = SF_SHAPE + 2 * dryFacSF;
-      }
-
-      /* calculate slotAmp_dry and slotAmp_wet */
-      slotAmp(&slotAmp_dry, &slotAmp_wet, &self->hybOutputRealDry__FDK[ch][6],
-              &self->hybOutputImagDry__FDK[ch][6],
-              &self->hybOutputRealWet__FDK[ch][6],
-              &self->hybOutputImagWet__FDK[ch][6], cplxBands, hybBands);
-
-      /* slotAmp_ratio will be scaled by slotAmpSF bits */
-      if (slotAmp_dry != FL2FXCONST_DBL(0.0f)) {
-        sc = fixMax(0, CntLeadingZeros(slotAmp_wet) - 1);
-        sc = sc - (sc & 1);
-
-        slotAmp_wet = sqrtFixp(slotAmp_wet << sc);
-        slotAmp_dry = invSqrtNorm2(slotAmp_dry, &slotAmpSF);
-
-        slotAmp_ratio = fMult(slotAmp_wet, slotAmp_dry);
-        slotAmpSF = slotAmpSF - (sc >> 1);
-      }
-
-      /* calculate common scale factor */
-      scale =
-          fixMax(3, fixMax(dryFacSF, slotAmpSF)); /* scale is at least with 3
-                                                     bits to avoid overflows
-                                                     when calculating dryFac  */
-      dryFac = dryFac >> (scale - dryFacSF);
-      slotAmp_ratio = slotAmp_ratio >> (scale - slotAmpSF);
-
-      /* limit dryFac */
-      dryFac = fixMax(
-          FL2FXCONST_DBL(0.25f) >> (INT)fixMin(2 * scale, DFRACT_BITS - 1),
-          fMult(dryFac, slotAmp_ratio) - (slotAmp_ratio >> scale) +
-              (dryFac >> scale));
-      dryFac = fixMin(
-          FL2FXCONST_DBL(0.50f) >> (INT)fixMin(2 * scale - 3, DFRACT_BITS - 1),
-          dryFac); /* reduce shift bits by 3, because upper
-                      limit 4.0 is scaled with 3 bits */
-      scale = 2 * scale + 1;
-
-      /* improve precision for dryFac */
-      sc = fixMax(0, CntLeadingZeros(dryFac) - 1);
-      dryFac = dryFac << (INT)fixMin(scale, sc);
-      scale = scale - fixMin(scale, sc);
-
-      /* shaping */
-      shapeBBEnv(&self->hybOutputRealDry__FDK[ch][6],
-                 &self->hybOutputImagDry__FDK[ch][6], dryFac, scale, cplxBands,
-                 hybBands);
-    }
-  }
-}
--- a/libSACdec/src/sac_reshapeBBEnv.h
+++ /dev/null
@@ -1,114 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround decoder library *************************
-
-   Author(s):
-
-   Description: SAC Dec guided envelope shaping
-
-*******************************************************************************/
-
-#ifndef SAC_RESHAPEBBENV_H
-#define SAC_RESHAPEBBENV_H
-
-#include "sac_dec_interface.h"
-
-#define BB_ENV_SIZE 9 /* END_BB_ENV - START_BB_ENV */
-
-void initBBEnv(spatialDec *self, int initStatesFlag);
-void SpatialDecReshapeBBEnv(spatialDec *self, const SPATIAL_BS_FRAME *frame,
-                            int ts);
-
-#endif
--- a/libSACdec/src/sac_rom.cpp
+++ /dev/null
@@ -1,709 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround decoder library *************************
-
-   Author(s):
-
-   Description: SAC Dec tables
-
-*******************************************************************************/
-
-#include "sac_rom.h"
-#include "sac_calcM1andM2.h"
-
-#define SCALE_CPC(a) (FL2FXCONST_CFG(a / (float)(1 << SCALE_PARAM_M1)))
-const FIXP_CFG dequantCPC__FDK[] = {
-    SCALE_CPC(-2.0f), SCALE_CPC(-1.9f), SCALE_CPC(-1.8f), SCALE_CPC(-1.7f),
-    SCALE_CPC(-1.6f), SCALE_CPC(-1.5f), SCALE_CPC(-1.4f), SCALE_CPC(-1.3f),
-    SCALE_CPC(-1.2f), SCALE_CPC(-1.1f), SCALE_CPC(-1.0f), SCALE_CPC(-0.9f),
-    SCALE_CPC(-0.8f), SCALE_CPC(-0.7f), SCALE_CPC(-0.6f), SCALE_CPC(-0.5f),
-    SCALE_CPC(-0.4f), SCALE_CPC(-0.3f), SCALE_CPC(-0.2f), SCALE_CPC(-0.1f),
-    SCALE_CPC(0.0f),  SCALE_CPC(0.1f),  SCALE_CPC(0.2f),  SCALE_CPC(0.3f),
-    SCALE_CPC(0.4f),  SCALE_CPC(0.5f),  SCALE_CPC(0.6f),  SCALE_CPC(0.7f),
-    SCALE_CPC(0.8f),  SCALE_CPC(0.9f),  SCALE_CPC(1.0f),  SCALE_CPC(1.1f),
-    SCALE_CPC(1.2f),  SCALE_CPC(1.3f),  SCALE_CPC(1.4f),  SCALE_CPC(1.5f),
-    SCALE_CPC(1.6f),  SCALE_CPC(1.7f),  SCALE_CPC(1.8f),  SCALE_CPC(1.9f),
-    SCALE_CPC(2.0f),  SCALE_CPC(2.1f),  SCALE_CPC(2.2f),  SCALE_CPC(2.3f),
-    SCALE_CPC(2.4f),  SCALE_CPC(2.5f),  SCALE_CPC(2.6f),  SCALE_CPC(2.7f),
-    SCALE_CPC(2.8f),  SCALE_CPC(2.9f),  SCALE_CPC(3.0f)};
-
-#define SCALE_ICC(a) (FL2FXCONST_CFG(a))
-const FIXP_CFG dequantICC__FDK[8] = {
-    /*SCALE_ICC(1.00000f)*/ FX_DBL2FX_CFG(MAXVAL_DBL),
-    SCALE_ICC(0.9370f),
-    SCALE_ICC(0.84118f),
-    SCALE_ICC(0.60092f),
-    SCALE_ICC(0.36764f),
-    SCALE_ICC(0.0000f),
-    SCALE_ICC(-0.58900f),
-    SCALE_ICC(-0.9900f)};
-
-#define SCALE_CLD2(a) (FL2FXCONST_CFG(a / (float)(1 << 8)))
-const FIXP_CFG dequantCLD__FDK[31] = {
-    SCALE_CLD2(-150.0f), SCALE_CLD2(-45.0f), SCALE_CLD2(-40.0f),
-    SCALE_CLD2(-35.0f),  SCALE_CLD2(-30.0f), SCALE_CLD2(-25.0f),
-    SCALE_CLD2(-22.0f),  SCALE_CLD2(-19.0f), SCALE_CLD2(-16.0f),
-    SCALE_CLD2(-13.0f),  SCALE_CLD2(-10.0f), SCALE_CLD2(-8.0f),
-    SCALE_CLD2(-6.0f),   SCALE_CLD2(-4.0f),  SCALE_CLD2(-2.0f),
-    SCALE_CLD2(0.0f),    SCALE_CLD2(2.0f),   SCALE_CLD2(4.0f),
-    SCALE_CLD2(6.0f),    SCALE_CLD2(8.0f),   SCALE_CLD2(10.0f),
-    SCALE_CLD2(13.0f),   SCALE_CLD2(16.0f),  SCALE_CLD2(19.0f),
-    SCALE_CLD2(22.0f),   SCALE_CLD2(25.0f),  SCALE_CLD2(30.0f),
-    SCALE_CLD2(35.0f),   SCALE_CLD2(40.0f),  SCALE_CLD2(45.0f),
-    SCALE_CLD2(150.0f)};
-
-#define SCALE_IPD(a) (FL2FXCONST_CFG(a / (float)(1 << IPD_SCALE)))
-const FIXP_CFG dequantIPD__FDK[16] = {
-    /* SCALE_IPD(0.000000000f), SCALE_IPD(0.392699082f),
-       SCALE_IPD(0.785398163f), SCALE_IPD(1.178097245f),
-       SCALE_IPD(1.570796327f), SCALE_IPD(1.963495408f),
-       SCALE_IPD(2.356194490f), SCALE_IPD(2.748893572f),
-       SCALE_IPD(3.141592654f), SCALE_IPD(3.534291735f),
-       SCALE_IPD(3.926990817f), SCALE_IPD(4.319689899f),
-       SCALE_IPD(4.712388980f), SCALE_IPD(5.105088062f),
-       SCALE_IPD(5.497787144f), SCALE_IPD(5.890486225f) */
-    SCALE_IPD(0.00000000000000f), SCALE_IPD(0.392699082f),
-    SCALE_IPD(0.78539816339745f), SCALE_IPD(1.178097245f),
-    SCALE_IPD(1.57079632679490f), SCALE_IPD(1.963495408f),
-    SCALE_IPD(2.35619449019234f), SCALE_IPD(2.748893572f),
-    SCALE_IPD(3.14159265358979f), SCALE_IPD(3.534291735f),
-    SCALE_IPD(3.92699081698724f), SCALE_IPD(4.319689899f),
-    SCALE_IPD(4.71238898038469f), SCALE_IPD(5.105088062f),
-    SCALE_IPD(5.49778714378214f), SCALE_IPD(5.890486225f)};
-
-#define SCALE_SPLIT_ANGLE(a) (FL2FXCONST_CFG(a / (float)(1 << IPD_SCALE)))
-/*
-  Generate table dequantIPD_CLD_ICC_splitAngle__FDK[16][31][8]:
-
-  #define ABS_THR                         ( 1e-9f * 32768 * 32768 )
-
-  float dequantICC[] =
-  {1.0000f,0.9370f,0.84118f,0.60092f,0.36764f,0.0f,-0.5890f,-0.9900f}; float
-  dequantCLD[] =
-  {-150.0,-45.0,-40.0,-35.0,-30.0,-25.0,-22.0,-19.0,-16.0,-13.0,-10.0, -8.0,
-                          -6.0, -4.0, -2.0,  0.0,  2.0,  4.0,  6.0,  8.0,
-  10.0, 13.0, 16.0, 19.0, 22.0, 25.0, 30.0, 35.0, 40.0, 45.0, 150.0 }; float
-  dequantIPD[] =
-  {0.f,0.392699082f,0.785398163f,1.178097245f,1.570796327f,1.963495408f,
-                        2.35619449f,2.748893572f,3.141592654f,3.534291735f,3.926990817f,
-                        4.319689899f,4.71238898f,5.105088062f,5.497787144f,5.890486225f};
-
-  for (ipdIdx=0; ipdIdx<16; ipdIdx++)
-    for (cldIdx=0; cldIdx<31; cldIdx++)
-      for (iccIdx=0; iccIdx<8; iccIdx++) {
-        ipd = dequantIPD[ipdIdx];
-        cld = dequantCLD[cldIdx];
-        icc = dequantICC[iccIdx];
-        iidLin = (float) pow(10.0f, cld / 20.0f);
-        iidLin2 = iidLin * iidLin;
-        iidLin21 = iidLin2 + 1.0f;
-        sinIpd = (float) sin(ipd);
-        cosIpd = (float) cos(ipd);
-        temp1 = 2.0f * icc * iidLin;
-        temp1c = temp1 * cosIpd;
-        ratio = (iidLin21 + temp1c) / (iidLin21 + temp1) + ABS_THR;
-        w2 = (float) pow(ratio, 0.25f);
-        w1 = 2.0f - w2;
-        dequantIPD_CLD_ICC_splitAngle__FDK[ipdIdx][cldIdx][iccIdx] = (float)
-  atan2(w2 * sinIpd, w1 * iidLin + w2 * cosIpd);
-      }
-*/
-
-#define SCALE_CLD(a) (FL2FXCONST_CFG(a))
-
-const FIXP_CFG dequantCLD_c_l[31] = {
-    SCALE_CLD(0.0000000316f),
-    SCALE_CLD(0.0056233243f),
-    SCALE_CLD(0.0099994997f),
-    SCALE_CLD(0.0177799836f),
-    SCALE_CLD(0.0316069759f),
-    SCALE_CLD(0.0561454296f),
-    SCALE_CLD(0.0791834071f),
-    SCALE_CLD(0.1115021780f),
-    SCALE_CLD(0.1565355062f),
-    SCALE_CLD(0.2184644639f),
-    SCALE_CLD(0.3015113473f),
-    SCALE_CLD(0.3698741496f),
-    SCALE_CLD(0.4480624795f),
-    SCALE_CLD(0.5336171389f),
-    SCALE_CLD(0.6219832301f),
-    SCALE_CLD(0.7071067691f),
-    SCALE_CLD(0.7830305696f),
-    SCALE_CLD(0.8457261920f),
-    SCALE_CLD(0.8940021992f),
-    SCALE_CLD(0.9290818572f),
-    SCALE_CLD(0.9534626007f),
-    SCALE_CLD(0.9758449197f),
-    SCALE_CLD(0.9876723289f),
-    SCALE_CLD(0.9937641621f),
-    SCALE_CLD(0.9968600869f),
-    SCALE_CLD(0.9984226227f),
-    SCALE_CLD(0.9995003939f),
-    SCALE_CLD(0.9998419285f),
-    SCALE_CLD(0.9999499917f),
-    SCALE_CLD(0.9999842048f),
-    /*SCALE_CLD(1.0000000000f)*/ FX_DBL2FX_CFG(MAXVAL_DBL)};
-
-#define SC_H(a) (FL2FXCONST_CFG(a))
-#define DATA_TYPE_H FIXP_CFG
-
-/* not correlated  tables */
-const DATA_TYPE_H H11_nc[31][8] = {
-    {SC_H(0.0000000316f), SC_H(0.0000000296f), SC_H(0.0000000266f),
-     SC_H(0.0000000190f), SC_H(0.0000000116f), SC_H(0.0000000000f),
-     SC_H(-0.0000000186f), SC_H(-0.0000000313f)},
-    {SC_H(0.0056233243f), SC_H(0.0052728835f), SC_H(0.0047394098f),
-     SC_H(0.0033992692f), SC_H(0.0020946222f), SC_H(0.0000316215f),
-     SC_H(-0.0032913829f), SC_H(-0.0055664564f)},
-    {SC_H(0.0099994997f), SC_H(0.0093815643f), SC_H(0.0084402543f),
-     SC_H(0.0060722125f), SC_H(0.0037622179f), SC_H(0.0000999898f),
-     SC_H(-0.0058238208f), SC_H(-0.0098974844f)},
-    {SC_H(0.0177799836f), SC_H(0.0166974831f), SC_H(0.0150465844f),
-     SC_H(0.0108831404f), SC_H(0.0068073822f), SC_H(0.0003161267f),
-     SC_H(-0.0102626514f), SC_H(-0.0175957214f)},
-    {SC_H(0.0316069759f), SC_H(0.0297324844f), SC_H(0.0268681273f),
-     SC_H(0.0196138974f), SC_H(0.0124691967f), SC_H(0.0009989988f),
-     SC_H(-0.0179452803f), SC_H(-0.0312700421f)},
-    {SC_H(0.0561454296f), SC_H(0.0529650487f), SC_H(0.0480896905f),
-     SC_H(0.0356564634f), SC_H(0.0232860073f), SC_H(0.0031523081f),
-     SC_H(-0.0309029408f), SC_H(-0.0555154830f)},
-    {SC_H(0.0791834071f), SC_H(0.0748842582f), SC_H(0.0682762116f),
-     SC_H(0.0513241664f), SC_H(0.0343080349f), SC_H(0.0062700072f),
-     SC_H(-0.0422340371f), SC_H(-0.0782499388f)},
-    {SC_H(0.1115021780f), SC_H(0.1057924852f), SC_H(0.0969873071f),
-     SC_H(0.0742305145f), SC_H(0.0511277616f), SC_H(0.0124327289f),
-     SC_H(-0.0566596612f), SC_H(-0.1100896299f)},
-    {SC_H(0.1565355062f), SC_H(0.1491366178f), SC_H(0.1376826316f),
-     SC_H(0.1078186408f), SC_H(0.0770794004f), SC_H(0.0245033558f),
-     SC_H(-0.0735980421f), SC_H(-0.1543303132f)},
-    {SC_H(0.2184644639f), SC_H(0.2091979682f), SC_H(0.1947948188f),
-     SC_H(0.1568822265f), SC_H(0.1172478944f), SC_H(0.0477267131f),
-     SC_H(-0.0899507254f), SC_H(-0.2148526460f)},
-    {SC_H(0.3015113473f), SC_H(0.2904391289f), SC_H(0.2731673419f),
-     SC_H(0.2273024023f), SC_H(0.1786239147f), SC_H(0.0909090787f),
-     SC_H(-0.0964255333f), SC_H(-0.2951124907f)},
-    {SC_H(0.3698741496f), SC_H(0.3578284085f), SC_H(0.3390066922f),
-     SC_H(0.2888108492f), SC_H(0.2351117432f), SC_H(0.1368068755f),
-     SC_H(-0.0850296095f), SC_H(-0.3597966135f)},
-    {SC_H(0.4480624795f), SC_H(0.4354025424f), SC_H(0.4156077504f),
-     SC_H(0.3627120256f), SC_H(0.3058823943f), SC_H(0.2007599771f),
-     SC_H(-0.0484020934f), SC_H(-0.4304940701f)},
-    {SC_H(0.5336171389f), SC_H(0.5208471417f), SC_H(0.5008935928f),
-     SC_H(0.4476420581f), SC_H(0.3905044496f), SC_H(0.2847472429f),
-     SC_H(0.0276676007f), SC_H(-0.4966579080f)},
-    {SC_H(0.6219832301f), SC_H(0.6096963882f), SC_H(0.5905415416f),
-     SC_H(0.5396950245f), SC_H(0.4856070578f), SC_H(0.3868631124f),
-     SC_H(0.1531652957f), SC_H(-0.5045361519f)},
-    {SC_H(0.7071067691f), SC_H(0.6958807111f), SC_H(0.6784504056f),
-     SC_H(0.6326373219f), SC_H(0.5847306848f), SC_H(0.4999999702f),
-     SC_H(0.3205464482f), SC_H(0.0500000045f)},
-    {SC_H(0.7830305696f), SC_H(0.7733067870f), SC_H(0.7582961321f),
-     SC_H(0.7194055915f), SC_H(0.6797705293f), SC_H(0.6131368876f),
-     SC_H(0.4997332692f), SC_H(0.6934193969f)},
-    {SC_H(0.8457261920f), SC_H(0.8377274871f), SC_H(0.8254694939f),
-     SC_H(0.7942851782f), SC_H(0.7635439038f), SC_H(0.7152527571f),
-     SC_H(0.6567122936f), SC_H(0.8229061961f)},
-    {SC_H(0.8940021992f), SC_H(0.8877248168f), SC_H(0.8781855106f),
-     SC_H(0.8544237614f), SC_H(0.8318918347f), SC_H(0.7992399335f),
-     SC_H(0.7751275301f), SC_H(0.8853276968f)},
-    {SC_H(0.9290818572f), SC_H(0.9243524075f), SC_H(0.9172304869f),
-     SC_H(0.8998877406f), SC_H(0.8841174841f), SC_H(0.8631930947f),
-     SC_H(0.8565139771f), SC_H(0.9251161218f)},
-    {SC_H(0.9534626007f), SC_H(0.9500193000f), SC_H(0.9448821545f),
-     SC_H(0.9326565266f), SC_H(0.9220023751f), SC_H(0.9090909362f),
-     SC_H(0.9096591473f), SC_H(0.9514584541f)},
-    {SC_H(0.9758449197f), SC_H(0.9738122821f), SC_H(0.9708200693f),
-     SC_H(0.9639287591f), SC_H(0.9582763910f), SC_H(0.9522733092f),
-     SC_H(0.9553207159f), SC_H(0.9750427008f)},
-    {SC_H(0.9876723289f), SC_H(0.9865267277f), SC_H(0.9848603010f),
-     SC_H(0.9811310172f), SC_H(0.9782302976f), SC_H(0.9754966497f),
-     SC_H(0.9779621363f), SC_H(0.9873252511f)},
-    {SC_H(0.9937641621f), SC_H(0.9931397438f), SC_H(0.9922404289f),
-     SC_H(0.9902750254f), SC_H(0.9888116717f), SC_H(0.9875672460f),
-     SC_H(0.9891131520f), SC_H(0.9936066866f)},
-    {SC_H(0.9968600869f), SC_H(0.9965277910f), SC_H(0.9960530400f),
-     SC_H(0.9950347543f), SC_H(0.9943022728f), SC_H(0.9937300086f),
-     SC_H(0.9946073294f), SC_H(0.9967863560f)},
-    {SC_H(0.9984226227f), SC_H(0.9982488155f), SC_H(0.9980020523f),
-     SC_H(0.9974802136f), SC_H(0.9971146584f), SC_H(0.9968476892f),
-     SC_H(0.9973216057f), SC_H(0.9983873963f)},
-    {SC_H(0.9995003939f), SC_H(0.9994428754f), SC_H(0.9993617535f),
-     SC_H(0.9991930723f), SC_H(0.9990783334f), SC_H(0.9990010262f),
-     SC_H(0.9991616607f), SC_H(0.9994897842f)},
-    {SC_H(0.9998419285f), SC_H(0.9998232722f), SC_H(0.9997970462f),
-     SC_H(0.9997430444f), SC_H(0.9997069836f), SC_H(0.9996838570f),
-     SC_H(0.9997364879f), SC_H(0.9998386502f)},
-    {SC_H(0.9999499917f), SC_H(0.9999440312f), SC_H(0.9999356270f),
-     SC_H(0.9999184012f), SC_H(0.9999070764f), SC_H(0.9998999834f),
-     SC_H(0.9999169707f), SC_H(0.9999489784f)},
-    {SC_H(0.9999842048f), SC_H(0.9999822974f), SC_H(0.9999796152f),
-     SC_H(0.9999741912f), SC_H(0.9999706149f), SC_H(0.9999684095f),
-     SC_H(0.9999738336f), SC_H(0.9999839067f)},
-    /* { SC_H( 1.0000000000f), SC_H( 1.0000000000f), SC_H( 1.0000000000f),
-       SC_H( 1.0000000000f), SC_H( 1.0000000000f), SC_H( 1.0000000000f),
-       SC_H( 1.0000000000f), SC_H( 1.0000000000f)} */
-    {FX_DBL2FX_CFG(MAXVAL_DBL), FX_DBL2FX_CFG(MAXVAL_DBL),
-     FX_DBL2FX_CFG(MAXVAL_DBL), FX_DBL2FX_CFG(MAXVAL_DBL),
-     FX_DBL2FX_CFG(MAXVAL_DBL), FX_DBL2FX_CFG(MAXVAL_DBL),
-     FX_DBL2FX_CFG(MAXVAL_DBL), FX_DBL2FX_CFG(MAXVAL_DBL)}};
-const DATA_TYPE_H H12_nc[31][8] = {
-    {SC_H(0.0000000000f), SC_H(0.0000000110f), SC_H(0.0000000171f),
-     SC_H(0.0000000253f), SC_H(0.0000000294f), SC_H(0.0000000316f),
-     SC_H(0.0000000256f), SC_H(0.0000000045f)},
-    {SC_H(0.0000000000f), SC_H(0.0019540924f), SC_H(0.0030265113f),
-     SC_H(0.0044795922f), SC_H(0.0052186525f), SC_H(0.0056232354f),
-     SC_H(0.0045594489f), SC_H(0.0007977085f)},
-    {SC_H(0.0000000000f), SC_H(0.0034606720f), SC_H(0.0053620986f),
-     SC_H(0.0079446984f), SC_H(0.0092647560f), SC_H(0.0099989995f),
-     SC_H(0.0081285369f), SC_H(0.0014247064f)},
-    {SC_H(0.0000000000f), SC_H(0.0061091618f), SC_H(0.0094724922f),
-     SC_H(0.0140600521f), SC_H(0.0164252054f), SC_H(0.0177771728f),
-     SC_H(0.0145191532f), SC_H(0.0025531140f)},
-    {SC_H(0.0000000000f), SC_H(0.0107228858f), SC_H(0.0166464616f),
-     SC_H(0.0247849934f), SC_H(0.0290434174f), SC_H(0.0315911844f),
-     SC_H(0.0260186065f), SC_H(0.0046027615f)},
-    {SC_H(0.0000000000f), SC_H(0.0186282862f), SC_H(0.0289774220f),
-     SC_H(0.0433696397f), SC_H(0.0510888547f), SC_H(0.0560568646f),
-     SC_H(0.0468755551f), SC_H(0.0083869267f)},
-    {SC_H(0.0000000000f), SC_H(0.0257363543f), SC_H(0.0401044972f),
-     SC_H(0.0602979437f), SC_H(0.0713650510f), SC_H(0.0789347738f),
-     SC_H(0.0669798329f), SC_H(0.0121226767f)},
-    {SC_H(0.0000000000f), SC_H(0.0352233723f), SC_H(0.0550108925f),
-     SC_H(0.0832019597f), SC_H(0.0990892947f), SC_H(0.1108068749f),
-     SC_H(0.0960334241f), SC_H(0.0176920593f)},
-    {SC_H(0.0000000000f), SC_H(0.0475566536f), SC_H(0.0744772255f),
-     SC_H(0.1134835035f), SC_H(0.1362429112f), SC_H(0.1546057910f),
-     SC_H(0.1381545961f), SC_H(0.0261824392f)},
-    {SC_H(0.0000000000f), SC_H(0.0629518181f), SC_H(0.0989024863f),
-     SC_H(0.1520351619f), SC_H(0.1843357086f), SC_H(0.2131874412f),
-     SC_H(0.1990868896f), SC_H(0.0395608991f)},
-    {SC_H(0.0000000000f), SC_H(0.0809580907f), SC_H(0.1276271492f),
-     SC_H(0.1980977356f), SC_H(0.2429044843f), SC_H(0.2874797881f),
-     SC_H(0.2856767476f), SC_H(0.0617875643f)},
-    {SC_H(0.0000000000f), SC_H(0.0936254337f), SC_H(0.1479234397f),
-     SC_H(0.2310739607f), SC_H(0.2855334580f), SC_H(0.3436433673f),
-     SC_H(0.3599678576f), SC_H(0.0857512727f)},
-    {SC_H(0.0000000000f), SC_H(0.1057573780f), SC_H(0.1674221754f),
-     SC_H(0.2630588412f), SC_H(0.3274079263f), SC_H(0.4005688727f),
-     SC_H(0.4454404712f), SC_H(0.1242370531f)},
-    {SC_H(0.0000000000f), SC_H(0.1160409302f), SC_H(0.1839915067f),
-     SC_H(0.2904545665f), SC_H(0.3636667728f), SC_H(0.4512939751f),
-     SC_H(0.5328993797f), SC_H(0.1951362640f)},
-    {SC_H(0.0000000000f), SC_H(0.1230182052f), SC_H(0.1952532977f),
-     SC_H(0.3091802597f), SC_H(0.3886501491f), SC_H(0.4870318770f),
-     SC_H(0.6028295755f), SC_H(0.3637395203f)},
-    {SC_H(0.0000000000f), SC_H(0.1254990250f), SC_H(0.1992611140f),
-     SC_H(0.3158638775f), SC_H(0.3976053298f), SC_H(0.5000000000f),
-     SC_H(0.6302776933f), SC_H(0.7053368092f)},
-    {SC_H(0.0000000000f), SC_H(0.1230182052f), SC_H(0.1952533126f),
-     SC_H(0.3091802597f), SC_H(0.3886501491f), SC_H(0.4870319068f),
-     SC_H(0.6028295755f), SC_H(0.3637394905f)},
-    {SC_H(0.0000000000f), SC_H(0.1160409302f), SC_H(0.1839915216f),
-     SC_H(0.2904545665f), SC_H(0.3636668026f), SC_H(0.4512939751f),
-     SC_H(0.5328993797f), SC_H(0.1951362044f)},
-    {SC_H(0.0000000000f), SC_H(0.1057573855f), SC_H(0.1674221754f),
-     SC_H(0.2630588710f), SC_H(0.3274079263f), SC_H(0.4005688727f),
-     SC_H(0.4454405010f), SC_H(0.1242370382f)},
-    {SC_H(0.0000000000f), SC_H(0.0936254337f), SC_H(0.1479234397f),
-     SC_H(0.2310739607f), SC_H(0.2855334580f), SC_H(0.3436433673f),
-     SC_H(0.3599678576f), SC_H(0.0857512653f)},
-    {SC_H(0.0000000000f), SC_H(0.0809580907f), SC_H(0.1276271492f),
-     SC_H(0.1980977207f), SC_H(0.2429044843f), SC_H(0.2874797881f),
-     SC_H(0.2856767476f), SC_H(0.0617875606f)},
-    {SC_H(0.0000000000f), SC_H(0.0629518107f), SC_H(0.0989024863f),
-     SC_H(0.1520351619f), SC_H(0.1843357235f), SC_H(0.2131874412f),
-     SC_H(0.1990868896f), SC_H(0.0395609401f)},
-    {SC_H(0.0000000000f), SC_H(0.0475566462f), SC_H(0.0744772255f),
-     SC_H(0.1134835184f), SC_H(0.1362429112f), SC_H(0.1546057761f),
-     SC_H(0.1381545961f), SC_H(0.0261824802f)},
-    {SC_H(0.0000000000f), SC_H(0.0352233797f), SC_H(0.0550108962f),
-     SC_H(0.0832019448f), SC_H(0.0990892798f), SC_H(0.1108068526f),
-     SC_H(0.0960334465f), SC_H(0.0176920686f)},
-    {SC_H(0.0000000000f), SC_H(0.0257363524f), SC_H(0.0401044935f),
-     SC_H(0.0602979474f), SC_H(0.0713650808f), SC_H(0.0789347589f),
-     SC_H(0.0669797957f), SC_H(0.0121226516f)},
-    {SC_H(0.0000000000f), SC_H(0.0186282881f), SC_H(0.0289774258f),
-     SC_H(0.0433696248f), SC_H(0.0510888547f), SC_H(0.0560568906f),
-     SC_H(0.0468755886f), SC_H(0.0083869714f)},
-    {SC_H(0.0000000000f), SC_H(0.0107228830f), SC_H(0.0166464727f),
-     SC_H(0.0247849822f), SC_H(0.0290434249f), SC_H(0.0315911621f),
-     SC_H(0.0260186475f), SC_H(0.0046027377f)},
-    {SC_H(0.0000000000f), SC_H(0.0061091576f), SC_H(0.0094724894f),
-     SC_H(0.0140600465f), SC_H(0.0164251942f), SC_H(0.0177771524f),
-     SC_H(0.0145191504f), SC_H(0.0025530567f)},
-    {SC_H(0.0000000000f), SC_H(0.0034606743f), SC_H(0.0053620976f),
-     SC_H(0.0079446994f), SC_H(0.0092647672f), SC_H(0.0099990256f),
-     SC_H(0.0081285043f), SC_H(0.0014247177f)},
-    {SC_H(0.0000000000f), SC_H(0.0019540912f), SC_H(0.0030265225f),
-     SC_H(0.0044795908f), SC_H(0.0052186381f), SC_H(0.0056232223f),
-     SC_H(0.0045594289f), SC_H(0.0007977359f)},
-    {SC_H(0.0000000000f), SC_H(0.0000000149f), SC_H(0.0000000298f),
-     SC_H(0.0000000298f), SC_H(0.0000000000f), SC_H(0.0000000596f),
-     SC_H(0.0000000000f), SC_H(0.0000000000f)}};
-
-/*
-  for (i=0; i<31; i++) {
-    cld = dequantCLD[i];
-    val = (float)(FDKexp(cld/dbe)/(1+FDKexp(cld/dbe)));
-    val = (float)(dbe*FDKlog(val));
-  }
-*/
-#define SCALE_CLD_C1C2(a) (FL2FXCONST_DBL(a / (float)(1 << SF_CLD_C1C2)))
-const FIXP_DBL dequantCLD_c1[31] = {SCALE_CLD_C1C2(-1.5000000000000000e+002f),
-                                    SCALE_CLD_C1C2(-4.5000137329101563e+001f),
-                                    SCALE_CLD_C1C2(-4.0000434875488281e+001f),
-                                    SCALE_CLD_C1C2(-3.5001373291015625e+001f),
-                                    SCALE_CLD_C1C2(-3.0004341125488281e+001f),
-                                    SCALE_CLD_C1C2(-2.5013711929321289e+001f),
-                                    SCALE_CLD_C1C2(-2.2027315139770508e+001f),
-                                    SCALE_CLD_C1C2(-1.9054332733154297e+001f),
-                                    SCALE_CLD_C1C2(-1.6107742309570313e+001f),
-                                    SCALE_CLD_C1C2(-1.3212384223937988e+001f),
-                                    SCALE_CLD_C1C2(-1.0413927078247070e+001f),
-                                    SCALE_CLD_C1C2(-8.6389207839965820e+000f),
-                                    SCALE_CLD_C1C2(-6.9732279777526855e+000f),
-                                    SCALE_CLD_C1C2(-5.4554042816162109e+000f),
-                                    SCALE_CLD_C1C2(-4.1244258880615234e+000f),
-                                    SCALE_CLD_C1C2(-3.0102999210357666e+000f),
-                                    SCALE_CLD_C1C2(-2.1244258880615234e+000f),
-                                    SCALE_CLD_C1C2(-1.4554045200347900e+000f),
-                                    SCALE_CLD_C1C2(-9.7322785854339600e-001f),
-                                    SCALE_CLD_C1C2(-6.3892036676406860e-001f),
-                                    SCALE_CLD_C1C2(-4.1392669081687927e-001f),
-                                    SCALE_CLD_C1C2(-2.1238386631011963e-001f),
-                                    SCALE_CLD_C1C2(-1.0774217545986176e-001f),
-                                    SCALE_CLD_C1C2(-5.4333221167325974e-002f),
-                                    SCALE_CLD_C1C2(-2.7315950021147728e-002f),
-                                    SCALE_CLD_C1C2(-1.3711934909224510e-002f),
-                                    SCALE_CLD_C1C2(-4.3406565673649311e-003f),
-                                    SCALE_CLD_C1C2(-1.3732088264077902e-003f),
-                                    SCALE_CLD_C1C2(-4.3438826105557382e-004f),
-                                    SCALE_CLD_C1C2(-1.3745666365139186e-004f),
-                                    SCALE_CLD_C1C2(0.0000000000000000e+000f)};
-
-/* sac_stp */
-/* none scaled */
-const FIXP_CFG BP__FDK[] = {FL2FXCONST_CFG(0.73919999599457),
-                            FL2FXCONST_CFG(0.97909998893738),
-                            FL2FXCONST_CFG(0.99930000305176)};
-
-/* scaled with 26 bits */
-const FIXP_CFG BP_GF__FDK[] = {
-    FL2FXCONST_CFG(0.00000000643330), FL2FXCONST_CFG(0.00004396850232),
-    FL2FXCONST_CFG(0.00087456948552), FL2FXCONST_CFG(0.00474648220243),
-    FL2FXCONST_CFG(0.01717987244800), FL2FXCONST_CFG(0.04906742491073),
-    FL2FXCONST_CFG(0.10569518656729), FL2FXCONST_CFG(0.21165767592653),
-    FL2FXCONST_CFG(0.36036762478024), FL2FXCONST_CFG(0.59894182766948),
-    FL2FXCONST_CFG(0.81641678929129), FL2FXCONST_CFG(0.97418481133397),
-    FL2FXCONST_CFG(0.99575411610845), FL2FXCONST_CFG(0.88842666281361),
-    FL2FXCONST_CFG(0.79222317063736), FL2FXCONST_CFG(0.70828604318604),
-    FL2FXCONST_CFG(0.66395054816338), FL2FXCONST_CFG(0.64633739516952),
-    FL2FXCONST_CFG(0.66098278185255)};
-
-/* sac_bitdec */
-const INT samplingFreqTable[16] = {96000, 88200, 64000, 48000, 44100, 32000,
-                                   24000, 22050, 16000, 12000, 11025, 8000,
-                                   7350,  0,     0,     0};
-
-const UCHAR freqResTable[] = {0, 28, 20, 14, 10, 7, 5, 4};
-
-const UCHAR freqResTable_LD[] = {0, 23, 15, 12, 9, 7, 5, 4};
-
-const UCHAR tempShapeChanTable[][8] = {{5, 5, 4, 6, 6, 4, 4, 2},
-                                       {5, 5, 5, 7, 7, 4, 4, 2}};
-
-const TREEPROPERTIES treePropertyTable[] = {
-    {1, 6, 5, 0, {0, 0, 0, 0, 1}}, {1, 6, 5, 0, {0, 0, 1, 0, 0}},
-    {2, 6, 3, 1, {1, 0, 0, 0, 0}}, {2, 8, 5, 1, {1, 0, 0, 0, 0}},
-    {2, 8, 5, 1, {1, 0, 0, 0, 0}}, {6, 8, 2, 0, {0, 0, 0, 0, 0}},
-    {6, 8, 2, 0, {0, 0, 0, 0, 0}}, {1, 2, 1, 0, {0, 0, 0, 0, 0}}};
-
-const SCHAR kernels_4_to_71[MAX_HYBRID_BANDS] = {
-    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-    2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
-    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
-    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
-    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
-    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};
-
-const SCHAR kernels_5_to_71[MAX_HYBRID_BANDS] = {
-    0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3,
-    3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
-    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
-    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
-    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
-    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4};
-
-const SCHAR kernels_7_to_71[MAX_HYBRID_BANDS] = {
-    0, 0, 0, 0, 0, 0, 1, 1, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5,
-    5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
-    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
-    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
-    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
-    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6};
-
-const SCHAR kernels_10_to_71[MAX_HYBRID_BANDS] = {
-    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 7, 7, 7, 8, 8,
-    8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
-    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
-    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
-    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
-    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9};
-
-const SCHAR kernels_14_to_71[MAX_HYBRID_BANDS] = {
-    0,  0,  0,  0,  1,  1,  2,  3,  4,  4,  5,  6,  6,  7,  7,  8,  8,
-    8,  9,  9,  9,  10, 10, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12,
-    12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13,
-    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
-    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
-    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
-    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
-    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13};
-
-const SCHAR kernels_20_to_71[MAX_HYBRID_BANDS] = {
-    0,  0,  1,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14,
-    14, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 18, 18, 18, 18,
-    18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19,
-    19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
-    19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
-    19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
-    19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
-    19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19};
-
-const SCHAR kernels_28_to_71[MAX_HYBRID_BANDS] = {
-    0,  0,  1,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14,
-    15, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 21, 22, 22, 22, 23,
-    23, 23, 23, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 26, 26, 26,
-    26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
-    27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
-    27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
-    27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
-    27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27};
-
-const SCHAR kernels_4_to_64[MAX_HYBRID_BANDS] = {
-    0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-    2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
-    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
-    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
-    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
-    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};
-
-const SCHAR kernels_5_to_64[MAX_HYBRID_BANDS] = {
-    0, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
-    3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
-    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
-    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
-    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
-    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4};
-
-const SCHAR kernels_7_to_64[MAX_HYBRID_BANDS] = {
-    0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5,
-    5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
-    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
-    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
-    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
-    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6};
-
-const SCHAR kernels_9_to_64[MAX_HYBRID_BANDS] = {
-    0, 1, 2, 3, 3, 4, 4, 5, 5, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7,
-    7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
-    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
-    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
-    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
-    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8};
-
-const SCHAR kernels_12_to_64[MAX_HYBRID_BANDS] = {
-    0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  7,  7,  7,  8,  8,  8,  8,  9,
-    9,  9,  9,  9,  10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11,
-    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
-    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
-    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
-    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
-    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11};
-
-const SCHAR kernels_15_to_64[MAX_HYBRID_BANDS] = {
-    0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  9,  10, 10, 10, 11, 11, 11, 11, 12,
-    12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14,
-    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
-    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
-    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
-    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
-    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14};
-
-const SCHAR kernels_23_to_64[MAX_HYBRID_BANDS] = {
-    0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 12, 13, 13, 14, 14, 15,
-    15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 19, 20, 20, 20,
-    20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22,
-    22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
-    22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
-    22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
-    22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22};
-
-const UCHAR mapping_15_to_23[MAX_PARAMETER_BANDS_LD] = {
-    0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  9, 10,
-    10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14};
-
-const UCHAR mapping_12_to_23[MAX_PARAMETER_BANDS_LD] = {
-    0, 1, 2, 3, 4, 4, 5, 5, 6, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 10, 11, 11, 11};
-
-const UCHAR mapping_9_to_23[MAX_PARAMETER_BANDS_LD] = {
-    0, 1, 2, 3, 3, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8};
-
-const UCHAR mapping_7_to_23[MAX_PARAMETER_BANDS_LD] = {
-    0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6};
-
-const UCHAR mapping_5_to_23[MAX_PARAMETER_BANDS_LD] = {
-    0, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4};
-
-const UCHAR mapping_4_to_23[MAX_PARAMETER_BANDS_LD] = {
-    0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3};
-
-const FIXP_CFG clipGainTable__FDK[] = {
-    /*CLIP_PROTECT_GAIN_0(1.000000f)*/ FX_DBL2FX_CFG(MAXVAL_DBL),
-    CLIP_PROTECT_GAIN_1(1.189207f),
-    CLIP_PROTECT_GAIN_1(1.414213f),
-    CLIP_PROTECT_GAIN_1(1.681792f),
-    /*CLIP_PROTECT_GAIN_1(2.000000f)*/ FX_DBL2FX_CFG(MAXVAL_DBL),
-    CLIP_PROTECT_GAIN_2(2.378414f),
-    CLIP_PROTECT_GAIN_2(2.828427f),
-    /*CLIP_PROTECT_GAIN_2(4.000000f)*/ FX_DBL2FX_CFG(MAXVAL_DBL)};
-
-const UCHAR clipGainSFTable__FDK[] = {0, 1, 1, 1, 1, 2, 2, 2};
-
-const UCHAR pbStrideTable[] = {1, 2, 5, 28};
-
-const int smgTimeTable[] = {64, 128, 256, 512};
-
-/* table is scaled by factor 0.5 */
-const FIXP_CFG envShapeDataTable__FDK[5][2] = {
-    {FL2FXCONST_CFG(0.25000000000000f), FL2FXCONST_CFG(0.25000000000000f)},
-    {FL2FXCONST_CFG(0.35355339059327f), FL2FXCONST_CFG(0.31498026247372f)},
-    {FL2FXCONST_CFG(0.50000000000000f), FL2FXCONST_CFG(0.39685026299205f)},
-    {FL2FXCONST_CFG(0.70710678118655f), FL2FXCONST_CFG(0.50000000000000f)},
-    {/*FL2FXCONST_CFG( 1.00000000000000f)*/ FX_DBL2FX_CFG(MAXVAL_DBL),
-     FL2FXCONST_CFG(0.62996052494744f)}};
-
-/* sac_calcM1andM2 */
-const SCHAR row2channelSTP[][MAX_M2_INPUT] = {{0, 1}, {0, 3}, {0, 2},  {0, 4},
-                                              {0, 4}, {0, 2}, {-1, 2}, {0, 1}};
-
-const SCHAR row2channelGES[][MAX_M2_INPUT] = {{0, 1}, {0, 3}, {0, 3},  {0, 5},
-                                              {0, 5}, {0, 2}, {-1, 2}, {0, 1}};
-
-const SCHAR row2residual[][MAX_M2_INPUT] = {{-1, 0},  {-1, 0},  {-1, -1},
-                                            {-1, -1}, {-1, -1}, {-1, -1},
-                                            {-1, -1}, {-1, 0}};
-
-/*******************************************************************************
- Functionname: sac_getCLDValues
- *******************************************************************************
-
- Description: Get CLD values from table index.
-
- Arguments:
-   index: Table index
-   *cu, *cl : Pointer to locations where resulting values will be written to.
-
- Return: nothing
-
-*******************************************************************************/
-void SpatialDequantGetCLDValues(int index, FIXP_DBL* cu, FIXP_DBL* cl) {
-  *cu = FX_CFG2FX_DBL(dequantCLD_c_l[index]);
-  *cl = FX_CFG2FX_DBL(dequantCLD_c_l[31 - 1 - index]);
-}
-
-void SpatialDequantGetCLD2Values(int idx, FIXP_DBL* x) {
-  *x = FX_CFG2FX_DBL(dequantCLD__FDK[idx]);
-}
--- a/libSACdec/src/sac_rom.h
+++ /dev/null
@@ -1,230 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround decoder library *************************
-
-   Author(s):
-
-   Description: SAC Dec tables
-
-*******************************************************************************/
-
-#ifndef SAC_ROM_H
-#define SAC_ROM_H
-
-#include "FDK_archdef.h"
-#include "sac_dec_interface.h"
-
-#include "huff_nodes.h"
-#include "sac_bitdec.h"
-#include "machine_type.h"
-
-/* Global ROM table data type: */
-#ifndef ARCH_PREFER_MULT_32x32
-#define FIXP_CFG FIXP_SGL
-#define FX_CFG2FX_DBL FX_SGL2FX_DBL
-#define FX_CFG2FX_SGL
-#define CFG(a) (FX_DBL2FXCONST_SGL(a))
-#define FL2FXCONST_CFG FL2FXCONST_SGL
-#define FX_DBL2FX_CFG(x) FX_DBL2FX_SGL((FIXP_DBL)(x))
-#else
-#define FIXP_CFG FIXP_DBL
-#define FX_CFG2FX_DBL
-#define FX_CFG2FX_SGL FX_DBL2FX_SGL
-#define CFG(a) FIXP_DBL(a)
-#define FL2FXCONST_CFG FL2FXCONST_DBL
-#define FX_DBL2FX_CFG(x) ((FIXP_DBL)(x))
-#endif
-
-/* others  */
-#define SCALE_INV_ICC (2)
-#define G_dd_SCALE (2)
-
-#define QCC_SCALE 1
-#define M1M2_DATA FIXP_DBL
-#ifndef ARCH_PREFER_MULT_32x32
-#define M1M2_CDATA FIXP_SGL
-#define M1M2_CDATA2FX_DBL(a) FX_SGL2FX_DBL(a)
-#define FX_DBL2M1M2_CDATA(a) FX_DBL2FX_SGL(a)
-#else
-#define M1M2_CDATA FIXP_DBL
-#define M1M2_CDATA2FX_DBL(a) (a)
-#define FX_DBL2M1M2_CDATA(a) (a)
-#endif
-
-#define CLIP_PROTECT_GAIN_0(x) FL2FXCONST_CFG(((x) / (float)(1 << 0)))
-#define CLIP_PROTECT_GAIN_1(x) FL2FXCONST_CFG(((x) / (float)(1 << 1)))
-#define CLIP_PROTECT_GAIN_2(x) FL2FXCONST_CFG(((x) / (float)(1 << 2)))
-
-#define SF_CLD_C1C2 (8)
-
-extern const FIXP_CFG dequantCPC__FDK[];
-extern const FIXP_CFG dequantICC__FDK[8];
-extern const FIXP_CFG dequantCLD__FDK[31];
-
-#define IPD_SCALE (5)
-#define PI__IPD (FL2FXCONST_DBL(3.1415926535897932f / (float)(1 << IPD_SCALE)))
-/* Define for PI*2 for better precision in  SpatialDecApplyPhase() */
-#define PIx2__IPD \
-  (FL2FXCONST_DBL(3.1415926535897932f / (float)(1 << (IPD_SCALE - 1))))
-
-extern const FIXP_CFG dequantIPD__FDK[16];
-
-extern const FIXP_CFG H11_nc[31][8];
-extern const FIXP_CFG H12_nc[31][8];
-
-extern const FIXP_DBL dequantCLD_c1[31];
-
-extern const FIXP_CFG BP__FDK[];
-extern const FIXP_CFG BP_GF__FDK[];
-extern const SCHAR row2channelSTP[][MAX_M2_INPUT];
-
-/* sac_bitdec */
-extern const INT samplingFreqTable[16];
-extern const UCHAR freqResTable[];
-extern const UCHAR freqResTable_LD[];
-extern const UCHAR tempShapeChanTable[2][8];
-extern const TREEPROPERTIES treePropertyTable[];
-
-extern const SCHAR kernels_4_to_71[MAX_HYBRID_BANDS];
-extern const SCHAR kernels_5_to_71[MAX_HYBRID_BANDS];
-extern const SCHAR kernels_7_to_71[MAX_HYBRID_BANDS];
-extern const SCHAR kernels_10_to_71[MAX_HYBRID_BANDS];
-extern const SCHAR kernels_14_to_71[MAX_HYBRID_BANDS];
-extern const SCHAR kernels_20_to_71[MAX_HYBRID_BANDS];
-extern const SCHAR kernels_28_to_71[MAX_HYBRID_BANDS];
-
-extern const UCHAR mapping_4_to_28[MAX_PARAMETER_BANDS];
-extern const UCHAR mapping_5_to_28[MAX_PARAMETER_BANDS];
-extern const UCHAR mapping_7_to_28[MAX_PARAMETER_BANDS];
-extern const UCHAR mapping_10_to_28[MAX_PARAMETER_BANDS];
-extern const UCHAR mapping_14_to_28[MAX_PARAMETER_BANDS];
-extern const UCHAR mapping_20_to_28[MAX_PARAMETER_BANDS];
-extern const SCHAR kernels_4_to_64[MAX_HYBRID_BANDS];
-extern const SCHAR kernels_5_to_64[MAX_HYBRID_BANDS];
-extern const SCHAR kernels_7_to_64[MAX_HYBRID_BANDS];
-extern const SCHAR kernels_9_to_64[MAX_HYBRID_BANDS];
-extern const SCHAR kernels_12_to_64[MAX_HYBRID_BANDS];
-extern const SCHAR kernels_15_to_64[MAX_HYBRID_BANDS];
-extern const SCHAR kernels_23_to_64[MAX_HYBRID_BANDS];
-
-extern const UCHAR mapping_15_to_23[MAX_PARAMETER_BANDS_LD];
-extern const UCHAR mapping_12_to_23[MAX_PARAMETER_BANDS_LD];
-extern const UCHAR mapping_9_to_23[MAX_PARAMETER_BANDS_LD];
-extern const UCHAR mapping_7_to_23[MAX_PARAMETER_BANDS_LD];
-extern const UCHAR mapping_5_to_23[MAX_PARAMETER_BANDS_LD];
-extern const UCHAR mapping_4_to_23[MAX_PARAMETER_BANDS_LD];
-
-extern const FIXP_CFG clipGainTable__FDK[];
-extern const UCHAR clipGainSFTable__FDK[];
-
-extern const UCHAR pbStrideTable[];
-extern const int smgTimeTable[];
-
-extern const FIXP_CFG envShapeDataTable__FDK[5][2];
-extern const SCHAR row2channelGES[][MAX_M2_INPUT];
-
-/* sac_calcM1andM2 */
-extern const SCHAR row2residual[][MAX_M2_INPUT];
-
-void SpatialDequantGetCLDValues(int index, FIXP_DBL* cu, FIXP_DBL* cl);
-
-void SpatialDequantGetCLD2Values(int index, FIXP_DBL* x);
-
-/* External helper functions */
-static inline int SacGetHybridSubbands(int qmfSubbands) {
-  return qmfSubbands - MAX_QMF_BANDS_TO_HYBRID + 10;
-}
-
-#endif /* SAC_ROM_H */
--- a/libSACdec/src/sac_smoothing.cpp
+++ /dev/null
@@ -1,295 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround decoder library *************************
-
-   Author(s):
-
-   Description: SAC Dec parameter smoothing
-
-*******************************************************************************/
-
-#include "sac_dec.h"
-#include "sac_bitdec.h"
-#include "sac_smoothing.h"
-#include "sac_rom.h"
-
-/*******************************************************************************
- Functionname: calcFilterCoeff
- *******************************************************************************
-
- Description:
-
- Arguments:
-
- Input:
-
- Output:
-
-
-*******************************************************************************/
-static FIXP_DBL calcFilterCoeff__FDK(spatialDec *self, int ps,
-                                     const SPATIAL_BS_FRAME *frame) {
-  int dSlots;
-  FIXP_DBL delta;
-
-  dSlots = frame->paramSlot[ps] - self->smoothState->prevParamSlot;
-
-  if (dSlots <= 0) {
-    dSlots += self->timeSlots;
-  }
-
-  delta = fDivNorm(dSlots, self->smgTime[ps]);
-
-  return delta;
-}
-
-/*******************************************************************************
- Functionname: getSmoothOnOff
- *******************************************************************************
-
- Description:
-
- Arguments:
-
- Input:
-
- Output:
-
-
-*******************************************************************************/
-static int getSmoothOnOff(spatialDec *self, int ps, int pb) {
-  int smoothBand = 0;
-
-  smoothBand = self->smgData[ps][pb];
-
-  return smoothBand;
-}
-
-void SpatialDecSmoothM1andM2(spatialDec *self, const SPATIAL_BS_FRAME *frame,
-                             int ps) {
-  FIXP_DBL delta__FDK;
-  FIXP_DBL one_minus_delta__FDK;
-
-  int pb, row, col;
-  int residualBands = 0;
-
-  if (self->residualCoding) {
-    int i;
-    int boxes = self->numOttBoxes;
-    for (i = 0; i < boxes; i++) {
-      if (self->residualBands[i] > residualBands) {
-        residualBands = self->residualBands[i];
-      }
-    }
-  }
-
-  delta__FDK = calcFilterCoeff__FDK(self, ps, frame);
-  if (delta__FDK == /*FL2FXCONST_DBL(1.0f)*/ (FIXP_DBL)MAXVAL_DBL)
-    one_minus_delta__FDK = FL2FXCONST_DBL(0.0f);
-  else if (delta__FDK == FL2FXCONST_DBL(0.0f))
-    one_minus_delta__FDK = /*FL2FXCONST_DBL(1.0f)*/ (FIXP_DBL)MAXVAL_DBL;
-  else
-    one_minus_delta__FDK = (FL2FXCONST_DBL(0.5f) - (delta__FDK >> 1)) << 1;
-
-  for (pb = 0; pb < self->numParameterBands; pb++) {
-    int smoothBand;
-
-    smoothBand = getSmoothOnOff(self, ps, pb);
-
-    if (smoothBand && (pb >= residualBands)) {
-      for (row = 0; row < self->numM2rows; row++) {
-        for (col = 0; col < self->numVChannels; col++) {
-          self->M2Real__FDK[row][col][pb] =
-              ((fMultDiv2(delta__FDK, self->M2Real__FDK[row][col][pb]) +
-                fMultDiv2(one_minus_delta__FDK,
-                          self->M2RealPrev__FDK[row][col][pb]))
-               << 1);
-          if (0 || (self->phaseCoding == 3)) {
-            self->M2Imag__FDK[row][col][pb] =
-                ((fMultDiv2(delta__FDK, self->M2Imag__FDK[row][col][pb]) +
-                  fMultDiv2(one_minus_delta__FDK,
-                            self->M2ImagPrev__FDK[row][col][pb]))
-                 << 1);
-          }
-        }
-      }
-    }
-  }
-  self->smoothState->prevParamSlot = frame->paramSlot[ps];
-}
-
-/* init states */
-void initParameterSmoothing(spatialDec *self) {
-  self->smoothState->prevParamSlot = 0;
-}
-
-void SpatialDecSmoothOPD(spatialDec *self, const SPATIAL_BS_FRAME *frame,
-                         int ps) {
-  int pb;
-  int dSlots;
-  FIXP_DBL delta__FDK;
-  FIXP_DBL one_minus_delta__FDK;
-  FIXP_DBL *phaseLeftSmooth__FDK = self->smoothState->opdLeftState__FDK;
-  FIXP_DBL *phaseRightSmooth__FDK = self->smoothState->opdRightState__FDK;
-  int quantCoarse;
-
-  quantCoarse = frame->IPDLosslessData[0].bsQuantCoarseXXX[ps];
-
-  if (frame->OpdSmoothingMode == 0) {
-    FDKmemcpy(phaseLeftSmooth__FDK, self->PhaseLeft__FDK,
-              self->numParameterBands * sizeof(FIXP_DBL));
-    FDKmemcpy(phaseRightSmooth__FDK, self->PhaseRight__FDK,
-              self->numParameterBands * sizeof(FIXP_DBL));
-  } else {
-    if (ps == 0) {
-      dSlots = frame->paramSlot[ps] + 1;
-    } else {
-      dSlots = frame->paramSlot[ps] - frame->paramSlot[ps - 1];
-    }
-
-    delta__FDK = (FIXP_DBL)((INT)(FL2FXCONST_DBL(0.0078125f)) * dSlots);
-
-    if (delta__FDK == (FIXP_DBL)MAXVAL_DBL /*FL2FXCONST_DBL(1.0f)*/)
-      one_minus_delta__FDK = FL2FXCONST_DBL(0.0f);
-    else if (delta__FDK == FL2FXCONST_DBL(0.0f))
-      one_minus_delta__FDK = (FIXP_DBL)MAXVAL_DBL /*FL2FXCONST_DBL(1.0f)*/;
-    else
-      one_minus_delta__FDK = (FL2FXCONST_DBL(0.5f) - (delta__FDK >> 1)) << 1;
-
-    for (pb = 0; pb < self->numParameterBands; pb++) {
-      FIXP_DBL tmpL, tmpR, tmp;
-
-      tmpL = self->PhaseLeft__FDK[pb];
-      tmpR = self->PhaseRight__FDK[pb];
-
-      while (tmpL > phaseLeftSmooth__FDK[pb] + PI__IPD) tmpL -= PI__IPD << 1;
-      while (tmpL < phaseLeftSmooth__FDK[pb] - PI__IPD) tmpL += PI__IPD << 1;
-      while (tmpR > phaseRightSmooth__FDK[pb] + PI__IPD) tmpR -= PI__IPD << 1;
-      while (tmpR < phaseRightSmooth__FDK[pb] - PI__IPD) tmpR += PI__IPD << 1;
-
-      phaseLeftSmooth__FDK[pb] =
-          fMult(delta__FDK, tmpL) +
-          fMult(one_minus_delta__FDK, phaseLeftSmooth__FDK[pb]);
-      phaseRightSmooth__FDK[pb] =
-          fMult(delta__FDK, tmpR) +
-          fMult(one_minus_delta__FDK, phaseRightSmooth__FDK[pb]);
-
-      tmp = (((tmpL >> 1) - (tmpR >> 1)) - ((phaseLeftSmooth__FDK[pb] >> 1) -
-                                            (phaseRightSmooth__FDK[pb] >> 1)))
-            << 1;
-      while (tmp > PI__IPD) tmp -= PI__IPD << 1;
-      while (tmp < -PI__IPD) tmp += PI__IPD << 1;
-      if (fixp_abs(tmp) > fMult((quantCoarse ? FL2FXCONST_DBL(50.f / 180.f)
-                                             : FL2FXCONST_DBL(25.f / 180.f)),
-                                PI__IPD)) {
-        phaseLeftSmooth__FDK[pb] = tmpL;
-        phaseRightSmooth__FDK[pb] = tmpR;
-      }
-
-      while (phaseLeftSmooth__FDK[pb] > PI__IPD << 1)
-        phaseLeftSmooth__FDK[pb] -= PI__IPD << 1;
-      while (phaseLeftSmooth__FDK[pb] < (FIXP_DBL)0)
-        phaseLeftSmooth__FDK[pb] += PI__IPD << 1;
-      while (phaseRightSmooth__FDK[pb] > PI__IPD << 1)
-        phaseRightSmooth__FDK[pb] -= PI__IPD << 1;
-      while (phaseRightSmooth__FDK[pb] < (FIXP_DBL)0)
-        phaseRightSmooth__FDK[pb] += PI__IPD << 1;
-
-      self->PhaseLeft__FDK[pb] = phaseLeftSmooth__FDK[pb];
-      self->PhaseRight__FDK[pb] = phaseRightSmooth__FDK[pb];
-    }
-  }
-  return;
-}
--- a/libSACdec/src/sac_smoothing.h
+++ /dev/null
@@ -1,114 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround decoder library *************************
-
-   Author(s):
-
-   Description: SAC Dec parameter smoothing
-
-*******************************************************************************/
-
-#ifndef SAC_SMOOTHING_H
-#define SAC_SMOOTHING_H
-
-#include "sac_dec.h"
-
-void initParameterSmoothing(spatialDec *self);
-void SpatialDecSmoothM1andM2(spatialDec *self, const SPATIAL_BS_FRAME *frame,
-                             int ps);
-void SpatialDecSmoothOPD(spatialDec *self, const SPATIAL_BS_FRAME *frame,
-                         int ps);
-
-#endif
--- a/libSACdec/src/sac_stp.cpp
+++ /dev/null
@@ -1,548 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround decoder library *************************
-
-   Author(s):
-
-   Description: SAC Dec subband processing
-
-*******************************************************************************/
-
-#include "sac_stp.h"
-#include "sac_calcM1andM2.h"
-#include "sac_bitdec.h"
-#include "FDK_matrixCalloc.h"
-#include "sac_rom.h"
-
-#define BP_GF_START 6
-#define BP_GF_SIZE 25
-#define HP_SIZE 9
-#define STP_UPDATE_ENERGY_RATE 32
-
-#define SF_WET 5
-#define SF_DRY \
-  3 /* SF_DRY == 2 would produce good conformance test results as well */
-#define SF_PRODUCT_BP_GF 13
-#define SF_PRODUCT_BP_GF_GF 26
-#define SF_SCALE 2
-
-#define SF_SCALE_LD64 FL2FXCONST_DBL(0.03125)      /* LD64((1<<SF_SCALE))*/
-#define STP_LPF_COEFF1__FDK FL2FXCONST_DBL(0.950f) /* 0.95 */
-#define ONE_MINUS_STP_LPF_COEFF1__FDK FL2FXCONST_DBL(0.05f) /* 1.0 - 0.95 */
-#define STP_LPF_COEFF2__FDK FL2FXCONST_DBL(0.450f)          /* 0.45 */
-#define ONE_MINUS_STP_LPF_COEFF2__FDK \
-  FL2FXCONST_DBL(1.0f - 0.450f) /* 1.0 - 0.45 */
-#define STP_SCALE_LIMIT__FDK \
-  FL2FXCONST_DBL(2.82f / (float)(1 << SF_SCALE)) /* scaled by SF_SCALE */
-#define ONE_DIV_STP_SCALE_LIMIT__FDK                                          \
-  FL2FXCONST_DBL(1.0f / 2.82f / (float)(1 << SF_SCALE)) /* scaled by SF_SCALE \
-                                                         */
-#define ABS_THR__FDK       \
-  FL2FXCONST_DBL(ABS_THR / \
-                 ((float)(1 << (22 + 22 - 26)))) /* scaled by 18 bits */
-#define ABS_THR2__FDK                      \
-  FL2FXCONST_DBL(ABS_THR * 32.0f * 32.0f / \
-                 ((float)(1 << (22 + 22 - 26)))) /* scaled by 10 bits */
-#define STP_SCALE_LIMIT_HI \
-  FL2FXCONST_DBL(3.02222222222 / (1 << SF_SCALE)) /* see 4. below */
-#define STP_SCALE_LIMIT_LO \
-  FL2FXCONST_DBL(0.28289992119 / (1 << SF_SCALE)) /* see 4. below */
-#define STP_SCALE_LIMIT_HI_LD64                 \
-  FL2FXCONST_DBL(0.04986280452) /* see 4. below \
-                                 */
-#define STP_SCALE_LIMIT_LO_LD64                 \
-  FL2FXCONST_DBL(0.05692613500) /* see 4. below \
-                                 */
-
-/*  Scale factor calculation for the diffuse signal needs adapted thresholds
-    for STP_SCALE_LIMIT and 1/STP_SCALE_LIMIT:
-
-    1. scale = sqrt(DryNrg/WetNrg)
-
-    2. Damping of scale factor
-       scale2 = 0.1 + 0.9 * scale
-
-    3. Limiting of scale factor
-          STP_SCALE_LIMIT           >=        scale2        >= 1/STP_SCALE_LIMIT
-       => STP_SCALE_LIMIT           >=  (0.1 + 0.9 * scale) >= 1/STP_SCALE_LIMIT
-       => (STP_SCALE_LIMIT-0.1)/0.9 >=        scale         >=
-   (1/STP_SCALE_LIMIT-0.1)/0.9
-
-    3. Limiting of scale factor before sqrt calculation
-       ((STP_SCALE_LIMIT-0.1)/0.9)^2 >= (scale^2) >=
-   ((1/STP_SCALE_LIMIT-0.1)/0.9)^2 (STP_SCALE_LIMIT_HI)^2        >= (scale^2) >=
-   (STP_SCALE_LIMIT_LO)^2
-
-    4. Thresholds for limiting of scale factor
-       STP_SCALE_LIMIT_HI      = ((2.82-0.1)/0.9)
-       STP_SCALE_LIMIT_LO      = (((1.0/2.82)-0.1)/0.9)
-       STP_SCALE_LIMIT_HI_LD64 = LD64(STP_SCALE_LIMIT_HI*STP_SCALE_LIMIT_HI)
-       STP_SCALE_LIMIT_LO_LD64 = LD64(STP_SCALE_LIMIT_LO*STP_SCALE_LIMIT_LO)
-*/
-
-#define DRY_ENER_WEIGHT(DryEner) DryEner = DryEner >> dry_scale_dmx
-
-#define WET_ENER_WEIGHT(WetEner) WetEner = WetEner << wet_scale_dmx
-
-#define DRY_ENER_SUM_REAL(DryEner, dmxReal, n) \
-  DryEner +=                                   \
-      fMultDiv2(fPow2Div2(dmxReal << SF_DRY), pBP[n]) >> ((2 * SF_DRY) - 2)
-
-#define DRY_ENER_SUM_CPLX(DryEner, dmxReal, dmxImag, n) \
-  DryEner += fMultDiv2(                                 \
-      fPow2Div2(dmxReal << SF_DRY) + fPow2Div2(dmxImag << SF_DRY), pBP[n])
-
-#define CALC_WET_SCALE(dryIdx, wetIdx)                                         \
-  if ((DryEnerLD64[dryIdx] - STP_SCALE_LIMIT_HI_LD64) > WetEnerLD64[wetIdx]) { \
-    scale[wetIdx] = STP_SCALE_LIMIT_HI;                                        \
-  } else if (DryEnerLD64[dryIdx] <                                             \
-             (WetEnerLD64[wetIdx] - STP_SCALE_LIMIT_LO_LD64)) {                \
-    scale[wetIdx] = STP_SCALE_LIMIT_LO;                                        \
-  } else {                                                                     \
-    tmp = ((DryEnerLD64[dryIdx] - WetEnerLD64[wetIdx]) >> 1) - SF_SCALE_LD64;  \
-    scale[wetIdx] = CalcInvLdData(tmp);                                        \
-  }
-
-struct STP_DEC {
-  FIXP_DBL runDryEner[MAX_INPUT_CHANNELS];
-  FIXP_DBL runWetEner[MAX_OUTPUT_CHANNELS];
-  FIXP_DBL oldDryEnerLD64[MAX_INPUT_CHANNELS];
-  FIXP_DBL oldWetEnerLD64[MAX_OUTPUT_CHANNELS];
-  FIXP_DBL prev_tp_scale[MAX_OUTPUT_CHANNELS];
-  const FIXP_CFG *BP;
-  const FIXP_CFG *BP_GF;
-  int update_old_ener;
-};
-
-inline void combineSignalReal(FIXP_DBL *hybOutputRealDry,
-                              FIXP_DBL *hybOutputRealWet, int bands) {
-  int n;
-
-  for (n = bands - 1; n >= 0; n--) {
-    *hybOutputRealDry = *hybOutputRealDry + *hybOutputRealWet;
-    hybOutputRealDry++, hybOutputRealWet++;
-  }
-}
-
-inline void combineSignalRealScale1(FIXP_DBL *hybOutputRealDry,
-                                    FIXP_DBL *hybOutputRealWet, FIXP_DBL scaleX,
-                                    int bands) {
-  int n;
-
-  for (n = bands - 1; n >= 0; n--) {
-    *hybOutputRealDry =
-        *hybOutputRealDry +
-        (fMultDiv2(*hybOutputRealWet, scaleX) << (SF_SCALE + 1));
-    hybOutputRealDry++, hybOutputRealWet++;
-  }
-}
-
-inline void combineSignalCplx(FIXP_DBL *hybOutputRealDry,
-                              FIXP_DBL *hybOutputImagDry,
-                              FIXP_DBL *hybOutputRealWet,
-                              FIXP_DBL *hybOutputImagWet, int bands) {
-  int n;
-
-  for (n = bands - 1; n >= 0; n--) {
-    *hybOutputRealDry = *hybOutputRealDry + *hybOutputRealWet;
-    *hybOutputImagDry = *hybOutputImagDry + *hybOutputImagWet;
-    hybOutputRealDry++, hybOutputRealWet++;
-    hybOutputImagDry++, hybOutputImagWet++;
-  }
-}
-
-inline void combineSignalCplxScale1(FIXP_DBL *hybOutputRealDry,
-                                    FIXP_DBL *hybOutputImagDry,
-                                    FIXP_DBL *hybOutputRealWet,
-                                    FIXP_DBL *hybOutputImagWet,
-                                    const FIXP_CFG *pBP, FIXP_DBL scaleX,
-                                    int bands) {
-  int n;
-  FIXP_DBL scaleY;
-  for (n = bands - 1; n >= 0; n--) {
-    scaleY = fMultDiv2(scaleX, *pBP);
-    *hybOutputRealDry =
-        *hybOutputRealDry +
-        (fMultDiv2(*hybOutputRealWet, scaleY) << (SF_SCALE + 2));
-    *hybOutputImagDry =
-        *hybOutputImagDry +
-        (fMultDiv2(*hybOutputImagWet, scaleY) << (SF_SCALE + 2));
-    hybOutputRealDry++, hybOutputRealWet++;
-    hybOutputImagDry++, hybOutputImagWet++;
-    pBP++;
-  }
-}
-
-inline void combineSignalCplxScale2(FIXP_DBL *hybOutputRealDry,
-                                    FIXP_DBL *hybOutputImagDry,
-                                    FIXP_DBL *hybOutputRealWet,
-                                    FIXP_DBL *hybOutputImagWet, FIXP_DBL scaleX,
-                                    int bands) {
-  int n;
-
-  for (n = bands - 1; n >= 0; n--) {
-    *hybOutputRealDry =
-        *hybOutputRealDry +
-        (fMultDiv2(*hybOutputRealWet, scaleX) << (SF_SCALE + 1));
-    *hybOutputImagDry =
-        *hybOutputImagDry +
-        (fMultDiv2(*hybOutputImagWet, scaleX) << (SF_SCALE + 1));
-    hybOutputRealDry++, hybOutputRealWet++;
-    hybOutputImagDry++, hybOutputImagWet++;
-  }
-}
-
-/*******************************************************************************
- Functionname: subbandTPCreate
- ******************************************************************************/
-SACDEC_ERROR subbandTPCreate(HANDLE_STP_DEC *hStpDec) {
-  HANDLE_STP_DEC self = NULL;
-  FDK_ALLOCATE_MEMORY_1D(self, 1, struct STP_DEC)
-  if (hStpDec != NULL) {
-    *hStpDec = self;
-  }
-
-  return MPS_OK;
-bail:
-  return MPS_OUTOFMEMORY;
-}
-
-SACDEC_ERROR subbandTPInit(HANDLE_STP_DEC self) {
-  SACDEC_ERROR err = MPS_OK;
-  int ch;
-
-  for (ch = 0; ch < MAX_OUTPUT_CHANNELS; ch++) {
-    self->prev_tp_scale[ch] = FL2FXCONST_DBL(1.0f / (1 << SF_SCALE));
-    self->oldWetEnerLD64[ch] =
-        FL2FXCONST_DBL(0.34375f); /* 32768.0*32768.0/2^(44-26-10) */
-  }
-  for (ch = 0; ch < MAX_INPUT_CHANNELS; ch++) {
-    self->oldDryEnerLD64[ch] =
-        FL2FXCONST_DBL(0.1875f); /* 32768.0*32768.0/2^(44-26) */
-  }
-
-  self->BP = BP__FDK;
-  self->BP_GF = BP_GF__FDK;
-
-  self->update_old_ener = 0;
-
-  return err;
-}
-
-/*******************************************************************************
- Functionname: subbandTPDestroy
- ******************************************************************************/
-void subbandTPDestroy(HANDLE_STP_DEC *hStpDec) {
-  if (hStpDec != NULL) {
-    FDK_FREE_MEMORY_1D(*hStpDec);
-  }
-}
-
-/*******************************************************************************
- Functionname: subbandTPApply
- ******************************************************************************/
-SACDEC_ERROR subbandTPApply(spatialDec *self, const SPATIAL_BS_FRAME *frame) {
-  FIXP_DBL *qmfOutputRealDry[MAX_OUTPUT_CHANNELS];
-  FIXP_DBL *qmfOutputImagDry[MAX_OUTPUT_CHANNELS];
-  FIXP_DBL *qmfOutputRealWet[MAX_OUTPUT_CHANNELS];
-  FIXP_DBL *qmfOutputImagWet[MAX_OUTPUT_CHANNELS];
-
-  FIXP_DBL DryEner[MAX_INPUT_CHANNELS];
-  FIXP_DBL scale[MAX_OUTPUT_CHANNELS];
-
-  FIXP_DBL DryEnerLD64[MAX_INPUT_CHANNELS];
-  FIXP_DBL WetEnerLD64[MAX_OUTPUT_CHANNELS];
-
-  FIXP_DBL DryEner0 = FL2FXCONST_DBL(0.0f);
-  FIXP_DBL WetEnerX, damp, tmp;
-  FIXP_DBL dmxReal0, dmxImag0;
-  int skipChannels[MAX_OUTPUT_CHANNELS];
-  int n, ch, cplxBands, cplxHybBands;
-  int dry_scale_dmx, wet_scale_dmx;
-  int i_LF, i_RF;
-  HANDLE_STP_DEC hStpDec;
-  const FIXP_CFG *pBP;
-
-  int nrgScale = (2 * self->clipProtectGainSF__FDK);
-
-  hStpDec = self->hStpDec;
-
-  /* set scalefactor and loop counter */
-  FDK_ASSERT(SF_DRY >= 1);
-  {
-    cplxBands = BP_GF_SIZE;
-    cplxHybBands = self->hybridBands;
-    dry_scale_dmx = (2 * SF_DRY) - 2;
-    wet_scale_dmx = 2;
-  }
-
-  /* setup pointer for forming the direct downmix signal */
-  for (ch = 0; ch < self->numOutputChannels; ch++) {
-    qmfOutputRealDry[ch] = &self->hybOutputRealDry__FDK[ch][7];
-    qmfOutputRealWet[ch] = &self->hybOutputRealWet__FDK[ch][7];
-    qmfOutputImagDry[ch] = &self->hybOutputImagDry__FDK[ch][7];
-    qmfOutputImagWet[ch] = &self->hybOutputImagWet__FDK[ch][7];
-  }
-
-  /* clear skipping flag for all output channels */
-  FDKmemset(skipChannels, 0, self->numOutputChannels * sizeof(int));
-
-  /* set scale values to zero */
-  FDKmemset(scale, 0, self->numOutputChannels * sizeof(FIXP_DBL));
-
-  /* update normalisation energy with latest smoothed energy */
-  if (hStpDec->update_old_ener == STP_UPDATE_ENERGY_RATE) {
-    hStpDec->update_old_ener = 1;
-    for (ch = 0; ch < self->numInputChannels; ch++) {
-      hStpDec->oldDryEnerLD64[ch] =
-          CalcLdData(hStpDec->runDryEner[ch] + ABS_THR__FDK);
-    }
-    for (ch = 0; ch < self->numOutputChannels; ch++) {
-      hStpDec->oldWetEnerLD64[ch] =
-          CalcLdData(hStpDec->runWetEner[ch] + ABS_THR2__FDK);
-    }
-  } else {
-    hStpDec->update_old_ener++;
-  }
-
-  /* get channel configuration */
-  switch (self->treeConfig) {
-    case TREE_212:
-      i_LF = 0;
-      i_RF = 1;
-      break;
-    default:
-      return MPS_WRONG_TREECONFIG;
-  }
-
-  /* form the 'direct' downmix signal */
-  pBP = hStpDec->BP_GF - BP_GF_START;
-  switch (self->treeConfig) {
-    case TREE_212:
-      for (n = BP_GF_START; n < cplxBands; n++) {
-        dmxReal0 = qmfOutputRealDry[i_LF][n] + qmfOutputRealDry[i_RF][n];
-        dmxImag0 = qmfOutputImagDry[i_LF][n] + qmfOutputImagDry[i_RF][n];
-        DRY_ENER_SUM_CPLX(DryEner0, dmxReal0, dmxImag0, n);
-      }
-      DRY_ENER_WEIGHT(DryEner0);
-      break;
-    default:;
-  }
-  DryEner[0] = DryEner0;
-
-  /* normalise the 'direct' signals */
-  for (ch = 0; ch < self->numInputChannels; ch++) {
-    DryEner[ch] = DryEner[ch] << (nrgScale);
-    hStpDec->runDryEner[ch] =
-        fMult(STP_LPF_COEFF1__FDK, hStpDec->runDryEner[ch]) +
-        fMult(ONE_MINUS_STP_LPF_COEFF1__FDK, DryEner[ch]);
-    if (DryEner[ch] != FL2FXCONST_DBL(0.0f)) {
-      DryEnerLD64[ch] =
-          fixMax((CalcLdData(DryEner[ch]) - hStpDec->oldDryEnerLD64[ch]),
-                 FL2FXCONST_DBL(-0.484375f));
-    } else {
-      DryEnerLD64[ch] = FL2FXCONST_DBL(-0.484375f);
-    }
-  }
-  if (self->treeConfig == TREE_212) {
-    for (; ch < MAX_INPUT_CHANNELS; ch++) {
-      DryEnerLD64[ch] = FL2FXCONST_DBL(-0.484375f);
-    }
-  }
-
-  /* normalise the 'diffuse' signals */
-  pBP = hStpDec->BP_GF - BP_GF_START;
-  for (ch = 0; ch < self->numOutputChannels; ch++) {
-    if (skipChannels[ch]) {
-      continue;
-    }
-
-    WetEnerX = FL2FXCONST_DBL(0.0f);
-    for (n = BP_GF_START; n < cplxBands; n++) {
-      tmp = fPow2Div2(qmfOutputRealWet[ch][n] << SF_WET);
-      tmp += fPow2Div2(qmfOutputImagWet[ch][n] << SF_WET);
-      WetEnerX += fMultDiv2(tmp, pBP[n]);
-    }
-    WET_ENER_WEIGHT(WetEnerX);
-
-    WetEnerX = WetEnerX << (nrgScale);
-    hStpDec->runWetEner[ch] =
-        fMult(STP_LPF_COEFF1__FDK, hStpDec->runWetEner[ch]) +
-        fMult(ONE_MINUS_STP_LPF_COEFF1__FDK, WetEnerX);
-
-    if (WetEnerX == FL2FXCONST_DBL(0.0f)) {
-      WetEnerLD64[ch] = FL2FXCONST_DBL(-0.484375f);
-    } else {
-      WetEnerLD64[ch] =
-          fixMax((CalcLdData(WetEnerX) - hStpDec->oldWetEnerLD64[ch]),
-                 FL2FXCONST_DBL(-0.484375f));
-    }
-  }
-
-  /* compute scale factor for the 'diffuse' signals */
-  switch (self->treeConfig) {
-    case TREE_212:
-      if (DryEner[0] != FL2FXCONST_DBL(0.0f)) {
-        CALC_WET_SCALE(0, i_LF);
-        CALC_WET_SCALE(0, i_RF);
-      }
-      break;
-    default:;
-  }
-
-  damp = FL2FXCONST_DBL(0.1f / (1 << SF_SCALE));
-  for (ch = 0; ch < self->numOutputChannels; ch++) {
-    /* damp the scaling factor */
-    scale[ch] = damp + fMult(FL2FXCONST_DBL(0.9f), scale[ch]);
-
-    /* limiting the scale factor */
-    if (scale[ch] > STP_SCALE_LIMIT__FDK) {
-      scale[ch] = STP_SCALE_LIMIT__FDK;
-    }
-    if (scale[ch] < ONE_DIV_STP_SCALE_LIMIT__FDK) {
-      scale[ch] = ONE_DIV_STP_SCALE_LIMIT__FDK;
-    }
-
-    /* low pass filter the scaling factor */
-    scale[ch] =
-        fMult(STP_LPF_COEFF2__FDK, scale[ch]) +
-        fMult(ONE_MINUS_STP_LPF_COEFF2__FDK, hStpDec->prev_tp_scale[ch]);
-    hStpDec->prev_tp_scale[ch] = scale[ch];
-  }
-
-  /* combine 'direct' and scaled 'diffuse' signal */
-  FDK_ASSERT((HP_SIZE - 3 + 10 - 1) == PC_NUM_HYB_BANDS);
-  const SCHAR *channlIndex = row2channelSTP[self->treeConfig];
-
-  for (ch = 0; ch < self->numOutputChannels; ch++) {
-    int no_scaling;
-
-    no_scaling = !frame->tempShapeEnableChannelSTP[channlIndex[ch]];
-    if (no_scaling) {
-      combineSignalCplx(
-          &self->hybOutputRealDry__FDK[ch][self->tp_hybBandBorder],
-          &self->hybOutputImagDry__FDK[ch][self->tp_hybBandBorder],
-          &self->hybOutputRealWet__FDK[ch][self->tp_hybBandBorder],
-          &self->hybOutputImagWet__FDK[ch][self->tp_hybBandBorder],
-          cplxHybBands - self->tp_hybBandBorder);
-
-    } else {
-      FIXP_DBL scaleX;
-      scaleX = scale[ch];
-      pBP = hStpDec->BP - self->tp_hybBandBorder;
-      /* Band[HP_SIZE-3+10-1] needs not to be processed in
-         combineSignalCplxScale1(), because pB[HP_SIZE-3+10-1] would be 1.0 */
-      combineSignalCplxScale1(
-          &self->hybOutputRealDry__FDK[ch][self->tp_hybBandBorder],
-          &self->hybOutputImagDry__FDK[ch][self->tp_hybBandBorder],
-          &self->hybOutputRealWet__FDK[ch][self->tp_hybBandBorder],
-          &self->hybOutputImagWet__FDK[ch][self->tp_hybBandBorder],
-          &pBP[self->tp_hybBandBorder], scaleX,
-          (HP_SIZE - 3 + 10 - 1) - self->tp_hybBandBorder);
-
-      {
-        combineSignalCplxScale2(
-            &self->hybOutputRealDry__FDK[ch][HP_SIZE - 3 + 10 - 1],
-            &self->hybOutputImagDry__FDK[ch][HP_SIZE - 3 + 10 - 1],
-            &self->hybOutputRealWet__FDK[ch][HP_SIZE - 3 + 10 - 1],
-            &self->hybOutputImagWet__FDK[ch][HP_SIZE - 3 + 10 - 1], scaleX,
-            cplxHybBands - (HP_SIZE - 3 + 10 - 1));
-      }
-    }
-  }
-
-  return (SACDEC_ERROR)MPS_OK;
-  ;
-}
--- a/libSACdec/src/sac_stp.h
+++ /dev/null
@@ -1,115 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround decoder library *************************
-
-   Author(s):
-
-   Description: SAC Dec subband processing
-
-*******************************************************************************/
-
-#ifndef SAC_STP_H
-#define SAC_STP_H
-
-#include "sac_dec.h"
-
-SACDEC_ERROR subbandTPCreate(HANDLE_STP_DEC *hStpDec);
-
-SACDEC_ERROR subbandTPInit(HANDLE_STP_DEC self);
-
-SACDEC_ERROR subbandTPApply(spatialDec *self, const SPATIAL_BS_FRAME *frame);
-void subbandTPDestroy(HANDLE_STP_DEC *hStpDec);
-
-#endif
--- a/libSACdec/src/sac_tsd.cpp
+++ /dev/null
@@ -1,353 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround decoder library *************************
-
-   Author(s):   Matthias Hildenbrand
-
-   Description: USAC MPS212 Transient Steering Decorrelator (TSD)
-
-*******************************************************************************/
-
-#include "sac_tsd.h"
-
-#define TSD_START_BAND (7)
-#define SIZE_S (4)
-#define SIZE_C (5)
-
-/*** Tables ***/
-RAM_ALIGN
-LNK_SECTION_CONSTDATA
-static const UCHAR nBitsTsdCW_32slots[32] = {
-    5,  9,  13, 16, 18, 20, 22, 24, 25, 26, 27, 28, 29, 29, 30, 30,
-    30, 29, 29, 28, 27, 26, 25, 24, 22, 20, 18, 16, 13, 9,  5,  0};
-
-RAM_ALIGN
-LNK_SECTION_CONSTDATA
-static const UCHAR nBitsTsdCW_64slots[64] = {
-    6,  11, 16, 20, 23, 27, 30, 33, 35, 38, 40, 42, 44, 46, 48, 49,
-    51, 52, 53, 55, 56, 57, 58, 58, 59, 60, 60, 60, 61, 61, 61, 61,
-    61, 61, 61, 60, 60, 60, 59, 58, 58, 57, 56, 55, 53, 52, 51, 49,
-    48, 46, 44, 42, 40, 38, 35, 33, 30, 27, 23, 20, 16, 11, 6,  0};
-
-RAM_ALIGN
-LNK_SECTION_CONSTDATA
-static const FIXP_STP phiTsd[8] = {
-    STCP(0x7fffffff, 0x00000000), STCP(0x5a82799a, 0x5a82799a),
-    STCP(0x00000000, 0x7fffffff), STCP(0xa57d8666, 0x5a82799a),
-    STCP(0x80000000, 0x00000000), STCP(0xa57d8666, 0xa57d8666),
-    STCP(0x00000000, 0x80000000), STCP(0x5a82799a, 0xa57d8666),
-};
-
-/*** Static Functions ***/
-static void longmult1(USHORT a[], USHORT b, USHORT d[], int len) {
-  int k;
-  ULONG tmp;
-  ULONG b0 = (ULONG)b;
-
-  tmp = ((ULONG)a[0]) * b0;
-  d[0] = (USHORT)tmp;
-
-  for (k = 1; k < len; k++) {
-    tmp = (tmp >> 16) + ((ULONG)a[k]) * b0;
-    d[k] = (USHORT)tmp;
-  }
-}
-
-static void longdiv(USHORT b[], USHORT a, USHORT d[], USHORT *pr, int len) {
-  ULONG r;
-  ULONG tmp;
-  int k;
-
-  FDK_ASSERT(a != 0);
-
-  r = 0;
-
-  for (k = len - 1; k >= 0; k--) {
-    tmp = ((ULONG)b[k]) + (r << 16);
-
-    if (tmp) {
-      d[k] = (USHORT)(tmp / a);
-      r = tmp - d[k] * a;
-    } else {
-      d[k] = 0;
-    }
-  }
-  *pr = (USHORT)r;
-}
-
-static void longsub(USHORT a[], USHORT b[], int lena, int lenb) {
-  int h;
-  LONG carry = 0;
-
-  FDK_ASSERT(lena >= lenb);
-  for (h = 0; h < lenb; h++) {
-    carry += ((LONG)a[h]) - ((LONG)b[h]);
-    a[h] = (USHORT)carry;
-    carry = carry >> 16;
-  }
-
-  for (; h < lena; h++) {
-    carry = ((LONG)a[h]) + carry;
-    a[h] = (USHORT)carry;
-    carry = carry >> 16;
-  }
-
-  FDK_ASSERT(carry ==
-             0); /* carry != 0 indicates subtraction underflow, e.g. b > a */
-  return;
-}
-
-static int longcompare(USHORT a[], USHORT b[], int len) {
-  int i;
-
-  for (i = len - 1; i > 0; i--) {
-    if (a[i] != b[i]) break;
-  }
-  return (a[i] >= b[i]) ? 1 : 0;
-}
-
-FDK_INLINE int isTrSlot(const TSD_DATA *pTsdData, const int ts) {
-  return (pTsdData->bsTsdTrPhaseData[ts] >= 0);
-}
-
-/*** Public Functions ***/
-int TsdRead(HANDLE_FDK_BITSTREAM hBs, const int numSlots, TSD_DATA *pTsdData) {
-  int nBitsTrSlots = 0;
-  int bsTsdNumTrSlots;
-  const UCHAR *nBitsTsdCW_tab = NULL;
-
-  switch (numSlots) {
-    case 32:
-      nBitsTrSlots = 4;
-      nBitsTsdCW_tab = nBitsTsdCW_32slots;
-      break;
-    case 64:
-      nBitsTrSlots = 5;
-      nBitsTsdCW_tab = nBitsTsdCW_64slots;
-      break;
-    default:
-      return 1;
-  }
-
-  /*** Read TempShapeData for bsTempShapeConfig == 3 ***/
-  pTsdData->bsTsdEnable = FDKreadBit(hBs);
-  if (!pTsdData->bsTsdEnable) {
-    return 0;
-  }
-
-  /*** Parse/Decode TsdData() ***/
-  pTsdData->numSlots = numSlots;
-
-  bsTsdNumTrSlots = FDKreadBits(hBs, nBitsTrSlots);
-
-  /* Decode transient slot positions */
-  {
-    int nBitsTsdCW = (int)nBitsTsdCW_tab[bsTsdNumTrSlots];
-    SCHAR *phaseData = pTsdData->bsTsdTrPhaseData;
-    int p = bsTsdNumTrSlots + 1;
-    int k, h;
-    USHORT s[SIZE_S] = {0};
-    USHORT c[SIZE_C] = {0};
-    USHORT r[1];
-
-    /* Init with TsdSepData[k] = 0 */
-    for (k = 0; k < numSlots; k++) {
-      phaseData[k] = -1; /* means TsdSepData[] = 0 */
-    }
-
-    for (h = (SIZE_S - 1); h >= 0; h--) {
-      if (nBitsTsdCW > h * 16) {
-        s[h] = (USHORT)FDKreadBits(hBs, nBitsTsdCW - h * 16);
-        nBitsTsdCW = h * 16;
-      }
-    }
-
-    /* c = prod_{h=1}^{p} (k-p+h)/h */
-    k = numSlots - 1;
-    c[0] = k - p + 1;
-    for (h = 2; h <= p; h++) {
-      longmult1(c, (k - p + h), c, 5); /* c *= k - p + h; */
-      longdiv(c, h, c, r, 5);          /* c /= h; */
-      FDK_ASSERT(*r == 0);
-    }
-
-    /* go through all slots */
-    for (; k >= 0; k--) {
-      if (p > k) {
-        for (; k >= 0; k--) {
-          phaseData[k] = 1; /* means TsdSepData[] = 1 */
-        }
-        break;
-      }
-      if (longcompare(s, c, 4)) { /* (s >= c) */
-        longsub(s, c, 4, 4);      /* s -= c; */
-        phaseData[k] = 1;         /* means TsdSepData[] = 1 */
-        if (p == 1) {
-          break;
-        }
-        /* Update c for next iteration: c_new = c_old * p / k */
-        longmult1(c, p, c, 5);
-        p--;
-      } else {
-        /* Update c for next iteration: c_new = c_old * (k-p) / k */
-        longmult1(c, (k - p), c, 5);
-      }
-      longdiv(c, k, c, r, 5);
-      FDK_ASSERT(*r == 0);
-    }
-
-    /* Read phase data */
-    for (k = 0; k < numSlots; k++) {
-      if (phaseData[k] == 1) {
-        phaseData[k] = FDKreadBits(hBs, 3);
-      }
-    }
-  }
-
-  return 0;
-}
-
-void TsdGenerateNonTr(const int numHybridBands, const TSD_DATA *pTsdData,
-                      const int ts, FIXP_DBL *pVdirectReal,
-                      FIXP_DBL *pVdirectImag, FIXP_DBL *pVnonTrReal,
-                      FIXP_DBL *pVnonTrImag, FIXP_DBL **ppDecorrInReal,
-                      FIXP_DBL **ppDecorrInImag) {
-  int k = 0;
-
-  if (!isTrSlot(pTsdData, ts)) {
-    /* Let allpass based decorrelator read from direct input. */
-    *ppDecorrInReal = pVdirectReal;
-    *ppDecorrInImag = pVdirectImag;
-    return;
-  }
-
-  /* Generate nonTr input signal for allpass based decorrelator */
-  for (; k < TSD_START_BAND; k++) {
-    pVnonTrReal[k] = pVdirectReal[k];
-    pVnonTrImag[k] = pVdirectImag[k];
-  }
-  for (; k < numHybridBands; k++) {
-    pVnonTrReal[k] = (FIXP_DBL)0;
-    pVnonTrImag[k] = (FIXP_DBL)0;
-  }
-  *ppDecorrInReal = pVnonTrReal;
-  *ppDecorrInImag = pVnonTrImag;
-}
-
-void TsdApply(const int numHybridBands, const TSD_DATA *pTsdData, int *pTsdTs,
-              const FIXP_DBL *pVdirectReal, const FIXP_DBL *pVdirectImag,
-              FIXP_DBL *pDnonTrReal, FIXP_DBL *pDnonTrImag) {
-  const int ts = *pTsdTs;
-
-  if (isTrSlot(pTsdData, ts)) {
-    int k;
-    const FIXP_STP *phi = &phiTsd[pTsdData->bsTsdTrPhaseData[ts]];
-    FDK_ASSERT((pTsdData->bsTsdTrPhaseData[ts] >= 0) &&
-               (pTsdData->bsTsdTrPhaseData[ts] < 8));
-
-    /* d = d_nonTr + v_direct * exp(j * bsTsdTrPhaseData[ts]/4 * pi ) */
-    for (k = TSD_START_BAND; k < numHybridBands; k++) {
-      FIXP_DBL tempReal, tempImag;
-      cplxMult(&tempReal, &tempImag, pVdirectReal[k], pVdirectImag[k], *phi);
-      pDnonTrReal[k] += tempReal;
-      pDnonTrImag[k] += tempImag;
-    }
-  }
-
-  /* The modulo MAX_TSD_TIME_SLOTS operation is to avoid illegal memory accesses
-   * in case of errors. */
-  *pTsdTs = (ts + 1) & (MAX_TSD_TIME_SLOTS - 1);
-  return;
-}
--- a/libSACdec/src/sac_tsd.h
+++ /dev/null
@@ -1,167 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround decoder library *************************
-
-   Author(s):   Matthias Hildenbrand
-
-   Description: USAC MPS212 Transient Steering Decorrelator (TSD)
-
-*******************************************************************************/
-
-#ifndef SAC_TSD_H
-#define SAC_TSD_H
-
-#include "FDK_bitstream.h"
-#include "common_fix.h"
-
-#define MAX_TSD_TIME_SLOTS (64)
-
-/** Structure which holds the data needed to apply TSD to current frame. */
-typedef struct {
-  UCHAR bsTsdEnable; /**< for current frame TSD is (0:disabled, 1:enabled) */
-  UCHAR numSlots;    /**< total number of QMF slots per frame */
-  SCHAR
-  bsTsdTrPhaseData[MAX_TSD_TIME_SLOTS]; /**< -1 => TsdSepData[ts]=0; 0-7:
-                                           values of bsTsdTrPhaseData[ts]
-                                           and TsdSepData[ts]=1 */
-} TSD_DATA;
-
-FDK_INLINE int isTsdActive(const TSD_DATA *pTsdData) {
-  return (int)pTsdData->bsTsdEnable;
-}
-
-/**
- * \brief Parse and Decode TSD data.
- * \param[in] hBs bitstream handle to read data from.
- * \param[in] numSlots number of QMF slots per frame.
- * \param[out] pTsdData pointer to TSD data structure.
- * \return 0 on succes, 1 on error.
- */
-int TsdRead(HANDLE_FDK_BITSTREAM hBs, const int numSlots, TSD_DATA *pTsdData);
-
-/**
- * \brief Perform transient seperation (v_{x,nonTr} signal).
- * \param[in] numHybridBands number of hybrid bands.
- * \param[in] pTsdData pointer to TSD data structure.
- * \param[in] pVdirectReal pointer to array with direct signal.
- * \param[in] pVdirectImag pointer to array with direct signal.
- * \param[out] pVnonTrReal pointer to array with nonTr signal.
- * \param[out] pVnonTrImag pointer to array with nonTr signal.
- * \param[out] ppDecorrInReal handle to array where allpass based decorrelator
- * should read from (modified by this function).
- * \param[out] ppDecorrInImag handle to array where allpass based decorrelator
- * should read from (modified by this function).
- */
-void TsdGenerateNonTr(const int numHybridBands, const TSD_DATA *pTsdData,
-                      const int ts, FIXP_DBL *pVdirectReal,
-                      FIXP_DBL *pVdirectImag, FIXP_DBL *pVnonTrReal,
-                      FIXP_DBL *pVnonTrImag, FIXP_DBL **ppDecorrInReal,
-                      FIXP_DBL **ppDecorrInImag);
-
-/**
- * \brief Generate d_{x,Tr} signal and add to d_{x,nonTr} signal
- * \param[in] numHybridBands
- * \param[in,out] pTsdData
- * \param pTsdTs pointer to persistent time slot counter
- * \param[in] pVdirectReal
- * \param[in] pVdirectImag
- * \param[out] pDnonTrReal
- * \param[out] pDnonTrImag
- */
-void TsdApply(const int numHybridBands, const TSD_DATA *pTsdData, int *pTsdTs,
-              const FIXP_DBL *pVdirectReal, const FIXP_DBL *pVdirectImag,
-              FIXP_DBL *pDnonTrReal, FIXP_DBL *pDnonTrImag);
-
-#endif /* #ifndef SAC_TSD_H */
--- a/libSACenc/include/sacenc_lib.h
+++ /dev/null
@@ -1,405 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround encoder library *************************
-
-   Author(s):   Max Neuendorf
-
-   Description: Encoder Library Interface
-                Encoder API
-
-*******************************************************************************/
-
-/**************************************************************************/ /**
-   \file
- ******************************************************************************/
-
-#ifndef SACENC_LIB_H
-#define SACENC_LIB_H
-
-/* Includes ******************************************************************/
-#include "machine_type.h"
-#include "FDK_audio.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-/* Defines *******************************************************************/
-
-/* Data Types ****************************************************************/
-
-/**
- *  Space encoder error codes.
- */
-typedef enum {
-  SACENC_OK = 0x00000000, /*!< No error happened. All fine. */
-  SACENC_INVALID_HANDLE =
-      0x00000080, /*!< Handle passed to function call was invalid. */
-  SACENC_MEMORY_ERROR = 0x00000800, /*!< Memory allocation failed. */
-  SACENC_INIT_ERROR = 0x00008000,   /*!< General initialization error. */
-  SACENC_ENCODE_ERROR =
-      0x00080000, /*!< The encoding process was interrupted by an unexpected
-                     error. */
-  SACENC_PARAM_ERROR = 0x00800000,           /*!< Invalid runtime parameter. */
-  SACENC_UNSUPPORTED_PARAMETER = 0x00800001, /*!< Parameter not available. */
-  SACENC_INVALID_CONFIG = 0x00800002,        /*!< Configuration not provided. */
-  SACENC_UNKNOWN_ERROR = 0x08000000          /*!< Unknown error. */
-
-} FDK_SACENC_ERROR;
-
-typedef enum {
-  SACENC_INVALID_MODE = 0,
-  SACENC_212 = 8,
-  SACENC_ESCAPE = 15
-
-} MP4SPACEENC_MODE;
-
-typedef enum {
-  SACENC_BANDS_INVALID = 0,
-  SACENC_BANDS_4 = 4,
-  SACENC_BANDS_5 = 5,
-  SACENC_BANDS_7 = 7,
-  SACENC_BANDS_9 = 9,
-  SACENC_BANDS_12 = 12,
-  SACENC_BANDS_15 = 15,
-  SACENC_BANDS_23 = 23
-
-} MP4SPACEENC_BANDS_CONFIG;
-
-typedef enum {
-  SACENC_QUANTMODE_INVALID = -1,
-  SACENC_QUANTMODE_FINE = 0,
-  SACENC_QUANTMODE_EBQ1 = 1,
-  SACENC_QUANTMODE_EBQ2 = 2,
-  SACENC_QUANTMODE_RSVD3 = 3
-
-} MP4SPACEENC_QUANTMODE;
-
-typedef enum {
-  SACENC_DMXGAIN_INVALID = -1,
-  SACENC_DMXGAIN_0_dB = 0,
-  SACENC_DMXGAIN_1_5_dB = 1,
-  SACENC_DMXGAIN_3_dB = 2,
-  SACENC_DMXGAIN_4_5_dB = 3,
-  SACENC_DMXGAIN_6_dB = 4,
-  SACENC_DMXGAIN_7_5_dB = 5,
-  SACENC_DMXGAIN_9_dB = 6,
-  SACENC_DMXGAIN_12_dB = 7
-
-} MP4SPACEENC_DMX_GAIN;
-
-/**
- * \brief  Space Encoder setting parameters.
- *
- * Use FDK_sacenc_setParam() function to configure the internal status of the
- * following parameters.
- */
-typedef enum {
-  SACENC_LOWDELAY, /*!< Configure lowdelay MPEG Surround.
-                        - 0: Disable Lowdelay. (default)
-                        - 1: Enable Lowdelay.
-                        - 2: Enable Lowdelay including keep frame. */
-
-  SACENC_ENC_MODE, /*!< Configure encoder tree mode. See ::MP4SPACEENC_MODE for
-                      available values. */
-
-  SACENC_SAMPLERATE, /*!< Configure encoder sampling rate. */
-
-  SACENC_FRAME_TIME_SLOTS, /*!< Configure number of slots per spatial frame. */
-
-  SACENC_PARAM_BANDS, /*!< Configure number of parameter bands. See
-                         ::MP4SPACEENC_BANDS_CONFIG for available values. */
-
-  SACENC_TIME_DOM_DMX, /*!< Configure time domain downmix.
-                            - 0: No time domain downmix. (default)
-                            - 1: Static time domain downmix.
-                            - 2: Enhanced time domain downmix, stereo to mono
-                          only. */
-
-  SACENC_DMX_GAIN, /*!< Configure downmix gain. See ::MP4SPACEENC_DMX_GAIN for
-                      available values. */
-
-  SACENC_COARSE_QUANT, /*!< Use coarse parameter quantization.
-                            - 0: No (default)
-                            - 1: Yes */
-
-  SACENC_QUANT_MODE, /*!< Configure quanitzation mode. See
-                        ::MP4SPACEENC_QUANTMODE for available values. */
-
-  SACENC_TIME_ALIGNMENT, /*!< Configure time alignment in samples. */
-
-  SACENC_INDEPENDENCY_COUNT, /*!< Configure the independency count. (count == 0
-                                means independencyFlag == 1) */
-
-  SACENC_INDEPENDENCY_FACTOR, /*!< How often should we set the independency flag
-                               */
-
-  SACENC_NONE /*!< ------ */
-
-} SPACEENC_PARAM;
-
-/**
- *  Describes Spatial Specific Config.
- */
-typedef struct {
-  INT nSscSizeBits; /*!< Number of valid bits in pSsc buffer. */
-  UCHAR *pSsc;      /*!< SpatialSpecificConfig buffer in binary format. */
-
-} MPEG4SPACEENC_SSCBUF;
-
-/**
- *  Provides some info about the encoder configuration.
- */
-typedef struct {
-  INT nSampleRate;         /*!< Configured sampling rate.*/
-  INT nSamplesFrame;       /*!< Frame length in samples. */
-  INT nTotalInputChannels; /*!< Number of expected audio input channels. */
-  INT nDmxDelay;           /*!< Delay of the downmixed signal. */
-  INT nCodecDelay;         /*!< Delay of the whole en-/decoded signal, including
-                              core-coder delay. */
-  INT nDecoderDelay;       /*!< Delay added by the MP4SPACE decoder. */
-  INT nPayloadDelay;       /*!< Delay of the payload. */
-  INT nDiscardOutFrames; /*!< Number of dmx frames to discard for alignment with
-                            bitstream. */
-
-  MPEG4SPACEENC_SSCBUF
-  *pSscBuf; /*!< Pointer to Spatial Specific Config structure. */
-
-} MP4SPACEENC_INFO;
-
-/**
- *  MPEG Surround encoder handle.
- */
-typedef struct MP4SPACE_ENCODER *HANDLE_MP4SPACE_ENCODER;
-
-/**
- *  Defines the input arguments for a FDK_sacenc_encode() call.
- */
-typedef struct {
-  INT nInputSamples; /*!< Number of valid input audio samples (multiple of input
-                        channels). */
-  UINT inputBufferSizePerChannel; /*!< Size of input buffer (input audio
-                                     samples) per channel. */
-  UINT isInputInterleaved; /*!< Indicates if input audio samples are represented
-                              in blocks or interleaved:
-                                - 0 : in blocks.
-                                - 1 : interleaved. */
-
-} SACENC_InArgs;
-
-/**
- *  Defines the output arguments for a FDK_sacenc_encode() call.
- */
-typedef struct {
-  INT nOutputBits;    /*!< Number of valid payload bits generated during
-                         FDK_sacenc_encode(). */
-  INT nOutputSamples; /*!< Number of valid output audio samples generated during
-                         FDK_sacenc_encode(). */
-  UINT nSamplesConsumed; /*!< Number of input audio samples consumed in
-                            FDK_sacenc_encode(). */
-
-} SACENC_OutArgs;
-
-/* Constants *****************************************************************/
-
-/* Function / Class Declarations *********************************************/
-
-/**
- * \brief  Opens a new instace of the MPEG Surround encoder.
- *
- * \param phMp4SpaceEnc      Pointer to the encoder handle to be deallocated.
- *
- * \return
- *          - SACENC_OK, on success.
- *          - SACENC_INVALID_HANDLE, SACENC_MEMORY_ERROR, on failure.
- */
-FDK_SACENC_ERROR FDK_sacenc_open(HANDLE_MP4SPACE_ENCODER *phMp4SpaceEnc);
-
-/**
- * \brief  Finalizes opening process of MPEG Surround encoder.
- *
- * Shows, how many samples are needed as input
- *
- * \param hMp4SpaceEnc       A valid MPEG Surround encoder handle.
- * \param dmxDelay           Downmix delay.
- *
- * \return
- *          - SACENC_OK, on success.
- *          - SACENC_INVALID_HANDLE, SACENC_INIT_ERROR, SACENC_INVALID_CONFIG,
- * on failure.
- */
-FDK_SACENC_ERROR FDK_sacenc_init(HANDLE_MP4SPACE_ENCODER hMp4SpaceEnc,
-                                 const INT dmxDelay);
-
-/**
- * \brief  Close the MPEG Surround encoder instance.
- *
- * Deallocate encoder instance and free whole memory.
- *
- * \param phMp4SpaceEnc      Pointer to the encoder handle to be deallocated.
- *
- * \return
- *          - SACENC_OK, on success.
- *          - SACENC_INVALID_HANDLE, on failure.
- */
-FDK_SACENC_ERROR FDK_sacenc_close(HANDLE_MP4SPACE_ENCODER *phMp4SpaceEnc);
-
-/**
- * \brief  MPEG surround parameter extraction, framwise.
- *
- * \param hMp4SpaceEnc       A valid MPEG Surround encoder handle.
- *
- * \return
- *          - SACENC_OK, on success.
- *          - SACENC_INVALID_HANDLE, on failure.
- */
-FDK_SACENC_ERROR FDK_sacenc_encode(const HANDLE_MP4SPACE_ENCODER hMp4SpaceEnc,
-                                   const FDK_bufDescr *inBufDesc,
-                                   const FDK_bufDescr *outBufDesc,
-                                   const SACENC_InArgs *inargs,
-                                   SACENC_OutArgs *outargs);
-
-/**
- * \brief  Provides information on produced bitstream.
- *
- * \param hMp4SpaceEnc       A valid MPEG Surround encoder handle.
- * \param pInfo              Pointer to an encoder info struct, filled on
- * return.
- *
- * \return
- *          - SACENC_OK, on success.
- *          - SACENC_INVALID_HANDLE, on failure.
- */
-FDK_SACENC_ERROR FDK_sacenc_getInfo(const HANDLE_MP4SPACE_ENCODER hMp4SpaceEnc,
-                                    MP4SPACEENC_INFO *const pInfo);
-
-/**
- * \brief  Set one single MPEG Surround encoder parameter.
- *
- * This function allows configuration of all encoder parameters specified in
- * ::SPACEENC_PARAM. Each parameter must be set with a separate function call.
- * An internal validation of the configuration value range will be done.
- *
- * \param hMp4SpaceEnc       A valid MPEG Surround encoder handle.
- * \param param              Parameter to be set. See ::SPACEENC_PARAM.
- * \param value              Parameter value. See parameter description in
- * ::SPACEENC_PARAM.
- *
- * \return
- *          - SACENC_OK, on success.
- *          - SACENC_INVALID_HANDLE, SACENC_UNSUPPORTED_PARAMETER,
- * SACENC_INVALID_CONFIG, on failure.
- */
-FDK_SACENC_ERROR FDK_sacenc_setParam(HANDLE_MP4SPACE_ENCODER hMp4SpaceEnc,
-                                     const SPACEENC_PARAM param,
-                                     const UINT value);
-
-/**
- * \brief  Get information about MPEG Surround encoder library build.
- *
- * Fill a given LIB_INFO structure with library version information.
- *
- * \param info               Pointer to an allocated LIB_INFO struct.
- *
- * \return
- *          - SACENC_OK, on success.
- *          - SACENC_INVALID_HANDLE, SACENC_INIT_ERROR, on failure.
- */
-FDK_SACENC_ERROR FDK_sacenc_getLibInfo(LIB_INFO *info);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* SACENC_LIB_H */
--- a/libSACenc/src/sacenc_bitstream.cpp
+++ /dev/null
@@ -1,826 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround encoder library *************************
-
-   Author(s):
-
-   Description: Encoder Library Interface
-                Bitstream Writer
-
-*******************************************************************************/
-
-/* Includes ******************************************************************/
-#include "sacenc_bitstream.h"
-#include "sacenc_const.h"
-
-#include "genericStds.h"
-#include "common_fix.h"
-
-#include "FDK_matrixCalloc.h"
-#include "sacenc_nlc_enc.h"
-
-/* Defines *******************************************************************/
-#define MAX_FREQ_RES_INDEX 8
-#define MAX_SAMPLING_FREQUENCY_INDEX 13
-#define SAMPLING_FREQUENCY_INDEX_ESCAPE 15
-
-/* Data Types ****************************************************************/
-typedef struct {
-  SCHAR cld_old[SACENC_MAX_NUM_BOXES][MAX_NUM_BINS];
-  SCHAR icc_old[SACENC_MAX_NUM_BOXES][MAX_NUM_BINS];
-  UCHAR quantCoarseCldPrev[SACENC_MAX_NUM_BOXES][MAX_NUM_PARAMS];
-  UCHAR quantCoarseIccPrev[SACENC_MAX_NUM_BOXES][MAX_NUM_PARAMS];
-
-} PREV_OTTDATA;
-
-typedef struct {
-  PREV_OTTDATA prevOttData;
-
-} STATIC_SPATIALFRAME;
-
-typedef struct BSF_INSTANCE {
-  SPATIALSPECIFICCONFIG spatialSpecificConfig;
-  SPATIALFRAME frame;
-  STATIC_SPATIALFRAME prevFrameData;
-
-} BSF_INSTANCE;
-
-/* Constants *****************************************************************/
-static const INT SampleRateTable[MAX_SAMPLING_FREQUENCY_INDEX] = {
-    96000, 88200, 64000, 48000, 44100, 32000, 24000,
-    22050, 16000, 12000, 11025, 8000,  7350};
-
-static const UCHAR FreqResBinTable_LD[MAX_FREQ_RES_INDEX] = {0, 23, 15, 12,
-                                                             9, 7,  5,  4};
-static const UCHAR FreqResStrideTable_LD[] = {1, 2, 5, 23};
-
-/* Function / Class Declarations *********************************************/
-
-/* Function / Class Definition ***********************************************/
-static FDK_SACENC_ERROR DuplicateLosslessData(
-    const INT startBox, const INT stopBox,
-    const LOSSLESSDATA *const hLosslessDataFrom, const INT setFrom,
-    LOSSLESSDATA *const hLosslessDataTo, const INT setTo) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if ((NULL == hLosslessDataFrom) || (NULL == hLosslessDataTo)) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    int i;
-
-    for (i = startBox; i < stopBox; i++) {
-      hLosslessDataTo->bsXXXDataMode[i][setTo] =
-          hLosslessDataFrom->bsXXXDataMode[i][setFrom];
-      hLosslessDataTo->bsDataPair[i][setTo] =
-          hLosslessDataFrom->bsDataPair[i][setFrom];
-      hLosslessDataTo->bsQuantCoarseXXX[i][setTo] =
-          hLosslessDataFrom->bsQuantCoarseXXX[i][setFrom];
-      hLosslessDataTo->bsFreqResStrideXXX[i][setTo] =
-          hLosslessDataFrom->bsFreqResStrideXXX[i][setFrom];
-    }
-  }
-  return error;
-}
-
-FDK_SACENC_ERROR fdk_sacenc_duplicateParameterSet(
-    const SPATIALFRAME *const hFrom, const INT setFrom, SPATIALFRAME *const hTo,
-    const INT setTo) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if ((NULL == hFrom) || (NULL == hTo)) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    int box;
-    /* Only Copy Parameter Set selective stuff */
-
-    /* OTT-Data */
-    for (box = 0; box < SACENC_MAX_NUM_BOXES; box++) {
-      FDKmemcpy(hTo->ottData.cld[box][setTo], hFrom->ottData.cld[box][setFrom],
-                sizeof(hFrom->ottData.cld[0][0]));
-      FDKmemcpy(hTo->ottData.icc[box][setTo], hFrom->ottData.icc[box][setFrom],
-                sizeof(hFrom->ottData.icc[0][0]));
-    }
-
-    /* LOSSLESSDATA */
-    DuplicateLosslessData(0, SACENC_MAX_NUM_BOXES, &hFrom->CLDLosslessData,
-                          setFrom, &hTo->CLDLosslessData, setTo);
-    DuplicateLosslessData(0, SACENC_MAX_NUM_BOXES, &hFrom->ICCLosslessData,
-                          setFrom, &hTo->ICCLosslessData, setTo);
-
-  } /* valid handle */
-
-  return error;
-}
-
-/* set frame defaults */
-static void clearFrame(SPATIALFRAME *const pFrame) {
-  FDKmemclear(pFrame, sizeof(SPATIALFRAME));
-
-  pFrame->bsIndependencyFlag = 1;
-  pFrame->framingInfo.numParamSets = 1;
-}
-
-static void fine2coarse(SCHAR *const data, const DATA_TYPE dataType,
-                        const INT startBand, const INT numBands) {
-  int i;
-  if (dataType == t_CLD) {
-    for (i = startBand; i < startBand + numBands; i++) {
-      data[i] /= 2;
-    }
-  } else {
-    for (i = startBand; i < startBand + numBands; i++) {
-      data[i] >>= 1;
-    }
-  }
-}
-
-static void coarse2fine(SCHAR *const data, const DATA_TYPE dataType,
-                        const INT startBand, const INT numBands) {
-  int i;
-
-  for (i = startBand; i < startBand + numBands; i++) {
-    data[i] <<= 1;
-  }
-
-  if (dataType == t_CLD) {
-    for (i = startBand; i < startBand + numBands; i++) {
-      if (data[i] == -14) {
-        data[i] = -15;
-      } else if (data[i] == 14) {
-        data[i] = 15;
-      }
-    }
-  } /* (dataType == t_CLD) */
-}
-
-static UCHAR getBsFreqResStride(const INT index) {
-  const UCHAR *pFreqResStrideTable = NULL;
-  int freqResStrideTableSize = 0;
-
-  pFreqResStrideTable = FreqResStrideTable_LD;
-  freqResStrideTableSize =
-      sizeof(FreqResStrideTable_LD) / sizeof(*FreqResStrideTable_LD);
-
-  return (((NULL != pFreqResStrideTable) && (index >= 0) &&
-           (index < freqResStrideTableSize))
-              ? pFreqResStrideTable[index]
-              : 1);
-}
-
-/* write data to bitstream */
-static void ecData(HANDLE_FDK_BITSTREAM bitstream,
-                   SCHAR data[MAX_NUM_PARAMS][MAX_NUM_BINS],
-                   SCHAR oldData[MAX_NUM_BINS],
-                   UCHAR quantCoarseXXXprev[MAX_NUM_PARAMS],
-                   LOSSLESSDATA *const losslessData, const DATA_TYPE dataType,
-                   const INT paramIdx, const INT numParamSets,
-                   const INT independencyFlag, const INT startBand,
-                   const INT stopBand, const INT defaultValue) {
-  int ps, pb, strOffset, pbStride, dataBands, i;
-  int aStrides[MAX_NUM_BINS + 1] = {0};
-  SHORT cmpIdxData[2][MAX_NUM_BINS] = {{0}};
-  SHORT cmpOldData[MAX_NUM_BINS] = {0};
-
-  /* bsXXXDataMode */
-  if (independencyFlag || (losslessData->bsQuantCoarseXXX[paramIdx][0] !=
-                           quantCoarseXXXprev[paramIdx])) {
-    losslessData->bsXXXDataMode[paramIdx][0] = FINECOARSE;
-  } else {
-    losslessData->bsXXXDataMode[paramIdx][0] = KEEP;
-    for (i = startBand; i < stopBand; i++) {
-      if (data[0][i] != oldData[i]) {
-        losslessData->bsXXXDataMode[paramIdx][0] = FINECOARSE;
-        break;
-      }
-    }
-  }
-
-  FDKwriteBits(bitstream, losslessData->bsXXXDataMode[paramIdx][0], 2);
-
-  for (ps = 1; ps < numParamSets; ps++) {
-    if (losslessData->bsQuantCoarseXXX[paramIdx][ps] !=
-        losslessData->bsQuantCoarseXXX[paramIdx][ps - 1]) {
-      losslessData->bsXXXDataMode[paramIdx][ps] = FINECOARSE;
-    } else {
-      losslessData->bsXXXDataMode[paramIdx][ps] = KEEP;
-      for (i = startBand; i < stopBand; i++) {
-        if (data[ps][i] != data[ps - 1][i]) {
-          losslessData->bsXXXDataMode[paramIdx][ps] = FINECOARSE;
-          break;
-        }
-      }
-    }
-
-    FDKwriteBits(bitstream, losslessData->bsXXXDataMode[paramIdx][ps], 2);
-  } /* for ps */
-
-  /* Create data pairs if possible */
-  for (ps = 0; ps < (numParamSets - 1); ps++) {
-    if (losslessData->bsXXXDataMode[paramIdx][ps] == FINECOARSE) {
-      /* Check if next parameter set is FINCOARSE */
-      if (losslessData->bsXXXDataMode[paramIdx][ps + 1] == FINECOARSE) {
-        /* We have to check if ps and ps+1 use the same bsXXXQuantMode */
-        /* and also have the same stride */
-        if ((losslessData->bsQuantCoarseXXX[paramIdx][ps + 1] ==
-             losslessData->bsQuantCoarseXXX[paramIdx][ps]) &&
-            (losslessData->bsFreqResStrideXXX[paramIdx][ps + 1] ==
-             losslessData->bsFreqResStrideXXX[paramIdx][ps])) {
-          losslessData->bsDataPair[paramIdx][ps] = 1;
-          losslessData->bsDataPair[paramIdx][ps + 1] = 1;
-
-          /* We have a data pair -> Jump to the ps after next ps*/
-          ps++;
-          continue;
-        }
-      }
-      /* dataMode of next ps is not FINECOARSE or does not use the same
-       * bsXXXQuantMode/stride */
-      /* -> no dataPair possible */
-      losslessData->bsDataPair[paramIdx][ps] = 0;
-
-      /* Initialize ps after next ps to Zero (only important for the last
-       * parameter set) */
-      losslessData->bsDataPair[paramIdx][ps + 1] = 0;
-    } else {
-      /* No FINECOARSE -> no data pair possible */
-      losslessData->bsDataPair[paramIdx][ps] = 0;
-
-      /* Initialize ps after next ps to Zero (only important for the last
-       * parameter set) */
-      losslessData->bsDataPair[paramIdx][ps + 1] = 0;
-    }
-  } /* for ps */
-
-  for (ps = 0; ps < numParamSets; ps++) {
-    if (losslessData->bsXXXDataMode[paramIdx][ps] == DEFAULT) {
-      /* Prepare old data */
-      for (i = startBand; i < stopBand; i++) {
-        oldData[i] = defaultValue;
-      }
-      quantCoarseXXXprev[paramIdx] = 0; /* Default data are always fine */
-    }
-
-    if (losslessData->bsXXXDataMode[paramIdx][ps] == FINECOARSE) {
-      FDKwriteBits(bitstream, losslessData->bsDataPair[paramIdx][ps], 1);
-      FDKwriteBits(bitstream, losslessData->bsQuantCoarseXXX[paramIdx][ps], 1);
-      FDKwriteBits(bitstream, losslessData->bsFreqResStrideXXX[paramIdx][ps],
-                   2);
-
-      if (losslessData->bsQuantCoarseXXX[paramIdx][ps] !=
-          quantCoarseXXXprev[paramIdx]) {
-        if (quantCoarseXXXprev[paramIdx]) {
-          coarse2fine(oldData, dataType, startBand, stopBand - startBand);
-        } else {
-          fine2coarse(oldData, dataType, startBand, stopBand - startBand);
-        }
-      }
-
-      /* Handle strides */
-      pbStride =
-          getBsFreqResStride(losslessData->bsFreqResStrideXXX[paramIdx][ps]);
-      dataBands = (stopBand - startBand - 1) / pbStride + 1;
-
-      aStrides[0] = startBand;
-      for (pb = 1; pb <= dataBands; pb++) {
-        aStrides[pb] = aStrides[pb - 1] + pbStride;
-      }
-
-      strOffset = 0;
-      while (aStrides[dataBands] > stopBand) {
-        if (strOffset < dataBands) {
-          strOffset++;
-        }
-        for (i = strOffset; i <= dataBands; i++) {
-          aStrides[i]--;
-        }
-      } /* while */
-
-      for (pb = 0; pb < dataBands; pb++) {
-        cmpOldData[startBand + pb] = oldData[aStrides[pb]];
-        cmpIdxData[0][startBand + pb] = data[ps][aStrides[pb]];
-
-        if (losslessData->bsDataPair[paramIdx][ps]) {
-          cmpIdxData[1][startBand + pb] = data[ps + 1][aStrides[pb]];
-        }
-      } /* for pb*/
-
-      /* Finally encode */
-      if (losslessData->bsDataPair[paramIdx][ps]) {
-        fdk_sacenc_ecDataPairEnc(bitstream, cmpIdxData, cmpOldData, dataType, 0,
-                                 startBand, dataBands,
-                                 losslessData->bsQuantCoarseXXX[paramIdx][ps],
-                                 independencyFlag && (ps == 0));
-      } else {
-        fdk_sacenc_ecDataSingleEnc(bitstream, cmpIdxData, cmpOldData, dataType,
-                                   0, startBand, dataBands,
-                                   losslessData->bsQuantCoarseXXX[paramIdx][ps],
-                                   independencyFlag && (ps == 0));
-      }
-
-      /* Overwrite old data */
-      for (i = startBand; i < stopBand; i++) {
-        if (losslessData->bsDataPair[paramIdx][ps]) {
-          oldData[i] = data[ps + 1][i];
-        } else {
-          oldData[i] = data[ps][i];
-        }
-      }
-
-      quantCoarseXXXprev[paramIdx] =
-          losslessData->bsQuantCoarseXXX[paramIdx][ps];
-
-      /* Jump forward if we have encoded a data pair */
-      if (losslessData->bsDataPair[paramIdx][ps]) {
-        ps++;
-      }
-
-    } /* if (losslessData->bsXXXDataMode[paramIdx][ps] == FINECOARSE ) */
-  }   /* for ps */
-}
-
-/****************************************************************************/
-/* Bitstream formatter interface functions                                  */
-/****************************************************************************/
-static FDK_SACENC_ERROR getBsFreqResIndex(const INT numBands,
-                                          INT *const pbsFreqResIndex) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if (NULL == pbsFreqResIndex) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    const UCHAR *pFreqResBinTable = FreqResBinTable_LD;
-    int i;
-    *pbsFreqResIndex = -1;
-
-    for (i = 0; i < MAX_FREQ_RES_INDEX; i++) {
-      if (numBands == pFreqResBinTable[i]) {
-        *pbsFreqResIndex = i;
-        break;
-      }
-    }
-    if (*pbsFreqResIndex < 0 || *pbsFreqResIndex >= MAX_FREQ_RES_INDEX) {
-      error = SACENC_INVALID_CONFIG;
-    }
-  }
-  return error;
-}
-
-static FDK_SACENC_ERROR getSamplingFrequencyIndex(
-    const INT bsSamplingFrequency, INT *const pbsSamplingFrequencyIndex) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if (NULL == pbsSamplingFrequencyIndex) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    int i;
-    *pbsSamplingFrequencyIndex = SAMPLING_FREQUENCY_INDEX_ESCAPE;
-
-    for (i = 0; i < MAX_SAMPLING_FREQUENCY_INDEX; i++) {
-      if (bsSamplingFrequency == SampleRateTable[i]) { /*spatial sampling rate*/
-        *pbsSamplingFrequencyIndex = i;
-        break;
-      }
-    }
-  }
-  return error;
-}
-
-/* destroy encoder instance */
-FDK_SACENC_ERROR fdk_sacenc_destroySpatialBitstreamEncoder(
-    HANDLE_BSF_INSTANCE *selfPtr) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if ((selfPtr == NULL) || (*selfPtr == NULL)) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    if (*selfPtr != NULL) {
-      FDK_FREE_MEMORY_1D(*selfPtr);
-    }
-  }
-  return error;
-}
-
-/* create encoder instance */
-FDK_SACENC_ERROR fdk_sacenc_createSpatialBitstreamEncoder(
-    HANDLE_BSF_INSTANCE *selfPtr) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if (NULL == selfPtr) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    /* allocate encoder struct */
-    FDK_ALLOCATE_MEMORY_1D(*selfPtr, 1, BSF_INSTANCE);
-  }
-  return error;
-
-bail:
-  fdk_sacenc_destroySpatialBitstreamEncoder(selfPtr);
-  return ((SACENC_OK == error) ? SACENC_MEMORY_ERROR : error);
-}
-
-/* init encoder instance */
-FDK_SACENC_ERROR fdk_sacenc_initSpatialBitstreamEncoder(
-    HANDLE_BSF_INSTANCE selfPtr) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if (selfPtr == NULL) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    /* init/clear */
-    clearFrame(&selfPtr->frame);
-
-  } /* valid handle */
-  return error;
-}
-
-/* get SpatialSpecificConfig struct */
-SPATIALSPECIFICCONFIG *fdk_sacenc_getSpatialSpecificConfig(
-    HANDLE_BSF_INSTANCE selfPtr) {
-  return ((selfPtr == NULL) ? NULL : &(selfPtr->spatialSpecificConfig));
-}
-
-/* write SpatialSpecificConfig to stream */
-FDK_SACENC_ERROR fdk_sacenc_writeSpatialSpecificConfig(
-    SPATIALSPECIFICCONFIG *const spatialSpecificConfig,
-    UCHAR *const pOutputBuffer, const INT outputBufferSize,
-    INT *const pnOutputBits) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-  INT bsSamplingFrequencyIndex = 0;
-  INT bsFreqRes = 0;
-
-  if ((spatialSpecificConfig == NULL) || (pOutputBuffer == NULL) ||
-      (pnOutputBits == NULL)) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    FDK_BITSTREAM bitstream;
-
-    /* Find FreqRes */
-    if (SACENC_OK != (error = getBsFreqResIndex(spatialSpecificConfig->numBands,
-                                                &bsFreqRes)))
-      goto bail;
-
-    /* Find SamplingFrequencyIndex */
-    if (SACENC_OK != (error = getSamplingFrequencyIndex(
-                          spatialSpecificConfig->bsSamplingFrequency,
-                          &bsSamplingFrequencyIndex)))
-      goto bail;
-
-    /* bind extern buffer to bitstream handle */
-    FDKinitBitStream(&bitstream, pOutputBuffer, outputBufferSize, 0, BS_WRITER);
-
-    /****************************************************************************/
-    /* write to bitstream */
-
-    FDKwriteBits(&bitstream, bsSamplingFrequencyIndex, 4);
-
-    if (bsSamplingFrequencyIndex == 15) {
-      FDKwriteBits(&bitstream, spatialSpecificConfig->bsSamplingFrequency, 24);
-    }
-
-    FDKwriteBits(&bitstream, spatialSpecificConfig->bsFrameLength, 5);
-
-    FDKwriteBits(&bitstream, bsFreqRes, 3);
-    FDKwriteBits(&bitstream, spatialSpecificConfig->bsTreeConfig, 4);
-    FDKwriteBits(&bitstream, spatialSpecificConfig->bsQuantMode, 2);
-
-    FDKwriteBits(&bitstream, 0, 1); /* bsArbitraryDownmix */
-
-    FDKwriteBits(&bitstream, spatialSpecificConfig->bsFixedGainDMX, 3);
-
-    FDKwriteBits(&bitstream, TEMPSHAPE_OFF, 2);
-    FDKwriteBits(&bitstream, spatialSpecificConfig->bsDecorrConfig, 2);
-
-    FDKbyteAlign(&bitstream, 0); /* byte alignment */
-
-    /* return number of valid bits in bitstream */
-    if ((*pnOutputBits = FDKgetValidBits(&bitstream)) >
-        (outputBufferSize * 8)) {
-      error = SACENC_INVALID_CONFIG;
-      goto bail;
-    }
-
-    /* terminate buffer with alignment */
-    FDKbyteAlign(&bitstream, 0);
-
-  } /* valid handle */
-
-bail:
-  return error;
-}
-
-/* get SpatialFrame struct */
-SPATIALFRAME *fdk_sacenc_getSpatialFrame(HANDLE_BSF_INSTANCE selfPtr,
-                                         const SPATIALFRAME_TYPE frameType) {
-  int idx = -1;
-
-  switch (frameType) {
-    case READ_SPATIALFRAME:
-    case WRITE_SPATIALFRAME:
-      idx = 0;
-      break;
-    default:
-      idx = -1; /* invalid configuration */
-  }             /* switch frameType */
-
-  return (((selfPtr == NULL) || (idx == -1)) ? NULL : &selfPtr->frame);
-}
-
-static FDK_SACENC_ERROR writeFramingInfo(HANDLE_FDK_BITSTREAM hBitstream,
-                                         const FRAMINGINFO *const pFramingInfo,
-                                         const INT frameLength) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if ((hBitstream == NULL) || (pFramingInfo == NULL)) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    FDKwriteBits(hBitstream, pFramingInfo->bsFramingType, 1);
-    FDKwriteBits(hBitstream, pFramingInfo->numParamSets - 1, 1);
-
-    if (pFramingInfo->bsFramingType) {
-      int ps = 0;
-      int numParamSets = pFramingInfo->numParamSets;
-
-      {
-        for (ps = 0; ps < numParamSets; ps++) {
-          int bitsParamSlot = 0;
-          while ((1 << bitsParamSlot) < (frameLength + 1)) bitsParamSlot++;
-          if (bitsParamSlot > 0)
-            FDKwriteBits(hBitstream, pFramingInfo->bsParamSlots[ps],
-                         bitsParamSlot);
-        }
-      }
-    } /* pFramingInfo->bsFramingType */
-  }   /* valid handle */
-
-  return error;
-}
-
-static FDK_SACENC_ERROR writeSmgData(HANDLE_FDK_BITSTREAM hBitstream,
-                                     const SMGDATA *const pSmgData,
-                                     const INT numParamSets,
-                                     const INT dataBands) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if ((hBitstream == NULL) || (pSmgData == NULL)) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    int i, j;
-
-    for (i = 0; i < numParamSets; i++) {
-      FDKwriteBits(hBitstream, pSmgData->bsSmoothMode[i], 2);
-
-      if (pSmgData->bsSmoothMode[i] >= 2) {
-        FDKwriteBits(hBitstream, pSmgData->bsSmoothTime[i], 2);
-      }
-      if (pSmgData->bsSmoothMode[i] == 3) {
-        const int stride = getBsFreqResStride(pSmgData->bsFreqResStride[i]);
-        FDKwriteBits(hBitstream, pSmgData->bsFreqResStride[i], 2);
-        for (j = 0; j < dataBands; j += stride) {
-          FDKwriteBits(hBitstream, pSmgData->bsSmgData[i][j], 1);
-        }
-      }
-    } /* for i */
-  }   /* valid handle */
-
-  return error;
-}
-
-static FDK_SACENC_ERROR writeOttData(
-    HANDLE_FDK_BITSTREAM hBitstream, PREV_OTTDATA *const pPrevOttData,
-    OTTDATA *const pOttData, const OTTCONFIG ottConfig[SACENC_MAX_NUM_BOXES],
-    LOSSLESSDATA *const pCLDLosslessData, LOSSLESSDATA *const pICCLosslessData,
-    const INT numOttBoxes, const INT numBands, const INT numParamSets,
-    const INT bsIndependencyFlag) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if ((hBitstream == NULL) || (pPrevOttData == NULL) || (pOttData == NULL) ||
-      (ottConfig == NULL) || (pCLDLosslessData == NULL) ||
-      (pICCLosslessData == NULL)) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    int i;
-    for (i = 0; i < numOttBoxes; i++) {
-      ecData(hBitstream, pOttData->cld[i], pPrevOttData->cld_old[i],
-             pPrevOttData->quantCoarseCldPrev[i], pCLDLosslessData, t_CLD, i,
-             numParamSets, bsIndependencyFlag, 0, ottConfig[i].bsOttBands, 15);
-    }
-    {
-      for (i = 0; i < numOttBoxes; i++) {
-        {
-          ecData(hBitstream, pOttData->icc[i], pPrevOttData->icc_old[i],
-                 pPrevOttData->quantCoarseIccPrev[i], pICCLosslessData, t_ICC,
-                 i, numParamSets, bsIndependencyFlag, 0, numBands, 0);
-        }
-      } /* for i */
-    }
-  } /* valid handle */
-
-  return error;
-}
-
-/* write extension frame data to stream */
-static FDK_SACENC_ERROR WriteSpatialExtensionFrame(
-    HANDLE_FDK_BITSTREAM bitstream, HANDLE_BSF_INSTANCE self) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if ((bitstream == NULL) || (self == NULL)) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    FDKbyteAlign(bitstream, 0);
-  } /* valid handle */
-
-  return error;
-}
-
-/* write frame data to stream */
-FDK_SACENC_ERROR fdk_sacenc_writeSpatialFrame(UCHAR *const pOutputBuffer,
-                                              const INT outputBufferSize,
-                                              INT *const pnOutputBits,
-                                              HANDLE_BSF_INSTANCE selfPtr) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if ((pOutputBuffer == NULL) || (pnOutputBits == NULL) || (selfPtr == NULL)) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    SPATIALFRAME *frame = NULL;
-    SPATIALSPECIFICCONFIG *config = NULL;
-    FDK_BITSTREAM bitstream;
-
-    int i, j, numParamSets, numOttBoxes;
-
-    if ((NULL ==
-         (frame = fdk_sacenc_getSpatialFrame(selfPtr, READ_SPATIALFRAME))) ||
-        (NULL == (config = &(selfPtr->spatialSpecificConfig)))) {
-      error = SACENC_INVALID_HANDLE;
-      goto bail;
-    }
-
-    numOttBoxes = selfPtr->spatialSpecificConfig.treeDescription.numOttBoxes;
-
-    numParamSets = frame->framingInfo.numParamSets;
-
-    if (frame->bUseBBCues) {
-      for (i = 0; i < SACENC_MAX_NUM_BOXES; i++) {
-        /* If a transient was detected, force only the second ps broad band */
-        if (numParamSets == 1) {
-          frame->CLDLosslessData.bsFreqResStrideXXX[i][0] = 3;
-          frame->ICCLosslessData.bsFreqResStrideXXX[i][0] = 3;
-        } else {
-          for (j = 1; j < MAX_NUM_PARAMS; j++) {
-            frame->CLDLosslessData.bsFreqResStrideXXX[i][j] = 3;
-            frame->ICCLosslessData.bsFreqResStrideXXX[i][j] = 3;
-          }
-        }
-      }
-    } /* frame->bUseBBCues */
-
-    /* bind extern buffer to bitstream handle */
-    FDKinitBitStream(&bitstream, pOutputBuffer, outputBufferSize, 0, BS_WRITER);
-
-    if (SACENC_OK != (error = writeFramingInfo(
-                          &bitstream, &(frame->framingInfo),
-                          selfPtr->spatialSpecificConfig.bsFrameLength))) {
-      goto bail;
-    }
-
-    /* write bsIndependencyFlag */
-    FDKwriteBits(&bitstream, frame->bsIndependencyFlag, 1);
-
-    /* write spatial data to bitstream */
-    if (SACENC_OK !=
-        (error = writeOttData(&bitstream, &selfPtr->prevFrameData.prevOttData,
-                              &frame->ottData, config->ottConfig,
-                              &frame->CLDLosslessData, &frame->ICCLosslessData,
-                              numOttBoxes, config->numBands, numParamSets,
-                              frame->bsIndependencyFlag))) {
-      goto bail;
-    }
-    if (SACENC_OK != (error = writeSmgData(&bitstream, &frame->smgData,
-                                           numParamSets, config->numBands))) {
-      goto bail;
-    }
-
-    /* byte alignment */
-    FDKbyteAlign(&bitstream, 0);
-
-    /* Write SpatialExtensionFrame */
-    if (SACENC_OK !=
-        (error = WriteSpatialExtensionFrame(&bitstream, selfPtr))) {
-      goto bail;
-    }
-
-    if (NULL ==
-        (frame = fdk_sacenc_getSpatialFrame(selfPtr, WRITE_SPATIALFRAME))) {
-      error = SACENC_INVALID_HANDLE;
-      goto bail;
-    }
-
-    clearFrame(frame);
-
-    /* return number of valid bits in bitstream */
-    if ((*pnOutputBits = FDKgetValidBits(&bitstream)) >
-        (outputBufferSize * 8)) {
-      error = SACENC_INVALID_CONFIG;
-      goto bail;
-    }
-
-    /* terminate buffer with alignment */
-    FDKbyteAlign(&bitstream, 0);
-
-  } /* valid handle */
-
-bail:
-  return error;
-}
--- a/libSACenc/src/sacenc_bitstream.h
+++ /dev/null
@@ -1,296 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround encoder library *************************
-
-   Author(s):
-
-   Description: Encoder Library Interface
-                Bitstream Writer
-
-*******************************************************************************/
-
-#ifndef SACENC_BITSTREAM_H
-#define SACENC_BITSTREAM_H
-
-/* Includes ******************************************************************/
-#include "FDK_bitstream.h"
-#include "FDK_matrixCalloc.h"
-#include "sacenc_lib.h"
-#include "sacenc_const.h"
-
-/* Defines *******************************************************************/
-#define MAX_NUM_BINS 23
-#define MAX_NUM_PARAMS 2
-#define MAX_NUM_OUTPUTCHANNELS SACENC_MAX_OUTPUT_CHANNELS
-#define MAX_TIME_SLOTS 32
-
-typedef enum {
-  TREE_212 = 7,
-  TREE_ESCAPE = 15
-
-} TREECONFIG;
-
-typedef enum {
-  FREQ_RES_40 = 0,
-  FREQ_RES_20 = 1,
-  FREQ_RES_10 = 2,
-  FREQ_RES_5 = 3
-
-} FREQ;
-
-typedef enum {
-  QUANTMODE_INVALID = -1,
-  QUANTMODE_FINE = 0,
-  QUANTMODE_EBQ1 = 1,
-  QUANTMODE_EBQ2 = 2
-
-} QUANTMODE;
-
-typedef enum {
-  TEMPSHAPE_OFF = 0
-
-} TEMPSHAPECONFIG;
-
-typedef enum {
-  FIXEDGAINDMX_INVALID = -1,
-  FIXEDGAINDMX_0 = 0,
-  FIXEDGAINDMX_1 = 1,
-  FIXEDGAINDMX_2 = 2,
-  FIXEDGAINDMX_3 = 3,
-  FIXEDGAINDMX_4 = 4,
-  FIXEDGAINDMX_5 = 5,
-  FIXEDGAINDMX_6 = 6,
-  FIXEDGAINDMX_7 = 7
-
-} FIXEDGAINDMXCONFIG;
-
-typedef enum {
-  DECORR_INVALID = -1,
-  DECORR_QMFSPLIT0 = 0, /* QMF splitfreq: 3, 15, 24, 65 */
-  DECORR_QMFSPLIT1 = 1, /* QMF splitfreq: 3, 50, 65, 65 */
-  DECORR_QMFSPLIT2 = 2  /* QMF splitfreq: 0, 15, 65, 65 */
-
-} DECORRCONFIG;
-
-typedef enum {
-  DEFAULT = 0,
-  KEEP = 1,
-  INTERPOLATE = 2,
-  FINECOARSE = 3
-
-} DATA_MODE;
-
-typedef enum {
-  READ_SPATIALFRAME = 0,
-  WRITE_SPATIALFRAME = 1
-
-} SPATIALFRAME_TYPE;
-
-/* Data Types ****************************************************************/
-typedef struct {
-  INT numOttBoxes;
-  INT numInChan;
-  INT numOutChan;
-
-} TREEDESCRIPTION;
-
-typedef struct {
-  INT bsOttBands;
-
-} OTTCONFIG;
-
-typedef struct {
-  INT bsSamplingFrequency; /* for bsSamplingFrequencyIndex */
-  INT bsFrameLength;
-  INT numBands; /* for bsFreqRes */
-  TREECONFIG bsTreeConfig;
-  QUANTMODE bsQuantMode;
-  FIXEDGAINDMXCONFIG bsFixedGainDMX;
-  int bsEnvQuantMode;
-  DECORRCONFIG bsDecorrConfig;
-  TREEDESCRIPTION treeDescription;
-  OTTCONFIG ottConfig[SACENC_MAX_NUM_BOXES];
-
-} SPATIALSPECIFICCONFIG;
-
-typedef struct {
-  UCHAR bsFramingType;
-  UCHAR numParamSets;
-  UCHAR bsParamSlots[MAX_NUM_PARAMS];
-
-} FRAMINGINFO;
-
-typedef struct {
-  SCHAR cld[SACENC_MAX_NUM_BOXES][MAX_NUM_PARAMS][MAX_NUM_BINS];
-  SCHAR icc[SACENC_MAX_NUM_BOXES][MAX_NUM_PARAMS][MAX_NUM_BINS];
-
-} OTTDATA;
-
-typedef struct {
-  UCHAR bsSmoothMode[MAX_NUM_PARAMS];
-  UCHAR bsSmoothTime[MAX_NUM_PARAMS];
-  UCHAR bsFreqResStride[MAX_NUM_PARAMS];
-  UCHAR bsSmgData[MAX_NUM_PARAMS][MAX_NUM_BINS];
-
-} SMGDATA;
-
-typedef struct {
-  UCHAR bsEnvShapeChannel[MAX_NUM_OUTPUTCHANNELS];
-  UCHAR bsEnvShapeData[MAX_NUM_OUTPUTCHANNELS][MAX_TIME_SLOTS];
-
-} TEMPSHAPEDATA;
-
-typedef struct {
-  UCHAR bsXXXDataMode[SACENC_MAX_NUM_BOXES][MAX_NUM_PARAMS];
-  UCHAR bsDataPair[SACENC_MAX_NUM_BOXES][MAX_NUM_PARAMS];
-  UCHAR bsQuantCoarseXXX[SACENC_MAX_NUM_BOXES][MAX_NUM_PARAMS];
-  UCHAR bsFreqResStrideXXX[SACENC_MAX_NUM_BOXES][MAX_NUM_PARAMS];
-
-} LOSSLESSDATA;
-
-typedef struct {
-  FRAMINGINFO framingInfo;
-  UCHAR bsIndependencyFlag;
-  OTTDATA ottData;
-  SMGDATA smgData;
-  TEMPSHAPEDATA tempShapeData;
-  LOSSLESSDATA CLDLosslessData;
-  LOSSLESSDATA ICCLosslessData;
-  UCHAR bUseBBCues;
-
-} SPATIALFRAME;
-
-typedef struct BSF_INSTANCE *HANDLE_BSF_INSTANCE;
-
-/* Constants *****************************************************************/
-
-/* Function / Class Declarations *********************************************/
-/* destroy encoder instance */
-FDK_SACENC_ERROR fdk_sacenc_destroySpatialBitstreamEncoder(
-    HANDLE_BSF_INSTANCE *selfPtr);
-
-/* create encoder instance */
-FDK_SACENC_ERROR fdk_sacenc_createSpatialBitstreamEncoder(
-    HANDLE_BSF_INSTANCE *selfPtr);
-
-FDK_SACENC_ERROR fdk_sacenc_initSpatialBitstreamEncoder(
-    HANDLE_BSF_INSTANCE selfPtr);
-
-/* get SpatialSpecificConfig struct */
-SPATIALSPECIFICCONFIG *fdk_sacenc_getSpatialSpecificConfig(
-    HANDLE_BSF_INSTANCE selfPtr);
-
-/* write SpatialSpecificConfig to stream */
-FDK_SACENC_ERROR fdk_sacenc_writeSpatialSpecificConfig(
-    SPATIALSPECIFICCONFIG *const spatialSpecificConfig,
-    UCHAR *const pOutputBuffer, const INT outputBufferSize,
-    INT *const pnOutputBits);
-
-/* get SpatialFrame struct */
-SPATIALFRAME *fdk_sacenc_getSpatialFrame(HANDLE_BSF_INSTANCE selfPtr,
-                                         const SPATIALFRAME_TYPE frameType);
-
-/* write frame data to stream */
-FDK_SACENC_ERROR fdk_sacenc_writeSpatialFrame(UCHAR *const pOutputBuffer,
-                                              const INT outputBufferSize,
-                                              INT *const pnOutputBits,
-                                              HANDLE_BSF_INSTANCE selfPtr);
-
-/* Copy/Save spatial frame data for one parameter set */
-FDK_SACENC_ERROR fdk_sacenc_duplicateParameterSet(
-    const SPATIALFRAME *const hFrom, const INT setFrom, SPATIALFRAME *const hTo,
-    const INT setTo);
-
-#endif /* SACENC_BITSTREAM_H */
--- a/libSACenc/src/sacenc_const.h
+++ /dev/null
@@ -1,126 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround encoder library *************************
-
-   Author(s):   Markus Multrus
-
-   Description: Encoder Library Interface
-                constants to MPEG-4 spatial encoder lib
-
-*******************************************************************************/
-
-#ifndef SACENC_CONST_H
-#define SACENC_CONST_H
-
-/* Includes ******************************************************************/
-#include "machine_type.h"
-
-/* Defines *******************************************************************/
-#define NUM_QMF_BANDS 64
-#define MAX_QMF_BANDS 128
-
-#define SACENC_MAX_NUM_BOXES 1
-#define SACENC_MAX_INPUT_CHANNELS 2
-#define SACENC_MAX_OUTPUT_CHANNELS 1
-
-#define SACENC_FLOAT_EPSILON (1e-9f)
-
-/* Data Types ****************************************************************/
-
-/* Constants *****************************************************************/
-
-/* Function / Class Declarations *********************************************/
-
-#endif /* SACENC_CONST_H */
--- a/libSACenc/src/sacenc_delay.cpp
+++ /dev/null
@@ -1,472 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround encoder library *************************
-
-   Author(s):   Christian Goettlinger
-
-   Description: Encoder Library Interface
-                delay management of the encoder
-
-*******************************************************************************/
-
-/**************************************************************************/ /**
- \file
- This file contains all delay infrastructure
- ******************************************************************************/
-
-/* Includes ******************************************************************/
-#include "sacenc_delay.h"
-#include "sacenc_const.h"
-#include "FDK_matrixCalloc.h"
-
-/* Defines *******************************************************************/
-
-/* Data Types ****************************************************************/
-struct DELAY {
-  struct DELAY_CONFIG {
-    /* Routing Config Switches*/
-    INT bDmxAlign;
-    INT bTimeDomDmx;
-    INT bMinimizeDelay;
-    INT bSacTimeAlignmentDynamicOut;
-
-    /* Needed Input Variables*/
-    INT nQmfLen;
-    INT nFrameLen;
-    INT nSurroundDelay;
-    INT nArbDmxDelay;
-    INT nLimiterDelay;
-    INT nCoreCoderDelay;
-    INT nSacStreamMuxDelay;
-    INT nSacTimeAlignment; /* Overwritten, if bSacTimeAlignmentDynamicOut */
-  } config;
-
-  /* Variable Delaybuffers -> Delays */
-  INT nDmxAlignBuffer;
-  INT nSurroundAnalysisBuffer;
-  INT nArbDmxAnalysisBuffer;
-  INT nOutputAudioBuffer;
-  INT nBitstreamFrameBuffer;
-  INT nOutputAudioQmfFrameBuffer;
-  INT nDiscardOutFrames;
-
-  /* Variable Delaybuffers Computation Variables */
-  INT nBitstreamFrameBufferSize;
-
-  /* Output: Infos */
-  INT nInfoDmxDelay; /* Delay of the downmixed signal after the space encoder */
-  INT nInfoCodecDelay; /* Delay of the whole en-/decoder including CoreCoder */
-  INT nInfoDecoderDelay; /* Delay of the Mpeg Surround decoder */
-};
-
-/* Constants *****************************************************************/
-
-/* Function / Class Declarations *********************************************/
-
-/* Function / Class Definition ***********************************************/
-
-/*-----------------------------------------------------------------------------
-functionname: fdk_sacenc_delay_Open()
-description:  initializes Delays
-returns:      noError on success, an apropriate error code else
------------------------------------------------------------------------------*/
-FDK_SACENC_ERROR fdk_sacenc_delay_Open(HANDLE_DELAY *phDelay) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if (NULL == phDelay) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    FDK_ALLOCATE_MEMORY_1D(*phDelay, 1, struct DELAY);
-  }
-  return error;
-
-bail:
-  fdk_sacenc_delay_Close(phDelay);
-  return ((SACENC_OK == error) ? SACENC_MEMORY_ERROR : error);
-}
-
-/*-----------------------------------------------------------------------------
-functionname: fdk_sacenc_delay_Close()
-description:  destructs Delay
-returns:      noError on success, an apropriate error code else
------------------------------------------------------------------------------*/
-FDK_SACENC_ERROR fdk_sacenc_delay_Close(HANDLE_DELAY *phDelay) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if (NULL == phDelay) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    if (NULL != *phDelay) {
-      FDK_FREE_MEMORY_1D(*phDelay);
-    }
-  }
-  return error;
-}
-
-FDK_SACENC_ERROR fdk_sacenc_delay_Init(HANDLE_DELAY hDelay, const INT nQmfLen,
-                                       const INT nFrameLen,
-                                       const INT nCoreCoderDelay,
-                                       const INT nSacStreamMuxDelay) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if (NULL == hDelay) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    /* Fill structure before calculation */
-    FDKmemclear(&hDelay->config, sizeof(hDelay->config));
-
-    hDelay->config.nQmfLen = nQmfLen;
-    hDelay->config.nFrameLen = nFrameLen;
-    hDelay->config.nCoreCoderDelay = nCoreCoderDelay;
-    hDelay->config.nSacStreamMuxDelay = nSacStreamMuxDelay;
-  }
-  return error;
-}
-
-/*-----------------------------------------------------------------------------
-functionname: fdk_sacenc_delay_SubCalulateBufferDelays()
-description:  Calculates the Delays of the buffers
-returns:      Error Code
------------------------------------------------------------------------------*/
-FDK_SACENC_ERROR fdk_sacenc_delay_SubCalulateBufferDelays(HANDLE_DELAY hDel) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if (NULL == hDel) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    int nEncoderAnDelay, nEncoderSynDelay, nEncoderWinDelay, nDecoderAnDelay,
-        nDecoderSynDelay, nResidualCoderFrameDelay,
-        nArbDmxResidualCoderFrameDelay;
-
-    if (hDel->config.bSacTimeAlignmentDynamicOut > 0) {
-      hDel->config.nSacTimeAlignment = 0;
-    }
-
-    {
-      nEncoderAnDelay =
-          2 * hDel->config.nQmfLen +
-          hDel->config.nQmfLen / 2; /* Only Ld-QMF Delay, no hybrid */
-      nEncoderSynDelay = 1 * hDel->config.nQmfLen + hDel->config.nQmfLen / 2;
-      nDecoderAnDelay = 2 * hDel->config.nQmfLen + hDel->config.nQmfLen / 2;
-      nDecoderSynDelay = 1 * hDel->config.nQmfLen + hDel->config.nQmfLen / 2;
-      nEncoderWinDelay =
-          hDel->config.nFrameLen / 2; /* WindowLookahead is just half a frame */
-    }
-
-    { nResidualCoderFrameDelay = 0; }
-
-    { nArbDmxResidualCoderFrameDelay = 0; }
-
-    /* Calculate variable Buffer-Delays */
-    if (hDel->config.bTimeDomDmx == 0) {
-      /* ArbitraryDmx and TdDmx off */
-      int tempDelay;
-
-      hDel->nSurroundAnalysisBuffer = 0;
-      hDel->nArbDmxAnalysisBuffer = 0;
-      tempDelay = nEncoderSynDelay + hDel->config.nLimiterDelay +
-                  hDel->config.nCoreCoderDelay +
-                  hDel->config.nSacTimeAlignment + nDecoderAnDelay;
-      tempDelay = (nResidualCoderFrameDelay * hDel->config.nFrameLen) +
-                  hDel->config.nSacStreamMuxDelay - tempDelay;
-
-      if (tempDelay > 0) {
-        hDel->nBitstreamFrameBuffer = 0;
-        hDel->nOutputAudioBuffer = tempDelay;
-      } else {
-        tempDelay = -tempDelay;
-        hDel->nBitstreamFrameBuffer =
-            (tempDelay + hDel->config.nFrameLen - 1) / hDel->config.nFrameLen;
-        hDel->nOutputAudioBuffer =
-            (hDel->nBitstreamFrameBuffer * hDel->config.nFrameLen) - tempDelay;
-      }
-
-      hDel->nOutputAudioQmfFrameBuffer =
-          (hDel->nOutputAudioBuffer + (hDel->config.nQmfLen / 2) - 1) /
-          hDel->config.nQmfLen;
-
-      if (hDel->config.bDmxAlign > 0) {
-        tempDelay = nEncoderWinDelay + nEncoderAnDelay + nEncoderSynDelay +
-                    hDel->nOutputAudioBuffer + hDel->config.nLimiterDelay +
-                    hDel->config.nCoreCoderDelay;
-        hDel->nDiscardOutFrames =
-            (tempDelay + hDel->config.nFrameLen - 1) / hDel->config.nFrameLen;
-        hDel->nDmxAlignBuffer =
-            hDel->nDiscardOutFrames * hDel->config.nFrameLen - tempDelay;
-      } else {
-        hDel->nDiscardOutFrames = 0;
-        hDel->nDmxAlignBuffer = 0;
-      }
-
-      /* Output: Info-Variables */
-      hDel->nInfoDmxDelay = hDel->nSurroundAnalysisBuffer + nEncoderAnDelay +
-                            nEncoderWinDelay + nEncoderSynDelay +
-                            hDel->nOutputAudioBuffer +
-                            hDel->config.nLimiterDelay;
-      hDel->nInfoCodecDelay =
-          hDel->nInfoDmxDelay + hDel->config.nCoreCoderDelay +
-          hDel->config.nSacTimeAlignment + nDecoderAnDelay + nDecoderSynDelay;
-
-    } else {
-      /* ArbitraryDmx or TdDmx on */
-      int tempDelay1, tempDelay2, tempDelay12, tempDelay3;
-
-      tempDelay1 = hDel->config.nArbDmxDelay - hDel->config.nSurroundDelay;
-
-      if (tempDelay1 >= 0) {
-        hDel->nSurroundAnalysisBuffer = tempDelay1;
-        hDel->nArbDmxAnalysisBuffer = 0;
-      } else {
-        hDel->nSurroundAnalysisBuffer = 0;
-        hDel->nArbDmxAnalysisBuffer = -tempDelay1;
-      }
-
-      tempDelay1 = nEncoderWinDelay + hDel->config.nSurroundDelay +
-                   hDel->nSurroundAnalysisBuffer +
-                   nEncoderAnDelay; /*Surround Path*/
-      tempDelay2 = nEncoderWinDelay + hDel->config.nArbDmxDelay +
-                   hDel->nArbDmxAnalysisBuffer +
-                   nEncoderAnDelay; /* ArbDmx Compare Path */
-      tempDelay3 = hDel->config.nArbDmxDelay + hDel->config.nLimiterDelay +
-                   hDel->config.nCoreCoderDelay +
-                   hDel->config.nSacTimeAlignment +
-                   nDecoderAnDelay; /* ArbDmx Passthrough*/
-
-      tempDelay12 =
-          FDKmax(nResidualCoderFrameDelay, nArbDmxResidualCoderFrameDelay) *
-          hDel->config.nFrameLen;
-      tempDelay12 += hDel->config.nSacStreamMuxDelay;
-
-      if (tempDelay1 > tempDelay2) {
-        tempDelay12 += tempDelay1;
-      } else {
-        tempDelay12 += tempDelay2;
-      }
-
-      if (tempDelay3 > tempDelay12) {
-        if (hDel->config.bMinimizeDelay > 0) {
-          hDel->nBitstreamFrameBuffer =
-              (tempDelay3 - tempDelay12) / hDel->config.nFrameLen; /*floor*/
-          hDel->nOutputAudioBuffer = 0;
-          hDel->nSurroundAnalysisBuffer +=
-              (tempDelay3 - tempDelay12 -
-               (hDel->nBitstreamFrameBuffer * hDel->config.nFrameLen));
-          hDel->nArbDmxAnalysisBuffer +=
-              (tempDelay3 - tempDelay12 -
-               (hDel->nBitstreamFrameBuffer * hDel->config.nFrameLen));
-        } else {
-          hDel->nBitstreamFrameBuffer =
-              ((tempDelay3 - tempDelay12) + hDel->config.nFrameLen - 1) /
-              hDel->config.nFrameLen;
-          hDel->nOutputAudioBuffer =
-              hDel->nBitstreamFrameBuffer * hDel->config.nFrameLen +
-              tempDelay12 - tempDelay3;
-        }
-      } else {
-        hDel->nBitstreamFrameBuffer = 0;
-        hDel->nOutputAudioBuffer = tempDelay12 - tempDelay3;
-      }
-
-      if (hDel->config.bDmxAlign > 0) {
-        int tempDelay = hDel->config.nArbDmxDelay + hDel->nOutputAudioBuffer +
-                        hDel->config.nLimiterDelay +
-                        hDel->config.nCoreCoderDelay;
-        hDel->nDiscardOutFrames =
-            (tempDelay + hDel->config.nFrameLen - 1) / hDel->config.nFrameLen;
-        hDel->nDmxAlignBuffer =
-            hDel->nDiscardOutFrames * hDel->config.nFrameLen - tempDelay;
-      } else {
-        hDel->nDiscardOutFrames = 0;
-        hDel->nDmxAlignBuffer = 0;
-      }
-
-      /* Output: Info-Variables */
-      hDel->nInfoDmxDelay = hDel->config.nArbDmxDelay +
-                            hDel->nOutputAudioBuffer +
-                            hDel->config.nLimiterDelay;
-      hDel->nInfoCodecDelay =
-          hDel->nInfoDmxDelay + hDel->config.nCoreCoderDelay +
-          hDel->config.nSacTimeAlignment + nDecoderAnDelay + nDecoderSynDelay;
-      hDel->nInfoDecoderDelay = nDecoderAnDelay + nDecoderSynDelay;
-
-    } /* ArbitraryDmx or TdDmx on */
-
-    /* Additonal Variables needed for Computation Issues */
-    hDel->nBitstreamFrameBufferSize = hDel->nBitstreamFrameBuffer + 1;
-  }
-
-  return error;
-}
-
-static FDK_SACENC_ERROR assignParameterInRange(
-    const INT startRange, /* including startRange */
-    const INT stopRange,  /* including stopRange */
-    const INT value,      /* value to write*/
-    INT *const ptr        /* destination pointer*/
-) {
-  FDK_SACENC_ERROR error = SACENC_INVALID_CONFIG;
-
-  if ((startRange <= value) && (value <= stopRange)) {
-    *ptr = value;
-    error = SACENC_OK;
-  }
-
-  return error;
-}
-
-FDK_SACENC_ERROR fdk_sacenc_delay_SetDmxAlign(HANDLE_DELAY hDelay,
-                                              const INT bDmxAlignIn) {
-  return (assignParameterInRange(0, 1, bDmxAlignIn, &hDelay->config.bDmxAlign));
-}
-
-FDK_SACENC_ERROR fdk_sacenc_delay_SetTimeDomDmx(HANDLE_DELAY hDelay,
-                                                const INT bTimeDomDmxIn) {
-  return (
-      assignParameterInRange(0, 1, bTimeDomDmxIn, &hDelay->config.bTimeDomDmx));
-}
-
-FDK_SACENC_ERROR fdk_sacenc_delay_SetSacTimeAlignmentDynamicOut(
-    HANDLE_DELAY hDelay, const INT bSacTimeAlignmentDynamicOutIn) {
-  return (assignParameterInRange(0, 1, bSacTimeAlignmentDynamicOutIn,
-                                 &hDelay->config.bSacTimeAlignmentDynamicOut));
-}
-
-FDK_SACENC_ERROR fdk_sacenc_delay_SetNSacTimeAlignment(
-    HANDLE_DELAY hDelay, const INT nSacTimeAlignmentIn) {
-  return (assignParameterInRange(-32768, 32767, nSacTimeAlignmentIn,
-                                 &hDelay->config.nSacTimeAlignment));
-}
-
-FDK_SACENC_ERROR fdk_sacenc_delay_SetMinimizeDelay(HANDLE_DELAY hDelay,
-                                                   const INT bMinimizeDelay) {
-  return (assignParameterInRange(0, 1, bMinimizeDelay,
-                                 &hDelay->config.bMinimizeDelay));
-}
-
-INT fdk_sacenc_delay_GetOutputAudioBufferDelay(HANDLE_DELAY hDelay) {
-  return (hDelay->nOutputAudioBuffer);
-}
-
-INT fdk_sacenc_delay_GetSurroundAnalysisBufferDelay(HANDLE_DELAY hDelay) {
-  return (hDelay->nSurroundAnalysisBuffer);
-}
-
-INT fdk_sacenc_delay_GetArbDmxAnalysisBufferDelay(HANDLE_DELAY hDelay) {
-  return (hDelay->nArbDmxAnalysisBuffer);
-}
-
-INT fdk_sacenc_delay_GetBitstreamFrameBufferSize(HANDLE_DELAY hDelay) {
-  return (hDelay->nBitstreamFrameBufferSize);
-}
-
-INT fdk_sacenc_delay_GetDmxAlignBufferDelay(HANDLE_DELAY hDelay) {
-  return (hDelay->nDmxAlignBuffer);
-}
-
-INT fdk_sacenc_delay_GetDiscardOutFrames(HANDLE_DELAY hDelay) {
-  return (hDelay->nDiscardOutFrames);
-}
-
-INT fdk_sacenc_delay_GetInfoDmxDelay(HANDLE_DELAY hDelay) {
-  return (hDelay->nInfoDmxDelay);
-}
-
-INT fdk_sacenc_delay_GetInfoCodecDelay(HANDLE_DELAY hDelay) {
-  return (hDelay->nInfoCodecDelay);
-}
-
-INT fdk_sacenc_delay_GetInfoDecoderDelay(HANDLE_DELAY hDelay) {
-  return (hDelay->nInfoDecoderDelay);
-}
--- a/libSACenc/src/sacenc_delay.h
+++ /dev/null
@@ -1,175 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround encoder library *************************
-
-   Author(s):   Christian Goettlinger
-
-   Description: Encoder Library Interface
-                delay management of the encoder
-
-*******************************************************************************/
-
-/**************************************************************************/ /**
-   \file
- ******************************************************************************/
-#ifndef SACENC_DELAY_H
-#define SACENC_DELAY_H
-
-/* Includes ******************************************************************/
-#include "sacenc_lib.h"
-#include "machine_type.h"
-#include "FDK_matrixCalloc.h"
-
-/* Defines *******************************************************************/
-#define MAX_DELAY_INPUT 1024
-#define MAX_DELAY_OUTPUT 4096
-/* bumped from 0 to 5. this should be equal or larger to the dualrate sbr
- * resampler filter length */
-#define MAX_DELAY_SURROUND_ANALYSIS 5
-#define MAX_BITSTREAM_DELAY 1
-
-/* Data Types ****************************************************************/
-typedef struct DELAY *HANDLE_DELAY;
-
-/* Constants *****************************************************************/
-
-/* Function / Class Declarations *********************************************/
-FDK_SACENC_ERROR fdk_sacenc_delay_Open(HANDLE_DELAY *phDelay);
-
-FDK_SACENC_ERROR fdk_sacenc_delay_Close(HANDLE_DELAY *phDelay);
-
-FDK_SACENC_ERROR fdk_sacenc_delay_Init(HANDLE_DELAY hDelay, const INT nQmfLen,
-                                       const INT nFrameLen,
-                                       const INT nCoreCoderDelay,
-                                       const INT nSacStreamMuxDelay);
-
-FDK_SACENC_ERROR fdk_sacenc_delay_SubCalulateBufferDelays(HANDLE_DELAY hDel);
-
-/* Set Expert Config Parameters */
-FDK_SACENC_ERROR fdk_sacenc_delay_SetDmxAlign(HANDLE_DELAY hDelay,
-                                              const INT bDmxAlignIn);
-
-FDK_SACENC_ERROR fdk_sacenc_delay_SetTimeDomDmx(HANDLE_DELAY hDelay,
-                                                const INT bTimeDomDmxIn);
-
-FDK_SACENC_ERROR fdk_sacenc_delay_SetSacTimeAlignmentDynamicOut(
-    HANDLE_DELAY hDelay, const INT bSacTimeAlignmentDynamicOutIn);
-
-FDK_SACENC_ERROR fdk_sacenc_delay_SetNSacTimeAlignment(
-    HANDLE_DELAY hDelay, const INT nSacTimeAlignmentIn);
-
-FDK_SACENC_ERROR fdk_sacenc_delay_SetMinimizeDelay(HANDLE_DELAY hDelay,
-                                                   const INT bMinimizeDelay);
-
-/* Get Internal Variables */
-INT fdk_sacenc_delay_GetOutputAudioBufferDelay(HANDLE_DELAY hDelay);
-
-INT fdk_sacenc_delay_GetSurroundAnalysisBufferDelay(HANDLE_DELAY hDelay);
-
-INT fdk_sacenc_delay_GetArbDmxAnalysisBufferDelay(HANDLE_DELAY hDelay);
-
-INT fdk_sacenc_delay_GetBitstreamFrameBufferSize(HANDLE_DELAY hDelay);
-
-INT fdk_sacenc_delay_GetDmxAlignBufferDelay(HANDLE_DELAY hDelay);
-
-INT fdk_sacenc_delay_GetDiscardOutFrames(HANDLE_DELAY hDelay);
-
-INT fdk_sacenc_delay_GetInfoDmxDelay(HANDLE_DELAY hDelay);
-
-INT fdk_sacenc_delay_GetInfoCodecDelay(HANDLE_DELAY hDelay);
-
-INT fdk_sacenc_delay_GetInfoDecoderDelay(HANDLE_DELAY hDelay);
-
-#endif /* SACENC_DELAY_H */
--- a/libSACenc/src/sacenc_dmx_tdom_enh.cpp
+++ /dev/null
@@ -1,639 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround encoder library *************************
-
-   Author(s):   M. Luis Valero
-
-   Description: Enhanced Time Domain Downmix
-
-*******************************************************************************/
-
-/* Includes ******************************************************************/
-#include "sacenc_dmx_tdom_enh.h"
-
-#include "FDK_matrixCalloc.h"
-#include "FDK_trigFcts.h"
-#include "fixpoint_math.h"
-
-/* Defines *******************************************************************/
-#define PI_FLT 3.1415926535897931f
-#define ALPHA_FLT 0.0001f
-
-#define PI_E (2)
-#define PI_M (FL2FXCONST_DBL(PI_FLT / (1 << PI_E)))
-
-#define ALPHA_E (13)
-#define ALPHA_M (FL2FXCONST_DBL(ALPHA_FLT * (1 << ALPHA_E)))
-
-enum { L = 0, R = 1 };
-
-/* Data Types ****************************************************************/
-typedef struct T_ENHANCED_TIME_DOMAIN_DMX {
-  int maxFramelength;
-
-  int framelength;
-
-  FIXP_DBL prev_gain_m[2];
-  INT prev_gain_e;
-  FIXP_DBL prev_H1_m[2];
-  INT prev_H1_e;
-
-  FIXP_DBL *sinusWindow_m;
-  SCHAR sinusWindow_e;
-
-  FIXP_DBL prev_Left_m;
-  INT prev_Left_e;
-  FIXP_DBL prev_Right_m;
-  INT prev_Right_e;
-  FIXP_DBL prev_XNrg_m;
-  INT prev_XNrg_e;
-
-  FIXP_DBL lin_bbCld_weight_m;
-  INT lin_bbCld_weight_e;
-  FIXP_DBL gain_weight_m[2];
-  INT gain_weight_e;
-
-} ENHANCED_TIME_DOMAIN_DMX;
-
-/* Constants *****************************************************************/
-
-/* Function / Class Declarations *********************************************/
-static void calculateRatio(const FIXP_DBL sqrt_linCld_m,
-                           const INT sqrt_linCld_e, const FIXP_DBL lin_Cld_m,
-                           const INT lin_Cld_e, const FIXP_DBL Icc_m,
-                           const INT Icc_e, FIXP_DBL G_m[2], INT *G_e);
-
-static void calculateDmxGains(const FIXP_DBL lin_Cld_m, const INT lin_Cld_e,
-                              const FIXP_DBL lin_Cld2_m, const INT lin_Cld2_e,
-                              const FIXP_DBL Icc_m, const INT Icc_e,
-                              const FIXP_DBL G_m[2], const INT G_e,
-                              FIXP_DBL H1_m[2], INT *pH1_e);
-
-/* Function / Class Definition ***********************************************/
-static FIXP_DBL invSqrtNorm2(const FIXP_DBL op_m, const INT op_e,
-                             INT *const result_e) {
-  FIXP_DBL src_m = op_m;
-  int src_e = op_e;
-
-  if (src_e & 1) {
-    src_m >>= 1;
-    src_e += 1;
-  }
-
-  src_m = invSqrtNorm2(src_m, result_e);
-  *result_e = (*result_e) - (src_e >> 1);
-
-  return src_m;
-}
-
-static FIXP_DBL sqrtFixp(const FIXP_DBL op_m, const INT op_e,
-                         INT *const result_e) {
-  FIXP_DBL src_m = op_m;
-  int src_e = op_e;
-
-  if (src_e & 1) {
-    src_m >>= 1;
-    src_e += 1;
-  }
-
-  *result_e = (src_e >> 1);
-  return sqrtFixp(src_m);
-}
-
-static FIXP_DBL fixpAdd(const FIXP_DBL src1_m, const INT src1_e,
-                        const FIXP_DBL src2_m, const INT src2_e,
-                        INT *const dst_e) {
-  FIXP_DBL dst_m;
-
-  if (src1_m == FL2FXCONST_DBL(0.f)) {
-    *dst_e = src2_e;
-    dst_m = src2_m;
-  } else if (src2_m == FL2FXCONST_DBL(0.f)) {
-    *dst_e = src1_e;
-    dst_m = src1_m;
-  } else {
-    *dst_e = fixMax(src1_e, src2_e) + 1;
-    dst_m =
-        scaleValue(src1_m, fixMax((src1_e - (*dst_e)), -(DFRACT_BITS - 1))) +
-        scaleValue(src2_m, fixMax((src2_e - (*dst_e)), -(DFRACT_BITS - 1)));
-  }
-  return dst_m;
-}
-
-/**
- * \brief  Sum up fixpoint values with best possible accuracy.
- *
- * \param value1        First input value.
- * \param q1            Scaling factor of first input value.
- * \param pValue2       Pointer to second input value, will be modified on
- * return.
- * \param pQ2           Pointer to second scaling factor, will be modified on
- * return.
- *
- * \return    void
- */
-static void fixpAddNorm(const FIXP_DBL value1, const INT q1,
-                        FIXP_DBL *const pValue2, INT *const pQ2) {
-  const int headroom1 = fNormz(fixp_abs(value1)) - 1;
-  const int headroom2 = fNormz(fixp_abs(*pValue2)) - 1;
-  int resultScale = fixMax(q1 - headroom1, (*pQ2) - headroom2);
-
-  if ((value1 != FL2FXCONST_DBL(0.f)) && (*pValue2 != FL2FXCONST_DBL(0.f))) {
-    resultScale++;
-  }
-
-  *pValue2 =
-      scaleValue(value1, q1 - resultScale) +
-      scaleValue(*pValue2, fixMax(-(DFRACT_BITS - 1), ((*pQ2) - resultScale)));
-  *pQ2 = (*pValue2 != (FIXP_DBL)0) ? resultScale : DFRACT_BITS - 1;
-}
-
-FDK_SACENC_ERROR fdk_sacenc_open_enhancedTimeDomainDmx(
-    HANDLE_ENHANCED_TIME_DOMAIN_DMX *phEnhancedTimeDmx, const INT framelength) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-  HANDLE_ENHANCED_TIME_DOMAIN_DMX hEnhancedTimeDmx = NULL;
-
-  if (NULL == phEnhancedTimeDmx) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    FDK_ALLOCATE_MEMORY_1D(hEnhancedTimeDmx, 1, ENHANCED_TIME_DOMAIN_DMX);
-    FDK_ALLOCATE_MEMORY_1D(hEnhancedTimeDmx->sinusWindow_m, 1 + framelength,
-                           FIXP_DBL);
-    hEnhancedTimeDmx->maxFramelength = framelength;
-    *phEnhancedTimeDmx = hEnhancedTimeDmx;
-  }
-  return error;
-
-bail:
-  fdk_sacenc_close_enhancedTimeDomainDmx(&hEnhancedTimeDmx);
-  return ((SACENC_OK == error) ? SACENC_MEMORY_ERROR : error);
-}
-
-FDK_SACENC_ERROR fdk_sacenc_init_enhancedTimeDomainDmx(
-    HANDLE_ENHANCED_TIME_DOMAIN_DMX hEnhancedTimeDmx,
-    const FIXP_DBL *const pInputGain_m, const INT inputGain_e,
-    const FIXP_DBL outputGain_m, const INT outputGain_e,
-    const INT framelength) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if (hEnhancedTimeDmx == NULL) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    int smp;
-    if (framelength > hEnhancedTimeDmx->maxFramelength) {
-      error = SACENC_INIT_ERROR;
-      goto bail;
-    }
-
-    hEnhancedTimeDmx->framelength = framelength;
-
-    INT deltax_e;
-    FIXP_DBL deltax_m;
-
-    deltax_m = fDivNormHighPrec(
-        PI_M, (FIXP_DBL)(2 * hEnhancedTimeDmx->framelength), &deltax_e);
-    deltax_m = scaleValue(deltax_m, PI_E + deltax_e - (DFRACT_BITS - 1) - 1);
-    deltax_e = 1;
-
-    for (smp = 0; smp < hEnhancedTimeDmx->framelength + 1; smp++) {
-      hEnhancedTimeDmx->sinusWindow_m[smp] =
-          fMult(ALPHA_M, fPow2(fixp_sin(smp * deltax_m, deltax_e)));
-    }
-    hEnhancedTimeDmx->sinusWindow_e = -ALPHA_E;
-
-    hEnhancedTimeDmx->prev_Left_m = hEnhancedTimeDmx->prev_Right_m =
-        hEnhancedTimeDmx->prev_XNrg_m = FL2FXCONST_DBL(0.f);
-    hEnhancedTimeDmx->prev_Left_e = hEnhancedTimeDmx->prev_Right_e =
-        hEnhancedTimeDmx->prev_XNrg_e = DFRACT_BITS - 1;
-
-    hEnhancedTimeDmx->lin_bbCld_weight_m =
-        fDivNormHighPrec(fPow2(pInputGain_m[L]), fPow2(pInputGain_m[R]),
-                         &hEnhancedTimeDmx->lin_bbCld_weight_e);
-
-    hEnhancedTimeDmx->gain_weight_m[L] = fMult(pInputGain_m[L], outputGain_m);
-    hEnhancedTimeDmx->gain_weight_m[R] = fMult(pInputGain_m[R], outputGain_m);
-    hEnhancedTimeDmx->gain_weight_e =
-        -fNorm(fixMax(hEnhancedTimeDmx->gain_weight_m[L],
-                      hEnhancedTimeDmx->gain_weight_m[R]));
-
-    hEnhancedTimeDmx->gain_weight_m[L] = scaleValue(
-        hEnhancedTimeDmx->gain_weight_m[L], -hEnhancedTimeDmx->gain_weight_e);
-    hEnhancedTimeDmx->gain_weight_m[R] = scaleValue(
-        hEnhancedTimeDmx->gain_weight_m[R], -hEnhancedTimeDmx->gain_weight_e);
-    hEnhancedTimeDmx->gain_weight_e += inputGain_e + outputGain_e;
-
-    hEnhancedTimeDmx->prev_gain_m[L] = hEnhancedTimeDmx->gain_weight_m[L] >> 1;
-    hEnhancedTimeDmx->prev_gain_m[R] = hEnhancedTimeDmx->gain_weight_m[R] >> 1;
-    hEnhancedTimeDmx->prev_gain_e = hEnhancedTimeDmx->gain_weight_e + 1;
-
-    hEnhancedTimeDmx->prev_H1_m[L] =
-        scaleValue(hEnhancedTimeDmx->gain_weight_m[L], -4);
-    hEnhancedTimeDmx->prev_H1_m[R] =
-        scaleValue(hEnhancedTimeDmx->gain_weight_m[R], -4);
-    hEnhancedTimeDmx->prev_H1_e = 2 + 2 + hEnhancedTimeDmx->gain_weight_e;
-  }
-bail:
-  return error;
-}
-
-FDK_SACENC_ERROR fdk_sacenc_apply_enhancedTimeDomainDmx(
-    HANDLE_ENHANCED_TIME_DOMAIN_DMX hEnhancedTimeDmx,
-    const INT_PCM *const *const inputTime, INT_PCM *const outputTimeDmx,
-    const INT InputDelay) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if ((NULL == hEnhancedTimeDmx) || (NULL == inputTime) ||
-      (NULL == inputTime[L]) || (NULL == inputTime[R]) ||
-      (NULL == outputTimeDmx)) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    int smp;
-    FIXP_DBL lin_bbCld_m, lin_Cld_m, bbCorr_m, sqrt_linCld_m, G_m[2], H1_m[2],
-        gainLeft_m, gainRight_m;
-    FIXP_DBL bbNrgLeft_m, bbNrgRight_m, bbXNrg_m, nrgLeft_m, nrgRight_m, nrgX_m;
-    INT lin_bbCld_e, lin_Cld_e, bbCorr_e, sqrt_linCld_e, G_e, H1_e;
-    INT bbNrgLeft_e, bbNrgRight_e, bbXNrg_e, nrgLeft_e, nrgRight_e, nrgX_e;
-
-    /* Increase energy time resolution with shorter processing blocks. 128 is an
-     * empiric value. */
-    const int granuleLength = fixMin(128, hEnhancedTimeDmx->framelength);
-    int granuleShift =
-        (granuleLength > 1)
-            ? ((DFRACT_BITS - 1) - fNorm((FIXP_DBL)(granuleLength - 1)))
-            : 0;
-    granuleShift = fixMax(
-        3, granuleShift +
-               1); /* one bit more headroom for worst case accumulation */
-
-    smp = 0;
-
-    /* Prevent division by zero. */
-    bbNrgLeft_m = bbNrgRight_m = bbXNrg_m = (FIXP_DBL)(1);
-    bbNrgLeft_e = bbNrgRight_e = bbXNrg_e = 0;
-
-    do {
-      const int offset = smp;
-      FIXP_DBL partialL, partialR, partialX;
-      partialL = partialR = partialX = FL2FXCONST_DBL(0.f);
-
-      int in_margin = FDKmin(
-          getScalefactorPCM(
-              &inputTime[L][offset],
-              fixMin(offset + granuleLength, hEnhancedTimeDmx->framelength) -
-                  offset,
-              1),
-          getScalefactorPCM(
-              &inputTime[R][offset],
-              fixMin(offset + granuleLength, hEnhancedTimeDmx->framelength) -
-                  offset,
-              1));
-
-      /* partial energy */
-      for (smp = offset;
-           smp < fixMin(offset + granuleLength, hEnhancedTimeDmx->framelength);
-           smp++) {
-        FIXP_PCM inputL =
-            scaleValue((FIXP_PCM)inputTime[L][smp], in_margin - 1);
-        FIXP_PCM inputR =
-            scaleValue((FIXP_PCM)inputTime[R][smp], in_margin - 1);
-
-        partialL += fPow2Div2(inputL) >> (granuleShift - 3);
-        partialR += fPow2Div2(inputR) >> (granuleShift - 3);
-        partialX += fMultDiv2(inputL, inputR) >> (granuleShift - 3);
-      }
-
-      fixpAddNorm(partialL, granuleShift - 2 * in_margin, &bbNrgLeft_m,
-                  &bbNrgLeft_e);
-      fixpAddNorm(partialR, granuleShift - 2 * in_margin, &bbNrgRight_m,
-                  &bbNrgRight_e);
-      fixpAddNorm(partialX, granuleShift - 2 * in_margin, &bbXNrg_m, &bbXNrg_e);
-    } while (smp < hEnhancedTimeDmx->framelength);
-
-    nrgLeft_m =
-        fixpAdd(hEnhancedTimeDmx->prev_Left_m, hEnhancedTimeDmx->prev_Left_e,
-                bbNrgLeft_m, bbNrgLeft_e, &nrgLeft_e);
-    nrgRight_m =
-        fixpAdd(hEnhancedTimeDmx->prev_Right_m, hEnhancedTimeDmx->prev_Right_e,
-                bbNrgRight_m, bbNrgRight_e, &nrgRight_e);
-    nrgX_m =
-        fixpAdd(hEnhancedTimeDmx->prev_XNrg_m, hEnhancedTimeDmx->prev_XNrg_e,
-                bbXNrg_m, bbXNrg_e, &nrgX_e);
-
-    lin_bbCld_m = fMult(hEnhancedTimeDmx->lin_bbCld_weight_m,
-                        fDivNorm(nrgLeft_m, nrgRight_m, &lin_bbCld_e));
-    lin_bbCld_e +=
-        hEnhancedTimeDmx->lin_bbCld_weight_e + nrgLeft_e - nrgRight_e;
-
-    bbCorr_m = fMult(nrgX_m, invSqrtNorm2(fMult(nrgLeft_m, nrgRight_m),
-                                          nrgLeft_e + nrgRight_e, &bbCorr_e));
-    bbCorr_e += nrgX_e;
-
-    hEnhancedTimeDmx->prev_Left_m = bbNrgLeft_m;
-    hEnhancedTimeDmx->prev_Left_e = bbNrgLeft_e;
-    hEnhancedTimeDmx->prev_Right_m = bbNrgRight_m;
-    hEnhancedTimeDmx->prev_Right_e = bbNrgRight_e;
-    hEnhancedTimeDmx->prev_XNrg_m = bbXNrg_m;
-    hEnhancedTimeDmx->prev_XNrg_e = bbXNrg_e;
-
-    /*
-       bbCld    = 10.f*log10(lin_bbCld)
-
-       lin_Cld  = pow(10,bbCld/20)
-                = pow(10,10.f*log10(lin_bbCld)/20.f)
-                = sqrt(lin_bbCld)
-
-       lin_Cld2 = lin_Cld*lin_Cld
-                = sqrt(lin_bbCld)*sqrt(lin_bbCld)
-                = lin_bbCld
-     */
-    lin_Cld_m = sqrtFixp(lin_bbCld_m, lin_bbCld_e, &lin_Cld_e);
-    sqrt_linCld_m = sqrtFixp(lin_Cld_m, lin_Cld_e, &sqrt_linCld_e);
-
-    /*calculate how much right and how much left signal, to avoid signal
-     * cancellations*/
-    calculateRatio(sqrt_linCld_m, sqrt_linCld_e, lin_Cld_m, lin_Cld_e, bbCorr_m,
-                   bbCorr_e, G_m, &G_e);
-
-    /*calculate downmix gains*/
-    calculateDmxGains(lin_Cld_m, lin_Cld_e, lin_bbCld_m, lin_bbCld_e, bbCorr_m,
-                      bbCorr_e, G_m, G_e, H1_m, &H1_e);
-
-    /*adapt output gains*/
-    H1_m[L] = fMult(H1_m[L], hEnhancedTimeDmx->gain_weight_m[L]);
-    H1_m[R] = fMult(H1_m[R], hEnhancedTimeDmx->gain_weight_m[R]);
-    H1_e += hEnhancedTimeDmx->gain_weight_e;
-
-    gainLeft_m = hEnhancedTimeDmx->prev_gain_m[L];
-    gainRight_m = hEnhancedTimeDmx->prev_gain_m[R];
-
-    INT intermediate_gain_e =
-        +hEnhancedTimeDmx->sinusWindow_e + H1_e - hEnhancedTimeDmx->prev_gain_e;
-
-    for (smp = 0; smp < hEnhancedTimeDmx->framelength; smp++) {
-      const INT N = hEnhancedTimeDmx->framelength;
-      FIXP_DBL intermediate_gainLeft_m, intermediate_gainRight_m, tmp;
-
-      intermediate_gainLeft_m =
-          scaleValue((fMult(hEnhancedTimeDmx->sinusWindow_m[smp], H1_m[L]) +
-                      fMult(hEnhancedTimeDmx->sinusWindow_m[N - smp],
-                            hEnhancedTimeDmx->prev_H1_m[L])),
-                     intermediate_gain_e);
-      intermediate_gainRight_m =
-          scaleValue((fMult(hEnhancedTimeDmx->sinusWindow_m[smp], H1_m[R]) +
-                      fMult(hEnhancedTimeDmx->sinusWindow_m[N - smp],
-                            hEnhancedTimeDmx->prev_H1_m[R])),
-                     intermediate_gain_e);
-
-      gainLeft_m = intermediate_gainLeft_m +
-                   fMult(FL2FXCONST_DBL(1.f - ALPHA_FLT), gainLeft_m);
-      gainRight_m = intermediate_gainRight_m +
-                    fMult(FL2FXCONST_DBL(1.f - ALPHA_FLT), gainRight_m);
-
-      tmp = fMultDiv2(gainLeft_m, (FIXP_PCM)inputTime[L][smp + InputDelay]) +
-            fMultDiv2(gainRight_m, (FIXP_PCM)inputTime[R][smp + InputDelay]);
-      outputTimeDmx[smp] = (INT_PCM)SATURATE_SHIFT(
-          tmp,
-          -(hEnhancedTimeDmx->prev_gain_e + 1 - (DFRACT_BITS - SAMPLE_BITS)),
-          SAMPLE_BITS);
-    }
-
-    hEnhancedTimeDmx->prev_gain_m[L] = gainLeft_m;
-    hEnhancedTimeDmx->prev_gain_m[R] = gainRight_m;
-
-    hEnhancedTimeDmx->prev_H1_m[L] = H1_m[L];
-    hEnhancedTimeDmx->prev_H1_m[R] = H1_m[R];
-    hEnhancedTimeDmx->prev_H1_e = H1_e;
-  }
-
-  return error;
-}
-
-static void calculateRatio(const FIXP_DBL sqrt_linCld_m,
-                           const INT sqrt_linCld_e, const FIXP_DBL lin_Cld_m,
-                           const INT lin_Cld_e, const FIXP_DBL Icc_m,
-                           const INT Icc_e, FIXP_DBL G_m[2], INT *G_e) {
-#define G_SCALE_FACTOR (2)
-
-  if (Icc_m >= FL2FXCONST_DBL(0.f)) {
-    G_m[0] = G_m[1] = FL2FXCONST_DBL(1.f / (float)(1 << G_SCALE_FACTOR));
-    G_e[0] = G_SCALE_FACTOR;
-  } else {
-    const FIXP_DBL max_gain_factor =
-        FL2FXCONST_DBL(2.f / (float)(1 << G_SCALE_FACTOR));
-    FIXP_DBL tmp1_m, tmp2_m, numerator_m, denominator_m, r_m, r4_m, q;
-    INT tmp1_e, tmp2_e, numerator_e, denominator_e, r_e, r4_e;
-
-    /*  r   = (lin_Cld + 1 + 2*Icc*sqrt_linCld) / (lin_Cld + 1 -
-     * 2*Icc*sqrt_linCld) = (tmp1 + tmp2) / (tmp1 - tmp2)
-     */
-    tmp1_m =
-        fixpAdd(lin_Cld_m, lin_Cld_e, FL2FXCONST_DBL(1.f / 2.f), 1, &tmp1_e);
-
-    tmp2_m = fMult(Icc_m, sqrt_linCld_m);
-    tmp2_e = 1 + Icc_e + sqrt_linCld_e;
-    numerator_m = fixpAdd(tmp1_m, tmp1_e, tmp2_m, tmp2_e, &numerator_e);
-    denominator_m = fixpAdd(tmp1_m, tmp1_e, -tmp2_m, tmp2_e, &denominator_e);
-
-    if ((numerator_m > FL2FXCONST_DBL(0.f)) &&
-        (denominator_m > FL2FXCONST_DBL(0.f))) {
-      r_m = fDivNorm(numerator_m, denominator_m, &r_e);
-      r_e += numerator_e - denominator_e;
-
-      /* r_4 = sqrt( sqrt( r ) ) */
-      r4_m = sqrtFixp(r_m, r_e, &r4_e);
-      r4_m = sqrtFixp(r4_m, r4_e, &r4_e);
-
-      r4_e -= G_SCALE_FACTOR;
-
-      /* q = min(r4_m, max_gain_factor) */
-      q = ((r4_e >= 0) && (r4_m >= (max_gain_factor >> r4_e)))
-              ? max_gain_factor
-              : scaleValue(r4_m, r4_e);
-    } else {
-      q = FL2FXCONST_DBL(0.f);
-    }
-
-    G_m[0] = max_gain_factor - q;
-    G_m[1] = q;
-
-    *G_e = G_SCALE_FACTOR;
-  }
-}
-
-static void calculateDmxGains(const FIXP_DBL lin_Cld_m, const INT lin_Cld_e,
-                              const FIXP_DBL lin_Cld2_m, const INT lin_Cld2_e,
-                              const FIXP_DBL Icc_m, const INT Icc_e,
-                              const FIXP_DBL G_m[2], const INT G_e,
-                              FIXP_DBL H1_m[2], INT *pH1_e) {
-#define H1_SCALE_FACTOR (2)
-  const FIXP_DBL max_gain_factor =
-      FL2FXCONST_DBL(2.f / (float)(1 << H1_SCALE_FACTOR));
-
-  FIXP_DBL nrgRight_m, nrgLeft_m, crossNrg_m, inv_weight_num_m,
-      inv_weight_denom_m, inverse_weight_m, inverse_weight_limited;
-  INT nrgRight_e, nrgLeft_e, crossNrg_e, inv_weight_num_e, inv_weight_denom_e,
-      inverse_weight_e;
-
-  /* nrgRight = sqrt(1/(lin_Cld2 + 1) */
-  nrgRight_m = fixpAdd(lin_Cld2_m, lin_Cld2_e, FL2FXCONST_DBL(1.f / 2.f), 1,
-                       &nrgRight_e);
-  nrgRight_m = invSqrtNorm2(nrgRight_m, nrgRight_e, &nrgRight_e);
-
-  /* nrgLeft = lin_Cld * nrgRight */
-  nrgLeft_m = fMult(lin_Cld_m, nrgRight_m);
-  nrgLeft_e = lin_Cld_e + nrgRight_e;
-
-  /* crossNrg = sqrt(nrgLeft*nrgRight) */
-  crossNrg_m = sqrtFixp(fMult(nrgLeft_m, nrgRight_m), nrgLeft_e + nrgRight_e,
-                        &crossNrg_e);
-
-  /* inverse_weight = sqrt((nrgLeft + nrgRight) / ( (G[0]*G[0]*nrgLeft) +
-   * (G[1]*G[1]*nrgRight) + 2*G[0]*G[1]*Icc*crossNrg)) = sqrt(inv_weight_num /
-   * inv_weight_denom)
-   */
-  inv_weight_num_m =
-      fixpAdd(nrgRight_m, nrgRight_e, nrgLeft_m, nrgLeft_e, &inv_weight_num_e);
-
-  inv_weight_denom_m =
-      fixpAdd(fMult(fPow2(G_m[0]), nrgLeft_m), 2 * G_e + nrgLeft_e,
-              fMult(fPow2(G_m[1]), nrgRight_m), 2 * G_e + nrgRight_e,
-              &inv_weight_denom_e);
-
-  inv_weight_denom_m =
-      fixpAdd(fMult(fMult(fMult(G_m[0], G_m[1]), crossNrg_m), Icc_m),
-              1 + 2 * G_e + crossNrg_e + Icc_e, inv_weight_denom_m,
-              inv_weight_denom_e, &inv_weight_denom_e);
-
-  if (inv_weight_denom_m > FL2FXCONST_DBL(0.f)) {
-    inverse_weight_m =
-        fDivNorm(inv_weight_num_m, inv_weight_denom_m, &inverse_weight_e);
-    inverse_weight_m =
-        sqrtFixp(inverse_weight_m,
-                 inverse_weight_e + inv_weight_num_e - inv_weight_denom_e,
-                 &inverse_weight_e);
-    inverse_weight_e -= H1_SCALE_FACTOR;
-
-    /* inverse_weight_limited = min(max_gain_factor, inverse_weight) */
-    inverse_weight_limited =
-        ((inverse_weight_e >= 0) &&
-         (inverse_weight_m >= (max_gain_factor >> inverse_weight_e)))
-            ? max_gain_factor
-            : scaleValue(inverse_weight_m, inverse_weight_e);
-  } else {
-    inverse_weight_limited = max_gain_factor;
-  }
-
-  H1_m[0] = fMult(G_m[0], inverse_weight_limited);
-  H1_m[1] = fMult(G_m[1], inverse_weight_limited);
-
-  *pH1_e = G_e + H1_SCALE_FACTOR;
-}
-
-FDK_SACENC_ERROR fdk_sacenc_close_enhancedTimeDomainDmx(
-    HANDLE_ENHANCED_TIME_DOMAIN_DMX *phEnhancedTimeDmx) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if (phEnhancedTimeDmx == NULL) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    if (*phEnhancedTimeDmx != NULL) {
-      if ((*phEnhancedTimeDmx)->sinusWindow_m != NULL) {
-        FDK_FREE_MEMORY_1D((*phEnhancedTimeDmx)->sinusWindow_m);
-      }
-      FDK_FREE_MEMORY_1D(*phEnhancedTimeDmx);
-    }
-  }
-  return error;
-}
--- a/libSACenc/src/sacenc_dmx_tdom_enh.h
+++ /dev/null
@@ -1,134 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround encoder library *************************
-
-   Author(s):   M. Luis Valero
-
-   Description: Enhanced Time Domain Downmix
-
-*******************************************************************************/
-
-#ifndef SACENC_DMX_TDOM_ENH_H
-#define SACENC_DMX_TDOM_ENH_H
-
-/* Includes ******************************************************************/
-#include "sacenc_lib.h"
-#include "common_fix.h"
-
-/* Defines *******************************************************************/
-
-/* Data Types ****************************************************************/
-typedef struct T_ENHANCED_TIME_DOMAIN_DMX *HANDLE_ENHANCED_TIME_DOMAIN_DMX;
-
-/* Constants *****************************************************************/
-
-/* Function / Class Declarations *********************************************/
-FDK_SACENC_ERROR fdk_sacenc_open_enhancedTimeDomainDmx(
-    HANDLE_ENHANCED_TIME_DOMAIN_DMX *hEnhancedTimeDmx, const INT framelength);
-
-FDK_SACENC_ERROR fdk_sacenc_init_enhancedTimeDomainDmx(
-    HANDLE_ENHANCED_TIME_DOMAIN_DMX hEnhancedTimeDmx,
-    const FIXP_DBL *const pInputGain_m, const INT inputGain_e,
-    const FIXP_DBL outputGain_m, const INT outputGain_e, const INT framelength);
-
-FDK_SACENC_ERROR fdk_sacenc_apply_enhancedTimeDomainDmx(
-    HANDLE_ENHANCED_TIME_DOMAIN_DMX hEnhancedTimeDmx,
-    const INT_PCM *const *const inputTime, INT_PCM *const outputTimeDmx,
-    const INT InputDelay);
-
-FDK_SACENC_ERROR fdk_sacenc_close_enhancedTimeDomainDmx(
-    HANDLE_ENHANCED_TIME_DOMAIN_DMX *hEnhancedTimeDmx);
-
-#endif /* SACENC_DMX_TDOM_ENH_H */
--- a/libSACenc/src/sacenc_filter.cpp
+++ /dev/null
@@ -1,207 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround encoder library *************************
-
-   Author(s):   M. Multrus
-
-   Description: Encoder Library
-                Filter functions
-
-*******************************************************************************/
-
-/* Includes ******************************************************************/
-#include "sacenc_filter.h"
-
-/* Defines *******************************************************************/
-
-/* Data Types ****************************************************************/
-typedef struct T_DC_FILTER {
-  FIXP_DBL c__FDK;
-  FIXP_DBL state__FDK;
-
-} DC_FILTER;
-
-/* Constants *****************************************************************/
-
-/* Function / Class Declarations *********************************************/
-
-/* Function / Class Definition ***********************************************/
-FDK_SACENC_ERROR fdk_sacenc_createDCFilter(HANDLE_DC_FILTER *hDCFilter) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if (NULL == hDCFilter) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    FDK_ALLOCATE_MEMORY_1D(*hDCFilter, 1, DC_FILTER);
-  }
-  return error;
-
-bail:
-  fdk_sacenc_destroyDCFilter(hDCFilter);
-  return ((SACENC_OK == error) ? SACENC_MEMORY_ERROR : error);
-}
-
-FDK_SACENC_ERROR fdk_sacenc_initDCFilter(HANDLE_DC_FILTER hDCFilter,
-                                         const UINT sampleRate) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  FIXP_DBL expC;
-  int s;
-
-  /* Conversion for use of CalcInvLdData: e^x = 2^(x*log10(e)/log10(2) =
-     CalcInvLdData(x*log10(e)/log10(2)/64.0) 1.44269504089 = log10(e)/log10(2)
-     0.5           = scale constant value with 1 Bits
-  */
-  expC = fDivNormHighPrec((FIXP_DBL)20, (FIXP_DBL)sampleRate, &s);
-  expC = fMultDiv2(FL2FXCONST_DBL(-1.44269504089 * 0.5), expC) >>
-         (LD_DATA_SHIFT - 1 - 1);
-
-  if (s < 0)
-    expC = expC >> (-s);
-  else
-    expC = expC << (s);
-
-  expC = CalcInvLdData(expC);
-
-  hDCFilter->c__FDK = expC;
-  hDCFilter->state__FDK = FL2FXCONST_DBL(0.0f);
-
-  return error;
-}
-
-FDK_SACENC_ERROR fdk_sacenc_destroyDCFilter(HANDLE_DC_FILTER *hDCFilter) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if ((hDCFilter != NULL) && (*hDCFilter != NULL)) {
-    FDKfree(*hDCFilter);
-
-    *hDCFilter = NULL;
-  }
-
-  return error;
-}
-
-FDK_SACENC_ERROR fdk_sacenc_applyDCFilter(HANDLE_DC_FILTER hDCFilter,
-                                          const INT_PCM *const signalIn,
-                                          INT_PCM *const signalOut,
-                                          const INT signalLength) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if ((hDCFilter == NULL) || (signalIn == NULL) || (signalOut == NULL)) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    const INT_PCM *const x = signalIn;
-    INT_PCM *const y = signalOut;
-    const FIXP_DBL c = hDCFilter->c__FDK;
-    FIXP_DBL *const state = &hDCFilter->state__FDK;
-    int i;
-    FIXP_DBL x0, x1, y1;
-
-    x1 = x0 = FX_PCM2FX_DBL(x[0]) >> DC_FILTER_SF;
-    y1 = x0 + (*state);
-
-    for (i = 1; i < signalLength; i++) {
-      x0 = FX_PCM2FX_DBL(x[i]) >> DC_FILTER_SF;
-      y[i - 1] = FX_DBL2FX_PCM(y1);
-      y1 = x0 - x1 + fMult(c, y1);
-      x1 = x0;
-    }
-
-    *state = fMult(c, y1) - x1;
-    y[i - 1] = FX_DBL2FX_PCM(y1);
-  }
-
-  return error;
-}
--- a/libSACenc/src/sacenc_filter.h
+++ /dev/null
@@ -1,133 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround encoder library *************************
-
-   Author(s):   M. Multrus
-
-   Description: Encoder Library Interface
-                Filter functions
-
-*******************************************************************************/
-
-#ifndef SACENC_FILTER_H
-#define SACENC_FILTER_H
-
-/* Includes ******************************************************************/
-#include "common_fix.h"
-#include "sacenc_lib.h"
-#include "FDK_matrixCalloc.h"
-
-/* Defines *******************************************************************/
-#define DC_FILTER_SF 1
-
-/* Data Types ****************************************************************/
-typedef struct T_DC_FILTER *HANDLE_DC_FILTER;
-
-/* Constants *****************************************************************/
-
-/* Function / Class Declarations *********************************************/
-FDK_SACENC_ERROR fdk_sacenc_createDCFilter(HANDLE_DC_FILTER *hDCFilter);
-
-FDK_SACENC_ERROR fdk_sacenc_initDCFilter(HANDLE_DC_FILTER hDCFilter,
-                                         const UINT sampleRate);
-
-FDK_SACENC_ERROR fdk_sacenc_destroyDCFilter(HANDLE_DC_FILTER *hDCFilter);
-
-FDK_SACENC_ERROR fdk_sacenc_applyDCFilter(HANDLE_DC_FILTER hDCFilter,
-                                          const INT_PCM *const signalIn,
-                                          INT_PCM *const signalOut,
-                                          const INT signalLength);
-
-#endif /* SACENC_FILTER_H */
--- a/libSACenc/src/sacenc_framewindowing.cpp
+++ /dev/null
@@ -1,568 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround encoder library *************************
-
-   Author(s):   Max Neuendorf
-
-   Description: Encoder Library Interface
-                Get windows for framing
-
-*******************************************************************************/
-
-/**************************************************************************/ /**
-   \file
-   Description of file contents
- ******************************************************************************/
-
-/* Includes ******************************************************************/
-#include "sacenc_framewindowing.h"
-#include "sacenc_vectorfunctions.h"
-
-/* Defines *******************************************************************/
-
-/* Data Types ****************************************************************/
-typedef struct T_FRAMEWINDOW {
-  INT nTimeSlotsMax;
-  INT bFrameKeep;
-  INT startSlope;
-  INT stopSlope;
-  INT startRect;
-  INT stopRect;
-
-  INT taperAnaLen;
-  INT taperSynLen;
-  FIXP_WIN pTaperAna__FDK[MAX_TIME_SLOTS];
-  FIXP_WIN pTaperSyn__FDK[MAX_TIME_SLOTS];
-
-} FRAMEWINDOW;
-
-typedef enum {
-  FIX_INVALID = -1,
-  FIX_RECT_SMOOTH = 0,
-  FIX_SMOOTH_RECT = 1,
-  FIX_LARGE_SMOOTH = 2,
-  FIX_RECT_TRIANG = 3
-
-} FIX_TYPE;
-
-typedef enum {
-  VAR_INVALID = -1,
-  VAR_HOLD = 0,
-  VAR_ISOLATE = 1
-
-} VAR_TYPE;
-
-/* Constants *****************************************************************/
-
-/* Function / Class Declarations *********************************************/
-
-/* Function / Class Definition ***********************************************/
-static void calcTaperWin(FIXP_WIN *pTaperWin, INT timeSlots) {
-  FIXP_DBL x;
-  int i, scale;
-
-  for (i = 0; i < timeSlots; i++) {
-    x = fDivNormHighPrec((FIXP_DBL)i, (FIXP_DBL)timeSlots, &scale);
-
-    if (scale < 0) {
-      pTaperWin[i] = FX_DBL2FX_WIN(x >> (-scale));
-    } else {
-      pTaperWin[i] = FX_DBL2FX_WIN(x << (scale));
-    }
-  }
-  pTaperWin[timeSlots] = FX_DBL2FX_WIN((FIXP_DBL)MAXVAL_DBL);
-}
-
-FDK_SACENC_ERROR fdk_sacenc_frameWindow_Create(
-    HANDLE_FRAMEWINDOW *phFrameWindow) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if (NULL == phFrameWindow) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    /* Memory Allocation */
-    FDK_ALLOCATE_MEMORY_1D(*phFrameWindow, 1, FRAMEWINDOW);
-  }
-  return error;
-
-bail:
-  fdk_sacenc_frameWindow_Destroy(phFrameWindow);
-  return ((SACENC_OK == error) ? SACENC_MEMORY_ERROR : error);
-}
-
-FDK_SACENC_ERROR fdk_sacenc_frameWindow_Init(
-    HANDLE_FRAMEWINDOW hFrameWindow,
-    const FRAMEWINDOW_CONFIG *const pFrameWindowConfig) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if ((hFrameWindow == NULL) || (pFrameWindowConfig == NULL)) {
-    error = SACENC_INVALID_HANDLE;
-  } else if (pFrameWindowConfig->nTimeSlotsMax < 0) {
-    error = SACENC_INIT_ERROR;
-  } else {
-    int ts;
-    hFrameWindow->bFrameKeep = pFrameWindowConfig->bFrameKeep;
-    hFrameWindow->nTimeSlotsMax = pFrameWindowConfig->nTimeSlotsMax;
-
-    FIXP_WIN winMaxVal = FX_DBL2FX_WIN((FIXP_DBL)MAXVAL_DBL);
-    int timeSlots = pFrameWindowConfig->nTimeSlotsMax;
-    {
-      hFrameWindow->startSlope = 0;
-      hFrameWindow->stopSlope = ((3 * timeSlots) >> 1) - 1;
-      hFrameWindow->startRect = timeSlots >> 1;
-      hFrameWindow->stopRect = timeSlots;
-      calcTaperWin(hFrameWindow->pTaperSyn__FDK, timeSlots >> 1);
-      hFrameWindow->taperSynLen = timeSlots >> 1;
-    }
-
-    /* Calculate Taper for non-rect. ana. windows */
-    hFrameWindow->taperAnaLen =
-        hFrameWindow->startRect - hFrameWindow->startSlope;
-    for (ts = 0; ts < hFrameWindow->taperAnaLen; ts++) {
-      { hFrameWindow->pTaperAna__FDK[ts] = winMaxVal; }
-    }
-  }
-
-  return error;
-}
-
-FDK_SACENC_ERROR fdk_sacenc_frameWindow_Destroy(
-    HANDLE_FRAMEWINDOW *phFrameWindow) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if ((NULL != phFrameWindow) && (NULL != *phFrameWindow)) {
-    FDKfree(*phFrameWindow);
-    *phFrameWindow = NULL;
-  }
-  return error;
-}
-
-static FDK_SACENC_ERROR FrameWinList_Reset(FRAMEWIN_LIST *const pFrameWinList) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if (NULL == pFrameWinList) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    int k = 0;
-    for (k = 0; k < MAX_NUM_PARAMS; k++) {
-      pFrameWinList->dat[k].slot = -1;
-      pFrameWinList->dat[k].hold = FW_INTP;
-    }
-    pFrameWinList->n = 0;
-  }
-  return error;
-}
-
-static FDK_SACENC_ERROR FrameWindowList_Add(FRAMEWIN_LIST *const pFrameWinList,
-                                            const INT slot,
-                                            const FW_SLOTTYPE hold) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if (NULL == pFrameWinList) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    if (pFrameWinList->n >= MAX_NUM_PARAMS) { /* Place left in List ?*/
-      error = SACENC_PARAM_ERROR;
-    } else if (pFrameWinList->n > 0 &&
-               pFrameWinList->dat[pFrameWinList->n - 1].slot - slot > 0) {
-      error = SACENC_PARAM_ERROR;
-    } else {
-      pFrameWinList->dat[pFrameWinList->n].slot = slot;
-      pFrameWinList->dat[pFrameWinList->n].hold = hold;
-      pFrameWinList->n++;
-    }
-  }
-  return error;
-}
-
-static FDK_SACENC_ERROR FrameWindowList_Remove(
-    FRAMEWIN_LIST *const pFrameWinList, const INT idx) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if (NULL == pFrameWinList) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    int k = 0;
-    if (idx < 0 || idx >= MAX_NUM_PARAMS) {
-      error = SACENC_PARAM_ERROR;
-    } else if (pFrameWinList->n > 0) {
-      if (idx == MAX_NUM_PARAMS - 1) {
-        pFrameWinList->dat[idx].slot = -1;
-        pFrameWinList->dat[idx].hold = FW_INTP;
-      } else {
-        for (k = idx; k < MAX_NUM_PARAMS - 1; k++) {
-          pFrameWinList->dat[k] = pFrameWinList->dat[k + 1];
-        }
-      }
-      pFrameWinList->n--;
-    }
-  }
-  return error;
-}
-
-static FDK_SACENC_ERROR FrameWindowList_Limit(
-    FRAMEWIN_LIST *const pFrameWinList, const INT ll /*lower limit*/,
-    const INT ul /*upper limit*/
-) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if (NULL == pFrameWinList) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    int k = 0;
-    for (k = 0; k < pFrameWinList->n; k++) {
-      if (pFrameWinList->dat[k].slot < ll || pFrameWinList->dat[k].slot > ul) {
-        FrameWindowList_Remove(pFrameWinList, k);
-        --k;
-      }
-    }
-  }
-  return error;
-}
-
-FDK_SACENC_ERROR fdk_sacenc_frameWindow_GetWindow(
-    HANDLE_FRAMEWINDOW hFrameWindow, INT tr_pos[MAX_NUM_PARAMS],
-    const INT timeSlots, FRAMINGINFO *const pFramingInfo,
-    FIXP_WIN *pWindowAna__FDK[MAX_NUM_PARAMS],
-    FRAMEWIN_LIST *const pFrameWinList, const INT avoid_keep) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if ((hFrameWindow == NULL) || (tr_pos == NULL) || (pFramingInfo == NULL) ||
-      (pFrameWinList == NULL) || (pWindowAna__FDK == NULL)) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    const VAR_TYPE varType = VAR_HOLD;
-    const int tranL = 4;
-    int winCnt = 0;
-    int w, ps;
-
-    int startSlope = hFrameWindow->startSlope;
-    int stopSlope = hFrameWindow->stopSlope;
-    int startRect = hFrameWindow->startRect;
-    int stopRect = hFrameWindow->stopRect;
-    int taperAnaLen = hFrameWindow->taperAnaLen;
-
-    FIXP_WIN winMaxVal = FX_DBL2FX_WIN((FIXP_DBL)MAXVAL_DBL);
-    FIXP_WIN applyRightWindowGain__FDK[MAX_NUM_PARAMS];
-    FIXP_WIN *pTaperAna__FDK = hFrameWindow->pTaperAna__FDK;
-
-    /* sanity check */
-    for (ps = 0; ps < MAX_NUM_PARAMS; ps++) {
-      if (pWindowAna__FDK[ps] == NULL) {
-        error = SACENC_INVALID_HANDLE;
-        goto bail;
-      }
-    }
-
-    if ((timeSlots > hFrameWindow->nTimeSlotsMax) || (timeSlots < 0)) {
-      error = SACENC_INVALID_CONFIG;
-      goto bail;
-    }
-
-    /* Reset */
-    if (SACENC_OK != (error = FrameWinList_Reset(pFrameWinList))) goto bail;
-
-    FDKmemclear(applyRightWindowGain__FDK, sizeof(applyRightWindowGain__FDK));
-
-    if (tr_pos[0] > -1) { /* Transients in first (left) half? */
-      int p_l = tr_pos[0];
-      winCnt = 0;
-
-      /* Create Parameter Positions */
-      switch (varType) {
-        case VAR_HOLD:
-          if (SACENC_OK !=
-              (error = FrameWindowList_Add(pFrameWinList, p_l - 1, FW_HOLD)))
-            goto bail;
-          if (SACENC_OK !=
-              (error = FrameWindowList_Add(pFrameWinList, p_l, FW_INTP)))
-            goto bail;
-          break;
-        case VAR_ISOLATE:
-          if (SACENC_OK !=
-              (error = FrameWindowList_Add(pFrameWinList, p_l - 1, FW_HOLD)))
-            goto bail;
-          if (SACENC_OK !=
-              (error = FrameWindowList_Add(pFrameWinList, p_l, FW_INTP)))
-            goto bail;
-          if (SACENC_OK != (error = FrameWindowList_Add(pFrameWinList,
-                                                        p_l + tranL, FW_HOLD)))
-            goto bail;
-          if (SACENC_OK != (error = FrameWindowList_Add(
-                                pFrameWinList, p_l + tranL + 1, FW_INTP)))
-            goto bail;
-          break;
-        default:
-          error = SACENC_INVALID_CONFIG;
-          break;
-      }
-
-      /* Outside of frame? => Kick Out */
-      if (SACENC_OK !=
-          (error = FrameWindowList_Limit(pFrameWinList, 0, timeSlots - 1)))
-        goto bail;
-
-      /* Add timeSlots as temporary border for window creation */
-      if (SACENC_OK !=
-          (error = FrameWindowList_Add(pFrameWinList, timeSlots - 1, FW_HOLD)))
-        goto bail;
-
-      /* Create Windows */
-      for (ps = 0; ps < pFrameWinList->n - 1; ps++) {
-        if (FW_HOLD != pFrameWinList->dat[ps].hold) {
-          int const start = pFrameWinList->dat[ps].slot;
-          int const stop = pFrameWinList->dat[ps + 1].slot;
-
-          /* Analysis Window */
-          FDKmemset_flex(pWindowAna__FDK[winCnt], FX_DBL2FX_WIN((FIXP_DBL)0),
-                         start);
-          FDKmemset_flex(&pWindowAna__FDK[winCnt][start], winMaxVal,
-                         stop - start + 1);
-          FDKmemset_flex(&pWindowAna__FDK[winCnt][stop + 1],
-                         FX_DBL2FX_WIN((FIXP_DBL)0), timeSlots - stop - 1);
-
-          applyRightWindowGain__FDK[winCnt] =
-              pWindowAna__FDK[winCnt][timeSlots - 1];
-          winCnt++;
-        }
-      } /* ps */
-
-      /* Pop temporary frame border */
-      if (SACENC_OK !=
-          (error = FrameWindowList_Remove(pFrameWinList, pFrameWinList->n - 1)))
-        goto bail;
-    } else { /* No transient in left half of ana. window */
-      winCnt = 0;
-
-      /* Add paramter set at end of frame */
-      if (SACENC_OK !=
-          (error = FrameWindowList_Add(pFrameWinList, timeSlots - 1, FW_INTP)))
-        goto bail;
-      /* Analysis Window */
-      FDKmemset_flex(pWindowAna__FDK[winCnt], FX_DBL2FX_WIN((FIXP_DBL)0),
-                     startSlope);
-      FDKmemcpy_flex(&pWindowAna__FDK[winCnt][startSlope], 1, pTaperAna__FDK, 1,
-                     taperAnaLen);
-      FDKmemset_flex(&pWindowAna__FDK[winCnt][startRect], winMaxVal,
-                     timeSlots - startRect);
-
-      applyRightWindowGain__FDK[winCnt] = winMaxVal;
-      winCnt++;
-    } /* if (tr_pos[0] > -1) */
-
-    for (w = 0; w < winCnt; w++) {
-      if (applyRightWindowGain__FDK[w] > (FIXP_WIN)0) {
-        if (tr_pos[1] > -1) { /* Transients in second (right) half? */
-          int p_r = tr_pos[1];
-
-          /* Analysis Window */
-          FDKmemset_flex(&pWindowAna__FDK[w][timeSlots], winMaxVal,
-                         p_r - timeSlots);
-          FDKmemset_flex(&pWindowAna__FDK[w][p_r], FX_DBL2FX_WIN((FIXP_DBL)0),
-                         2 * timeSlots - p_r);
-
-        } else { /* No transient in right half of ana. window */
-          /* Analysis Window */
-          FDKmemset_flex(&pWindowAna__FDK[w][timeSlots], winMaxVal,
-                         stopRect - timeSlots + 1);
-          FDKmemcpy_flex(&pWindowAna__FDK[w][stopRect], 1,
-                         &pTaperAna__FDK[taperAnaLen - 1], -1, taperAnaLen);
-          FDKmemset_flex(&pWindowAna__FDK[w][stopSlope + 1],
-                         FX_DBL2FX_WIN((FIXP_DBL)0),
-                         2 * timeSlots - stopSlope - 1);
-
-        } /* if (tr_pos[1] > -1) */
-
-        /* Weight */
-        if (applyRightWindowGain__FDK[w] < winMaxVal) {
-          int ts;
-          for (ts = 0; ts < timeSlots; ts++) {
-            pWindowAna__FDK[w][timeSlots + ts] =
-                FX_DBL2FX_WIN(fMult(pWindowAna__FDK[w][timeSlots + ts],
-                                    applyRightWindowGain__FDK[w]));
-          }
-        }
-      } /* if (applyRightWindowGain[w] > 0.0f) */
-      else {
-        /* All Zero */
-        FDKmemset_flex(&pWindowAna__FDK[w][timeSlots],
-                       FX_DBL2FX_WIN((FIXP_DBL)0), timeSlots);
-      }
-    } /* loop over windows */
-
-    if (hFrameWindow->bFrameKeep == 1) {
-      FDKmemcpy_flex(&pWindowAna__FDK[0][2 * timeSlots], 1,
-                     &pWindowAna__FDK[0][timeSlots], 1, timeSlots);
-      FDKmemcpy_flex(&pWindowAna__FDK[0][timeSlots], 1, pWindowAna__FDK[0], 1,
-                     timeSlots);
-
-      if (avoid_keep != 0) {
-        FDKmemset_flex(pWindowAna__FDK[0], FX_DBL2FX_WIN((FIXP_DBL)0),
-                       timeSlots);
-      } else {
-        FDKmemset_flex(pWindowAna__FDK[0], winMaxVal, timeSlots);
-      }
-    } /* if (hFrameWindow->bFrameKeep==1) */
-
-    /* Feed Info to Bitstream Formatter */
-    pFramingInfo->numParamSets = pFrameWinList->n;
-    pFramingInfo->bsFramingType = 1; /* variable framing */
-    for (ps = 0; ps < pFramingInfo->numParamSets; ps++) {
-      pFramingInfo->bsParamSlots[ps] = pFrameWinList->dat[ps].slot;
-    }
-
-    /* if there is just one param set at last slot,
-       use fixed framing to save some bits */
-    if ((pFramingInfo->numParamSets == 1) &&
-        (pFramingInfo->bsParamSlots[0] == timeSlots - 1)) {
-      pFramingInfo->bsFramingType = 0;
-    }
-
-  } /* valid handle */
-
-bail:
-
-  return error;
-}
-
-FDK_SACENC_ERROR fdk_sacenc_analysisWindowing(
-    const INT nTimeSlots, const INT startTimeSlot,
-    FIXP_WIN *pFrameWindowAna__FDK, const FIXP_DPK *const *const ppDataIn__FDK,
-    FIXP_DPK *const *const ppDataOut__FDK, const INT nHybridBands,
-    const INT dim) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if ((pFrameWindowAna__FDK == NULL) || (ppDataIn__FDK == NULL) ||
-      (ppDataOut__FDK == NULL)) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    int i, ts;
-    FIXP_WIN maxVal = FX_DBL2FX_WIN((FIXP_DBL)MAXVAL_DBL);
-
-    if (dim == FW_CHANGE_DIM) {
-      for (ts = startTimeSlot; ts < nTimeSlots; ts++) {
-        FIXP_WIN win = pFrameWindowAna__FDK[ts];
-        if (win == maxVal) {
-          for (i = 0; i < nHybridBands; i++) {
-            ppDataOut__FDK[i][ts].v.re = ppDataIn__FDK[ts][i].v.re;
-            ppDataOut__FDK[i][ts].v.im = ppDataIn__FDK[ts][i].v.im;
-          }
-        } else {
-          for (i = 0; i < nHybridBands; i++) {
-            ppDataOut__FDK[i][ts].v.re = fMult(win, ppDataIn__FDK[ts][i].v.re);
-            ppDataOut__FDK[i][ts].v.im = fMult(win, ppDataIn__FDK[ts][i].v.im);
-          }
-        }
-      } /* ts */
-    } else {
-      for (ts = startTimeSlot; ts < nTimeSlots; ts++) {
-        FIXP_WIN win = pFrameWindowAna__FDK[ts];
-        if (win == maxVal) {
-          for (i = 0; i < nHybridBands; i++) {
-            ppDataOut__FDK[ts][i].v.re = ppDataIn__FDK[ts][i].v.re;
-            ppDataOut__FDK[ts][i].v.im = ppDataIn__FDK[ts][i].v.im;
-          }
-        } else {
-          for (i = 0; i < nHybridBands; i++) {
-            ppDataOut__FDK[ts][i].v.re = fMult(win, ppDataIn__FDK[ts][i].v.re);
-            ppDataOut__FDK[ts][i].v.im = fMult(win, ppDataIn__FDK[ts][i].v.im);
-          }
-        }
-      } /* ts */
-    }
-  }
-
-  return error;
-}
--- a/libSACenc/src/sacenc_framewindowing.h
+++ /dev/null
@@ -1,181 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround encoder library *************************
-
-   Author(s):   Max Neuendorf
-
-   Description: Encoder Library Interface
-                Get windows for framing
-
-*******************************************************************************/
-
-#ifndef SACENC_FRAMEWINDOWING_H
-#define SACENC_FRAMEWINDOWING_H
-
-/**************************************************************************/ /**
-   \file
-   Description of file contents
- ******************************************************************************/
-
-/* Includes ******************************************************************/
-#include "genericStds.h"
-#include "common_fix.h"
-#include "sacenc_lib.h"
-#include "sacenc_bitstream.h"
-
-/* Defines *******************************************************************/
-#define FIXP_WIN FIXP_DBL
-#define FX_DBL2FX_WIN(x) (x)
-#define DALDATATYPE_WIN DALDATATYPE_DFRACT
-
-typedef enum {
-  FW_INTP = 0,
-  FW_HOLD = 1
-
-} FW_SLOTTYPE;
-
-typedef enum {
-  FW_LEAVE_DIM = 0,
-  FW_CHANGE_DIM = 1
-
-} FW_DIMENSION;
-
-/* Data Types ****************************************************************/
-typedef struct T_FRAMEWINDOW *HANDLE_FRAMEWINDOW;
-
-typedef struct T_FRAMEWINDOW_CONFIG {
-  INT nTimeSlotsMax;
-  INT bFrameKeep;
-
-} FRAMEWINDOW_CONFIG;
-
-typedef struct {
-  INT slot;
-  FW_SLOTTYPE hold;
-
-} FRAMEWIN_DATA;
-
-typedef struct {
-  FRAMEWIN_DATA dat[MAX_NUM_PARAMS];
-  INT n;
-
-} FRAMEWIN_LIST;
-
-/* Constants *****************************************************************/
-
-/* Function / Class Declarations *********************************************/
-FDK_SACENC_ERROR fdk_sacenc_frameWindow_Create(
-    HANDLE_FRAMEWINDOW *phFrameWindow);
-
-FDK_SACENC_ERROR fdk_sacenc_frameWindow_Init(
-    HANDLE_FRAMEWINDOW hFrameWindow,
-    const FRAMEWINDOW_CONFIG *const pFrameWindowConfig);
-
-FDK_SACENC_ERROR fdk_sacenc_frameWindow_Destroy(
-    HANDLE_FRAMEWINDOW *phFrameWindow);
-
-FDK_SACENC_ERROR fdk_sacenc_frameWindow_GetWindow(
-    HANDLE_FRAMEWINDOW hFrameWindow, INT tr_pos[MAX_NUM_PARAMS],
-    const INT timeSlots, FRAMINGINFO *const pFramingInfo,
-    FIXP_WIN *pWindowAna__FDK[MAX_NUM_PARAMS],
-    FRAMEWIN_LIST *const pFrameWinList, const INT avoid_keep);
-
-FDK_SACENC_ERROR fdk_sacenc_analysisWindowing(
-    const INT nTimeSlots, const INT startTimeSlot,
-    FIXP_WIN *pFrameWindowAna__FDK, const FIXP_DPK *const *const ppDataIn__FDK,
-    FIXP_DPK *const *const ppDataOut__FDK, const INT nHybridBands,
-    const INT dim);
-
-#endif /* SACENC_FRAMEWINDOWING_H */
--- a/libSACenc/src/sacenc_huff_tab.cpp
+++ /dev/null
@@ -1,997 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround encoder library *************************
-
-   Author(s):   Markus Lohwasser
-
-   Description: SAC-Encoder constant huffman tables
-
-*******************************************************************************/
-
-/* Includes ******************************************************************/
-#include "sacenc_huff_tab.h"
-
-/* Defines *******************************************************************/
-
-/* Data Types ****************************************************************/
-
-/* Constants *****************************************************************/
-const HUFF_CLD_TABLE fdk_sacenc_huffCLDTab = {
-    {/* h1D[2][31] */
-     {HUFF_PACK(0x00000000, 1),  HUFF_PACK(0x00000002, 2),
-      HUFF_PACK(0x00000006, 3),  HUFF_PACK(0x0000000e, 4),
-      HUFF_PACK(0x0000001e, 5),  HUFF_PACK(0x0000003e, 6),
-      HUFF_PACK(0x0000007e, 7),  HUFF_PACK(0x000000fe, 8),
-      HUFF_PACK(0x000001fe, 9),  HUFF_PACK(0x000003fe, 10),
-      HUFF_PACK(0x000007fe, 11), HUFF_PACK(0x00000ffe, 12),
-      HUFF_PACK(0x00001ffe, 13), HUFF_PACK(0x00007ffe, 15),
-      HUFF_PACK(0x00007ffc, 15), HUFF_PACK(0x0000fffe, 16),
-      HUFF_PACK(0x0000fffa, 16), HUFF_PACK(0x0001fffe, 17),
-      HUFF_PACK(0x0001fff6, 17), HUFF_PACK(0x0003fffe, 18),
-      HUFF_PACK(0x0003ffff, 18), HUFF_PACK(0x0007ffde, 19),
-      HUFF_PACK(0x0003ffee, 18), HUFF_PACK(0x000fffbe, 20),
-      HUFF_PACK(0x001fff7e, 21), HUFF_PACK(0x00fffbfc, 24),
-      HUFF_PACK(0x00fffbfd, 24), HUFF_PACK(0x00fffbfe, 24),
-      HUFF_PACK(0x00fffbff, 24), HUFF_PACK(0x007ffdfc, 23),
-      HUFF_PACK(0x007ffdfd, 23)},
-     {HUFF_PACK(0x00000000, 1),  HUFF_PACK(0x00000002, 2),
-      HUFF_PACK(0x00000006, 3),  HUFF_PACK(0x0000000e, 4),
-      HUFF_PACK(0x0000001e, 5),  HUFF_PACK(0x0000003e, 6),
-      HUFF_PACK(0x0000007e, 7),  HUFF_PACK(0x000001fe, 9),
-      HUFF_PACK(0x000001fc, 9),  HUFF_PACK(0x000003fe, 10),
-      HUFF_PACK(0x000003fa, 10), HUFF_PACK(0x000007fe, 11),
-      HUFF_PACK(0x000007f6, 11), HUFF_PACK(0x00000ffe, 12),
-      HUFF_PACK(0x00000fee, 12), HUFF_PACK(0x00001ffe, 13),
-      HUFF_PACK(0x00001fde, 13), HUFF_PACK(0x00003ffe, 14),
-      HUFF_PACK(0x00003fbe, 14), HUFF_PACK(0x00003fbf, 14),
-      HUFF_PACK(0x00007ffe, 15), HUFF_PACK(0x0000fffe, 16),
-      HUFF_PACK(0x0001fffe, 17), HUFF_PACK(0x0007fffe, 19),
-      HUFF_PACK(0x0007fffc, 19), HUFF_PACK(0x000ffffa, 20),
-      HUFF_PACK(0x001ffffc, 21), HUFF_PACK(0x001ffffd, 21),
-      HUFF_PACK(0x001ffffe, 21), HUFF_PACK(0x001fffff, 21),
-      HUFF_PACK(0x000ffffb, 20)}},
-    {  /* HUFF_CLD_TAB_2D */
-     { /* HUFF_CLD_TAB_2D[0][] */
-      {/* HUFF_CLD_TAB_2D[0][0] */
-       {
-           /* LAV3_2D */
-           {{HUFF_PACK(0x00000002, 2), HUFF_PACK(0x00000002, 3),
-             HUFF_PACK(0x00000004, 5), HUFF_PACK(0x0000003e, 8)},
-            {HUFF_PACK(0x00000006, 4), HUFF_PACK(0x00000007, 4),
-             HUFF_PACK(0x0000000e, 6), HUFF_PACK(0x000000fe, 10)},
-            {HUFF_PACK(0x0000007e, 9), HUFF_PACK(0x0000001e, 7),
-             HUFF_PACK(0x0000000c, 6), HUFF_PACK(0x00000005, 5)},
-            {HUFF_PACK(0x000000ff, 10), HUFF_PACK(0x0000000d, 6),
-             HUFF_PACK(0x00000000, 3), HUFF_PACK(0x00000003, 2)}},
-           HUFF_PACK(0x00000000, 0) /* escape */
-       },
-       {
-           /* LAV5_2D */
-           {{HUFF_PACK(0x00000002, 3), HUFF_PACK(0x00000003, 3),
-             HUFF_PACK(0x00000010, 5), HUFF_PACK(0x0000007c, 7),
-             HUFF_PACK(0x000000d6, 8), HUFF_PACK(0x000003ee, 10)},
-            {HUFF_PACK(0x0000000a, 4), HUFF_PACK(0x0000000c, 4),
-             HUFF_PACK(0x00000016, 5), HUFF_PACK(0x00000034, 6),
-             HUFF_PACK(0x000000fe, 8), HUFF_PACK(0x00001f7e, 13)},
-            {HUFF_PACK(0x0000007e, 7), HUFF_PACK(0x00000036, 6),
-             HUFF_PACK(0x00000026, 6), HUFF_PACK(0x00000046, 7),
-             HUFF_PACK(0x0000011e, 9), HUFF_PACK(0x000001f6, 9)},
-            {HUFF_PACK(0x0000011f, 9), HUFF_PACK(0x000000d7, 8),
-             HUFF_PACK(0x0000008e, 8), HUFF_PACK(0x000000ff, 8),
-             HUFF_PACK(0x0000006a, 7), HUFF_PACK(0x0000004e, 7)},
-            {HUFF_PACK(0x00000fbe, 12), HUFF_PACK(0x000007de, 11),
-             HUFF_PACK(0x0000004f, 7), HUFF_PACK(0x00000037, 6),
-             HUFF_PACK(0x00000017, 5), HUFF_PACK(0x0000001e, 5)},
-            {HUFF_PACK(0x00001f7f, 13), HUFF_PACK(0x000000fa, 8),
-             HUFF_PACK(0x00000022, 6), HUFF_PACK(0x00000012, 5),
-             HUFF_PACK(0x0000000e, 4), HUFF_PACK(0x00000000, 2)}},
-           HUFF_PACK(0x00000000, 0) /* escape */
-       },
-       {
-           /* LAV7_2D */
-           {{HUFF_PACK(0x0000000e, 4), HUFF_PACK(0x0000000a, 4),
-             HUFF_PACK(0x0000000a, 5), HUFF_PACK(0x0000007c, 7),
-             HUFF_PACK(0x000000be, 8), HUFF_PACK(0x0000017a, 9),
-             HUFF_PACK(0x000000ee, 9), HUFF_PACK(0x000007b6, 11)},
-            {HUFF_PACK(0x00000006, 4), HUFF_PACK(0x0000000c, 4),
-             HUFF_PACK(0x00000016, 5), HUFF_PACK(0x00000026, 6),
-             HUFF_PACK(0x0000003e, 7), HUFF_PACK(0x0000002e, 7),
-             HUFF_PACK(0x000001ec, 9), HUFF_PACK(0x000047ce, 15)},
-            {HUFF_PACK(0x00000016, 6), HUFF_PACK(0x0000003c, 6),
-             HUFF_PACK(0x00000022, 6), HUFF_PACK(0x0000004e, 7),
-             HUFF_PACK(0x0000003f, 7), HUFF_PACK(0x0000005e, 8),
-             HUFF_PACK(0x000008fa, 12), HUFF_PACK(0x000008fb, 12)},
-            {HUFF_PACK(0x0000005f, 8), HUFF_PACK(0x000000fa, 8),
-             HUFF_PACK(0x000000bf, 8), HUFF_PACK(0x0000003a, 7),
-             HUFF_PACK(0x000001f6, 9), HUFF_PACK(0x000001de, 10),
-             HUFF_PACK(0x000003da, 10), HUFF_PACK(0x000007b7, 11)},
-            {HUFF_PACK(0x000001df, 10), HUFF_PACK(0x000003ee, 10),
-             HUFF_PACK(0x0000017b, 9), HUFF_PACK(0x000003ef, 10),
-             HUFF_PACK(0x000001ee, 9), HUFF_PACK(0x0000008e, 8),
-             HUFF_PACK(0x000001ef, 9), HUFF_PACK(0x000001fe, 9)},
-            {HUFF_PACK(0x000008f8, 12), HUFF_PACK(0x0000047e, 11),
-             HUFF_PACK(0x0000047f, 11), HUFF_PACK(0x00000076, 8),
-             HUFF_PACK(0x0000003c, 7), HUFF_PACK(0x00000046, 7),
-             HUFF_PACK(0x0000007a, 7), HUFF_PACK(0x0000007e, 7)},
-            {HUFF_PACK(0x000023e6, 14), HUFF_PACK(0x000011f2, 13),
-             HUFF_PACK(0x000001ff, 9), HUFF_PACK(0x0000003d, 7),
-             HUFF_PACK(0x0000004f, 7), HUFF_PACK(0x0000002e, 6),
-             HUFF_PACK(0x00000012, 5), HUFF_PACK(0x00000004, 4)},
-            {HUFF_PACK(0x000047cf, 15), HUFF_PACK(0x0000011e, 9),
-             HUFF_PACK(0x000000bc, 8), HUFF_PACK(0x000000fe, 8),
-             HUFF_PACK(0x0000001c, 6), HUFF_PACK(0x00000010, 5),
-             HUFF_PACK(0x0000000d, 4), HUFF_PACK(0x00000000, 2)}},
-           HUFF_PACK(0x00000000, 0) /* escape */
-       },
-       {
-           /* LAV9_2D */
-           {{HUFF_PACK(0x00000006, 4), HUFF_PACK(0x00000007, 4),
-             HUFF_PACK(0x00000006, 5), HUFF_PACK(0x0000007e, 7),
-             HUFF_PACK(0x0000000a, 7), HUFF_PACK(0x0000001e, 8),
-             HUFF_PACK(0x0000008a, 9), HUFF_PACK(0x0000004e, 10),
-             HUFF_PACK(0x00000276, 10), HUFF_PACK(0x000002e2, 11)},
-            {HUFF_PACK(0x00000000, 4), HUFF_PACK(0x0000000a, 4),
-             HUFF_PACK(0x00000016, 5), HUFF_PACK(0x00000026, 6),
-             HUFF_PACK(0x00000076, 7), HUFF_PACK(0x000000f2, 8),
-             HUFF_PACK(0x00000012, 8), HUFF_PACK(0x0000005e, 8),
-             HUFF_PACK(0x0000008b, 9), HUFF_PACK(0x00002e76, 15)},
-            {HUFF_PACK(0x00000012, 6), HUFF_PACK(0x00000007, 5),
-             HUFF_PACK(0x00000038, 6), HUFF_PACK(0x0000007c, 7),
-             HUFF_PACK(0x00000008, 7), HUFF_PACK(0x00000046, 8),
-             HUFF_PACK(0x000000f6, 8), HUFF_PACK(0x000001ca, 9),
-             HUFF_PACK(0x0000173a, 14), HUFF_PACK(0x00001738, 14)},
-            {HUFF_PACK(0x0000009e, 8), HUFF_PACK(0x0000004a, 7),
-             HUFF_PACK(0x00000026, 7), HUFF_PACK(0x0000000c, 7),
-             HUFF_PACK(0x0000004e, 8), HUFF_PACK(0x000000f7, 8),
-             HUFF_PACK(0x0000013a, 9), HUFF_PACK(0x0000009e, 11),
-             HUFF_PACK(0x000009fe, 12), HUFF_PACK(0x0000013e, 12)},
-            {HUFF_PACK(0x00000026, 9), HUFF_PACK(0x0000001a, 8),
-             HUFF_PACK(0x000001e6, 9), HUFF_PACK(0x000001e2, 9),
-             HUFF_PACK(0x000000ee, 8), HUFF_PACK(0x000001ce, 9),
-             HUFF_PACK(0x00000277, 10), HUFF_PACK(0x000003ce, 10),
-             HUFF_PACK(0x000002e6, 11), HUFF_PACK(0x000004fc, 11)},
-            {HUFF_PACK(0x000002e3, 11), HUFF_PACK(0x00000170, 10),
-             HUFF_PACK(0x00000172, 10), HUFF_PACK(0x000000ba, 9),
-             HUFF_PACK(0x0000003e, 9), HUFF_PACK(0x000001e3, 9),
-             HUFF_PACK(0x0000001b, 8), HUFF_PACK(0x0000003f, 9),
-             HUFF_PACK(0x0000009e, 9), HUFF_PACK(0x0000009f, 9)},
-            {HUFF_PACK(0x00000b9e, 13), HUFF_PACK(0x000009ff, 12),
-             HUFF_PACK(0x000004fd, 11), HUFF_PACK(0x000004fe, 11),
-             HUFF_PACK(0x000001cf, 9), HUFF_PACK(0x000000ef, 8),
-             HUFF_PACK(0x00000044, 8), HUFF_PACK(0x0000005f, 8),
-             HUFF_PACK(0x000000e4, 8), HUFF_PACK(0x000000f0, 8)},
-            {HUFF_PACK(0x00002e72, 15), HUFF_PACK(0x0000013f, 12),
-             HUFF_PACK(0x00000b9f, 13), HUFF_PACK(0x0000013e, 9),
-             HUFF_PACK(0x000000fe, 8), HUFF_PACK(0x00000047, 8),
-             HUFF_PACK(0x0000000e, 7), HUFF_PACK(0x0000007d, 7),
-             HUFF_PACK(0x00000010, 6), HUFF_PACK(0x00000024, 6)},
-            {HUFF_PACK(0x00002e77, 15), HUFF_PACK(0x00005ce6, 16),
-             HUFF_PACK(0x000000bb, 9), HUFF_PACK(0x000000e6, 8),
-             HUFF_PACK(0x00000016, 8), HUFF_PACK(0x000000ff, 8),
-             HUFF_PACK(0x0000007a, 7), HUFF_PACK(0x0000003a, 6),
-             HUFF_PACK(0x00000017, 5), HUFF_PACK(0x00000002, 4)},
-            {HUFF_PACK(0x00005ce7, 16), HUFF_PACK(0x000003cf, 10),
-             HUFF_PACK(0x00000017, 8), HUFF_PACK(0x000001cb, 9),
-             HUFF_PACK(0x0000009c, 8), HUFF_PACK(0x0000004b, 7),
-             HUFF_PACK(0x00000016, 6), HUFF_PACK(0x0000000a, 5),
-             HUFF_PACK(0x00000008, 4), HUFF_PACK(0x00000006, 3)}},
-           HUFF_PACK(0x00000000, 0) /* escape */
-       }},
-      {/* HUFF_CLD_TAB_2D[0][1] */
-       {
-           /* LAV3_2D */
-           {{HUFF_PACK(0x00000000, 1), HUFF_PACK(0x0000003e, 6),
-             HUFF_PACK(0x0000076e, 11), HUFF_PACK(0x00000ede, 12)},
-            {HUFF_PACK(0x00000006, 3), HUFF_PACK(0x0000003f, 6),
-             HUFF_PACK(0x000003b6, 10), HUFF_PACK(0x0000003a, 6)},
-            {HUFF_PACK(0x0000001c, 5), HUFF_PACK(0x000000ee, 8),
-             HUFF_PACK(0x000001da, 9), HUFF_PACK(0x0000001e, 5)},
-            {HUFF_PACK(0x000000ef, 8), HUFF_PACK(0x00000edf, 12),
-             HUFF_PACK(0x000000ec, 8), HUFF_PACK(0x00000002, 2)}},
-           HUFF_PACK(0x00000000, 0) /* escape */
-       },
-       {
-           /* LAV5_2D */
-           {{HUFF_PACK(0x00000006, 3), HUFF_PACK(0x0000001c, 5),
-             HUFF_PACK(0x0000007e, 8), HUFF_PACK(0x00000efc, 12),
-             HUFF_PACK(0x0000effe, 16), HUFF_PACK(0x0001dffe, 17)},
-            {HUFF_PACK(0x00000004, 3), HUFF_PACK(0x0000000a, 4),
-             HUFF_PACK(0x0000003e, 7), HUFF_PACK(0x00000efe, 12),
-             HUFF_PACK(0x000077fe, 15), HUFF_PACK(0x00000076, 7)},
-            {HUFF_PACK(0x00000006, 4), HUFF_PACK(0x00000016, 5),
-             HUFF_PACK(0x000000be, 8), HUFF_PACK(0x00000efd, 12),
-             HUFF_PACK(0x000000ee, 8), HUFF_PACK(0x0000000e, 5)},
-            {HUFF_PACK(0x0000003e, 6), HUFF_PACK(0x0000002e, 6),
-             HUFF_PACK(0x000001de, 9), HUFF_PACK(0x000003be, 10),
-             HUFF_PACK(0x0000007e, 7), HUFF_PACK(0x0000001e, 5)},
-            {HUFF_PACK(0x0000007f, 7), HUFF_PACK(0x0000005e, 7),
-             HUFF_PACK(0x00003bfe, 14), HUFF_PACK(0x000000fe, 9),
-             HUFF_PACK(0x0000001e, 6), HUFF_PACK(0x00000002, 3)},
-            {HUFF_PACK(0x000000bf, 8), HUFF_PACK(0x0001dfff, 17),
-             HUFF_PACK(0x00001dfe, 13), HUFF_PACK(0x000000ff, 9),
-             HUFF_PACK(0x0000003a, 6), HUFF_PACK(0x00000000, 2)}},
-           HUFF_PACK(0x00000000, 0) /* escape */
-       },
-       {
-           /* LAV7_2D */
-           {{HUFF_PACK(0x00000002, 3), HUFF_PACK(0x0000001c, 5),
-             HUFF_PACK(0x000000bc, 8), HUFF_PACK(0x000005fc, 11),
-             HUFF_PACK(0x00005ffe, 15), HUFF_PACK(0x0002ffde, 18),
-             HUFF_PACK(0x000bff7e, 20), HUFF_PACK(0x0017feff, 21)},
-            {HUFF_PACK(0x00000004, 3), HUFF_PACK(0x0000000a, 4),
-             HUFF_PACK(0x0000000e, 7), HUFF_PACK(0x000002fa, 10),
-             HUFF_PACK(0x000001fe, 13), HUFF_PACK(0x0000bff2, 16),
-             HUFF_PACK(0x0005ffbe, 19), HUFF_PACK(0x000000ee, 8)},
-            {HUFF_PACK(0x00000002, 4), HUFF_PACK(0x00000016, 5),
-             HUFF_PACK(0x000000f6, 8), HUFF_PACK(0x000005fe, 11),
-             HUFF_PACK(0x000001ff, 13), HUFF_PACK(0x0000bff6, 16),
-             HUFF_PACK(0x000001de, 9), HUFF_PACK(0x0000007e, 7)},
-            {HUFF_PACK(0x00000000, 5), HUFF_PACK(0x0000003c, 6),
-             HUFF_PACK(0x0000000e, 8), HUFF_PACK(0x0000003e, 10),
-             HUFF_PACK(0x00002ffe, 14), HUFF_PACK(0x000002fb, 10),
-             HUFF_PACK(0x000000f7, 8), HUFF_PACK(0x0000002e, 6)},
-            {HUFF_PACK(0x00000006, 6), HUFF_PACK(0x0000007a, 7),
-             HUFF_PACK(0x0000000a, 8), HUFF_PACK(0x0000007e, 11),
-             HUFF_PACK(0x000000fe, 12), HUFF_PACK(0x00000016, 9),
-             HUFF_PACK(0x00000006, 7), HUFF_PACK(0x00000002, 5)},
-            {HUFF_PACK(0x0000000f, 7), HUFF_PACK(0x00000076, 7),
-             HUFF_PACK(0x00000017, 9), HUFF_PACK(0x00005ff8, 15),
-             HUFF_PACK(0x00000bfe, 12), HUFF_PACK(0x0000001e, 9),
-             HUFF_PACK(0x0000007f, 7), HUFF_PACK(0x00000003, 4)},
-            {HUFF_PACK(0x00000004, 7), HUFF_PACK(0x000000bd, 8),
-             HUFF_PACK(0x0000bff3, 16), HUFF_PACK(0x00005fff, 15),
-             HUFF_PACK(0x00000bfa, 12), HUFF_PACK(0x0000017c, 9),
-             HUFF_PACK(0x0000003a, 6), HUFF_PACK(0x00000003, 3)},
-            {HUFF_PACK(0x0000017e, 9), HUFF_PACK(0x0017fefe, 21),
-             HUFF_PACK(0x00017fee, 17), HUFF_PACK(0x00005ffa, 15),
-             HUFF_PACK(0x00000bfb, 12), HUFF_PACK(0x000001df, 9),
-             HUFF_PACK(0x0000003e, 6), HUFF_PACK(0x00000006, 3)}},
-           HUFF_PACK(0x0017feff, 21) /* escape */
-       },
-       {
-           /* LAV9_2D */
-           {{HUFF_PACK(0x0000000e, 4), HUFF_PACK(0x00000014, 5),
-             HUFF_PACK(0x0000008e, 8), HUFF_PACK(0x000004fe, 11),
-             HUFF_PACK(0x000023fe, 14), HUFF_PACK(0x00008ffe, 16),
-             HUFF_PACK(0x0005ffbc, 19), HUFF_PACK(0x0017fef7, 21),
-             HUFF_PACK(0x0017fef7, 21), HUFF_PACK(0x0017fef7, 21)},
-            {HUFF_PACK(0x00000002, 3), HUFF_PACK(0x00000002, 4),
-             HUFF_PACK(0x00000044, 7), HUFF_PACK(0x0000027e, 10),
-             HUFF_PACK(0x000017fc, 13), HUFF_PACK(0x0000bff6, 16),
-             HUFF_PACK(0x0005ffbe, 19), HUFF_PACK(0x00011ff8, 17),
-             HUFF_PACK(0x000bff7a, 20), HUFF_PACK(0x000000bc, 8)},
-            {HUFF_PACK(0x00000006, 4), HUFF_PACK(0x00000016, 5),
-             HUFF_PACK(0x0000001a, 7), HUFF_PACK(0x000000fe, 10),
-             HUFF_PACK(0x000011f6, 13), HUFF_PACK(0x0000bffe, 16),
-             HUFF_PACK(0x00011ff9, 17), HUFF_PACK(0x0017fef6, 21),
-             HUFF_PACK(0x0000011e, 9), HUFF_PACK(0x00000056, 7)},
-            {HUFF_PACK(0x00000010, 5), HUFF_PACK(0x0000003e, 6),
-             HUFF_PACK(0x0000009e, 8), HUFF_PACK(0x000007fe, 11),
-             HUFF_PACK(0x000011f7, 13), HUFF_PACK(0x00005ff8, 15),
-             HUFF_PACK(0x00017fee, 17), HUFF_PACK(0x000007ff, 11),
-             HUFF_PACK(0x000000ae, 8), HUFF_PACK(0x0000001e, 7)},
-            {HUFF_PACK(0x00000026, 6), HUFF_PACK(0x0000000e, 6),
-             HUFF_PACK(0x000001ee, 9), HUFF_PACK(0x0000047e, 11),
-             HUFF_PACK(0x00000bfc, 12), HUFF_PACK(0x0000bfff, 16),
-             HUFF_PACK(0x000008fa, 12), HUFF_PACK(0x0000006e, 9),
-             HUFF_PACK(0x000001ef, 9), HUFF_PACK(0x0000007e, 7)},
-            {HUFF_PACK(0x0000007a, 7), HUFF_PACK(0x0000004e, 7),
-             HUFF_PACK(0x0000007e, 9), HUFF_PACK(0x000000de, 10),
-             HUFF_PACK(0x000011fe, 13), HUFF_PACK(0x00002ffe, 14),
-             HUFF_PACK(0x000004ff, 11), HUFF_PACK(0x000000ff, 10),
-             HUFF_PACK(0x000000bd, 8), HUFF_PACK(0x0000002e, 6)},
-            {HUFF_PACK(0x000000fe, 8), HUFF_PACK(0x000000af, 8),
-             HUFF_PACK(0x000001ec, 9), HUFF_PACK(0x000001be, 11),
-             HUFF_PACK(0x00011ffe, 17), HUFF_PACK(0x00002ffa, 14),
-             HUFF_PACK(0x000008fe, 12), HUFF_PACK(0x000003fe, 10),
-             HUFF_PACK(0x00000046, 7), HUFF_PACK(0x00000012, 5)},
-            {HUFF_PACK(0x0000003e, 8), HUFF_PACK(0x00000045, 7),
-             HUFF_PACK(0x000002fe, 10), HUFF_PACK(0x000bff7e, 20),
-             HUFF_PACK(0x00005ff9, 15), HUFF_PACK(0x00005ffa, 15),
-             HUFF_PACK(0x00000bfd, 12), HUFF_PACK(0x0000013e, 9),
-             HUFF_PACK(0x0000000c, 6), HUFF_PACK(0x00000007, 4)},
-            {HUFF_PACK(0x000000be, 8), HUFF_PACK(0x00000036, 8),
-             HUFF_PACK(0x000bff7f, 20), HUFF_PACK(0x00023ffe, 18),
-             HUFF_PACK(0x00011ffa, 17), HUFF_PACK(0x00005ffe, 15),
-             HUFF_PACK(0x000001bf, 11), HUFF_PACK(0x000001ed, 9),
-             HUFF_PACK(0x0000002a, 6), HUFF_PACK(0x00000000, 3)},
-            {HUFF_PACK(0x0000017e, 9), HUFF_PACK(0x0017fef7, 21),
-             HUFF_PACK(0x00047ffe, 19), HUFF_PACK(0x00047fff, 19),
-             HUFF_PACK(0x00011ffb, 17), HUFF_PACK(0x00002ffb, 14),
-             HUFF_PACK(0x0000047c, 11), HUFF_PACK(0x000001fe, 9),
-             HUFF_PACK(0x0000003c, 6), HUFF_PACK(0x00000006, 3)}},
-           HUFF_PACK(0x0017fef7, 21) /* escape */
-       }}},
-     { /* HUFF_CLD_TAB_2D[1][] */
-      {/* HUFF_CLD_TAB_2D[1][0] */
-       {
-           /* LAV3_2D */
-           {{HUFF_PACK(0x00000000, 1), HUFF_PACK(0x0000001e, 5),
-             HUFF_PACK(0x000003be, 10), HUFF_PACK(0x00000efe, 12)},
-            {HUFF_PACK(0x00000006, 3), HUFF_PACK(0x0000001c, 5),
-             HUFF_PACK(0x000001de, 9), HUFF_PACK(0x000000ea, 8)},
-            {HUFF_PACK(0x00000074, 7), HUFF_PACK(0x000000ee, 8),
-             HUFF_PACK(0x000000eb, 8), HUFF_PACK(0x0000001f, 5)},
-            {HUFF_PACK(0x0000077e, 11), HUFF_PACK(0x00000eff, 12),
-             HUFF_PACK(0x00000076, 7), HUFF_PACK(0x00000002, 2)}},
-           HUFF_PACK(0x00000000, 0) /* escape */
-       },
-       {
-           /* LAV5_2D */
-           {{HUFF_PACK(0x00000000, 2), HUFF_PACK(0x00000006, 4),
-             HUFF_PACK(0x00000024, 7), HUFF_PACK(0x0000025e, 11),
-             HUFF_PACK(0x00003cfe, 14), HUFF_PACK(0x000079fe, 15)},
-            {HUFF_PACK(0x00000006, 3), HUFF_PACK(0x00000007, 4),
-             HUFF_PACK(0x00000078, 7), HUFF_PACK(0x000003ce, 10),
-             HUFF_PACK(0x00001e7e, 13), HUFF_PACK(0x000000be, 9)},
-            {HUFF_PACK(0x00000008, 5), HUFF_PACK(0x0000003e, 6),
-             HUFF_PACK(0x00000026, 7), HUFF_PACK(0x0000012e, 10),
-             HUFF_PACK(0x000000bf, 9), HUFF_PACK(0x0000002e, 7)},
-            {HUFF_PACK(0x00000027, 7), HUFF_PACK(0x0000007a, 7),
-             HUFF_PACK(0x000001e4, 9), HUFF_PACK(0x00000096, 9),
-             HUFF_PACK(0x0000007b, 7), HUFF_PACK(0x0000003f, 6)},
-            {HUFF_PACK(0x000001e6, 9), HUFF_PACK(0x000001e5, 9),
-             HUFF_PACK(0x00000f3e, 12), HUFF_PACK(0x0000005e, 8),
-             HUFF_PACK(0x00000016, 6), HUFF_PACK(0x0000000e, 4)},
-            {HUFF_PACK(0x0000079e, 11), HUFF_PACK(0x000079ff, 15),
-             HUFF_PACK(0x0000025f, 11), HUFF_PACK(0x0000004a, 8),
-             HUFF_PACK(0x0000000a, 5), HUFF_PACK(0x00000002, 2)}},
-           HUFF_PACK(0x00000000, 0) /* escape */
-       },
-       {
-           /* LAV7_2D */
-           {{HUFF_PACK(0x00000000, 2), HUFF_PACK(0x00000006, 4),
-             HUFF_PACK(0x000000de, 8), HUFF_PACK(0x0000069e, 11),
-             HUFF_PACK(0x000034fe, 14), HUFF_PACK(0x0001a7fe, 17),
-             HUFF_PACK(0x00069ff6, 19), HUFF_PACK(0x00069ff7, 19)},
-            {HUFF_PACK(0x00000002, 3), HUFF_PACK(0x0000000c, 4),
-             HUFF_PACK(0x0000006a, 7), HUFF_PACK(0x0000034e, 10),
-             HUFF_PACK(0x00001fde, 13), HUFF_PACK(0x000069fe, 15),
-             HUFF_PACK(0x0001a7fc, 17), HUFF_PACK(0x00000372, 10)},
-            {HUFF_PACK(0x0000003e, 6), HUFF_PACK(0x0000003c, 6),
-             HUFF_PACK(0x000000df, 8), HUFF_PACK(0x000001ee, 10),
-             HUFF_PACK(0x00000dde, 12), HUFF_PACK(0x000069fa, 15),
-             HUFF_PACK(0x00000373, 10), HUFF_PACK(0x0000007a, 8)},
-            {HUFF_PACK(0x0000003e, 7), HUFF_PACK(0x00000068, 7),
-             HUFF_PACK(0x000001ba, 9), HUFF_PACK(0x000003f6, 10),
-             HUFF_PACK(0x00000d3e, 12), HUFF_PACK(0x0000034c, 10),
-             HUFF_PACK(0x000001fa, 9), HUFF_PACK(0x000000d2, 8)},
-            {HUFF_PACK(0x0000007e, 8), HUFF_PACK(0x0000007f, 8),
-             HUFF_PACK(0x000001f8, 9), HUFF_PACK(0x000006ee, 11),
-             HUFF_PACK(0x000003de, 11), HUFF_PACK(0x000001b8, 9),
-             HUFF_PACK(0x000001fc, 9), HUFF_PACK(0x0000006b, 7)},
-            {HUFF_PACK(0x000000f6, 9), HUFF_PACK(0x000001fe, 9),
-             HUFF_PACK(0x0000034d, 10), HUFF_PACK(0x00003fbe, 14),
-             HUFF_PACK(0x000007f6, 11), HUFF_PACK(0x000003fa, 10),
-             HUFF_PACK(0x0000003c, 7), HUFF_PACK(0x0000003d, 6)},
-            {HUFF_PACK(0x000003f7, 10), HUFF_PACK(0x00000376, 10),
-             HUFF_PACK(0x0001a7ff, 17), HUFF_PACK(0x00003fbf, 14),
-             HUFF_PACK(0x00000ddf, 12), HUFF_PACK(0x000001f9, 9),
-             HUFF_PACK(0x00000036, 6), HUFF_PACK(0x0000000e, 4)},
-            {HUFF_PACK(0x000003df, 11), HUFF_PACK(0x00034ffa, 18),
-             HUFF_PACK(0x000069fb, 15), HUFF_PACK(0x000034fc, 14),
-             HUFF_PACK(0x00000fee, 12), HUFF_PACK(0x000001ff, 9),
-             HUFF_PACK(0x0000000e, 5), HUFF_PACK(0x00000002, 2)}},
-           HUFF_PACK(0x00000000, 0) /* escape */
-       },
-       {
-           /* LAV9_2D */
-           {{HUFF_PACK(0x00000006, 3), HUFF_PACK(0x00000004, 4),
-             HUFF_PACK(0x00000012, 7), HUFF_PACK(0x000007fe, 11),
-             HUFF_PACK(0x00001f7e, 13), HUFF_PACK(0x0000fbfe, 16),
-             HUFF_PACK(0x0001f7fe, 17), HUFF_PACK(0x000b7dfe, 21),
-             HUFF_PACK(0x000b7dff, 21), HUFF_PACK(0x000b7dff, 21)},
-            {HUFF_PACK(0x00000000, 3), HUFF_PACK(0x00000006, 4),
-             HUFF_PACK(0x0000007c, 7), HUFF_PACK(0x00000046, 9),
-             HUFF_PACK(0x000007d0, 12), HUFF_PACK(0x00001f4e, 14),
-             HUFF_PACK(0x0000b7fe, 17), HUFF_PACK(0x00005bee, 16),
-             HUFF_PACK(0x00016fbe, 18), HUFF_PACK(0x000003ee, 10)},
-            {HUFF_PACK(0x00000006, 5), HUFF_PACK(0x0000000a, 5),
-             HUFF_PACK(0x0000002e, 7), HUFF_PACK(0x000003fe, 10),
-             HUFF_PACK(0x000007d2, 12), HUFF_PACK(0x00001f4f, 14),
-             HUFF_PACK(0x00002dfe, 15), HUFF_PACK(0x0000b7de, 17),
-             HUFF_PACK(0x000001fe, 10), HUFF_PACK(0x0000002e, 8)},
-            {HUFF_PACK(0x0000007a, 7), HUFF_PACK(0x0000007e, 7),
-             HUFF_PACK(0x0000007a, 8), HUFF_PACK(0x000001fa, 10),
-             HUFF_PACK(0x000007fe, 12), HUFF_PACK(0x00001f7c, 13),
-             HUFF_PACK(0x000016fa, 14), HUFF_PACK(0x0000009e, 10),
-             HUFF_PACK(0x00000020, 8), HUFF_PACK(0x00000021, 8)},
-            {HUFF_PACK(0x000000fe, 8), HUFF_PACK(0x00000016, 7),
-             HUFF_PACK(0x000000fe, 9), HUFF_PACK(0x0000016e, 10),
-             HUFF_PACK(0x0000009f, 10), HUFF_PACK(0x00000b7c, 13),
-             HUFF_PACK(0x000003de, 11), HUFF_PACK(0x000000b6, 9),
-             HUFF_PACK(0x000000be, 9), HUFF_PACK(0x0000007c, 8)},
-            {HUFF_PACK(0x0000005a, 8), HUFF_PACK(0x00000078, 8),
-             HUFF_PACK(0x00000047, 9), HUFF_PACK(0x00000044, 9),
-             HUFF_PACK(0x000007ff, 12), HUFF_PACK(0x000007d1, 12),
-             HUFF_PACK(0x000001f6, 10), HUFF_PACK(0x000001f7, 10),
-             HUFF_PACK(0x0000002f, 8), HUFF_PACK(0x0000002c, 7)},
-            {HUFF_PACK(0x000000fc, 9), HUFF_PACK(0x000001f6, 9),
-             HUFF_PACK(0x000000f6, 9), HUFF_PACK(0x000007ff, 11),
-             HUFF_PACK(0x000016fe, 14), HUFF_PACK(0x000002de, 11),
-             HUFF_PACK(0x000003ea, 11), HUFF_PACK(0x000000bf, 9),
-             HUFF_PACK(0x000000fa, 8), HUFF_PACK(0x0000000a, 6)},
-            {HUFF_PACK(0x0000004e, 9), HUFF_PACK(0x00000026, 8),
-             HUFF_PACK(0x000001ee, 10), HUFF_PACK(0x00005bfe, 16),
-             HUFF_PACK(0x00003efe, 14), HUFF_PACK(0x00000b7e, 13),
-             HUFF_PACK(0x000003eb, 11), HUFF_PACK(0x000001fe, 9),
-             HUFF_PACK(0x0000007b, 7), HUFF_PACK(0x00000007, 5)},
-            {HUFF_PACK(0x000001fb, 10), HUFF_PACK(0x00000045, 9),
-             HUFF_PACK(0x00016ffe, 18), HUFF_PACK(0x0001f7ff, 17),
-             HUFF_PACK(0x00002df6, 15), HUFF_PACK(0x00001f7d, 13),
-             HUFF_PACK(0x000003fe, 11), HUFF_PACK(0x0000005e, 8),
-             HUFF_PACK(0x0000003c, 6), HUFF_PACK(0x0000000e, 4)},
-            {HUFF_PACK(0x000003df, 11), HUFF_PACK(0x0005befe, 20),
-             HUFF_PACK(0x0002df7e, 19), HUFF_PACK(0x00016fff, 18),
-             HUFF_PACK(0x00007dfe, 15), HUFF_PACK(0x00000fa6, 13),
-             HUFF_PACK(0x000007de, 11), HUFF_PACK(0x00000079, 8),
-             HUFF_PACK(0x0000000e, 5), HUFF_PACK(0x00000002, 2)}},
-           HUFF_PACK(0x000b7dff, 21) /* escape */
-       }},
-      {/* HUFF_CLD_TAB_2D[1][1] */
-       {
-           /* LAV3_2D */
-           {{HUFF_PACK(0x00000000, 1), HUFF_PACK(0x0000000e, 4),
-             HUFF_PACK(0x000000fa, 8), HUFF_PACK(0x000007de, 11)},
-            {HUFF_PACK(0x0000000c, 4), HUFF_PACK(0x0000001e, 5),
-             HUFF_PACK(0x000000fe, 8), HUFF_PACK(0x000001f6, 9)},
-            {HUFF_PACK(0x000000ff, 8), HUFF_PACK(0x0000007c, 7),
-             HUFF_PACK(0x0000007e, 7), HUFF_PACK(0x0000001a, 5)},
-            {HUFF_PACK(0x000007df, 11), HUFF_PACK(0x000003ee, 10),
-             HUFF_PACK(0x0000001b, 5), HUFF_PACK(0x00000002, 2)}},
-           HUFF_PACK(0x00000000, 0) /* escape */
-       },
-       {
-           /* LAV5_2D */
-           {{HUFF_PACK(0x00000006, 3), HUFF_PACK(0x0000000e, 4),
-             HUFF_PACK(0x0000007c, 7), HUFF_PACK(0x000003fe, 10),
-             HUFF_PACK(0x00000fbe, 12), HUFF_PACK(0x00003efe, 14)},
-            {HUFF_PACK(0x00000000, 3), HUFF_PACK(0x00000001, 3),
-             HUFF_PACK(0x0000003c, 6), HUFF_PACK(0x0000005e, 8),
-             HUFF_PACK(0x000007de, 11), HUFF_PACK(0x000007be, 11)},
-            {HUFF_PACK(0x0000001e, 6), HUFF_PACK(0x0000000a, 5),
-             HUFF_PACK(0x0000001f, 6), HUFF_PACK(0x0000005f, 8),
-             HUFF_PACK(0x000001ee, 9), HUFF_PACK(0x000001f6, 9)},
-            {HUFF_PACK(0x000001fe, 9), HUFF_PACK(0x000000fe, 8),
-             HUFF_PACK(0x000000f6, 8), HUFF_PACK(0x000000fa, 8),
-             HUFF_PACK(0x0000007e, 7), HUFF_PACK(0x00000016, 6)},
-            {HUFF_PACK(0x000007bf, 11), HUFF_PACK(0x000003de, 10),
-             HUFF_PACK(0x000003ee, 10), HUFF_PACK(0x0000007a, 7),
-             HUFF_PACK(0x0000000e, 5), HUFF_PACK(0x00000006, 4)},
-            {HUFF_PACK(0x00003eff, 14), HUFF_PACK(0x00001f7e, 13),
-             HUFF_PACK(0x000003ff, 10), HUFF_PACK(0x0000002e, 7),
-             HUFF_PACK(0x00000004, 4), HUFF_PACK(0x00000002, 2)}},
-           HUFF_PACK(0x00000000, 0) /* escape */
-       },
-       {
-           /* LAV7_2D */
-           {{HUFF_PACK(0x00000002, 3), HUFF_PACK(0x0000000a, 4),
-             HUFF_PACK(0x0000001a, 6), HUFF_PACK(0x000001be, 9),
-             HUFF_PACK(0x000006e6, 11), HUFF_PACK(0x0000067a, 12),
-             HUFF_PACK(0x00000cf2, 13), HUFF_PACK(0x000033de, 15)},
-            {HUFF_PACK(0x0000000c, 4), HUFF_PACK(0x0000000e, 4),
-             HUFF_PACK(0x0000000e, 5), HUFF_PACK(0x000000de, 8),
-             HUFF_PACK(0x00000372, 10), HUFF_PACK(0x000003d6, 11),
-             HUFF_PACK(0x00000678, 12), HUFF_PACK(0x00000cf6, 13)},
-            {HUFF_PACK(0x00000036, 6), HUFF_PACK(0x00000012, 5),
-             HUFF_PACK(0x0000003e, 6), HUFF_PACK(0x0000003c, 7),
-             HUFF_PACK(0x000001b8, 9), HUFF_PACK(0x000003d4, 11),
-             HUFF_PACK(0x0000033e, 11), HUFF_PACK(0x0000033f, 11)},
-            {HUFF_PACK(0x0000007e, 8), HUFF_PACK(0x0000006a, 7),
-             HUFF_PACK(0x0000004e, 7), HUFF_PACK(0x0000007e, 7),
-             HUFF_PACK(0x000001ba, 9), HUFF_PACK(0x000000ce, 9),
-             HUFF_PACK(0x000000f6, 9), HUFF_PACK(0x000001ee, 10)},
-            {HUFF_PACK(0x000001ef, 10), HUFF_PACK(0x0000013e, 9),
-             HUFF_PACK(0x0000007f, 8), HUFF_PACK(0x00000066, 8),
-             HUFF_PACK(0x000000d6, 8), HUFF_PACK(0x0000003e, 7),
-             HUFF_PACK(0x000000d7, 8), HUFF_PACK(0x0000009e, 8)},
-            {HUFF_PACK(0x000007ae, 12), HUFF_PACK(0x000001e8, 10),
-             HUFF_PACK(0x000001e9, 10), HUFF_PACK(0x0000027e, 10),
-             HUFF_PACK(0x00000032, 7), HUFF_PACK(0x00000018, 6),
-             HUFF_PACK(0x00000026, 6), HUFF_PACK(0x00000034, 6)},
-            {HUFF_PACK(0x00000cf3, 13), HUFF_PACK(0x000007aa, 12),
-             HUFF_PACK(0x000007ab, 12), HUFF_PACK(0x0000027f, 10),
-             HUFF_PACK(0x000001bf, 9), HUFF_PACK(0x0000001b, 6),
-             HUFF_PACK(0x0000001e, 5), HUFF_PACK(0x0000000b, 4)},
-            {HUFF_PACK(0x000033df, 15), HUFF_PACK(0x000019ee, 14),
-             HUFF_PACK(0x000007af, 12), HUFF_PACK(0x000006e7, 11),
-             HUFF_PACK(0x000001bb, 9), HUFF_PACK(0x0000007f, 7),
-             HUFF_PACK(0x00000008, 4), HUFF_PACK(0x00000000, 2)}},
-           HUFF_PACK(0x00000000, 0) /* escape */
-       },
-       {
-           /* LAV9_2D */
-           {{HUFF_PACK(0x0000000e, 4), HUFF_PACK(0x00000008, 4),
-             HUFF_PACK(0x0000007e, 7), HUFF_PACK(0x000001fe, 9),
-             HUFF_PACK(0x000001ba, 10), HUFF_PACK(0x00000dbe, 12),
-             HUFF_PACK(0x00000d7e, 13), HUFF_PACK(0x00001af6, 14),
-             HUFF_PACK(0x00007fec, 15), HUFF_PACK(0x0001ffb6, 17)},
-            {HUFF_PACK(0x0000000a, 4), HUFF_PACK(0x0000000c, 4),
-             HUFF_PACK(0x0000000c, 5), HUFF_PACK(0x00000036, 7),
-             HUFF_PACK(0x000000de, 9), HUFF_PACK(0x000005fe, 11),
-             HUFF_PACK(0x000006be, 12), HUFF_PACK(0x00001b7e, 13),
-             HUFF_PACK(0x00007fee, 15), HUFF_PACK(0x00006dfe, 15)},
-            {HUFF_PACK(0x0000001e, 6), HUFF_PACK(0x0000000e, 5),
-             HUFF_PACK(0x0000000a, 5), HUFF_PACK(0x0000006a, 7),
-             HUFF_PACK(0x000001ae, 9), HUFF_PACK(0x000006fe, 11),
-             HUFF_PACK(0x00000376, 11), HUFF_PACK(0x00000dfe, 13),
-             HUFF_PACK(0x00000dff, 13), HUFF_PACK(0x00000d7f, 13)},
-            {HUFF_PACK(0x000000b6, 8), HUFF_PACK(0x0000005e, 7),
-             HUFF_PACK(0x0000007c, 7), HUFF_PACK(0x0000006e, 7),
-             HUFF_PACK(0x0000006a, 8), HUFF_PACK(0x0000016a, 9),
-             HUFF_PACK(0x00000ffe, 12), HUFF_PACK(0x00000dfe, 12),
-             HUFF_PACK(0x00000ffc, 12), HUFF_PACK(0x00001bfe, 13)},
-            {HUFF_PACK(0x0000035e, 10), HUFF_PACK(0x000001b6, 9),
-             HUFF_PACK(0x0000005e, 8), HUFF_PACK(0x000000b4, 8),
-             HUFF_PACK(0x0000006c, 7), HUFF_PACK(0x0000017e, 9),
-             HUFF_PACK(0x0000036e, 10), HUFF_PACK(0x000003ee, 10),
-             HUFF_PACK(0x0000037e, 11), HUFF_PACK(0x00000377, 11)},
-            {HUFF_PACK(0x00000fff, 12), HUFF_PACK(0x000001ae, 10),
-             HUFF_PACK(0x000001be, 10), HUFF_PACK(0x000001f6, 9),
-             HUFF_PACK(0x000001be, 9), HUFF_PACK(0x000000da, 8),
-             HUFF_PACK(0x000000fe, 8), HUFF_PACK(0x0000016b, 9),
-             HUFF_PACK(0x000000d6, 9), HUFF_PACK(0x0000037e, 10)},
-            {HUFF_PACK(0x000017fe, 13), HUFF_PACK(0x00000bfe, 12),
-             HUFF_PACK(0x000007de, 11), HUFF_PACK(0x000006de, 11),
-             HUFF_PACK(0x000001b8, 10), HUFF_PACK(0x000000d6, 8),
-             HUFF_PACK(0x0000002e, 7), HUFF_PACK(0x00000034, 7),
-             HUFF_PACK(0x000000de, 8), HUFF_PACK(0x000000be, 8)},
-            {HUFF_PACK(0x00007fef, 15), HUFF_PACK(0x000006bc, 12),
-             HUFF_PACK(0x00001bff, 13), HUFF_PACK(0x00001ffa, 13),
-             HUFF_PACK(0x000001b9, 10), HUFF_PACK(0x000003fe, 10),
-             HUFF_PACK(0x000000fa, 8), HUFF_PACK(0x0000002e, 6),
-             HUFF_PACK(0x00000034, 6), HUFF_PACK(0x0000001f, 6)},
-            {HUFF_PACK(0x00006dff, 15), HUFF_PACK(0x00001af7, 14),
-             HUFF_PACK(0x000036fe, 14), HUFF_PACK(0x000006fe, 12),
-             HUFF_PACK(0x00000fbe, 12), HUFF_PACK(0x0000035f, 10),
-             HUFF_PACK(0x000000b7, 8), HUFF_PACK(0x0000002c, 6),
-             HUFF_PACK(0x0000001e, 5), HUFF_PACK(0x00000009, 4)},
-            {HUFF_PACK(0x0001ffb7, 17), HUFF_PACK(0x0000ffda, 16),
-             HUFF_PACK(0x00000d7a, 13), HUFF_PACK(0x000017ff, 13),
-             HUFF_PACK(0x00000fbf, 12), HUFF_PACK(0x000002fe, 10),
-             HUFF_PACK(0x0000005f, 8), HUFF_PACK(0x00000016, 6),
-             HUFF_PACK(0x00000004, 4), HUFF_PACK(0x00000000, 2)}},
-           HUFF_PACK(0x00000000, 0) /* escape */
-       }}}}};
-
-const HUFF_ICC_TABLE fdk_sacenc_huffICCTab = {
-    {/* h1D[2][8] */
-     {HUFF_PACK(0x00000000, 1), HUFF_PACK(0x00000002, 2),
-      HUFF_PACK(0x00000006, 3), HUFF_PACK(0x0000000e, 4),
-      HUFF_PACK(0x0000001e, 5), HUFF_PACK(0x0000003e, 6),
-      HUFF_PACK(0x0000007e, 7), HUFF_PACK(0x0000007f, 7)},
-     {HUFF_PACK(0x00000000, 1), HUFF_PACK(0x00000002, 2),
-      HUFF_PACK(0x00000006, 3), HUFF_PACK(0x0000000e, 4),
-      HUFF_PACK(0x0000001e, 5), HUFF_PACK(0x0000003e, 6),
-      HUFF_PACK(0x0000007e, 7), HUFF_PACK(0x0000007f, 7)}},
-    {  /* HUFF_ICC_TAB_2D */
-     { /* HUFF_ICC_TAB_2D[0][] */
-      {/* HUFF_ICC_TAB_2D[0][0] */
-       {
-           /* LAV1_2D */
-           {{HUFF_PACK(0x00000000, 1), HUFF_PACK(0x00000006, 3)},
-            {HUFF_PACK(0x00000007, 3), HUFF_PACK(0x00000002, 2)}},
-           HUFF_PACK(0x00000000, 0) /* escape */
-       },
-       {
-           /* LAV3_2D */
-           {{HUFF_PACK(0x00000002, 2), HUFF_PACK(0x00000000, 2),
-             HUFF_PACK(0x0000000a, 5), HUFF_PACK(0x0000007e, 8)},
-            {HUFF_PACK(0x0000000e, 5), HUFF_PACK(0x00000004, 4),
-             HUFF_PACK(0x00000016, 6), HUFF_PACK(0x000003fe, 11)},
-            {HUFF_PACK(0x000001fe, 10), HUFF_PACK(0x000000fe, 9),
-             HUFF_PACK(0x0000003e, 7), HUFF_PACK(0x0000001e, 6)},
-            {HUFF_PACK(0x000003ff, 11), HUFF_PACK(0x00000017, 6),
-             HUFF_PACK(0x00000006, 4), HUFF_PACK(0x00000003, 2)}},
-           HUFF_PACK(0x00000000, 0) /* escape */
-       },
-       {
-           /* LAV5_2D */
-           {{HUFF_PACK(0x00000000, 2), HUFF_PACK(0x00000002, 3),
-             HUFF_PACK(0x0000000c, 5), HUFF_PACK(0x0000006a, 7),
-             HUFF_PACK(0x000000dc, 8), HUFF_PACK(0x000006ee, 11)},
-            {HUFF_PACK(0x0000001e, 5), HUFF_PACK(0x0000000c, 4),
-             HUFF_PACK(0x0000000d, 5), HUFF_PACK(0x0000001e, 6),
-             HUFF_PACK(0x000001ae, 9), HUFF_PACK(0x0000ddff, 16)},
-            {HUFF_PACK(0x000000de, 8), HUFF_PACK(0x0000007e, 7),
-             HUFF_PACK(0x0000001f, 6), HUFF_PACK(0x000001be, 9),
-             HUFF_PACK(0x00006efe, 15), HUFF_PACK(0x0000ddfe, 16)},
-            {HUFF_PACK(0x0000377e, 14), HUFF_PACK(0x00001bbe, 13),
-             HUFF_PACK(0x00000dde, 12), HUFF_PACK(0x000001bf, 9),
-             HUFF_PACK(0x000000d6, 8), HUFF_PACK(0x00000376, 10)},
-            {HUFF_PACK(0x0000ddff, 16), HUFF_PACK(0x0000ddff, 16),
-             HUFF_PACK(0x000001ba, 9), HUFF_PACK(0x00000034, 6),
-             HUFF_PACK(0x0000003e, 6), HUFF_PACK(0x0000000e, 5)},
-            {HUFF_PACK(0x0000ddff, 16), HUFF_PACK(0x000001af, 9),
-             HUFF_PACK(0x0000007f, 7), HUFF_PACK(0x00000036, 6),
-             HUFF_PACK(0x0000000e, 4), HUFF_PACK(0x00000002, 2)}},
-           HUFF_PACK(0x0000ddff, 16) /* escape */
-       },
-       {
-           /* LAV7_2D */
-           {{HUFF_PACK(0x00000000, 2), HUFF_PACK(0x0000000c, 4),
-             HUFF_PACK(0x0000002e, 6), HUFF_PACK(0x00000044, 7),
-             HUFF_PACK(0x00000086, 8), HUFF_PACK(0x0000069e, 11),
-             HUFF_PACK(0x0000043e, 11), HUFF_PACK(0x0000087a, 12)},
-            {HUFF_PACK(0x0000001e, 5), HUFF_PACK(0x0000000e, 4),
-             HUFF_PACK(0x0000002a, 6), HUFF_PACK(0x00000046, 7),
-             HUFF_PACK(0x0000015e, 9), HUFF_PACK(0x00000047, 7),
-             HUFF_PACK(0x0000034a, 10), HUFF_PACK(0x0000087b, 12)},
-            {HUFF_PACK(0x000000d6, 8), HUFF_PACK(0x00000026, 6),
-             HUFF_PACK(0x0000002f, 6), HUFF_PACK(0x000000d7, 8),
-             HUFF_PACK(0x0000006a, 7), HUFF_PACK(0x0000034e, 10),
-             HUFF_PACK(0x0000087b, 12), HUFF_PACK(0x0000087b, 12)},
-            {HUFF_PACK(0x000002be, 10), HUFF_PACK(0x000001a6, 9),
-             HUFF_PACK(0x000001be, 9), HUFF_PACK(0x00000012, 5),
-             HUFF_PACK(0x000001bf, 9), HUFF_PACK(0x0000087b, 12),
-             HUFF_PACK(0x0000087b, 12), HUFF_PACK(0x0000087b, 12)},
-            {HUFF_PACK(0x0000087b, 12), HUFF_PACK(0x0000087b, 12),
-             HUFF_PACK(0x0000087b, 12), HUFF_PACK(0x0000087b, 12),
-             HUFF_PACK(0x00000036, 6), HUFF_PACK(0x000000d0, 8),
-             HUFF_PACK(0x0000043c, 11), HUFF_PACK(0x0000043f, 11)},
-            {HUFF_PACK(0x0000087b, 12), HUFF_PACK(0x0000087b, 12),
-             HUFF_PACK(0x0000087b, 12), HUFF_PACK(0x0000034b, 10),
-             HUFF_PACK(0x00000027, 6), HUFF_PACK(0x00000020, 6),
-             HUFF_PACK(0x00000042, 7), HUFF_PACK(0x000000d1, 8)},
-            {HUFF_PACK(0x0000087b, 12), HUFF_PACK(0x0000087b, 12),
-             HUFF_PACK(0x000002bf, 10), HUFF_PACK(0x000000de, 8),
-             HUFF_PACK(0x000000ae, 8), HUFF_PACK(0x00000056, 7),
-             HUFF_PACK(0x00000016, 5), HUFF_PACK(0x00000014, 5)},
-            {HUFF_PACK(0x0000087b, 12), HUFF_PACK(0x0000069f, 11),
-             HUFF_PACK(0x000001a4, 9), HUFF_PACK(0x0000010e, 9),
-             HUFF_PACK(0x00000045, 7), HUFF_PACK(0x0000006e, 7),
-             HUFF_PACK(0x0000001f, 5), HUFF_PACK(0x00000001, 2)}},
-           HUFF_PACK(0x0000087b, 12) /* escape */
-       }},
-      {/* HUFF_ICC_TAB_2D[0][1] */
-       {
-           /* LAV1_2D */
-           {{HUFF_PACK(0x00000000, 1), HUFF_PACK(0x00000006, 3)},
-            {HUFF_PACK(0x00000007, 3), HUFF_PACK(0x00000002, 2)}},
-           HUFF_PACK(0x00000000, 0) /* escape */
-       },
-       {
-           /* LAV3_2D */
-           {{HUFF_PACK(0x00000002, 2), HUFF_PACK(0x00000004, 4),
-             HUFF_PACK(0x0000017e, 10), HUFF_PACK(0x000002fe, 11)},
-            {HUFF_PACK(0x00000000, 2), HUFF_PACK(0x0000000e, 5),
-             HUFF_PACK(0x000000be, 9), HUFF_PACK(0x00000016, 6)},
-            {HUFF_PACK(0x0000000f, 5), HUFF_PACK(0x00000014, 6),
-             HUFF_PACK(0x0000005e, 8), HUFF_PACK(0x00000006, 4)},
-            {HUFF_PACK(0x0000002e, 7), HUFF_PACK(0x000002ff, 11),
-             HUFF_PACK(0x00000015, 6), HUFF_PACK(0x00000003, 2)}},
-           HUFF_PACK(0x00000000, 0) /* escape */
-       },
-       {
-           /* LAV5_2D */
-           {{HUFF_PACK(0x00000000, 2), HUFF_PACK(0x0000001e, 5),
-             HUFF_PACK(0x000003fc, 10), HUFF_PACK(0x0000fffa, 16),
-             HUFF_PACK(0x000fff9e, 20), HUFF_PACK(0x000fff9f, 20)},
-            {HUFF_PACK(0x00000006, 3), HUFF_PACK(0x00000004, 4),
-             HUFF_PACK(0x000000be, 9), HUFF_PACK(0x00007ffe, 15),
-             HUFF_PACK(0x0007ffce, 19), HUFF_PACK(0x000000fe, 8)},
-            {HUFF_PACK(0x00000006, 4), HUFF_PACK(0x0000001e, 6),
-             HUFF_PACK(0x000003fd, 10), HUFF_PACK(0x0000fffb, 16),
-             HUFF_PACK(0x00000ffe, 12), HUFF_PACK(0x0000003e, 6)},
-            {HUFF_PACK(0x0000000a, 5), HUFF_PACK(0x0000007e, 7),
-             HUFF_PACK(0x00001ffe, 13), HUFF_PACK(0x00007fff, 15),
-             HUFF_PACK(0x0000005e, 8), HUFF_PACK(0x0000000e, 5)},
-            {HUFF_PACK(0x0000001f, 6), HUFF_PACK(0x000003fe, 10),
-             HUFF_PACK(0x0001fff2, 17), HUFF_PACK(0x00000ffc, 12),
-             HUFF_PACK(0x0000002e, 7), HUFF_PACK(0x0000000e, 4)},
-            {HUFF_PACK(0x000000bf, 9), HUFF_PACK(0x0003ffe6, 18),
-             HUFF_PACK(0x0000fff8, 16), HUFF_PACK(0x00000ffd, 12),
-             HUFF_PACK(0x00000016, 6), HUFF_PACK(0x00000002, 2)}},
-           HUFF_PACK(0x00000000, 0) /* escape */
-       },
-       {
-           /* LAV7_2D */
-           {{HUFF_PACK(0x00000002, 2), HUFF_PACK(0x0000001e, 6),
-             HUFF_PACK(0x00000ffe, 12), HUFF_PACK(0x0000ffff, 16),
-             HUFF_PACK(0x0000fffe, 16), HUFF_PACK(0x0000ffff, 16),
-             HUFF_PACK(0x0000ffff, 16), HUFF_PACK(0x0000ffff, 16)},
-            {HUFF_PACK(0x00000006, 3), HUFF_PACK(0x00000008, 5),
-             HUFF_PACK(0x000007fe, 11), HUFF_PACK(0x0000ffff, 16),
-             HUFF_PACK(0x0000ffff, 16), HUFF_PACK(0x0000ffff, 16),
-             HUFF_PACK(0x0000ffff, 16), HUFF_PACK(0x0000005a, 8)},
-            {HUFF_PACK(0x00000006, 4), HUFF_PACK(0x0000007a, 7),
-             HUFF_PACK(0x00000164, 10), HUFF_PACK(0x00007ffa, 15),
-             HUFF_PACK(0x0000ffff, 16), HUFF_PACK(0x0000ffff, 16),
-             HUFF_PACK(0x00001fee, 13), HUFF_PACK(0x0000003c, 6)},
-            {HUFF_PACK(0x0000000e, 5), HUFF_PACK(0x000000fe, 8),
-             HUFF_PACK(0x000002ce, 11), HUFF_PACK(0x000002cf, 11),
-             HUFF_PACK(0x00007ffb, 15), HUFF_PACK(0x00001fec, 13),
-             HUFF_PACK(0x000000b0, 9), HUFF_PACK(0x0000002e, 7)},
-            {HUFF_PACK(0x0000003e, 6), HUFF_PACK(0x000003fe, 10),
-             HUFF_PACK(0x00000165, 10), HUFF_PACK(0x00007ffc, 15),
-             HUFF_PACK(0x00001fef, 13), HUFF_PACK(0x000007fa, 11),
-             HUFF_PACK(0x000007f8, 11), HUFF_PACK(0x0000001f, 6)},
-            {HUFF_PACK(0x0000002f, 7), HUFF_PACK(0x000000f6, 8),
-             HUFF_PACK(0x00001fed, 13), HUFF_PACK(0x0000ffff, 16),
-             HUFF_PACK(0x00007ffd, 15), HUFF_PACK(0x00000ff2, 12),
-             HUFF_PACK(0x000000b1, 9), HUFF_PACK(0x0000000a, 5)},
-            {HUFF_PACK(0x00000009, 5), HUFF_PACK(0x00000166, 10),
-             HUFF_PACK(0x0000ffff, 16), HUFF_PACK(0x0000ffff, 16),
-             HUFF_PACK(0x00007ffe, 15), HUFF_PACK(0x00003ffc, 14),
-             HUFF_PACK(0x0000005b, 8), HUFF_PACK(0x0000000e, 4)},
-            {HUFF_PACK(0x0000007e, 7), HUFF_PACK(0x0000ffff, 16),
-             HUFF_PACK(0x0000ffff, 16), HUFF_PACK(0x0000ffff, 16),
-             HUFF_PACK(0x0000ffff, 16), HUFF_PACK(0x00000ff3, 12),
-             HUFF_PACK(0x000000f7, 8), HUFF_PACK(0x00000000, 2)}},
-           HUFF_PACK(0x0000ffff, 16) /* escape */
-       }}},
-     { /* HUFF_ICC_TAB_2D[1][] */
-      {/* HUFF_ICC_TAB_2D[1][0] */
-       {
-           /* LAV1_2D */
-           {{HUFF_PACK(0x00000000, 1), HUFF_PACK(0x00000006, 3)},
-            {HUFF_PACK(0x00000007, 3), HUFF_PACK(0x00000002, 2)}},
-           HUFF_PACK(0x00000000, 0) /* escape */
-       },
-       {
-           /* LAV3_2D */
-           {{HUFF_PACK(0x00000002, 2), HUFF_PACK(0x0000000e, 4),
-             HUFF_PACK(0x0000037e, 10), HUFF_PACK(0x00000dfe, 12)},
-            {HUFF_PACK(0x0000000f, 4), HUFF_PACK(0x0000000c, 4),
-             HUFF_PACK(0x000001ba, 9), HUFF_PACK(0x000001bb, 9)},
-            {HUFF_PACK(0x000000de, 8), HUFF_PACK(0x000000dc, 8),
-             HUFF_PACK(0x000001be, 9), HUFF_PACK(0x0000001a, 5)},
-            {HUFF_PACK(0x000006fe, 11), HUFF_PACK(0x00000dff, 12),
-             HUFF_PACK(0x00000036, 6), HUFF_PACK(0x00000000, 1)}},
-           HUFF_PACK(0x00000000, 0) /* escape */
-       },
-       {
-           /* LAV5_2D */
-           {{HUFF_PACK(0x00000000, 1), HUFF_PACK(0x0000000c, 4),
-             HUFF_PACK(0x000001b6, 9), HUFF_PACK(0x00001b7c, 13),
-             HUFF_PACK(0x0000dbfe, 16), HUFF_PACK(0x00036fff, 18)},
-            {HUFF_PACK(0x0000000e, 4), HUFF_PACK(0x0000001e, 5),
-             HUFF_PACK(0x000001be, 9), HUFF_PACK(0x00000dfe, 12),
-             HUFF_PACK(0x00036ffe, 18), HUFF_PACK(0x0000036e, 10)},
-            {HUFF_PACK(0x0000006e, 7), HUFF_PACK(0x000000fe, 8),
-             HUFF_PACK(0x000000d8, 8), HUFF_PACK(0x000036fe, 14),
-             HUFF_PACK(0x000006de, 11), HUFF_PACK(0x000000de, 8)},
-            {HUFF_PACK(0x000001fa, 9), HUFF_PACK(0x000000da, 8),
-             HUFF_PACK(0x00000dff, 12), HUFF_PACK(0x00001b7e, 13),
-             HUFF_PACK(0x000000d9, 8), HUFF_PACK(0x000000ff, 8)},
-            {HUFF_PACK(0x000003f6, 10), HUFF_PACK(0x000006fe, 11),
-             HUFF_PACK(0x00006dfe, 15), HUFF_PACK(0x0000037e, 10),
-             HUFF_PACK(0x000000fc, 8), HUFF_PACK(0x0000001a, 5)},
-            {HUFF_PACK(0x000007ee, 11), HUFF_PACK(0x0001b7fe, 17),
-             HUFF_PACK(0x00001b7d, 13), HUFF_PACK(0x000007ef, 11),
-             HUFF_PACK(0x0000003e, 6), HUFF_PACK(0x00000002, 2)}},
-           HUFF_PACK(0x00036fff, 18) /* escape */
-       },
-       {
-           /* LAV7_2D */
-           {{HUFF_PACK(0x00000000, 1), HUFF_PACK(0x0000000c, 4),
-             HUFF_PACK(0x000007ee, 11), HUFF_PACK(0x00001e7e, 13),
-             HUFF_PACK(0x00003cfe, 14), HUFF_PACK(0x000079ff, 15),
-             HUFF_PACK(0x000079ff, 15), HUFF_PACK(0x000079ff, 15)},
-            {HUFF_PACK(0x0000000e, 4), HUFF_PACK(0x0000001a, 5),
-             HUFF_PACK(0x000001e6, 9), HUFF_PACK(0x00001fbe, 13),
-             HUFF_PACK(0x000079fe, 15), HUFF_PACK(0x000079ff, 15),
-             HUFF_PACK(0x000079ff, 15), HUFF_PACK(0x000006fc, 11)},
-            {HUFF_PACK(0x0000006c, 7), HUFF_PACK(0x000000f6, 8),
-             HUFF_PACK(0x000001ba, 9), HUFF_PACK(0x00000dfc, 12),
-             HUFF_PACK(0x00000dfd, 12), HUFF_PACK(0x000079ff, 15),
-             HUFF_PACK(0x00000f3e, 12), HUFF_PACK(0x000001bb, 9)},
-            {HUFF_PACK(0x000000dc, 8), HUFF_PACK(0x000001fe, 9),
-             HUFF_PACK(0x0000036e, 10), HUFF_PACK(0x000003fe, 10),
-             HUFF_PACK(0x000079ff, 15), HUFF_PACK(0x00000fde, 12),
-             HUFF_PACK(0x000001ee, 9), HUFF_PACK(0x000000f2, 8)},
-            {HUFF_PACK(0x000001fa, 9), HUFF_PACK(0x000003f6, 10),
-             HUFF_PACK(0x000001be, 9), HUFF_PACK(0x000079ff, 15),
-             HUFF_PACK(0x00001fbf, 13), HUFF_PACK(0x000003ce, 10),
-             HUFF_PACK(0x000003ff, 10), HUFF_PACK(0x000000de, 8)},
-            {HUFF_PACK(0x00000078, 7), HUFF_PACK(0x000000da, 8),
-             HUFF_PACK(0x000079ff, 15), HUFF_PACK(0x000079ff, 15),
-             HUFF_PACK(0x000006fd, 11), HUFF_PACK(0x0000036c, 10),
-             HUFF_PACK(0x000001ef, 9), HUFF_PACK(0x000000fe, 8)},
-            {HUFF_PACK(0x0000036f, 10), HUFF_PACK(0x00000dfe, 12),
-             HUFF_PACK(0x000079ff, 15), HUFF_PACK(0x000079ff, 15),
-             HUFF_PACK(0x000079ff, 15), HUFF_PACK(0x0000036d, 10),
-             HUFF_PACK(0x000000fc, 8), HUFF_PACK(0x0000003e, 6)},
-            {HUFF_PACK(0x00000dff, 12), HUFF_PACK(0x000079ff, 15),
-             HUFF_PACK(0x000079ff, 15), HUFF_PACK(0x000079ff, 15),
-             HUFF_PACK(0x000079ff, 15), HUFF_PACK(0x0000079e, 11),
-             HUFF_PACK(0x0000007a, 7), HUFF_PACK(0x00000002, 2)}},
-           HUFF_PACK(0x000079ff, 15) /* escape */
-       }},
-      {/* HUFF_ICC_TAB_2D[1][1] */
-       {
-           /* LAV1_2D */
-           {{HUFF_PACK(0x00000000, 1), HUFF_PACK(0x00000006, 3)},
-            {HUFF_PACK(0x00000007, 3), HUFF_PACK(0x00000002, 2)}},
-           HUFF_PACK(0x00000000, 0) /* escape */
-       },
-       {
-           /* LAV3_2D */
-           {{HUFF_PACK(0x00000002, 2), HUFF_PACK(0x0000000e, 4),
-             HUFF_PACK(0x000000fc, 8), HUFF_PACK(0x00000fde, 12)},
-            {HUFF_PACK(0x0000000c, 4), HUFF_PACK(0x0000000d, 4),
-             HUFF_PACK(0x000001fe, 9), HUFF_PACK(0x000007ee, 11)},
-            {HUFF_PACK(0x000001fa, 9), HUFF_PACK(0x000001ff, 9),
-             HUFF_PACK(0x000000fe, 8), HUFF_PACK(0x0000003e, 6)},
-            {HUFF_PACK(0x00000fdf, 12), HUFF_PACK(0x000003f6, 10),
-             HUFF_PACK(0x0000001e, 5), HUFF_PACK(0x00000000, 1)}},
-           HUFF_PACK(0x00000000, 0) /* escape */
-       },
-       {
-           /* LAV5_2D */
-           {{HUFF_PACK(0x00000000, 2), HUFF_PACK(0x0000000e, 4),
-             HUFF_PACK(0x0000003a, 7), HUFF_PACK(0x00000676, 11),
-             HUFF_PACK(0x000019fe, 13), HUFF_PACK(0x0000cebe, 16)},
-            {HUFF_PACK(0x0000000f, 4), HUFF_PACK(0x00000002, 3),
-             HUFF_PACK(0x0000001e, 6), HUFF_PACK(0x000000fe, 9),
-             HUFF_PACK(0x000019d6, 13), HUFF_PACK(0x0000675e, 15)},
-            {HUFF_PACK(0x0000003e, 7), HUFF_PACK(0x00000032, 6),
-             HUFF_PACK(0x00000018, 5), HUFF_PACK(0x0000033e, 10),
-             HUFF_PACK(0x00000cfe, 12), HUFF_PACK(0x00000677, 11)},
-            {HUFF_PACK(0x00000674, 11), HUFF_PACK(0x0000019c, 9),
-             HUFF_PACK(0x000000ff, 9), HUFF_PACK(0x0000003b, 7),
-             HUFF_PACK(0x0000001c, 6), HUFF_PACK(0x0000007e, 8)},
-            {HUFF_PACK(0x000033fe, 14), HUFF_PACK(0x000033ff, 14),
-             HUFF_PACK(0x00000cea, 12), HUFF_PACK(0x00000066, 7),
-             HUFF_PACK(0x0000001a, 5), HUFF_PACK(0x00000006, 4)},
-            {HUFF_PACK(0x0000cebf, 16), HUFF_PACK(0x000033ae, 14),
-             HUFF_PACK(0x0000067e, 11), HUFF_PACK(0x0000019e, 9),
-             HUFF_PACK(0x0000001b, 5), HUFF_PACK(0x00000002, 2)}},
-           HUFF_PACK(0x00000000, 0) /* escape */
-       },
-       {
-           /* LAV7_2D */
-           {{HUFF_PACK(0x00000002, 2), HUFF_PACK(0x00000002, 4),
-             HUFF_PACK(0x000000fe, 9), HUFF_PACK(0x000007be, 12),
-             HUFF_PACK(0x00000ffc, 13), HUFF_PACK(0x00000ffd, 13),
-             HUFF_PACK(0x00001efe, 15), HUFF_PACK(0x00003dfe, 16)},
-            {HUFF_PACK(0x00000004, 4), HUFF_PACK(0x00000000, 3),
-             HUFF_PACK(0x0000003c, 7), HUFF_PACK(0x000000f6, 10),
-             HUFF_PACK(0x000001da, 11), HUFF_PACK(0x000003fe, 12),
-             HUFF_PACK(0x00003dfe, 15), HUFF_PACK(0x00003dff, 16)},
-            {HUFF_PACK(0x0000003c, 8), HUFF_PACK(0x0000003e, 7),
-             HUFF_PACK(0x0000000a, 5), HUFF_PACK(0x0000003a, 8),
-             HUFF_PACK(0x000003de, 11), HUFF_PACK(0x000007be, 13),
-             HUFF_PACK(0x00000f7e, 14), HUFF_PACK(0x00001efe, 14)},
-            {HUFF_PACK(0x000001de, 11), HUFF_PACK(0x000000ec, 10),
-             HUFF_PACK(0x0000007e, 9), HUFF_PACK(0x0000000c, 5),
-             HUFF_PACK(0x000001ee, 10), HUFF_PACK(0x00000f7e, 13),
-             HUFF_PACK(0x000007fc, 12), HUFF_PACK(0x00003dff, 15)},
-            {HUFF_PACK(0x00007ffe, 16), HUFF_PACK(0x000003be, 12),
-             HUFF_PACK(0x000000fe, 10), HUFF_PACK(0x000001fe, 10),
-             HUFF_PACK(0x0000001a, 6), HUFF_PACK(0x0000001c, 7),
-             HUFF_PACK(0x000007fd, 12), HUFF_PACK(0x00000ffe, 13)},
-            {HUFF_PACK(0x00003dff, 16), HUFF_PACK(0x000003bf, 12),
-             HUFF_PACK(0x00001ffe, 14), HUFF_PACK(0x000003ff, 12),
-             HUFF_PACK(0x0000003e, 8), HUFF_PACK(0x0000001b, 6),
-             HUFF_PACK(0x0000007e, 8), HUFF_PACK(0x000000f6, 9)},
-            {HUFF_PACK(0x00007fff, 16), HUFF_PACK(0x00003dff, 16),
-             HUFF_PACK(0x00003ffe, 15), HUFF_PACK(0x000001db, 11),
-             HUFF_PACK(0x000000ee, 10), HUFF_PACK(0x0000007a, 8),
-             HUFF_PACK(0x0000000e, 5), HUFF_PACK(0x0000000b, 5)},
-            {HUFF_PACK(0x00003dff, 16), HUFF_PACK(0x00003dff, 16),
-             HUFF_PACK(0x000003de, 12), HUFF_PACK(0x000001fe, 11),
-             HUFF_PACK(0x000001ee, 11), HUFF_PACK(0x0000007a, 9),
-             HUFF_PACK(0x00000006, 5), HUFF_PACK(0x00000003, 2)}},
-           HUFF_PACK(0x00003dff, 16) /* escape */
-       }}}}};
-
-const HUFF_PT0_TABLE fdk_sacenc_huffPart0Tab = {
-    {/* CLD */
-     HUFF_PACK(0x00000052, 8), HUFF_PACK(0x000000ae, 9),
-     HUFF_PACK(0x000000af, 9), HUFF_PACK(0x00000028, 7),
-     HUFF_PACK(0x0000006e, 7), HUFF_PACK(0x00000036, 6),
-     HUFF_PACK(0x0000001e, 5), HUFF_PACK(0x0000000e, 4),
-     HUFF_PACK(0x0000000c, 4), HUFF_PACK(0x0000000a, 4),
-     HUFF_PACK(0x00000002, 4), HUFF_PACK(0x00000016, 5),
-     HUFF_PACK(0x00000012, 5), HUFF_PACK(0x00000017, 5),
-     HUFF_PACK(0x00000000, 4), HUFF_PACK(0x00000004, 4),
-     HUFF_PACK(0x00000006, 4), HUFF_PACK(0x00000008, 4),
-     HUFF_PACK(0x00000007, 4), HUFF_PACK(0x00000003, 4),
-     HUFF_PACK(0x00000001, 4), HUFF_PACK(0x0000001a, 5),
-     HUFF_PACK(0x00000013, 5), HUFF_PACK(0x0000003e, 6),
-     HUFF_PACK(0x00000016, 6), HUFF_PACK(0x00000017, 6),
-     HUFF_PACK(0x0000006f, 7), HUFF_PACK(0x0000002a, 7),
-     HUFF_PACK(0x00000056, 8), HUFF_PACK(0x00000053, 8),
-     HUFF_PACK(0x0000003f, 6)},
-    {/* ICC */
-     HUFF_PACK(0x0000001e, 5), HUFF_PACK(0x0000000e, 4),
-     HUFF_PACK(0x00000006, 3), HUFF_PACK(0x00000000, 2),
-     HUFF_PACK(0x00000002, 2), HUFF_PACK(0x00000001, 2),
-     HUFF_PACK(0x0000003e, 6), HUFF_PACK(0x0000003f, 6)}};
-
-/* Function / Class Declarations *********************************************/
-
-/* Function / Class Definition ***********************************************/
--- a/libSACenc/src/sacenc_huff_tab.h
+++ /dev/null
@@ -1,222 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround encoder library *************************
-
-   Author(s):   Markus Lohwasser
-
-   Description: SAC-Encoder constant huffman tables
-
-*******************************************************************************/
-
-#ifndef SACENC_HUFF_TAB_H
-#define SACENC_HUFF_TAB_H
-
-/* Includes ******************************************************************/
-#include "machine_type.h"
-
-/* Defines *******************************************************************/
-#define HUFF_PACK(a, b)                                    \
-  {                                                        \
-    ((((ULONG)a) & 0x00FFFFFF) << 8) | (((ULONG)b) & 0xFF) \
-  } /*!< Pack huffman value and length information. */
-#define HUFF_VALUE(a)                                                         \
-  (((a.packed >> 8) & 0x00FFFFFF)) /*!< Return value from packed table entry. \
-                                    */
-#define HUFF_LENGTH(a) \
-  ((a.packed & 0xFF)) /*!< Return length from packed table entry. */
-
-/* Data Types ****************************************************************/
-/**
- * \brief  This struct contains packed huffman entries.
- *
- * The packed entry consist of hffman value and length information.
- *
- *   |---------------------------------|
- *   |         value          | length |
- *   |---------------------------------|
- *   |<------- 31...8 ------->|< 7..0 >|
- */
-typedef struct {
-  ULONG packed; /*! Packed huffman entry:
-                    - lower 8 bit are reservoed for length information
-                    - upper 24 bit contains huffman value */
-} HUFF_ENTRY;
-
-typedef struct {
-  HUFF_ENTRY entry[2][2];
-  HUFF_ENTRY escape;
-
-} LAV1_2D;
-
-typedef struct {
-  HUFF_ENTRY entry[4][4];
-  HUFF_ENTRY escape;
-
-} LAV3_2D;
-
-typedef struct {
-  HUFF_ENTRY entry[6][6];
-  HUFF_ENTRY escape;
-
-} LAV5_2D;
-
-typedef struct {
-  HUFF_ENTRY entry[7][7];
-  HUFF_ENTRY escape;
-
-} LAV6_2D;
-
-typedef struct {
-  HUFF_ENTRY entry[8][8];
-  HUFF_ENTRY escape;
-
-} LAV7_2D;
-
-typedef struct {
-  HUFF_ENTRY entry[10][10];
-  HUFF_ENTRY escape;
-
-} LAV9_2D;
-
-typedef struct {
-  HUFF_ENTRY entry[13][13];
-  HUFF_ENTRY escape;
-
-} LAV12_2D;
-
-typedef struct {
-  LAV3_2D lav3;
-  LAV5_2D lav5;
-  LAV7_2D lav7;
-  LAV9_2D lav9;
-
-} HUFF_CLD_TAB_2D;
-
-typedef struct {
-  LAV1_2D lav1;
-  LAV3_2D lav3;
-  LAV5_2D lav5;
-  LAV7_2D lav7;
-
-} HUFF_ICC_TAB_2D;
-
-typedef struct {
-  HUFF_ENTRY h1D[2][31];
-  HUFF_CLD_TAB_2D h2D[2][2];
-
-} HUFF_CLD_TABLE;
-
-typedef struct {
-  HUFF_ENTRY h1D[2][8];
-  HUFF_ICC_TAB_2D h2D[2][2];
-
-} HUFF_ICC_TABLE;
-
-typedef struct {
-  HUFF_ENTRY cld[31];
-  HUFF_ENTRY icc[8];
-
-} HUFF_PT0_TABLE;
-
-typedef HUFF_ENTRY HUFF_RES_TABLE[5][8];
-
-/* Constants *****************************************************************/
-extern const HUFF_CLD_TABLE fdk_sacenc_huffCLDTab;
-extern const HUFF_ICC_TABLE fdk_sacenc_huffICCTab;
-extern const HUFF_PT0_TABLE fdk_sacenc_huffPart0Tab;
-
-/* Function / Class Declarations *********************************************/
-
-#endif /* SACENC_HUFF_TAB_H */
--- a/libSACenc/src/sacenc_lib.cpp
+++ /dev/null
@@ -1,2042 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround encoder library *************************
-
-   Author(s):   Max Neuendorf
-
-   Description: Encoder Library Interface
-                Interface to Spacial Audio Coding Encoder lib
-
-*******************************************************************************/
-
-/****************************************************************************
-\file
-Description of file contents
-******************************************************************************/
-
-/* Includes ******************************************************************/
-#include "sacenc_lib.h"
-#include "sacenc_const.h"
-#include "genericStds.h"
-#include "FDK_core.h"
-#include "sacenc_tree.h"
-#include "sacenc_bitstream.h"
-#include "sacenc_onsetdetect.h"
-#include "sacenc_framewindowing.h"
-#include "sacenc_filter.h"
-#include "sacenc_paramextract.h"
-#include "sacenc_staticgain.h"
-#include "sacenc_delay.h"
-#include "sacenc_dmx_tdom_enh.h"
-#include "sacenc_vectorfunctions.h"
-#include "qmf.h"
-
-/* Defines *******************************************************************/
-
-/* Encoder library info */
-#define SACENC_LIB_VL0 2
-#define SACENC_LIB_VL1 0
-#define SACENC_LIB_VL2 0
-#define SACENC_LIB_TITLE "MPEG Surround Encoder"
-#ifdef __ANDROID__
-#define SACENC_LIB_BUILD_DATE ""
-#define SACENC_LIB_BUILD_TIME ""
-#else
-#define SACENC_LIB_BUILD_DATE __DATE__
-#define SACENC_LIB_BUILD_TIME __TIME__
-#endif
-
-#define MAX_MPEGS_BYTES (1 << 14)
-#define MAX_SSC_BYTES (1 << 6)
-
-#define MAX_SPACE_TREE_CHANNELS 2
-#define NUM_KEEP_WINDOWS 3
-
-/* Data Types ****************************************************************/
-typedef struct {
-  MP4SPACEENC_MODE encMode;
-  MP4SPACEENC_BANDS_CONFIG nParamBands;
-  MP4SPACEENC_QUANTMODE quantMode;
-  UCHAR bUseCoarseQuant;
-  UCHAR bLdMode;
-  UCHAR bTimeDomainDmx;
-  UINT sampleRate;
-  UINT frameTimeSlots;     /* e.g. 32 when used with HE-AAC */
-  UINT independencyFactor; /* how often should we set the independency flag */
-  INT timeAlignment;       /* additional delay for downmix */
-
-} MP4SPACEENC_SETUP, *HANDLE_MP4SPACEENC_SETUP;
-
-struct ENC_CONFIG_SETUP {
-  UCHAR bEncMode_212;
-  UCHAR maxHybridInStaticSlots;
-  LONG maxSamplingrate;
-  INT maxAnalysisLengthTimeSlots;
-  INT maxHybridBands;
-  INT maxQmfBands;
-  INT maxChIn;
-  INT maxFrameTimeSlots;
-  INT maxFrameLength;
-  INT maxChOut;
-  INT maxChTotOut;
-};
-
-struct MP4SPACE_ENCODER {
-  MP4SPACEENC_SETUP user;
-
-  ENC_CONFIG_SETUP setup; /* describe allocated instance */
-
-  HANDLE_FRAMEWINDOW
-  hFrameWindow;      /* Windowing, only created+updated, but not used */
-  INT nSamplesValid; /* Input Buffer Handling */
-
-  /* Routing Sensible Switches/Variables */
-  MP4SPACEENC_BANDS_CONFIG nParamBands;
-  UCHAR useTimeDomDownmix;
-
-  /* not Routing Sensible Switches/Varibles - must be contained in Check */
-  MP4SPACEENC_MODE encMode;
-  UCHAR bEncMode_212_only;
-
-  /* not Routing Sensible Switches/Varibles + lower Classes */
-  UCHAR useFrameKeep;
-  UINT independencyFactor;
-  UINT nSampleRate;
-  UCHAR nInputChannels;
-  UCHAR nOutputChannels;
-  UCHAR nFrameTimeSlots; /* e.g. 32 when used with HE-AAC */
-  UCHAR nQmfBands;
-  UCHAR nHybridBands;
-  UINT nFrameLength; /* number of output waveform samples/channel/frame */
-
-  /* not Routing Sensible Switches/Varibles + lower Classes, secondary computed
-   */
-  INT nSamplesNext;
-  INT nAnalysisLengthTimeSlots;
-  INT nAnalysisLookaheadTimeSlots;
-  INT nUpdateHybridPositionTimeSlots;
-  INT *pnOutputBits;
-  INT nInputDelay;
-  INT nOutputBufferDelay;
-  INT nSurroundAnalysisBufferDelay;
-  INT nBitstreamDelayBuffer;
-  INT nBitstreamBufferRead;
-  INT nBitstreamBufferWrite;
-  INT nDiscardOutFrames;
-  INT avoid_keep;
-
-  /* not Routing Sensible Switches/Varibles -> moved to lower Classes */
-  UCHAR useCoarseQuantCld;    /* Only Used in SpaceTreeSetup */
-  UCHAR useCoarseQuantIcc;    /* Only Used in SpaceTreeSetup */
-  UCHAR useCoarseQuantCpc;    /* Only Used in SpaceTreeSetup */
-  UCHAR useCoarseQuantArbDmx; /* ArbitraryDmx,... not available yet */
-  MP4SPACEENC_QUANTMODE
-  quantMode;          /* Used for quanitzation and in bitstream writer */
-  INT coreCoderDelay; /* Used in delay compensation */
-  INT timeAlignment;  /* Used in delay compensation */
-
-  /* Local Processing Variables */
-  INT independencyCount;
-  INT independencyFlag;
-  INT **ppTrCurrPos;                /* belongs somehow to Onset Detection */
-  INT trPrevPos[2 * MAX_NUM_TRANS]; /* belongs somehow to Onset Detection */
-
-  FRAMEWIN_LIST frameWinList;
-  SPATIALFRAME saveFrame;
-
-  /* Module-Handles */
-  SPACE_TREE_SETUP spaceTreeSetup;
-  MPEG4SPACEENC_SSCBUF sscBuf;
-  FIXP_WIN *pFrameWindowAna__FDK[MAX_NUM_PARAMS];
-  HANDLE_QMF_FILTER_BANK *phQmfFiltIn__FDK;
-  HANDLE_DC_FILTER phDCFilterSigIn[SACENC_MAX_INPUT_CHANNELS];
-  HANDLE_ONSET_DETECT phOnset[SACENC_MAX_INPUT_CHANNELS];
-  HANDLE_SPACE_TREE hSpaceTree;
-  HANDLE_BSF_INSTANCE hBitstreamFormatter;
-  HANDLE_STATIC_GAIN_CONFIG hStaticGainConfig;
-  HANDLE_STATIC_GAIN hStaticGain;
-  HANDLE_DELAY hDelay;
-
-  /* enhanced time domain downmix (for stereo input) */
-  HANDLE_ENHANCED_TIME_DOMAIN_DMX hEnhancedTimeDmx;
-
-  /* Data Buffers */
-  INT_PCM **ppTimeSigIn__FDK;
-  INT_PCM **ppTimeSigDelayIn__FDK;
-  INT_PCM **ppTimeSigOut__FDK;
-  FIXP_DPK ***pppHybridIn__FDK;
-  FIXP_DPK ***pppHybridInStatic__FDK;
-  FIXP_DPK ***pppProcDataIn__FDK;
-  INT_PCM *pOutputDelayBuffer__FDK;
-
-  UCHAR **ppBitstreamDelayBuffer;
-
-  UCHAR *pParameterBand2HybridBandOffset;
-  INT staticGainScale;
-
-  INT *pEncoderInputChScale;
-  INT *staticTimeDomainDmxInScale;
-};
-
-/* Constants *****************************************************************/
-static const UCHAR pValidBands_Ld[8] = {4, 5, 7, 9, 12, 15, 23, 40};
-
-static const UCHAR qmf2qmf[] = /* Bypass the HybridAnylyis/Synthesis*/
-    {0,   1,   2,   3,   4,   5,   6,   7,   8,   9,   10,  11,  12,  13,  14,
-     15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
-     30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,
-     45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
-     60,  61,  62,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,  73,  74,
-     75,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,
-     90,  91,  92,  93,  94,  95,  96,  97,  98,  99,  100, 101, 102, 103, 104,
-     105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,
-     120, 121, 122, 123, 124, 125, 126, 127};
-
-/* Function / Class Declarations *********************************************/
-static FDK_SACENC_ERROR mp4SpaceEnc_create(
-    HANDLE_MP4SPACE_ENCODER *phMp4SpaceEnc);
-
-static FDK_SACENC_ERROR FillSpatialSpecificConfig(
-    const HANDLE_MP4SPACE_ENCODER hEnc, SPATIALSPECIFICCONFIG *const hSsc);
-
-static FDK_SACENC_ERROR mp4SpaceEnc_FillSpaceTreeSetup(
-    const HANDLE_MP4SPACE_ENCODER hEnc,
-    SPACE_TREE_SETUP *const hSpaceTreeSetup);
-
-static FDK_SACENC_ERROR mp4SpaceEnc_InitDelayCompensation(
-    HANDLE_MP4SPACE_ENCODER hMp4SpaceEnc, const INT coreCoderDelay);
-
-static FDK_SACENC_ERROR mp4SpaceEnc_InitDefault(
-    HANDLE_MP4SPACE_ENCODER hMp4SpaceEnc);
-
-static DECORRCONFIG mp4SpaceEnc_GetDecorrConfig(const MP4SPACEENC_MODE encMode);
-
-static FDK_SACENC_ERROR mp4SpaceEnc_InitNumParamBands(
-    HANDLE_MP4SPACE_ENCODER hEnc, const MP4SPACEENC_BANDS_CONFIG nParamBands);
-
-/* Function / Class Definition ***********************************************/
-static UINT mp4SpaceEnc_GetNumQmfBands(const UINT nSampleRate) {
-  UINT nQmfBands = 0;
-
-  if (nSampleRate < 27713)
-    nQmfBands = 32;
-  else if (nSampleRate < 55426)
-    nQmfBands = 64;
-
-  return nQmfBands;
-}
-
-static UINT updateQmfFlags(const UINT flags, const INT keepStates) {
-  UINT qmfFlags = flags;
-
-  qmfFlags = (qmfFlags & (~(UINT)QMF_FLAG_LP));
-  qmfFlags = (qmfFlags | QMF_FLAG_MPSLDFB);
-  qmfFlags = (keepStates) ? (qmfFlags | QMF_FLAG_KEEP_STATES)
-                          : (qmfFlags & (~(UINT)QMF_FLAG_KEEP_STATES));
-
-  return qmfFlags;
-}
-
-static INT freq2HybridBand(const UINT nFrequency, const UINT nSampleRate,
-                           const UINT nQmfBands) {
-  /*
-    nQmfSlotWidth = (nSampleRate/2) / nQmfBands;
-    nQmfBand      = nFrequency / nQmfSlotWidth;
-  */
-  int nHybridBand = -1;
-  int scale = 0;
-  const FIXP_DBL temp = fDivNorm((FIXP_DBL)(2 * nFrequency * nQmfBands),
-                                 (FIXP_DBL)nSampleRate, &scale);
-  const int nQmfBand = scaleValue(temp, scale - (DFRACT_BITS - 1));
-
-  if ((nQmfBand > -1) && (nQmfBand < (int)nQmfBands)) {
-    nHybridBand = qmf2qmf[nQmfBand];
-  }
-
-  return nHybridBand;
-}
-
-/*
- * Examine buffer descriptor regarding choosen type.
- *
- * \param pBufDesc              Pointer to buffer descriptor
- * \param type                  Buffer type to look for.
-
- * \return - Buffer descriptor index.
- *         -1, if there is no entry available.
- */
-static INT getBufDescIdx(const FDK_bufDescr *pBufDesc, const UINT type) {
-  INT i, idx = -1;
-
-  for (i = 0; i < (int)pBufDesc->numBufs; i++) {
-    if (pBufDesc->pBufType[i] == type) {
-      idx = i;
-      break;
-    }
-  }
-  return idx;
-}
-
-FDK_SACENC_ERROR FDK_sacenc_open(HANDLE_MP4SPACE_ENCODER *phMp4SpaceEnc) {
-  return mp4SpaceEnc_create(phMp4SpaceEnc);
-}
-
-static FDK_SACENC_ERROR mp4SpaceEnc_create(
-    HANDLE_MP4SPACE_ENCODER *phMp4SpaceEnc) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-  HANDLE_MP4SPACE_ENCODER hEnc = NULL;
-  ENC_CONFIG_SETUP setup;
-
-  if (NULL == phMp4SpaceEnc) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    int i, ch;
-    FDKmemclear(&setup, sizeof(ENC_CONFIG_SETUP));
-
-    /* Allocate Encoder Instance */
-    FDK_ALLOCATE_MEMORY_1D(hEnc, 1, struct MP4SPACE_ENCODER);
-
-    /* Clear everything, also pointers. */
-    if (NULL != hEnc) {
-      FDKmemclear(hEnc, sizeof(struct MP4SPACE_ENCODER));
-    }
-
-    setup.maxSamplingrate = 48000;
-    setup.maxFrameTimeSlots = 16;
-
-    setup.maxAnalysisLengthTimeSlots = 3 * setup.maxFrameTimeSlots;
-    setup.maxQmfBands = mp4SpaceEnc_GetNumQmfBands(setup.maxSamplingrate);
-    ;
-    setup.maxHybridBands = setup.maxQmfBands;
-    setup.maxFrameLength = setup.maxQmfBands * setup.maxFrameTimeSlots;
-
-    setup.maxChIn = 2;
-    setup.maxChOut = 1;
-    setup.maxChTotOut = setup.maxChOut;
-    setup.bEncMode_212 = 1;
-    setup.maxHybridInStaticSlots = 24;
-
-    /* Open Static Gain*/
-    if (SACENC_OK !=
-        (error = fdk_sacenc_staticGain_OpenConfig(&hEnc->hStaticGainConfig))) {
-      goto bail;
-    }
-
-    /* enhanced time domain downmix (for stereo input) */
-    if (SACENC_OK != (error = fdk_sacenc_open_enhancedTimeDomainDmx(
-                          &hEnc->hEnhancedTimeDmx, setup.maxFrameLength))) {
-      goto bail;
-    }
-
-    FDK_ALLOCATE_MEMORY_1D(hEnc->pParameterBand2HybridBandOffset,
-                           MAX_NUM_PARAM_BANDS, UCHAR);
-
-    /* Create Space Tree first, to get number of in-/output channels */
-    if (SACENC_OK != (error = fdk_sacenc_spaceTree_Open(&hEnc->hSpaceTree))) {
-      goto bail;
-    }
-
-    FDK_ALLOCATE_MEMORY_1D(hEnc->pEncoderInputChScale, setup.maxChIn, INT);
-    FDK_ALLOCATE_MEMORY_1D(hEnc->staticTimeDomainDmxInScale, setup.maxChIn,
-                           INT);
-
-    FDK_ALLOCATE_MEMORY_1D(hEnc->phQmfFiltIn__FDK, setup.maxChIn,
-                           HANDLE_QMF_FILTER_BANK);
-
-    /* Allocate Analysis Filterbank Structs */
-    for (ch = 0; ch < setup.maxChIn; ch++) {
-      FDK_ALLOCATE_MEMORY_1D_INT(hEnc->phQmfFiltIn__FDK[ch], 1,
-                                 struct QMF_FILTER_BANK, SECT_DATA_L2)
-      FDK_ALLOCATE_MEMORY_1D_INT(hEnc->phQmfFiltIn__FDK[ch]->FilterStates,
-                                 2 * 5 * setup.maxQmfBands, FIXP_QAS,
-                                 SECT_DATA_L2)
-    }
-
-    /* Allocate Synthesis Filterbank Structs for arbitrary downmix */
-
-    /* Allocate DC Filter Struct for normal signal input */
-    for (ch = 0; ch < setup.maxChIn; ch++) {
-      if (SACENC_OK !=
-          (error = fdk_sacenc_createDCFilter(&hEnc->phDCFilterSigIn[ch]))) {
-        goto bail;
-      }
-    }
-
-    /* Open Onset Detection */
-    for (ch = 0; ch < setup.maxChIn; ch++) {
-      if (SACENC_OK != (error = fdk_sacenc_onsetDetect_Open(
-                            &hEnc->phOnset[ch], setup.maxFrameTimeSlots))) {
-        goto bail;
-      }
-    }
-
-    FDK_ALLOCATE_MEMORY_2D(hEnc->ppTrCurrPos, setup.maxChIn, MAX_NUM_TRANS,
-                           INT);
-
-    /* Create Windowing */
-    if (SACENC_OK !=
-        (error = fdk_sacenc_frameWindow_Create(&hEnc->hFrameWindow))) {
-      goto bail;
-    }
-
-    /* Open static gain */
-    if (SACENC_OK != (error = fdk_sacenc_staticGain_Open(&hEnc->hStaticGain))) {
-      goto bail;
-    }
-
-    /* create bitstream encoder */
-    if (SACENC_OK != (error = fdk_sacenc_createSpatialBitstreamEncoder(
-                          &hEnc->hBitstreamFormatter))) {
-      goto bail;
-    }
-
-    FDK_ALLOCATE_MEMORY_1D(hEnc->sscBuf.pSsc, MAX_SSC_BYTES, UCHAR);
-
-    {
-      FDK_ALLOCATE_MEMORY_2D(hEnc->ppTimeSigIn__FDK, setup.maxChIn,
-                             setup.maxFrameLength + MAX_DELAY_SURROUND_ANALYSIS,
-                             INT_PCM);
-    }
-    FDK_ALLOCATE_MEMORY_2D(hEnc->ppTimeSigDelayIn__FDK, setup.maxChIn,
-                           MAX_DELAY_SURROUND_ANALYSIS, INT_PCM);
-
-    /* Create new buffers for several signals (including arbitrary downmix) */
-    if (setup.bEncMode_212 == 0) {
-      /* pOutputDelayBuffer__FDK buffer is not needed for SACENC_212 mode */
-      FDK_ALLOCATE_MEMORY_1D(
-          hEnc->pOutputDelayBuffer__FDK,
-          (setup.maxFrameLength + MAX_DELAY_OUTPUT) * setup.maxChOut, INT_PCM);
-    }
-
-    /* allocate buffers */
-    if (setup.bEncMode_212 == 0) {
-      /* ppTimeSigOut__FDK buffer is not needed for SACENC_212 mode */
-      FDK_ALLOCATE_MEMORY_2D(hEnc->ppTimeSigOut__FDK, setup.maxChTotOut,
-                             setup.maxFrameLength, INT_PCM);
-    }
-
-    if (setup.bEncMode_212 == 1) {
-      /* pppHybridIn__FDK buffer can be reduced by maxFrameTimeSlots/2 slots for
-       * SACENC_212 mode */
-      FDK_ALLOCATE_MEMORY_3D(
-          hEnc->pppHybridIn__FDK, setup.maxChIn,
-          setup.maxAnalysisLengthTimeSlots - (setup.maxFrameTimeSlots >> 1),
-          setup.maxHybridBands, FIXP_DPK);
-      FDK_ALLOCATE_MEMORY_3D(hEnc->pppHybridInStatic__FDK, setup.maxChIn,
-                             setup.maxHybridInStaticSlots, setup.maxHybridBands,
-                             FIXP_DPK);
-    } else {
-      FDK_ALLOCATE_MEMORY_3D(hEnc->pppHybridIn__FDK, setup.maxChIn,
-                             setup.maxAnalysisLengthTimeSlots,
-                             setup.maxHybridBands, FIXP_DPK);
-    }
-
-    if (setup.bEncMode_212 == 0) {
-      /* pppProcDataIn__FDK buffer is not needed for SACENC_212 mode */
-      FDK_ALLOCATE_MEMORY_3D(hEnc->pppProcDataIn__FDK, MAX_SPACE_TREE_CHANNELS,
-                             setup.maxAnalysisLengthTimeSlots,
-                             setup.maxHybridBands, FIXP_DPK);
-    }
-    for (i = 0; i < MAX_NUM_PARAMS; i++) {
-      FDK_ALLOCATE_MEMORY_1D(hEnc->pFrameWindowAna__FDK[i],
-                             setup.maxAnalysisLengthTimeSlots, FIXP_WIN);
-    } /* for i */
-
-    if (SACENC_OK != (error = fdk_sacenc_delay_Open(&hEnc->hDelay))) {
-      goto bail;
-    }
-
-    if (setup.bEncMode_212 == 0) {
-      /* ppBitstreamDelayBuffer buffer is not needed for SACENC_212 mode */
-      FDK_ALLOCATE_MEMORY_2D(hEnc->ppBitstreamDelayBuffer, MAX_BITSTREAM_DELAY,
-                             MAX_MPEGS_BYTES, UCHAR);
-    }
-    FDK_ALLOCATE_MEMORY_1D(hEnc->pnOutputBits, MAX_BITSTREAM_DELAY, INT);
-
-    hEnc->setup = setup; /* save configuration used while encoder allocation. */
-    mp4SpaceEnc_InitDefault(hEnc);
-
-    if (NULL != phMp4SpaceEnc) {
-      *phMp4SpaceEnc = hEnc; /* return encoder handle */
-    }
-
-  } /* valid handle */
-
-  return error;
-
-bail:
-  if (NULL != hEnc) {
-    hEnc->setup = setup;
-    FDK_sacenc_close(&hEnc);
-  }
-  return ((SACENC_OK == error) ? SACENC_MEMORY_ERROR : error);
-}
-
-static FDK_SACENC_ERROR mp4SpaceEnc_InitDefault(HANDLE_MP4SPACE_ENCODER hEnc) {
-  FDK_SACENC_ERROR err = SACENC_OK;
-
-  /* Get default static gain configuration. */
-  if (SACENC_OK != (err = fdk_sacenc_staticGain_InitDefaultConfig(
-                        hEnc->hStaticGainConfig))) {
-    goto bail;
-  }
-
-bail:
-  return err;
-}
-
-static FDK_SACENC_ERROR FDK_sacenc_configure(
-    HANDLE_MP4SPACE_ENCODER hEnc, const HANDLE_MP4SPACEENC_SETUP hSetup) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  hEnc->nSampleRate = hSetup->sampleRate;
-  hEnc->encMode = hSetup->encMode;
-  hEnc->nQmfBands = mp4SpaceEnc_GetNumQmfBands(hEnc->nSampleRate);
-
-  /* Make sure that we have set time domain downmix for 212 */
-  if (hSetup->encMode == SACENC_212 && hSetup->bTimeDomainDmx == 0) {
-    error = SACENC_INVALID_CONFIG;
-  } else {
-    hEnc->useTimeDomDownmix = hSetup->bTimeDomainDmx;
-  }
-
-  hEnc->timeAlignment = hSetup->timeAlignment;
-  hEnc->quantMode = hSetup->quantMode;
-
-  hEnc->useCoarseQuantCld = hSetup->bUseCoarseQuant;
-  hEnc->useCoarseQuantCpc = hSetup->bUseCoarseQuant;
-  hEnc->useFrameKeep = (hSetup->bLdMode == 2);
-  hEnc->useCoarseQuantIcc = 0;    /* not available */
-  hEnc->useCoarseQuantArbDmx = 0; /* not available for user right now */
-  hEnc->independencyFactor = hSetup->independencyFactor;
-  hEnc->independencyCount = 0;
-  hEnc->independencyFlag = 1;
-
-  /* set number of Hybrid bands */
-  hEnc->nHybridBands = hEnc->nQmfBands;
-  hEnc->nFrameTimeSlots = hSetup->frameTimeSlots;
-  mp4SpaceEnc_InitNumParamBands(hEnc, hSetup->nParamBands);
-
-  return error;
-}
-
-FDK_SACENC_ERROR FDK_sacenc_init(HANDLE_MP4SPACE_ENCODER hEnc,
-                                 const INT dmxDelay) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  /* Sanity Checks */
-  if (NULL == hEnc) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    const int initStatesFlag = 1;
-
-    int ch; /* loop counter */
-    int nChInArbDmx;
-
-    if (SACENC_OK != (error = FDK_sacenc_configure(hEnc, &hEnc->user))) {
-      goto bail;
-    }
-
-    hEnc->bEncMode_212_only = hEnc->setup.bEncMode_212;
-
-    /* Slots per Frame and Frame Length */
-    if (hEnc->nFrameTimeSlots < 1) {
-      error = SACENC_INVALID_CONFIG;
-      goto bail;
-    }
-    hEnc->nFrameLength = hEnc->nQmfBands * hEnc->nFrameTimeSlots;
-
-    if (hEnc->useFrameKeep == 1) {
-      hEnc->nAnalysisLengthTimeSlots = 3 * hEnc->nFrameTimeSlots;
-      hEnc->nUpdateHybridPositionTimeSlots = hEnc->nFrameTimeSlots;
-    } else {
-      hEnc->nAnalysisLengthTimeSlots = 2 * hEnc->nFrameTimeSlots;
-      hEnc->nUpdateHybridPositionTimeSlots = 0;
-    }
-
-    {
-      hEnc->nAnalysisLookaheadTimeSlots =
-          hEnc->nAnalysisLengthTimeSlots - 3 * hEnc->nFrameTimeSlots / 2;
-    }
-
-    /* init parameterBand2hybridBandOffset table */
-    fdk_sacenc_calcParameterBand2HybridBandOffset(
-        (BOX_SUBBAND_CONFIG)hEnc->nParamBands, hEnc->nHybridBands,
-        hEnc->pParameterBand2HybridBandOffset);
-
-    /* Fill Setup structure for Space Tree */
-    if (SACENC_OK !=
-        (error = mp4SpaceEnc_FillSpaceTreeSetup(hEnc, &hEnc->spaceTreeSetup))) {
-      goto bail;
-    }
-
-    /* Init space tree configuration */
-    if (SACENC_OK !=
-        (error = fdk_sacenc_spaceTree_Init(
-             hEnc->hSpaceTree, &hEnc->spaceTreeSetup,
-             hEnc->pParameterBand2HybridBandOffset, hEnc->useFrameKeep))) {
-      goto bail;
-    }
-
-    /* Get space tree description and resulting number of input/output channels
-     */
-    {
-      SPACE_TREE_DESCRIPTION spaceTreeDescription;
-
-      if (SACENC_OK != (error = fdk_sacenc_spaceTree_GetDescription(
-                            hEnc->hSpaceTree, &spaceTreeDescription))) {
-        goto bail;
-      }
-
-      hEnc->nInputChannels =
-          spaceTreeDescription.nOutChannels; /* space tree description
-                                                describes decoder
-                                                configuration */
-      hEnc->nOutputChannels =
-          spaceTreeDescription.nInChannels; /* space tree description
-                                               describes decoder
-                                               configuration */
-    }
-
-    nChInArbDmx = 0;
-
-    /* INITIALIZATION */
-    for (ch = 0; ch < hEnc->nInputChannels; ch++) {
-      /* scaling in analysis qmf filterbank (7) */
-      hEnc->pEncoderInputChScale[ch] = 7;
-
-      {
-        /* additional scaling in qmf prototype filter for low delay */
-        hEnc->pEncoderInputChScale[ch] += 1;
-      }
-
-      { hEnc->pEncoderInputChScale[ch] += DC_FILTER_SF; }
-    } /* nInputChannels */
-
-    /* Init analysis filterbank */
-    for (ch = 0; ch < hEnc->nInputChannels; ch++) {
-      hEnc->phQmfFiltIn__FDK[ch]->flags =
-          updateQmfFlags(hEnc->phQmfFiltIn__FDK[ch]->flags, !initStatesFlag);
-
-      if (0 != qmfInitAnalysisFilterBank(
-                   hEnc->phQmfFiltIn__FDK[ch],
-                   (FIXP_QAS *)hEnc->phQmfFiltIn__FDK[ch]->FilterStates, 1,
-                   hEnc->nQmfBands, hEnc->nQmfBands, hEnc->nQmfBands,
-                   hEnc->phQmfFiltIn__FDK[ch]->flags)) {
-        error = SACENC_INIT_ERROR;
-        goto bail;
-      }
-    }
-
-    /* Initialize DC Filter. */
-    {
-      for (ch = 0; ch < hEnc->nInputChannels; ch++) {
-        if (SACENC_OK != (error = fdk_sacenc_initDCFilter(
-                              hEnc->phDCFilterSigIn[ch], hEnc->nSampleRate))) {
-          goto bail;
-        }
-      }
-    }
-
-    /* Init onset detect. */
-    {
-      /* init onset detect configuration struct */
-      ONSET_DETECT_CONFIG onsetDetectConfig;
-      onsetDetectConfig.maxTimeSlots = hEnc->nFrameTimeSlots;
-      onsetDetectConfig.lowerBoundOnsetDetection =
-          freq2HybridBand(1725, hEnc->nSampleRate, hEnc->nQmfBands);
-      onsetDetectConfig.upperBoundOnsetDetection = hEnc->nHybridBands;
-
-      for (ch = 0; ch < hEnc->nInputChannels; ch++) {
-        if (SACENC_OK != (error = fdk_sacenc_onsetDetect_Init(
-                              hEnc->phOnset[ch], &onsetDetectConfig, 1))) {
-          goto bail;
-        }
-      }
-    }
-
-    {
-      /* init windowing */
-      FRAMEWINDOW_CONFIG framewindowConfig;
-      framewindowConfig.nTimeSlotsMax = hEnc->nFrameTimeSlots;
-      framewindowConfig.bFrameKeep = hEnc->useFrameKeep;
-
-      if (SACENC_OK != (error = fdk_sacenc_frameWindow_Init(
-                            hEnc->hFrameWindow, &framewindowConfig))) {
-        goto bail;
-      }
-    }
-
-    /* Set encoder mode for static gain initialization. */
-    if (SACENC_OK != (error = fdk_sacenc_staticGain_SetEncMode(
-                          hEnc->hStaticGainConfig, hEnc->encMode))) {
-      goto bail;
-    }
-
-    /* Init static gain. */
-    if (SACENC_OK != (error = fdk_sacenc_staticGain_Init(
-                          hEnc->hStaticGain, hEnc->hStaticGainConfig,
-                          &(hEnc->staticGainScale)))) {
-      goto bail;
-    }
-
-    for (ch = 0; ch < hEnc->nInputChannels; ch++) {
-      hEnc->pEncoderInputChScale[ch] += hEnc->staticGainScale;
-    }
-
-    /* enhanced downmix for stereo input*/
-    if (hEnc->useTimeDomDownmix != 0) {
-      if (SACENC_OK != (error = fdk_sacenc_init_enhancedTimeDomainDmx(
-                            hEnc->hEnhancedTimeDmx,
-                            fdk_sacenc_getPreGainPtrFDK(hEnc->hStaticGain),
-                            hEnc->staticGainScale,
-                            fdk_sacenc_getPostGainFDK(hEnc->hStaticGain),
-                            hEnc->staticGainScale, hEnc->nFrameLength))) {
-        goto bail;
-      }
-    }
-
-    /* Create config structure for bitstream formatter including arbitrary
-     * downmix residual */
-    if (SACENC_OK != (error = fdk_sacenc_initSpatialBitstreamEncoder(
-                          hEnc->hBitstreamFormatter))) {
-      goto bail;
-    }
-
-    if (SACENC_OK != (error = FillSpatialSpecificConfig(
-                          hEnc, fdk_sacenc_getSpatialSpecificConfig(
-                                    hEnc->hBitstreamFormatter)))) {
-      goto bail;
-    }
-
-    if (SACENC_OK !=
-        (error = fdk_sacenc_writeSpatialSpecificConfig(
-             fdk_sacenc_getSpatialSpecificConfig(hEnc->hBitstreamFormatter),
-             hEnc->sscBuf.pSsc, MAX_SSC_BYTES, &hEnc->sscBuf.nSscSizeBits))) {
-      goto bail;
-    }
-
-    /* init delay compensation with dmx core coder delay; if no core coder is
-     * used, many other buffers are initialized nevertheless */
-    if (SACENC_OK !=
-        (error = mp4SpaceEnc_InitDelayCompensation(hEnc, dmxDelay))) {
-      goto bail;
-    }
-
-    /* How much input do we need? */
-    hEnc->nSamplesNext =
-        hEnc->nFrameLength * (hEnc->nInputChannels + nChInArbDmx);
-    hEnc->nSamplesValid = 0;
-  } /* valid handle */
-
-bail:
-  return error;
-}
-
-static INT getAnalysisLengthTimeSlots(FIXP_WIN *pFrameWindowAna,
-                                      INT nTimeSlots) {
-  int i;
-  for (i = nTimeSlots - 1; i >= 0; i--) {
-    if (pFrameWindowAna[i] != (FIXP_WIN)0) {
-      break;
-    }
-  }
-  nTimeSlots = i + 1;
-  return nTimeSlots;
-}
-
-static INT getAnalysisStartTimeSlot(FIXP_WIN *pFrameWindowAna, INT nTimeSlots) {
-  int startTimeSlot = 0;
-  int i;
-  for (i = 0; i < nTimeSlots; i++) {
-    if (pFrameWindowAna[i] != (FIXP_WIN)0) {
-      break;
-    }
-  }
-  startTimeSlot = i;
-  return startTimeSlot;
-}
-
-static FDK_SACENC_ERROR __FeedDeinterPreScale(
-    HANDLE_MP4SPACE_ENCODER hEnc, INT_PCM const *const pSamples,
-    INT_PCM *const pOutputSamples, INT const nSamples,
-    UINT const isInputInterleaved, UINT const inputBufferSizePerChannel,
-    UINT *const pnSamplesFed) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if ((hEnc == NULL) || (pSamples == NULL) || (pnSamplesFed == NULL)) {
-    error = SACENC_INVALID_HANDLE;
-  } else if (nSamples == 0) {
-    error = SACENC_INVALID_CONFIG; /* Flushing not implemented */
-  } else {
-    int ch;
-    const INT nChIn = hEnc->nInputChannels;
-    const INT nChInWithDmx = nChIn;
-    const INT samplesToFeed =
-        FDKmin(nSamples, hEnc->nSamplesNext - hEnc->nSamplesValid);
-    const INT nSamplesPerChannel = samplesToFeed / nChInWithDmx;
-
-    if ((samplesToFeed < 0) || (samplesToFeed % nChInWithDmx != 0) ||
-        (samplesToFeed > nChInWithDmx * (INT)hEnc->nFrameLength)) {
-      error = SACENC_INVALID_CONFIG;
-      goto bail;
-    }
-    int i;
-
-    const INT_PCM *pInput__FDK;
-    const INT_PCM *pInput2__FDK;
-
-    { /* no dmx align = default*/
-      pInput__FDK = pSamples;
-      pInput2__FDK = pSamples + (hEnc->nInputDelay * nChInWithDmx);
-    }
-
-    for (i = 0; i < hEnc->nInputChannels; i++) {
-      hEnc->staticTimeDomainDmxInScale[i] = hEnc->staticGainScale;
-    }
-
-    /*****        N-channel-input     *****/
-    for (ch = 0; ch < nChIn; ch++) {
-      /* Write delayed time signal into time signal buffer */
-      FDKmemcpy(&(hEnc->ppTimeSigIn__FDK[ch][0]),
-                &(hEnc->ppTimeSigDelayIn__FDK[ch][0]),
-                hEnc->nSurroundAnalysisBufferDelay * sizeof(INT_PCM));
-
-      if (isInputInterleaved) {
-        /* Add the new frame de-interleaved. Apply nSurroundAnalysisBufferDelay.
-         */
-        FDKmemcpy_flex(
-            &(hEnc->ppTimeSigIn__FDK[ch][hEnc->nSurroundAnalysisBufferDelay]),
-            1, pInput__FDK + ch, nChInWithDmx, hEnc->nInputDelay);
-        FDKmemcpy_flex(
-            &(hEnc->ppTimeSigIn__FDK[ch][hEnc->nSurroundAnalysisBufferDelay +
-                                         hEnc->nInputDelay]),
-            1, pInput2__FDK + ch, nChInWithDmx,
-            nSamplesPerChannel - hEnc->nInputDelay);
-      } else {
-        /* Input is already deinterleaved, just copy */
-        FDKmemcpy(
-            &(hEnc->ppTimeSigIn__FDK[ch][hEnc->nSurroundAnalysisBufferDelay]),
-            pInput__FDK + ch * inputBufferSizePerChannel,
-            hEnc->nInputDelay * sizeof(INT_PCM));
-        FDKmemcpy(
-            &(hEnc->ppTimeSigIn__FDK[ch][hEnc->nSurroundAnalysisBufferDelay +
-                                         hEnc->nInputDelay]),
-            pInput2__FDK + ch * inputBufferSizePerChannel,
-            (nSamplesPerChannel - hEnc->nInputDelay) * sizeof(INT_PCM));
-      }
-
-      /* Update time signal delay buffer */
-      FDKmemcpy(&(hEnc->ppTimeSigDelayIn__FDK[ch][0]),
-                &(hEnc->ppTimeSigIn__FDK[ch][hEnc->nFrameLength]),
-                hEnc->nSurroundAnalysisBufferDelay * sizeof(INT_PCM));
-    } /* for ch */
-
-    /*****      No Arbitrary Downmix      *****/
-    /* "Crude TD Dmx": Time DomainDownmix + NO Arbitrary Downmix, Delay Added at
-     * pOutputBuffer */
-    if ((hEnc->useTimeDomDownmix > 0)) {
-      if ((hEnc->useTimeDomDownmix == 1) || (hEnc->nInputChannels != 2)) {
-        error = SACENC_INVALID_CONFIG;
-        goto bail;
-      } else {
-        /* enhanced time domain downmix (for stereo input) */
-        if (hEnc->encMode == SACENC_212) {
-          if (pOutputSamples == NULL) {
-            error = SACENC_INVALID_HANDLE;
-            goto bail;
-          }
-
-          fdk_sacenc_apply_enhancedTimeDomainDmx(
-              hEnc->hEnhancedTimeDmx, hEnc->ppTimeSigIn__FDK, pOutputSamples,
-              hEnc->nSurroundAnalysisBufferDelay);
-        } else {
-          if (&hEnc->ppTimeSigOut__FDK[0][0] == NULL) {
-            error = SACENC_INVALID_HANDLE;
-            goto bail;
-          }
-
-          fdk_sacenc_apply_enhancedTimeDomainDmx(
-              hEnc->hEnhancedTimeDmx, hEnc->ppTimeSigIn__FDK,
-              &hEnc->ppTimeSigOut__FDK[0][0],
-              hEnc->nSurroundAnalysisBufferDelay);
-        }
-      }
-    }
-
-    /* update number of samples still to process */
-    hEnc->nSamplesValid += samplesToFeed;
-
-    /*return number of fed samples */
-    *pnSamplesFed = samplesToFeed;
-  }
-bail:
-  return error;
-}
-
-FDK_SACENC_ERROR FDK_sacenc_encode(const HANDLE_MP4SPACE_ENCODER hMp4SpaceEnc,
-                                   const FDK_bufDescr *inBufDesc,
-                                   const FDK_bufDescr *outBufDesc,
-                                   const SACENC_InArgs *inargs,
-                                   SACENC_OutArgs *outargs) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  const INT_PCM *pInputSamples =
-      (const INT_PCM *)inBufDesc->ppBase[getBufDescIdx(
-          inBufDesc, (FDK_BUF_TYPE_INPUT | FDK_BUF_TYPE_PCM_DATA))];
-
-  INT_PCM *const pOutputSamples = (INT_PCM *)outBufDesc->ppBase[getBufDescIdx(
-      outBufDesc, (FDK_BUF_TYPE_OUTPUT | FDK_BUF_TYPE_PCM_DATA))];
-
-  const int nOutputSamplesBufferSize =
-      outBufDesc->pBufSize[getBufDescIdx(
-          outBufDesc, (FDK_BUF_TYPE_OUTPUT | FDK_BUF_TYPE_PCM_DATA))] /
-      outBufDesc->pEleSize[getBufDescIdx(
-          outBufDesc, (FDK_BUF_TYPE_OUTPUT | FDK_BUF_TYPE_PCM_DATA))];
-
-  if ((hMp4SpaceEnc == NULL) || (pInputSamples == NULL)) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    int nOutputSamples;
-    int i, ch, ps, winCnt, ts, slot;
-    INT currTransPos = -1;
-    SPATIALFRAME *pFrameData = NULL;
-
-    /* Improve Code Readability */
-    const int nChIn = hMp4SpaceEnc->nInputChannels;
-    const int nChInWithDmx = nChIn;
-    const int nChOut = hMp4SpaceEnc->nOutputChannels;
-    const int nSamplesPerChannel = inargs->nInputSamples / nChInWithDmx;
-    const int nOutputSamplesMax = nSamplesPerChannel * nChOut;
-    const int nFrameTimeSlots = hMp4SpaceEnc->nFrameTimeSlots;
-
-    INT encoderInputChScale[SACENC_MAX_INPUT_CHANNELS];
-    INT nFrameTimeSlotsReduction = 0;
-
-    if (hMp4SpaceEnc->encMode == SACENC_212) {
-      nFrameTimeSlotsReduction = hMp4SpaceEnc->nFrameTimeSlots >> 1;
-    }
-
-    for (i = 0; i < nChIn; i++)
-      encoderInputChScale[i] = hMp4SpaceEnc->pEncoderInputChScale[i];
-
-    /* Sanity Check */
-    if ((0 != inargs->nInputSamples % nChInWithDmx)) {
-      error = SACENC_INVALID_CONFIG;
-      goto bail;
-    }
-
-    /*
-     * Get Frame Data Handle.
-     */
-
-    /* get bitstream handle (for storage of cld's, icc's and so on)
-     * get spatialframe 2 frames in the future; NOTE: this is necessary to
-     * synchronise spatial data and audio data */
-    if (NULL == (pFrameData = fdk_sacenc_getSpatialFrame(
-                     hMp4SpaceEnc->hBitstreamFormatter, WRITE_SPATIALFRAME))) {
-      error = SACENC_INVALID_HANDLE;
-      goto bail;
-    }
-
-    /* Independent Frames Counters*/
-    if (hMp4SpaceEnc->nDiscardOutFrames >
-        0) { /* Independent Frames if they should be discarded, Reset Counter*/
-      hMp4SpaceEnc->independencyCount =
-          0; /* Reset the counter, first valid frame is an independent one*/
-      hMp4SpaceEnc->independencyFlag = 1;
-    } else { /*hMp4SpaceEnc->nDiscardOutFrames == 0*/
-      hMp4SpaceEnc->independencyFlag =
-          (hMp4SpaceEnc->independencyCount == 0) ? 1 : 0;
-      if (hMp4SpaceEnc->independencyFactor > 0) {
-        hMp4SpaceEnc->independencyCount++;
-        hMp4SpaceEnc->independencyCount =
-            hMp4SpaceEnc->independencyCount %
-            ((int)hMp4SpaceEnc->independencyFactor);
-      } else { /* independencyFactor == 0 */
-        hMp4SpaceEnc->independencyCount = -1;
-      }
-    }
-
-    /*
-     * Time signal preprocessing:
-     * - Feed input buffer
-     * - Prescale time signal
-     * - Apply DC filter on input signal
-     */
-
-    /* Feed, Deinterleave, Pre-Scale the input time signals */
-    if (SACENC_OK !=
-        (error = __FeedDeinterPreScale(
-             hMp4SpaceEnc, pInputSamples, pOutputSamples, inargs->nInputSamples,
-             inargs->isInputInterleaved, inargs->inputBufferSizePerChannel,
-             &outargs->nSamplesConsumed))) {
-      goto bail;
-    }
-
-    if (hMp4SpaceEnc->nSamplesNext != hMp4SpaceEnc->nSamplesValid) {
-      error = SACENC_INVALID_CONFIG;
-      goto bail;
-    }
-
-    if (hMp4SpaceEnc->encMode == SACENC_212 &&
-        hMp4SpaceEnc->bEncMode_212_only) {
-      for (ch = 0; ch < nChIn; ch++) {
-        for (slot = 0; slot < nFrameTimeSlots; slot++) {
-          setCplxVec(
-              hMp4SpaceEnc->pppHybridIn__FDK
-                  [ch][hMp4SpaceEnc->nUpdateHybridPositionTimeSlots +
-                       nFrameTimeSlots - nFrameTimeSlotsReduction + slot],
-              (FIXP_DBL)0, hMp4SpaceEnc->nHybridBands);
-        }
-      }
-    }
-
-    /*
-     * Time / Frequency:
-     * - T/F audio input channels
-     * - T/F arbitrary downmix input channels
-     */
-    for (ch = 0; ch < nChIn; ch++) {
-      C_AALLOC_SCRATCH_START(pQmfInReal, FIXP_DBL, MAX_QMF_BANDS)
-      C_AALLOC_SCRATCH_START(pQmfInImag, FIXP_DBL, MAX_QMF_BANDS)
-      FIXP_GAIN *pPreGain =
-          fdk_sacenc_getPreGainPtrFDK(hMp4SpaceEnc->hStaticGain);
-
-      for (ts = 0; ts < nFrameTimeSlots; ts++) {
-        FIXP_DBL *pSpecReal;
-        FIXP_DBL *pSpecImag;
-
-        INT_PCM *pTimeIn =
-            &hMp4SpaceEnc->ppTimeSigIn__FDK[ch][(ts * hMp4SpaceEnc->nQmfBands)];
-
-        {
-          /* Apply DC filter on input channels */
-          if (SACENC_OK != (error = fdk_sacenc_applyDCFilter(
-                                hMp4SpaceEnc->phDCFilterSigIn[ch], pTimeIn,
-                                pTimeIn, hMp4SpaceEnc->nQmfBands))) {
-            goto bail;
-          }
-        }
-
-        /* QMF filterbank */
-        C_ALLOC_SCRATCH_START(pWorkBuffer, FIXP_DBL, (MAX_QMF_BANDS << 1));
-
-        qmfAnalysisFilteringSlot(hMp4SpaceEnc->phQmfFiltIn__FDK[ch], pQmfInReal,
-                                 pQmfInImag, pTimeIn, 1, pWorkBuffer);
-
-        C_ALLOC_SCRATCH_END(pWorkBuffer, FIXP_DBL, (MAX_QMF_BANDS << 1));
-
-        pSpecReal = pQmfInReal;
-        pSpecImag = pQmfInImag;
-
-        /* Apply pre-scale after filterbank */
-        if (MAXVAL_GAIN != pPreGain[ch]) {
-          for (i = 0; i < hMp4SpaceEnc->nHybridBands; i++) {
-            hMp4SpaceEnc
-                ->pppHybridIn__FDK[ch]
-                                  [hMp4SpaceEnc->nAnalysisLookaheadTimeSlots +
-                                   ts][i]
-                .v.re = fMult(pSpecReal[i], pPreGain[ch]);
-            hMp4SpaceEnc
-                ->pppHybridIn__FDK[ch]
-                                  [hMp4SpaceEnc->nAnalysisLookaheadTimeSlots +
-                                   ts][i]
-                .v.im = fMult(pSpecImag[i], pPreGain[ch]);
-          }
-        } else {
-          for (i = 0; i < hMp4SpaceEnc->nHybridBands; i++) {
-            hMp4SpaceEnc
-                ->pppHybridIn__FDK[ch]
-                                  [hMp4SpaceEnc->nAnalysisLookaheadTimeSlots +
-                                   ts][i]
-                .v.re = pSpecReal[i];
-            hMp4SpaceEnc
-                ->pppHybridIn__FDK[ch]
-                                  [hMp4SpaceEnc->nAnalysisLookaheadTimeSlots +
-                                   ts][i]
-                .v.im = pSpecImag[i];
-          }
-        }
-      } /* ts */
-      C_AALLOC_SCRATCH_END(pQmfInImag, FIXP_DBL, MAX_QMF_BANDS)
-      C_AALLOC_SCRATCH_END(pQmfInReal, FIXP_DBL, MAX_QMF_BANDS)
-
-      if (SACENC_OK != error) {
-        goto bail;
-      }
-    } /* ch */
-
-    if (hMp4SpaceEnc->encMode == SACENC_212 &&
-        hMp4SpaceEnc->bEncMode_212_only) {
-      for (ch = 0; ch < nChIn; ch++) {
-        for (slot = 0;
-             slot < (int)(hMp4SpaceEnc->nUpdateHybridPositionTimeSlots +
-                          nFrameTimeSlots - nFrameTimeSlotsReduction);
-             slot++) {
-          copyCplxVec(hMp4SpaceEnc->pppHybridIn__FDK[ch][slot],
-                      hMp4SpaceEnc->pppHybridInStatic__FDK[ch][slot],
-                      hMp4SpaceEnc->nHybridBands);
-        }
-      }
-      for (ch = 0; ch < nChIn; ch++) {
-        for (slot = 0;
-             slot < (int)(hMp4SpaceEnc->nUpdateHybridPositionTimeSlots +
-                          nFrameTimeSlots - nFrameTimeSlotsReduction);
-             slot++) {
-          copyCplxVec(
-              hMp4SpaceEnc->pppHybridInStatic__FDK[ch][slot],
-              hMp4SpaceEnc->pppHybridIn__FDK[ch][nFrameTimeSlots + slot],
-              hMp4SpaceEnc->nHybridBands);
-        }
-      }
-    }
-
-    /*
-     * Onset Detection:
-     * - detection of transients
-     * - build framing
-     */
-    for (ch = 0; ch < nChIn; ch++) {
-      if (ch != 3) { /* !LFE */
-        if (SACENC_OK !=
-            (error = fdk_sacenc_onsetDetect_Apply(
-                 hMp4SpaceEnc->phOnset[ch], nFrameTimeSlots,
-                 hMp4SpaceEnc->nHybridBands,
-                 &hMp4SpaceEnc->pppHybridIn__FDK
-                      [ch][hMp4SpaceEnc->nAnalysisLookaheadTimeSlots],
-                 encoderInputChScale[ch],
-                 hMp4SpaceEnc->trPrevPos[1], /* contains previous Transient */
-                 hMp4SpaceEnc->ppTrCurrPos[ch]))) {
-          goto bail;
-        }
-
-        if ((1) && (hMp4SpaceEnc->useFrameKeep == 0)) {
-          hMp4SpaceEnc->ppTrCurrPos[ch][0] = -1;
-        }
-
-        /* Find first Transient Position */
-        if ((hMp4SpaceEnc->ppTrCurrPos[ch][0] >= 0) &&
-            ((currTransPos < 0) ||
-             (hMp4SpaceEnc->ppTrCurrPos[ch][0] < currTransPos))) {
-          currTransPos = hMp4SpaceEnc->ppTrCurrPos[ch][0];
-        }
-      } /* !LFE */
-    }   /* ch */
-
-    if (hMp4SpaceEnc->useFrameKeep == 1) {
-      if ((currTransPos != -1) || (hMp4SpaceEnc->independencyFlag == 1)) {
-        hMp4SpaceEnc->avoid_keep = NUM_KEEP_WINDOWS;
-        currTransPos = -1;
-      }
-    }
-
-    /* Save previous Transient Position */
-    hMp4SpaceEnc->trPrevPos[0] =
-        FDKmax(-1, hMp4SpaceEnc->trPrevPos[1] - (INT)nFrameTimeSlots);
-    hMp4SpaceEnc->trPrevPos[1] = currTransPos;
-
-    /* Update Onset Detection Energy Buffer */
-    for (ch = 0; ch < nChIn; ch++) {
-      if (SACENC_OK != (error = fdk_sacenc_onsetDetect_Update(
-                            hMp4SpaceEnc->phOnset[ch], nFrameTimeSlots))) {
-        goto bail;
-      }
-    }
-
-    /* Framing */
-    if (SACENC_OK !=
-        (error = fdk_sacenc_frameWindow_GetWindow(
-             hMp4SpaceEnc->hFrameWindow, hMp4SpaceEnc->trPrevPos,
-             nFrameTimeSlots, &pFrameData->framingInfo,
-             hMp4SpaceEnc->pFrameWindowAna__FDK, &hMp4SpaceEnc->frameWinList,
-             hMp4SpaceEnc->avoid_keep))) {
-      goto bail;
-    }
-
-    /*
-     * MPS Processing:
-     */
-    for (ps = 0, winCnt = 0; ps < hMp4SpaceEnc->frameWinList.n; ++ps) {
-      /* Analysis Windowing */
-      if (hMp4SpaceEnc->frameWinList.dat[ps].hold == FW_HOLD) {
-        /* ************************************** */
-        /* ONLY COPY AND HOLD PREVIOUS PARAMETERS */
-        if (SACENC_OK != (error = fdk_sacenc_duplicateParameterSet(
-                              &hMp4SpaceEnc->saveFrame, 0, pFrameData, ps))) {
-          goto bail;
-        }
-
-      } else { /* !FW_HOLD */
-        /* ************************************** */
-        /* NEW WINDOW */
-
-        INT nAnalysisLengthTimeSlots, analysisStartTimeSlot;
-
-        nAnalysisLengthTimeSlots = getAnalysisLengthTimeSlots(
-            hMp4SpaceEnc->pFrameWindowAna__FDK[winCnt],
-            hMp4SpaceEnc->nAnalysisLengthTimeSlots);
-
-        analysisStartTimeSlot =
-            getAnalysisStartTimeSlot(hMp4SpaceEnc->pFrameWindowAna__FDK[winCnt],
-                                     hMp4SpaceEnc->nAnalysisLengthTimeSlots);
-
-        /* perform main signal analysis windowing in
-         * fdk_sacenc_spaceTree_Apply() */
-        FIXP_WIN *pFrameWindowAna__FDK =
-            hMp4SpaceEnc->pFrameWindowAna__FDK[winCnt];
-        FIXP_DPK ***pppHybridIn__FDK = hMp4SpaceEnc->pppHybridIn__FDK;
-        FIXP_DPK ***pppProcDataIn__FDK = hMp4SpaceEnc->pppProcDataIn__FDK;
-
-        if (hMp4SpaceEnc->encMode == SACENC_212 &&
-            hMp4SpaceEnc->bEncMode_212_only) {
-          pppProcDataIn__FDK = pppHybridIn__FDK;
-        }
-
-        if (SACENC_OK !=
-            (error = fdk_sacenc_spaceTree_Apply(
-                 hMp4SpaceEnc->hSpaceTree, ps, nChIn, nAnalysisLengthTimeSlots,
-                 analysisStartTimeSlot, hMp4SpaceEnc->nHybridBands,
-                 pFrameWindowAna__FDK, pppHybridIn__FDK,
-                 pppProcDataIn__FDK, /* multi-channel input */
-                 pFrameData, hMp4SpaceEnc->avoid_keep, encoderInputChScale))) {
-          goto bail;
-        }
-
-        /* Save spatial frame for potential hold parameter set */
-        if (SACENC_OK != (error = fdk_sacenc_duplicateParameterSet(
-                              pFrameData, ps, &hMp4SpaceEnc->saveFrame, 0))) {
-          goto bail;
-        }
-
-        ++winCnt;
-      }
-      if (hMp4SpaceEnc->avoid_keep > 0) {
-        hMp4SpaceEnc->avoid_keep--;
-      }
-    } /* Loop over Parameter Sets */
-    /* ---- End of Processing Loop ---- */
-
-    /*
-     * Update hybridInReal/Imag buffer and do the same for arbDmx
-     * this means to move the hybrid data of the current frame to the beginning
-     * of the 2*nFrameLength-long buffer
-     */
-    if (!(hMp4SpaceEnc->encMode == SACENC_212 &&
-          hMp4SpaceEnc->bEncMode_212_only)) {
-      for (ch = 0; ch < nChIn; ch++) { /* for automatic downmix */
-        for (slot = 0;
-             slot < (int)(hMp4SpaceEnc->nUpdateHybridPositionTimeSlots +
-                          nFrameTimeSlots - nFrameTimeSlotsReduction);
-             slot++) {
-          copyCplxVec(
-              hMp4SpaceEnc->pppHybridIn__FDK[ch][slot],
-              hMp4SpaceEnc->pppHybridIn__FDK[ch][nFrameTimeSlots + slot],
-              hMp4SpaceEnc->nHybridBands);
-        }
-        for (slot = 0; slot < nFrameTimeSlots; slot++) {
-          setCplxVec(
-              hMp4SpaceEnc->pppHybridIn__FDK
-                  [ch][hMp4SpaceEnc->nUpdateHybridPositionTimeSlots +
-                       nFrameTimeSlots - nFrameTimeSlotsReduction + slot],
-              (FIXP_DBL)0, hMp4SpaceEnc->nHybridBands);
-        }
-      }
-    }
-    /*
-     * Spatial Tonality:
-     */
-    {
-      /* Smooth config off. */
-      FDKmemclear(&pFrameData->smgData, sizeof(pFrameData->smgData));
-    }
-
-    /*
-     * Create bitstream
-     * - control independecy flag
-     * - write spatial frame
-     * - return bitstream
-     */
-    UCHAR *pBitstreamDelayBuffer;
-
-    if (hMp4SpaceEnc->encMode == SACENC_212) {
-      /* no bitstream delay buffer for SACENC_212 mode, write bitstream directly
-       * into the sacOutBuffer buffer which is provided by the core routine */
-      pBitstreamDelayBuffer = (UCHAR *)outBufDesc->ppBase[1];
-    } else {
-      /* bitstream delay is handled in ppBitstreamDelayBuffer buffer */
-      pBitstreamDelayBuffer =
-          hMp4SpaceEnc
-              ->ppBitstreamDelayBuffer[hMp4SpaceEnc->nBitstreamBufferWrite];
-    }
-    if (pBitstreamDelayBuffer == NULL) {
-      error = SACENC_INVALID_HANDLE;
-      goto bail;
-    }
-
-    pFrameData->bsIndependencyFlag = hMp4SpaceEnc->independencyFlag;
-
-    if (SACENC_OK !=
-        (error = fdk_sacenc_writeSpatialFrame(
-             pBitstreamDelayBuffer, MAX_MPEGS_BYTES,
-             &hMp4SpaceEnc->pnOutputBits[hMp4SpaceEnc->nBitstreamBufferWrite],
-             hMp4SpaceEnc->hBitstreamFormatter))) {
-      goto bail;
-    }
-
-    /* return bitstream info */
-    if ((hMp4SpaceEnc->nDiscardOutFrames == 0) &&
-        (getBufDescIdx(outBufDesc,
-                       (FDK_BUF_TYPE_OUTPUT | FDK_BUF_TYPE_BS_DATA)) != -1)) {
-      const INT idx = getBufDescIdx(
-          outBufDesc, (FDK_BUF_TYPE_OUTPUT | FDK_BUF_TYPE_BS_DATA));
-      const INT outBits =
-          hMp4SpaceEnc->pnOutputBits[hMp4SpaceEnc->nBitstreamBufferRead];
-
-      if (((outBits + 7) / 8) >
-          (INT)(outBufDesc->pBufSize[idx] / outBufDesc->pEleSize[idx])) {
-        outargs->nOutputBits = 0;
-        error = SACENC_ENCODE_ERROR;
-        goto bail;
-      }
-
-      /* return bitstream buffer, copy delayed bitstream for all configurations
-       * except for the SACENC_212 mode */
-      if (hMp4SpaceEnc->encMode != SACENC_212) {
-        FDKmemcpy(
-            outBufDesc->ppBase[idx],
-            hMp4SpaceEnc
-                ->ppBitstreamDelayBuffer[hMp4SpaceEnc->nBitstreamBufferRead],
-            (outBits + 7) / 8);
-      }
-
-      /* return number of valid bits */
-      outargs->nOutputBits = outBits;
-    } else { /* No spatial data should be returned if the current frame is to be
-                discarded. */
-      outargs->nOutputBits = 0;
-    }
-
-    /* update pointers */
-    hMp4SpaceEnc->nBitstreamBufferRead =
-        (hMp4SpaceEnc->nBitstreamBufferRead + 1) %
-        hMp4SpaceEnc->nBitstreamDelayBuffer;
-    hMp4SpaceEnc->nBitstreamBufferWrite =
-        (hMp4SpaceEnc->nBitstreamBufferWrite + 1) %
-        hMp4SpaceEnc->nBitstreamDelayBuffer;
-
-    /* Set Output Parameters */
-    nOutputSamples =
-        (hMp4SpaceEnc->nDiscardOutFrames == 0)
-            ? (nOutputSamplesMax)
-            : 0; /* don't output samples in case frames to be discarded */
-    if (nOutputSamples > nOutputSamplesBufferSize) {
-      error = SACENC_INVALID_CONFIG;
-      goto bail;
-    }
-    outargs->nOutputSamples = nOutputSamples;
-
-    { /* !bQmfOutput */
-
-      if (hMp4SpaceEnc->encMode != SACENC_212) {
-        /* delay output samples and interleave them */
-        /* note: in case of arbitrary downmix this will always be processed,
-         * because nOutputSamples != 0, even if bDMXAlign is switched on */
-        /* always run copy-func, so nOutputSamplesMax instead of nOutputSamples
-         */
-        for (ch = 0; ch < nChOut; ch++) {
-          FDKmemcpy_flex(
-              &hMp4SpaceEnc->pOutputDelayBuffer__FDK
-                   [ch + (hMp4SpaceEnc->nOutputBufferDelay) * nChOut],
-              nChOut, hMp4SpaceEnc->ppTimeSigOut__FDK[ch], 1,
-              nOutputSamplesMax / nChOut);
-        }
-
-        /* write delayed data in output pcm stream */
-        /* always calculate, limiter must have a lookahead!!! */
-        FDKmemcpy(pOutputSamples, hMp4SpaceEnc->pOutputDelayBuffer__FDK,
-                  nOutputSamplesMax * sizeof(INT_PCM));
-
-        /* update delay buffer (move back end to the beginning of the buffer) */
-        FDKmemmove(
-            hMp4SpaceEnc->pOutputDelayBuffer__FDK,
-            &hMp4SpaceEnc->pOutputDelayBuffer__FDK[nOutputSamplesMax],
-            nChOut * (hMp4SpaceEnc->nOutputBufferDelay) * sizeof(INT_PCM));
-      }
-
-      if (hMp4SpaceEnc->useTimeDomDownmix <= 0) {
-        if (SACENC_OK != (error = fdk_sacenc_staticPostGain_ApplyFDK(
-                              hMp4SpaceEnc->hStaticGain, pOutputSamples,
-                              nOutputSamplesMax, 0))) {
-          goto bail;
-        }
-      }
-
-    } /* !bQmfOutput */
-
-    if (hMp4SpaceEnc->nDiscardOutFrames > 0) {
-      hMp4SpaceEnc->nDiscardOutFrames--;
-    }
-
-    /* Invalidate Input Buffer */
-    hMp4SpaceEnc->nSamplesValid = 0;
-
-  } /* valid handle */
-bail:
-  return error;
-}
-
-FDK_SACENC_ERROR FDK_sacenc_close(HANDLE_MP4SPACE_ENCODER *phMp4SpaceEnc) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if (NULL != phMp4SpaceEnc) {
-    if (NULL != *phMp4SpaceEnc) {
-      int ch, i;
-      HANDLE_MP4SPACE_ENCODER const hEnc = *phMp4SpaceEnc;
-
-      if (hEnc->pParameterBand2HybridBandOffset != NULL) {
-        FDK_FREE_MEMORY_1D(hEnc->pParameterBand2HybridBandOffset);
-      }
-      /* Free Analysis Filterbank Structs */
-      if (hEnc->pEncoderInputChScale != NULL) {
-        FDK_FREE_MEMORY_1D(hEnc->pEncoderInputChScale);
-      }
-      if (hEnc->staticTimeDomainDmxInScale != NULL) {
-        FDK_FREE_MEMORY_1D(hEnc->staticTimeDomainDmxInScale);
-      }
-      if (hEnc->phQmfFiltIn__FDK != NULL) {
-        for (ch = 0; ch < hEnc->setup.maxChIn; ch++) {
-          if (hEnc->phQmfFiltIn__FDK[ch] != NULL) {
-            if (hEnc->phQmfFiltIn__FDK[ch]->FilterStates != NULL) {
-              FDK_FREE_MEMORY_1D(hEnc->phQmfFiltIn__FDK[ch]->FilterStates);
-            }
-            FDK_FREE_MEMORY_1D(hEnc->phQmfFiltIn__FDK[ch]);
-          }
-        }
-        FDK_FREE_MEMORY_1D(hEnc->phQmfFiltIn__FDK);
-      }
-      for (ch = 0; ch < hEnc->setup.maxChIn; ch++) {
-        if (NULL != hEnc->phDCFilterSigIn[ch]) {
-          fdk_sacenc_destroyDCFilter(&hEnc->phDCFilterSigIn[ch]);
-        }
-      }
-      /* Close Onset Detection */
-      for (ch = 0; ch < hEnc->setup.maxChIn; ch++) {
-        if (NULL != hEnc->phOnset[ch]) {
-          fdk_sacenc_onsetDetect_Close(&hEnc->phOnset[ch]);
-        }
-      }
-      if (hEnc->ppTrCurrPos) {
-        FDK_FREE_MEMORY_2D(hEnc->ppTrCurrPos);
-      }
-      if (hEnc->hFrameWindow) {
-        fdk_sacenc_frameWindow_Destroy(&hEnc->hFrameWindow);
-      }
-      /* Close Space Tree */
-      if (NULL != hEnc->hSpaceTree) {
-        fdk_sacenc_spaceTree_Close(&hEnc->hSpaceTree);
-      }
-      if (NULL != hEnc->hEnhancedTimeDmx) {
-        fdk_sacenc_close_enhancedTimeDomainDmx(&hEnc->hEnhancedTimeDmx);
-      }
-      /* Close Static Gain */
-      if (NULL != hEnc->hStaticGain) {
-        fdk_sacenc_staticGain_Close(&hEnc->hStaticGain);
-      }
-      if (NULL != hEnc->hStaticGainConfig) {
-        fdk_sacenc_staticGain_CloseConfig(&hEnc->hStaticGainConfig);
-      }
-      /* Close Delay*/
-      if (NULL != hEnc->hDelay) {
-        fdk_sacenc_delay_Close(&hEnc->hDelay);
-      }
-      /* Delete Bitstream Stuff */
-      if (NULL != hEnc->hBitstreamFormatter) {
-        fdk_sacenc_destroySpatialBitstreamEncoder(&(hEnc->hBitstreamFormatter));
-      }
-      if (hEnc->pppHybridIn__FDK != NULL) {
-        if (hEnc->setup.bEncMode_212 == 1) {
-          FDK_FREE_MEMORY_3D(hEnc->pppHybridIn__FDK);
-          FDK_FREE_MEMORY_3D(hEnc->pppHybridInStatic__FDK);
-        } else {
-          FDK_FREE_MEMORY_3D(hEnc->pppHybridIn__FDK);
-        }
-      }
-      if (hEnc->pppProcDataIn__FDK != NULL) {
-        FDK_FREE_MEMORY_3D(hEnc->pppProcDataIn__FDK);
-      }
-      if (hEnc->pOutputDelayBuffer__FDK != NULL) {
-        FDK_FREE_MEMORY_1D(hEnc->pOutputDelayBuffer__FDK);
-      }
-      if (hEnc->ppTimeSigIn__FDK != NULL) {
-        { FDK_FREE_MEMORY_2D(hEnc->ppTimeSigIn__FDK); }
-      }
-      if (hEnc->ppTimeSigDelayIn__FDK != NULL) {
-        FDK_FREE_MEMORY_2D(hEnc->ppTimeSigDelayIn__FDK);
-      }
-      if (hEnc->ppTimeSigOut__FDK != NULL) {
-        FDK_FREE_MEMORY_2D(hEnc->ppTimeSigOut__FDK);
-      }
-      for (i = 0; i < MAX_NUM_PARAMS; i++) {
-        if (hEnc->pFrameWindowAna__FDK[i] != NULL) {
-          FDK_FREE_MEMORY_1D(hEnc->pFrameWindowAna__FDK[i]);
-        }
-      }
-      if (hEnc->pnOutputBits != NULL) {
-        FDK_FREE_MEMORY_1D(hEnc->pnOutputBits);
-      }
-      if (hEnc->ppBitstreamDelayBuffer != NULL) {
-        FDK_FREE_MEMORY_2D(hEnc->ppBitstreamDelayBuffer);
-      }
-      if (hEnc->sscBuf.pSsc != NULL) {
-        FDK_FREE_MEMORY_1D(hEnc->sscBuf.pSsc);
-      }
-      FDK_FREE_MEMORY_1D(*phMp4SpaceEnc);
-    }
-  }
-
-  return error;
-}
-
-/*-----------------------------------------------------------------------------
-  functionname: mp4SpaceEnc_InitDelayCompensation()
-  description:  initialzes delay compensation
-  returns:      noError on success, an apropriate error code else
-  -----------------------------------------------------------------------------*/
-static FDK_SACENC_ERROR mp4SpaceEnc_InitDelayCompensation(
-    HANDLE_MP4SPACE_ENCODER hMp4SpaceEnc, const INT coreCoderDelay) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  /* Sanity Check */
-  if (hMp4SpaceEnc == NULL) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    hMp4SpaceEnc->coreCoderDelay = coreCoderDelay;
-
-    if (SACENC_OK != (error = fdk_sacenc_delay_Init(
-                          hMp4SpaceEnc->hDelay, hMp4SpaceEnc->nQmfBands,
-                          hMp4SpaceEnc->nFrameLength, coreCoderDelay,
-                          hMp4SpaceEnc->timeAlignment))) {
-      goto bail;
-    }
-
-    fdk_sacenc_delay_SetDmxAlign(hMp4SpaceEnc->hDelay, 0);
-    fdk_sacenc_delay_SetTimeDomDmx(
-        hMp4SpaceEnc->hDelay, (hMp4SpaceEnc->useTimeDomDownmix >= 1) ? 1 : 0);
-    fdk_sacenc_delay_SetMinimizeDelay(hMp4SpaceEnc->hDelay, 1);
-
-    if (SACENC_OK != (error = fdk_sacenc_delay_SubCalulateBufferDelays(
-                          hMp4SpaceEnc->hDelay))) {
-      goto bail;
-    }
-
-    /* init output delay compensation */
-    hMp4SpaceEnc->nBitstreamDelayBuffer =
-        fdk_sacenc_delay_GetBitstreamFrameBufferSize(hMp4SpaceEnc->hDelay);
-    hMp4SpaceEnc->nOutputBufferDelay =
-        fdk_sacenc_delay_GetOutputAudioBufferDelay(hMp4SpaceEnc->hDelay);
-    hMp4SpaceEnc->nSurroundAnalysisBufferDelay =
-        fdk_sacenc_delay_GetSurroundAnalysisBufferDelay(hMp4SpaceEnc->hDelay);
-    hMp4SpaceEnc->nBitstreamBufferRead = 0;
-    hMp4SpaceEnc->nBitstreamBufferWrite =
-        hMp4SpaceEnc->nBitstreamDelayBuffer - 1;
-
-    if (hMp4SpaceEnc->encMode == SACENC_212) {
-      /* mode 212 expects no bitstream delay */
-      if (hMp4SpaceEnc->nBitstreamBufferWrite !=
-          hMp4SpaceEnc->nBitstreamBufferRead) {
-        error = SACENC_PARAM_ERROR;
-        goto bail;
-      }
-
-      /* mode 212 expects no output buffer delay */
-      if (hMp4SpaceEnc->nOutputBufferDelay != 0) {
-        error = SACENC_PARAM_ERROR;
-        goto bail;
-      }
-    }
-
-    /*** Input delay to obtain a net encoder delay that is a multiple
-    of the used framelength to ensure synchronization of framing
-    in artistic down-mix with the corresponding spatial data.      ***/
-    hMp4SpaceEnc->nDiscardOutFrames =
-        fdk_sacenc_delay_GetDiscardOutFrames(hMp4SpaceEnc->hDelay);
-    hMp4SpaceEnc->nInputDelay =
-        fdk_sacenc_delay_GetDmxAlignBufferDelay(hMp4SpaceEnc->hDelay);
-
-    /* reset independency Flag counter */
-    hMp4SpaceEnc->independencyCount = 0;
-    hMp4SpaceEnc->independencyFlag = 1;
-
-    int i;
-
-    /* write some parameters to bitstream */
-    for (i = 0; i < hMp4SpaceEnc->nBitstreamDelayBuffer - 1; i++) {
-      SPATIALFRAME *pFrameData = NULL;
-
-      if (NULL == (pFrameData = fdk_sacenc_getSpatialFrame(
-                       hMp4SpaceEnc->hBitstreamFormatter, READ_SPATIALFRAME))) {
-        error = SACENC_INVALID_HANDLE;
-        goto bail;
-      }
-
-      pFrameData->bsIndependencyFlag = 1;
-      pFrameData->framingInfo.numParamSets = 1;
-      pFrameData->framingInfo.bsFramingType = 0;
-
-      fdk_sacenc_writeSpatialFrame(
-          hMp4SpaceEnc->ppBitstreamDelayBuffer[i], MAX_MPEGS_BYTES,
-          &hMp4SpaceEnc->pnOutputBits[i], hMp4SpaceEnc->hBitstreamFormatter);
-    }
-
-    if ((hMp4SpaceEnc->nInputDelay > MAX_DELAY_INPUT) ||
-        (hMp4SpaceEnc->nOutputBufferDelay > MAX_DELAY_OUTPUT) ||
-        (hMp4SpaceEnc->nSurroundAnalysisBufferDelay >
-         MAX_DELAY_SURROUND_ANALYSIS) ||
-        (hMp4SpaceEnc->nBitstreamDelayBuffer > MAX_BITSTREAM_DELAY)) {
-      error = SACENC_INIT_ERROR;
-      goto bail;
-    }
-  }
-
-bail:
-
-  return error;
-}
-
-static QUANTMODE __mapQuantMode(const MP4SPACEENC_QUANTMODE quantMode) {
-  QUANTMODE bsQuantMode = QUANTMODE_INVALID;
-
-  switch (quantMode) {
-    case SACENC_QUANTMODE_FINE:
-      bsQuantMode = QUANTMODE_FINE;
-      break;
-    case SACENC_QUANTMODE_EBQ1:
-      bsQuantMode = QUANTMODE_EBQ1;
-      break;
-    case SACENC_QUANTMODE_EBQ2:
-      bsQuantMode = QUANTMODE_EBQ2;
-      break;
-    case SACENC_QUANTMODE_RSVD3:
-    case SACENC_QUANTMODE_INVALID:
-    default:
-      bsQuantMode = QUANTMODE_INVALID;
-  } /* switch hEnc->quantMode */
-
-  return bsQuantMode;
-}
-
-static FDK_SACENC_ERROR FillSpatialSpecificConfig(
-    const HANDLE_MP4SPACE_ENCODER hEnc, SPATIALSPECIFICCONFIG *const hSsc) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if ((NULL == hEnc) || (NULL == hSsc)) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    SPACE_TREE_DESCRIPTION spaceTreeDescription;
-    int i;
-
-    /* Get tree description */
-    if (SACENC_OK != (error = fdk_sacenc_spaceTree_GetDescription(
-                          hEnc->hSpaceTree, &spaceTreeDescription))) {
-      goto bail;
-    }
-
-    /* Fill SSC */
-    FDKmemclear(hSsc, sizeof(SPATIALSPECIFICCONFIG)); /* reset */
-
-    hSsc->numBands = hEnc->spaceTreeSetup.nParamBands; /* for bsFreqRes */
-
-    /* Fill tree configuration */
-    hSsc->treeDescription.numOttBoxes = spaceTreeDescription.nOttBoxes;
-    hSsc->treeDescription.numInChan = spaceTreeDescription.nInChannels;
-    hSsc->treeDescription.numOutChan = spaceTreeDescription.nOutChannels;
-
-    for (i = 0; i < SACENC_MAX_NUM_BOXES; i++) {
-      hSsc->ottConfig[i].bsOttBands = hSsc->numBands;
-    }
-
-    switch (hEnc->encMode) {
-      case SACENC_212:
-        hSsc->bsTreeConfig = TREE_212;
-        break;
-      case SACENC_INVALID_MODE:
-      default:
-        error = SACENC_INVALID_CONFIG;
-        goto bail;
-    }
-
-    hSsc->bsSamplingFrequency =
-        hEnc->nSampleRate; /* for bsSamplingFrequencyIndex */
-    hSsc->bsFrameLength = hEnc->nFrameTimeSlots - 1;
-
-    /* map decorr type */
-    if (DECORR_INVALID ==
-        (hSsc->bsDecorrConfig = mp4SpaceEnc_GetDecorrConfig(hEnc->encMode))) {
-      error = SACENC_INVALID_CONFIG;
-      goto bail;
-    }
-
-    /* map quantMode */
-    if (QUANTMODE_INVALID ==
-        (hSsc->bsQuantMode = __mapQuantMode(hEnc->quantMode))) {
-      error = SACENC_INVALID_CONFIG;
-      goto bail;
-    }
-
-    /* Configure Gains*/
-    hSsc->bsFixedGainDMX = fdk_sacenc_staticGain_GetDmxGain(hEnc->hStaticGain);
-    hSsc->bsEnvQuantMode = 0;
-
-  } /* valid handle */
-
-bail:
-  return error;
-}
-
-static FDK_SACENC_ERROR mp4SpaceEnc_FillSpaceTreeSetup(
-    const HANDLE_MP4SPACE_ENCODER hEnc,
-    SPACE_TREE_SETUP *const hSpaceTreeSetup) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  /* Sanity Check */
-  if (NULL == hEnc || NULL == hSpaceTreeSetup) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    QUANTMODE tmpQuantmode = QUANTMODE_INVALID;
-
-    /* map quantMode */
-    if (QUANTMODE_INVALID == (tmpQuantmode = __mapQuantMode(hEnc->quantMode))) {
-      error = SACENC_INVALID_CONFIG;
-      goto bail;
-    }
-
-    hSpaceTreeSetup->nParamBands = hEnc->nParamBands;
-    hSpaceTreeSetup->bUseCoarseQuantTtoCld = hEnc->useCoarseQuantCld;
-    hSpaceTreeSetup->bUseCoarseQuantTtoIcc = hEnc->useCoarseQuantIcc;
-    hSpaceTreeSetup->quantMode = tmpQuantmode;
-    hSpaceTreeSetup->nHybridBandsMax = hEnc->nHybridBands;
-
-    switch (hEnc->encMode) {
-      case SACENC_212:
-        hSpaceTreeSetup->mode = SPACETREE_212;
-        hSpaceTreeSetup->nChannelsInMax = 2;
-        break;
-      case SACENC_INVALID_MODE:
-      default:
-        error = SACENC_INVALID_CONFIG;
-        goto bail;
-    } /* switch hEnc->encMode */
-
-  } /* valid handle */
-bail:
-  return error;
-}
-
-FDK_SACENC_ERROR FDK_sacenc_getInfo(const HANDLE_MP4SPACE_ENCODER hMp4SpaceEnc,
-                                    MP4SPACEENC_INFO *const pInfo) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if ((NULL == hMp4SpaceEnc) || (NULL == pInfo)) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    pInfo->nSampleRate = hMp4SpaceEnc->nSampleRate;
-    pInfo->nSamplesFrame = hMp4SpaceEnc->nFrameLength;
-    pInfo->nTotalInputChannels = hMp4SpaceEnc->nInputChannels;
-    pInfo->nDmxDelay = fdk_sacenc_delay_GetInfoDmxDelay(hMp4SpaceEnc->hDelay);
-    pInfo->nCodecDelay =
-        fdk_sacenc_delay_GetInfoCodecDelay(hMp4SpaceEnc->hDelay);
-    pInfo->nDecoderDelay =
-        fdk_sacenc_delay_GetInfoDecoderDelay(hMp4SpaceEnc->hDelay);
-    pInfo->nPayloadDelay =
-        fdk_sacenc_delay_GetBitstreamFrameBufferSize(hMp4SpaceEnc->hDelay) - 1;
-    pInfo->nDiscardOutFrames = hMp4SpaceEnc->nDiscardOutFrames;
-
-    pInfo->pSscBuf = &hMp4SpaceEnc->sscBuf;
-  }
-  return error;
-}
-
-FDK_SACENC_ERROR FDK_sacenc_setParam(HANDLE_MP4SPACE_ENCODER hMp4SpaceEnc,
-                                     const SPACEENC_PARAM param,
-                                     const UINT value) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  /* check encoder handle */
-  if (hMp4SpaceEnc == NULL) {
-    error = SACENC_INVALID_HANDLE;
-    goto bail;
-  }
-
-  /* apply param value */
-  switch (param) {
-    case SACENC_LOWDELAY:
-      if (!((value == 0) || (value == 1) || (value == 2))) {
-        error = SACENC_INVALID_CONFIG;
-        break;
-      }
-      hMp4SpaceEnc->user.bLdMode = value;
-      break;
-
-    case SACENC_ENC_MODE:
-      switch ((MP4SPACEENC_MODE)value) {
-        case SACENC_212:
-          hMp4SpaceEnc->user.encMode = (MP4SPACEENC_MODE)value;
-          break;
-        default:
-          error = SACENC_INVALID_CONFIG;
-      }
-      break;
-
-    case SACENC_SAMPLERATE:
-      if (((int)value < 0) ||
-          ((int)value > hMp4SpaceEnc->setup.maxSamplingrate)) {
-        error = SACENC_INVALID_CONFIG;
-        break;
-      }
-      hMp4SpaceEnc->user.sampleRate = value;
-      break;
-
-    case SACENC_FRAME_TIME_SLOTS:
-      if (((int)value < 0) ||
-          ((int)value > hMp4SpaceEnc->setup.maxFrameTimeSlots)) {
-        error = SACENC_INVALID_CONFIG;
-        break;
-      }
-      hMp4SpaceEnc->user.frameTimeSlots = value;
-      break;
-
-    case SACENC_PARAM_BANDS:
-      switch ((MP4SPACEENC_BANDS_CONFIG)value) {
-        case SACENC_BANDS_4:
-        case SACENC_BANDS_5:
-        case SACENC_BANDS_7:
-        case SACENC_BANDS_9:
-        case SACENC_BANDS_12:
-        case SACENC_BANDS_15:
-        case SACENC_BANDS_23:
-          hMp4SpaceEnc->user.nParamBands = (MP4SPACEENC_BANDS_CONFIG)value;
-          break;
-        default:
-          error = SACENC_INVALID_CONFIG;
-      }
-      break;
-
-    case SACENC_TIME_DOM_DMX:
-      if (!((value == 0) || (value == 2))) {
-        error = SACENC_INVALID_CONFIG;
-        break;
-      }
-      hMp4SpaceEnc->user.bTimeDomainDmx = value;
-      break;
-
-    case SACENC_DMX_GAIN:
-      if (!((value == 0) || (value == 1) || (value == 2) || (value == 3) ||
-            (value == 4) || (value == 5) || (value == 6) || (value == 7))) {
-        error = SACENC_INVALID_CONFIG;
-        break;
-      }
-      error = fdk_sacenc_staticGain_SetDmxGain(hMp4SpaceEnc->hStaticGainConfig,
-                                               (MP4SPACEENC_DMX_GAIN)value);
-      break;
-
-    case SACENC_COARSE_QUANT:
-      if (!((value == 0) || (value == 1))) {
-        error = SACENC_INVALID_CONFIG;
-        break;
-      }
-      hMp4SpaceEnc->user.bUseCoarseQuant = value;
-      break;
-
-    case SACENC_QUANT_MODE:
-      switch ((MP4SPACEENC_QUANTMODE)value) {
-        case SACENC_QUANTMODE_FINE:
-        case SACENC_QUANTMODE_EBQ1:
-        case SACENC_QUANTMODE_EBQ2:
-          hMp4SpaceEnc->user.quantMode = (MP4SPACEENC_QUANTMODE)value;
-          break;
-        default:
-          error = SACENC_INVALID_CONFIG;
-      }
-      break;
-
-    case SACENC_TIME_ALIGNMENT:
-      if ((INT)value < -32768 || (INT)value > 32767) {
-        error = SACENC_INVALID_CONFIG;
-        break;
-      }
-      hMp4SpaceEnc->user.timeAlignment = value;
-      break;
-
-    case SACENC_INDEPENDENCY_COUNT:
-      hMp4SpaceEnc->independencyCount = value;
-      break;
-
-    case SACENC_INDEPENDENCY_FACTOR:
-      hMp4SpaceEnc->user.independencyFactor = value;
-      break;
-
-    default:
-      error = SACENC_UNSUPPORTED_PARAMETER;
-      break;
-  } /* switch(param) */
-bail:
-  return error;
-}
-
-FDK_SACENC_ERROR FDK_sacenc_getLibInfo(LIB_INFO *info) {
-  int i = 0;
-
-  if (info == NULL) {
-    return SACENC_INVALID_HANDLE;
-  }
-
-  FDK_toolsGetLibInfo(info);
-
-  /* search for next free tab */
-  for (i = 0; i < FDK_MODULE_LAST; i++) {
-    if (info[i].module_id == FDK_NONE) break;
-  }
-  if (i == FDK_MODULE_LAST) {
-    return SACENC_INIT_ERROR;
-  }
-
-  info[i].module_id = FDK_MPSENC;
-  info[i].build_date = SACENC_LIB_BUILD_DATE;
-  info[i].build_time = SACENC_LIB_BUILD_TIME;
-  info[i].title = SACENC_LIB_TITLE;
-  info[i].version = LIB_VERSION(SACENC_LIB_VL0, SACENC_LIB_VL1, SACENC_LIB_VL2);
-  LIB_VERSION_STRING(&info[i]);
-
-  /* Capability flags */
-  info[i].flags = 0;
-  /* End of flags */
-
-  return SACENC_OK;
-}
-
-static DECORRCONFIG mp4SpaceEnc_GetDecorrConfig(
-    const MP4SPACEENC_MODE encMode) {
-  DECORRCONFIG decorrConfig = DECORR_INVALID;
-
-  /* set decorrConfig dependent on tree mode */
-  switch (encMode) {
-    case SACENC_212:
-      decorrConfig = DECORR_QMFSPLIT0;
-      break;
-    case SACENC_INVALID_MODE:
-    default:
-      decorrConfig = DECORR_INVALID;
-  }
-  return decorrConfig;
-}
-
-static FDK_SACENC_ERROR mp4SpaceEnc_InitNumParamBands(
-    HANDLE_MP4SPACE_ENCODER hEnc, const MP4SPACEENC_BANDS_CONFIG nParamBands) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  /* Set/Check nParamBands */
-  int k = 0;
-  const int n = sizeof(pValidBands_Ld) / sizeof(UCHAR);
-  const UCHAR *pBands = pValidBands_Ld;
-
-  while (k < n && pBands[k] != (UCHAR)nParamBands) ++k;
-  if (k == n) {
-    hEnc->nParamBands = SACENC_BANDS_INVALID;
-  } else {
-    hEnc->nParamBands = nParamBands;
-  }
-  return error;
-}
--- a/libSACenc/src/sacenc_nlc_enc.cpp
+++ /dev/null
@@ -1,1442 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround encoder library *************************
-
-   Author(s):   Karsten Linzmeier
-
-   Description: Noiseless Coding
-                Huffman encoder
-
-*******************************************************************************/
-
-/* Includes ******************************************************************/
-#include "sacenc_nlc_enc.h"
-
-#include "genericStds.h"
-#include "fixpoint_math.h"
-
-#include "sacenc_const.h"
-#include "sacenc_huff_tab.h"
-#include "sacenc_paramextract.h"
-
-/* Defines *******************************************************************/
-#define PAIR_SHIFT 4
-#define PAIR_MASK 0xf
-
-#define PBC_MIN_BANDS 5
-
-typedef enum {
-  BACKWARDS = 0x0,
-  FORWARDS = 0x1
-
-} DIRECTION;
-
-typedef enum {
-  DIFF_FREQ = 0x0,
-  DIFF_TIME = 0x1
-
-} DIFF_TYPE;
-
-typedef enum {
-  HUFF_1D = 0x0,
-  HUFF_2D = 0x1
-
-} CODING_SCHEME;
-
-typedef enum {
-  FREQ_PAIR = 0x0,
-  TIME_PAIR = 0x1
-
-} PAIRING;
-
-/* Data Types ****************************************************************/
-
-/* Constants *****************************************************************/
-static const UCHAR lavHuffVal[4] = {0, 2, 6, 7};
-static const UCHAR lavHuffLen[4] = {1, 2, 3, 3};
-
-static const UCHAR lav_step_CLD[] = {0, 0, 0, 0, 1, 1, 2, 2, 3, 3};
-static const UCHAR lav_step_ICC[] = {0, 0, 1, 1, 2, 2, 3, 3};
-
-/* Function / Class Declarations *********************************************/
-
-/* Function / Class Definition ***********************************************/
-static void split_lsb(const SHORT *const in_data, SHORT offset,
-                      const INT num_val, SHORT *const out_data_lsb,
-                      SHORT *const out_data_msb) {
-  int i;
-
-  for (i = 0; i < num_val; i++) {
-    SHORT val = in_data[i] + offset;
-    if (out_data_lsb != NULL) out_data_lsb[i] = val & 0x0001;
-    if (out_data_msb != NULL) out_data_msb[i] = val >> 1;
-  }
-}
-
-static void apply_lsb_coding(HANDLE_FDK_BITSTREAM strm,
-                             const SHORT *const in_data_lsb, const UINT num_lsb,
-                             const INT num_val) {
-  int i;
-
-  for (i = 0; i < num_val; i++) {
-    FDKwriteBits(strm, in_data_lsb[i], num_lsb);
-  }
-}
-
-static void calc_diff_freq(const SHORT *const in_data, SHORT *const out_data,
-                           const INT num_val) {
-  int i;
-  out_data[0] = in_data[0];
-
-  for (i = 1; i < num_val; i++) {
-    out_data[i] = in_data[i] - in_data[i - 1];
-  }
-}
-
-static void calc_diff_time(const SHORT *const in_data,
-                           const SHORT *const prev_data, SHORT *const out_data,
-                           const INT num_val) {
-  int i;
-  out_data[0] = in_data[0];
-  out_data[1] = prev_data[0];
-
-  for (i = 0; i < num_val; i++) {
-    out_data[i + 2] = in_data[i] - prev_data[i];
-  }
-}
-
-static INT sym_check(SHORT data[2], const INT lav, SHORT *const pSym_bits) {
-  UCHAR symBits = 0;
-  int sum_val = data[0] + data[1];
-  int diff_val = data[0] - data[1];
-  int num_sbits = 0;
-
-  if (sum_val != 0) {
-    int sum_neg = (sum_val < 0) ? 1 : 0;
-    if (sum_neg) {
-      sum_val = -sum_val;
-      diff_val = -diff_val;
-    }
-    symBits = (symBits << 1) | sum_neg;
-    num_sbits++;
-  }
-
-  if (diff_val != 0) {
-    int diff_neg = (diff_val < 0) ? 1 : 0;
-    if (diff_neg) {
-      diff_val = -diff_val;
-    }
-    symBits = (symBits << 1) | diff_neg;
-    num_sbits++;
-  }
-
-  if (pSym_bits != NULL) {
-    *pSym_bits = symBits;
-  }
-
-  if (sum_val % 2) {
-    data[0] = lav - sum_val / 2;
-    data[1] = lav - diff_val / 2;
-  } else {
-    data[0] = sum_val / 2;
-    data[1] = diff_val / 2;
-  }
-
-  return num_sbits;
-}
-
-static INT ilog2(UINT i) {
-  int l = 0;
-
-  if (i) i--;
-  while (i > 0) {
-    i >>= 1;
-    l++;
-  }
-
-  return l;
-}
-
-static SHORT calc_pcm_bits(const SHORT num_val, const SHORT num_levels) {
-  SHORT num_complete_chunks = 0, rest_chunk_size = 0;
-  SHORT max_grp_len = 0, bits_pcm = 0;
-  int chunk_levels, i;
-
-  switch (num_levels) {
-    case 3:
-      max_grp_len = 5;
-      break;
-    case 6:
-      max_grp_len = 5;
-      break;
-    case 7:
-      max_grp_len = 6;
-      break;
-    case 11:
-      max_grp_len = 2;
-      break;
-    case 13:
-      max_grp_len = 4;
-      break;
-    case 19:
-      max_grp_len = 4;
-      break;
-    case 25:
-      max_grp_len = 3;
-      break;
-    case 51:
-      max_grp_len = 4;
-      break;
-    default:
-      max_grp_len = 1;
-  }
-
-  num_complete_chunks = num_val / max_grp_len;
-  rest_chunk_size = num_val % max_grp_len;
-
-  chunk_levels = 1;
-  for (i = 1; i <= max_grp_len; i++) {
-    chunk_levels *= num_levels;
-  }
-
-  bits_pcm = (SHORT)(ilog2(chunk_levels) * num_complete_chunks);
-  bits_pcm += (SHORT)(ilog2(num_levels) * rest_chunk_size);
-
-  return bits_pcm;
-}
-
-static void apply_pcm_coding(HANDLE_FDK_BITSTREAM strm,
-                             const SHORT *const in_data_1,
-                             const SHORT *const in_data_2, const SHORT offset,
-                             const SHORT num_val, const SHORT num_levels) {
-  SHORT i = 0, j = 0, idx = 0;
-  SHORT max_grp_len = 0, grp_len = 0, next_val = 0;
-  int grp_val = 0, chunk_levels = 0;
-
-  SHORT pcm_chunk_size[7] = {0};
-
-  switch (num_levels) {
-    case 3:
-      max_grp_len = 5;
-      break;
-    case 5:
-      max_grp_len = 3;
-      break;
-    case 6:
-      max_grp_len = 5;
-      break;
-    case 7:
-      max_grp_len = 6;
-      break;
-    case 9:
-      max_grp_len = 5;
-      break;
-    case 11:
-      max_grp_len = 2;
-      break;
-    case 13:
-      max_grp_len = 4;
-      break;
-    case 19:
-      max_grp_len = 4;
-      break;
-    case 25:
-      max_grp_len = 3;
-      break;
-    case 51:
-      max_grp_len = 4;
-      break;
-    default:
-      max_grp_len = 1;
-  }
-
-  chunk_levels = 1;
-  for (i = 1; i <= max_grp_len; i++) {
-    chunk_levels *= num_levels;
-    pcm_chunk_size[i] = ilog2(chunk_levels);
-  }
-
-  for (i = 0; i < num_val; i += max_grp_len) {
-    grp_len = FDKmin(max_grp_len, num_val - i);
-    grp_val = 0;
-    for (j = 0; j < grp_len; j++) {
-      idx = i + j;
-      if (in_data_2 == NULL) {
-        next_val = in_data_1[idx];
-      } else if (in_data_1 == NULL) {
-        next_val = in_data_2[idx];
-      } else {
-        next_val = ((idx % 2) ? in_data_2[idx / 2] : in_data_1[idx / 2]);
-      }
-      next_val += offset;
-      grp_val = grp_val * num_levels + next_val;
-    }
-
-    FDKwriteBits(strm, grp_val, pcm_chunk_size[grp_len]);
-  }
-}
-
-static UINT huff_enc_1D(HANDLE_FDK_BITSTREAM strm, const DATA_TYPE data_type,
-                        const INT dim1, SHORT *const in_data,
-                        const SHORT num_val, const SHORT p0_flag) {
-  int i, offset = 0;
-  UINT huffBits = 0;
-
-  HUFF_ENTRY part0 = {0};
-  const HUFF_ENTRY *pHuffTab = NULL;
-
-  switch (data_type) {
-    case t_CLD:
-      pHuffTab = fdk_sacenc_huffCLDTab.h1D[dim1];
-      break;
-    case t_ICC:
-      pHuffTab = fdk_sacenc_huffICCTab.h1D[dim1];
-      break;
-  }
-
-  if (p0_flag) {
-    switch (data_type) {
-      case t_CLD:
-        part0 = fdk_sacenc_huffPart0Tab.cld[in_data[0]];
-        break;
-      case t_ICC:
-        part0 = fdk_sacenc_huffPart0Tab.icc[in_data[0]];
-        break;
-    }
-    huffBits += FDKwriteBits(strm, HUFF_VALUE(part0), HUFF_LENGTH(part0));
-    offset = 1;
-  }
-
-  for (i = offset; i < num_val; i++) {
-    int id_sign = 0;
-    int id = in_data[i];
-
-    if (id != 0) {
-      id_sign = 0;
-      if (id < 0) {
-        id = -id;
-        id_sign = 1;
-      }
-    }
-
-    huffBits +=
-        FDKwriteBits(strm, HUFF_VALUE(pHuffTab[id]), HUFF_LENGTH(pHuffTab[id]));
-
-    if (id != 0) {
-      huffBits += FDKwriteBits(strm, id_sign, 1);
-    }
-  } /* for i */
-
-  return huffBits;
-}
-
-static void getHuffEntry(const INT lav, const DATA_TYPE data_type, const INT i,
-                         const SHORT tab_idx_2D[2], const SHORT in_data[][2],
-                         HUFF_ENTRY *const pEntry, HUFF_ENTRY *const pEscape) {
-  const HUFF_CLD_TAB_2D *pCLD2dTab =
-      &fdk_sacenc_huffCLDTab.h2D[tab_idx_2D[0]][tab_idx_2D[1]];
-  const HUFF_ICC_TAB_2D *pICC2dTab =
-      &fdk_sacenc_huffICCTab.h2D[tab_idx_2D[0]][tab_idx_2D[1]];
-
-  switch (lav) {
-    case 1: {
-      const LAV1_2D *pLav1 = NULL;
-      switch (data_type) {
-        case t_CLD:
-          pLav1 = NULL;
-          break;
-        case t_ICC:
-          pLav1 = &pICC2dTab->lav1;
-          break;
-      }
-      if (pLav1 != NULL) {
-        *pEntry = pLav1->entry[in_data[i][0]][in_data[i][1]];
-        *pEscape = pLav1->escape;
-      }
-    } break;
-    case 3: {
-      const LAV3_2D *pLav3 = NULL;
-      switch (data_type) {
-        case t_CLD:
-          pLav3 = &pCLD2dTab->lav3;
-          break;
-        case t_ICC:
-          pLav3 = &pICC2dTab->lav3;
-          break;
-      }
-      if (pLav3 != NULL) {
-        *pEntry = pLav3->entry[in_data[i][0]][in_data[i][1]];
-        *pEscape = pLav3->escape;
-      }
-    } break;
-    case 5: {
-      const LAV5_2D *pLav5 = NULL;
-      switch (data_type) {
-        case t_CLD:
-          pLav5 = &pCLD2dTab->lav5;
-          break;
-        case t_ICC:
-          pLav5 = &pICC2dTab->lav5;
-          break;
-      }
-      if (pLav5 != NULL) {
-        *pEntry = pLav5->entry[in_data[i][0]][in_data[i][1]];
-        *pEscape = pLav5->escape;
-      }
-    } break;
-    case 7: {
-      const LAV7_2D *pLav7 = NULL;
-      switch (data_type) {
-        case t_CLD:
-          pLav7 = &pCLD2dTab->lav7;
-          break;
-        case t_ICC:
-          pLav7 = &pICC2dTab->lav7;
-          break;
-      }
-      if (pLav7 != NULL) {
-        *pEntry = pLav7->entry[in_data[i][0]][in_data[i][1]];
-        *pEscape = pLav7->escape;
-      }
-    } break;
-    case 9: {
-      const LAV9_2D *pLav9 = NULL;
-      switch (data_type) {
-        case t_CLD:
-          pLav9 = &pCLD2dTab->lav9;
-          break;
-        case t_ICC:
-          pLav9 = NULL;
-          break;
-      }
-      if (pLav9 != NULL) {
-        *pEntry = pLav9->entry[in_data[i][0]][in_data[i][1]];
-        *pEscape = pLav9->escape;
-      }
-    } break;
-  }
-}
-
-static UINT huff_enc_2D(HANDLE_FDK_BITSTREAM strm, const DATA_TYPE data_type,
-                        SHORT tab_idx_2D[2], SHORT lav_idx, SHORT in_data[][2],
-                        SHORT num_val, SHORT stride, SHORT *p0_data[2]) {
-  SHORT i = 0, lav = 0, num_sbits = 0, sym_bits = 0, escIdx = 0;
-  SHORT esc_data[2][MAXBANDS] = {{0}};
-
-  UINT huffBits = 0;
-
-  const HUFF_ENTRY *pHuffEntry = NULL;
-
-  switch (data_type) {
-    case t_CLD:
-      lav = 2 * lav_idx + 3; /* LAV */
-      pHuffEntry = fdk_sacenc_huffPart0Tab.cld;
-      break;
-    case t_ICC:
-      lav = 2 * lav_idx + 1; /* LAV */
-      pHuffEntry = fdk_sacenc_huffPart0Tab.icc;
-      break;
-  }
-
-  /* Partition 0 */
-  if (p0_data[0] != NULL) {
-    HUFF_ENTRY entry = pHuffEntry[*p0_data[0]];
-    huffBits += FDKwriteBits(strm, HUFF_VALUE(entry), HUFF_LENGTH(entry));
-  }
-  if (p0_data[1] != NULL) {
-    HUFF_ENTRY entry = pHuffEntry[*p0_data[1]];
-    huffBits += FDKwriteBits(strm, HUFF_VALUE(entry), HUFF_LENGTH(entry));
-  }
-
-  for (i = 0; i < num_val; i += stride) {
-    HUFF_ENTRY entry = {0};
-    HUFF_ENTRY escape = {0};
-
-    esc_data[0][escIdx] = in_data[i][0] + lav;
-    esc_data[1][escIdx] = in_data[i][1] + lav;
-
-    num_sbits = sym_check(in_data[i], lav, &sym_bits);
-
-    getHuffEntry(lav, data_type, i, tab_idx_2D, in_data, &entry, &escape);
-
-    huffBits += FDKwriteBits(strm, HUFF_VALUE(entry), HUFF_LENGTH(entry));
-
-    if ((HUFF_VALUE(entry) == HUFF_VALUE(escape)) &&
-        (HUFF_LENGTH(entry) == HUFF_LENGTH(escape))) {
-      escIdx++;
-    } else {
-      huffBits += FDKwriteBits(strm, sym_bits, num_sbits);
-    }
-  } /* for i */
-
-  if (escIdx > 0) {
-    huffBits += calc_pcm_bits(2 * escIdx, (2 * lav + 1));
-    if (strm != NULL) {
-      apply_pcm_coding(strm, esc_data[0], esc_data[1], 0 /*offset*/, 2 * escIdx,
-                       (2 * lav + 1));
-    }
-  }
-
-  return huffBits;
-}
-
-static SCHAR get_next_lav_step(const INT lav, const DATA_TYPE data_type) {
-  SCHAR lav_step = 0;
-
-  switch (data_type) {
-    case t_CLD:
-      lav_step = (lav > 9) ? -1 : lav_step_CLD[lav];
-      break;
-    case t_ICC:
-      lav_step = (lav > 7) ? -1 : lav_step_ICC[lav];
-      break;
-  }
-
-  return lav_step;
-}
-
-static INT diff_type_offset(const DIFF_TYPE diff_type) {
-  int offset = 0;
-  switch (diff_type) {
-    case DIFF_FREQ:
-      offset = 0;
-      break;
-    case DIFF_TIME:
-      offset = 2;
-      break;
-  }
-  return offset;
-}
-
-static SHORT calc_huff_bits(SHORT *in_data_1, SHORT *in_data_2,
-                            const DATA_TYPE data_type,
-                            const DIFF_TYPE diff_type_1,
-                            const DIFF_TYPE diff_type_2, const SHORT num_val,
-                            SHORT *const lav_idx, SHORT *const cdg_scheme) {
-  SHORT tab_idx_2D[2][2] = {{0}};
-  SHORT tab_idx_1D[2] = {0};
-  SHORT df_rest_flag[2] = {0};
-  SHORT p0_flag[2] = {0};
-
-  SHORT pair_vec[MAXBANDS][2] = {{0}};
-
-  SHORT *p0_data_1[2] = {NULL};
-  SHORT *p0_data_2[2] = {NULL};
-
-  SHORT i = 0;
-  SHORT lav_fp[2] = {0};
-
-  SHORT bit_count_1D = 0;
-  SHORT bit_count_2D_freq = 0;
-  SHORT bit_count_min = 0;
-
-  SHORT num_val_1_short = 0;
-  SHORT num_val_2_short = 0;
-
-  SHORT *in_data_1_short = NULL;
-  SHORT *in_data_2_short = NULL;
-
-  /* 1D Huffman coding */
-  bit_count_1D = 1; /* HUFF_1D */
-
-  num_val_1_short = num_val;
-  num_val_2_short = num_val;
-
-  if (in_data_1 != NULL) {
-    in_data_1_short = in_data_1 + diff_type_offset(diff_type_1);
-  }
-  if (in_data_2 != NULL) {
-    in_data_2_short = in_data_2 + diff_type_offset(diff_type_2);
-  }
-
-  p0_flag[0] = (diff_type_1 == DIFF_FREQ);
-  p0_flag[1] = (diff_type_2 == DIFF_FREQ);
-
-  tab_idx_1D[0] = (diff_type_1 == DIFF_FREQ) ? 0 : 1;
-  tab_idx_1D[1] = (diff_type_2 == DIFF_FREQ) ? 0 : 1;
-
-  if (in_data_1 != NULL) {
-    bit_count_1D += huff_enc_1D(NULL, data_type, tab_idx_1D[0], in_data_1_short,
-                                num_val_1_short, p0_flag[0]);
-  }
-  if (in_data_2 != NULL) {
-    bit_count_1D += huff_enc_1D(NULL, data_type, tab_idx_1D[1], in_data_2_short,
-                                num_val_2_short, p0_flag[1]);
-  }
-
-  bit_count_min = bit_count_1D;
-  *cdg_scheme = HUFF_1D << PAIR_SHIFT;
-  lav_idx[0] = lav_idx[1] = -1;
-
-  /* Huffman 2D frequency pairs */
-  bit_count_2D_freq = 1; /* HUFF_2D */
-
-  num_val_1_short = num_val;
-  num_val_2_short = num_val;
-
-  if (in_data_1 != NULL) {
-    in_data_1_short = in_data_1 + diff_type_offset(diff_type_1);
-  }
-  if (in_data_2 != NULL) {
-    in_data_2_short = in_data_2 + diff_type_offset(diff_type_2);
-  }
-
-  lav_fp[0] = lav_fp[1] = 0;
-
-  p0_data_1[0] = NULL;
-  p0_data_1[1] = NULL;
-  p0_data_2[0] = NULL;
-  p0_data_2[1] = NULL;
-
-  if (in_data_1 != NULL) {
-    if (diff_type_1 == DIFF_FREQ) {
-      p0_data_1[0] = &in_data_1[0];
-      p0_data_1[1] = NULL;
-
-      num_val_1_short -= 1;
-      in_data_1_short += 1;
-    }
-
-    df_rest_flag[0] = num_val_1_short % 2;
-
-    if (df_rest_flag[0]) num_val_1_short -= 1;
-
-    for (i = 0; i < num_val_1_short - 1; i += 2) {
-      pair_vec[i][0] = in_data_1_short[i];
-      pair_vec[i][1] = in_data_1_short[i + 1];
-
-      lav_fp[0] = FDKmax(lav_fp[0], fAbs(pair_vec[i][0]));
-      lav_fp[0] = FDKmax(lav_fp[0], fAbs(pair_vec[i][1]));
-    }
-
-    tab_idx_2D[0][0] = (diff_type_1 == DIFF_TIME) ? 1 : 0;
-    tab_idx_2D[0][1] = 0;
-
-    tab_idx_1D[0] = (diff_type_1 == DIFF_FREQ) ? 0 : 1;
-
-    lav_fp[0] = get_next_lav_step(lav_fp[0], data_type);
-
-    if (lav_fp[0] != -1) bit_count_2D_freq += lavHuffLen[lav_fp[0]];
-  }
-
-  if (in_data_2 != NULL) {
-    if (diff_type_2 == DIFF_FREQ) {
-      p0_data_2[0] = NULL;
-      p0_data_2[1] = &in_data_2[0];
-
-      num_val_2_short -= 1;
-      in_data_2_short += 1;
-    }
-
-    df_rest_flag[1] = num_val_2_short % 2;
-
-    if (df_rest_flag[1]) num_val_2_short -= 1;
-
-    for (i = 0; i < num_val_2_short - 1; i += 2) {
-      pair_vec[i + 1][0] = in_data_2_short[i];
-      pair_vec[i + 1][1] = in_data_2_short[i + 1];
-
-      lav_fp[1] = FDKmax(lav_fp[1], fAbs(pair_vec[i + 1][0]));
-      lav_fp[1] = FDKmax(lav_fp[1], fAbs(pair_vec[i + 1][1]));
-    }
-
-    tab_idx_2D[1][0] = (diff_type_2 == DIFF_TIME) ? 1 : 0;
-    tab_idx_2D[1][1] = 0;
-
-    tab_idx_1D[1] = (diff_type_2 == DIFF_FREQ) ? 0 : 1;
-
-    lav_fp[1] = get_next_lav_step(lav_fp[1], data_type);
-
-    if (lav_fp[1] != -1) bit_count_2D_freq += lavHuffLen[lav_fp[1]];
-  }
-
-  if ((lav_fp[0] != -1) && (lav_fp[1] != -1)) {
-    if (in_data_1 != NULL) {
-      bit_count_2D_freq +=
-          huff_enc_2D(NULL, data_type, tab_idx_2D[0], lav_fp[0], pair_vec,
-                      num_val_1_short, 2, p0_data_1);
-    }
-    if (in_data_2 != NULL) {
-      bit_count_2D_freq +=
-          huff_enc_2D(NULL, data_type, tab_idx_2D[1], lav_fp[1], pair_vec + 1,
-                      num_val_2_short, 2, p0_data_2);
-    }
-    if (in_data_1 != NULL) {
-      if (df_rest_flag[0])
-        bit_count_2D_freq +=
-            huff_enc_1D(NULL, data_type, tab_idx_1D[0],
-                        in_data_1_short + num_val_1_short, 1, 0);
-    }
-    if (in_data_2 != NULL) {
-      if (df_rest_flag[1])
-        bit_count_2D_freq +=
-            huff_enc_1D(NULL, data_type, tab_idx_1D[1],
-                        in_data_2_short + num_val_2_short, 1, 0);
-    }
-
-    if (bit_count_2D_freq < bit_count_min) {
-      bit_count_min = bit_count_2D_freq;
-      *cdg_scheme = HUFF_2D << PAIR_SHIFT | FREQ_PAIR;
-      lav_idx[0] = lav_fp[0];
-      lav_idx[1] = lav_fp[1];
-    }
-  }
-
-  return bit_count_min;
-}
-
-static void apply_huff_coding(HANDLE_FDK_BITSTREAM strm, SHORT *const in_data_1,
-                              SHORT *const in_data_2, const DATA_TYPE data_type,
-                              const DIFF_TYPE diff_type_1,
-                              const DIFF_TYPE diff_type_2, const SHORT num_val,
-                              const SHORT *const lav_idx,
-                              const SHORT cdg_scheme) {
-  SHORT tab_idx_2D[2][2] = {{0}};
-  SHORT tab_idx_1D[2] = {0};
-  SHORT df_rest_flag[2] = {0};
-  SHORT p0_flag[2] = {0};
-
-  SHORT pair_vec[MAXBANDS][2] = {{0}};
-
-  SHORT *p0_data_1[2] = {NULL};
-  SHORT *p0_data_2[2] = {NULL};
-
-  SHORT i = 0;
-
-  SHORT num_val_1_short = num_val;
-  SHORT num_val_2_short = num_val;
-
-  SHORT *in_data_1_short = NULL;
-  SHORT *in_data_2_short = NULL;
-
-  /* Offset */
-  if (in_data_1 != NULL) {
-    in_data_1_short = in_data_1 + diff_type_offset(diff_type_1);
-  }
-  if (in_data_2 != NULL) {
-    in_data_2_short = in_data_2 + diff_type_offset(diff_type_2);
-  }
-
-  /* Signalize coding scheme */
-  FDKwriteBits(strm, cdg_scheme >> PAIR_SHIFT, 1);
-
-  switch (cdg_scheme >> PAIR_SHIFT) {
-    case HUFF_1D:
-
-      p0_flag[0] = (diff_type_1 == DIFF_FREQ);
-      p0_flag[1] = (diff_type_2 == DIFF_FREQ);
-
-      tab_idx_1D[0] = (diff_type_1 == DIFF_FREQ) ? 0 : 1;
-      tab_idx_1D[1] = (diff_type_2 == DIFF_FREQ) ? 0 : 1;
-
-      if (in_data_1 != NULL) {
-        huff_enc_1D(strm, data_type, tab_idx_1D[0], in_data_1_short,
-                    num_val_1_short, p0_flag[0]);
-      }
-      if (in_data_2 != NULL) {
-        huff_enc_1D(strm, data_type, tab_idx_1D[1], in_data_2_short,
-                    num_val_2_short, p0_flag[1]);
-      }
-      break; /* HUFF_1D */
-
-    case HUFF_2D:
-
-      switch (cdg_scheme & PAIR_MASK) {
-        case FREQ_PAIR:
-
-          if (in_data_1 != NULL) {
-            if (diff_type_1 == DIFF_FREQ) {
-              p0_data_1[0] = &in_data_1[0];
-              p0_data_1[1] = NULL;
-
-              num_val_1_short -= 1;
-              in_data_1_short += 1;
-            }
-
-            df_rest_flag[0] = num_val_1_short % 2;
-
-            if (df_rest_flag[0]) num_val_1_short -= 1;
-
-            for (i = 0; i < num_val_1_short - 1; i += 2) {
-              pair_vec[i][0] = in_data_1_short[i];
-              pair_vec[i][1] = in_data_1_short[i + 1];
-            }
-
-            tab_idx_2D[0][0] = (diff_type_1 == DIFF_TIME) ? 1 : 0;
-            tab_idx_2D[0][1] = 0;
-
-            tab_idx_1D[0] = (diff_type_1 == DIFF_FREQ) ? 0 : 1;
-          } /* if( in_data_1 != NULL ) */
-
-          if (in_data_2 != NULL) {
-            if (diff_type_2 == DIFF_FREQ) {
-              p0_data_2[0] = NULL;
-              p0_data_2[1] = &in_data_2[0];
-
-              num_val_2_short -= 1;
-              in_data_2_short += 1;
-            }
-
-            df_rest_flag[1] = num_val_2_short % 2;
-
-            if (df_rest_flag[1]) num_val_2_short -= 1;
-
-            for (i = 0; i < num_val_2_short - 1; i += 2) {
-              pair_vec[i + 1][0] = in_data_2_short[i];
-              pair_vec[i + 1][1] = in_data_2_short[i + 1];
-            }
-
-            tab_idx_2D[1][0] = (diff_type_2 == DIFF_TIME) ? 1 : 0;
-            tab_idx_2D[1][1] = 0;
-
-            tab_idx_1D[1] = (diff_type_2 == DIFF_FREQ) ? 0 : 1;
-          } /* if( in_data_2 != NULL ) */
-
-          if (in_data_1 != NULL) {
-            FDKwriteBits(strm, lavHuffVal[lav_idx[0]], lavHuffLen[lav_idx[0]]);
-            huff_enc_2D(strm, data_type, tab_idx_2D[0], lav_idx[0], pair_vec,
-                        num_val_1_short, 2, p0_data_1);
-            if (df_rest_flag[0]) {
-              huff_enc_1D(strm, data_type, tab_idx_1D[0],
-                          in_data_1_short + num_val_1_short, 1, 0);
-            }
-          }
-          if (in_data_2 != NULL) {
-            FDKwriteBits(strm, lavHuffVal[lav_idx[1]], lavHuffLen[lav_idx[1]]);
-            huff_enc_2D(strm, data_type, tab_idx_2D[1], lav_idx[1],
-                        pair_vec + 1, num_val_2_short, 2, p0_data_2);
-            if (df_rest_flag[1]) {
-              huff_enc_1D(strm, data_type, tab_idx_1D[1],
-                          in_data_2_short + num_val_2_short, 1, 0);
-            }
-          }
-          break; /* FREQ_PAIR */
-
-        case TIME_PAIR:
-
-          if ((diff_type_1 == DIFF_FREQ) || (diff_type_2 == DIFF_FREQ)) {
-            p0_data_1[0] = &in_data_1[0];
-            p0_data_1[1] = &in_data_2[0];
-
-            in_data_1_short += 1;
-            in_data_2_short += 1;
-
-            num_val_1_short -= 1;
-          }
-
-          for (i = 0; i < num_val_1_short; i++) {
-            pair_vec[i][0] = in_data_1_short[i];
-            pair_vec[i][1] = in_data_2_short[i];
-          }
-
-          tab_idx_2D[0][0] =
-              ((diff_type_1 == DIFF_TIME) || (diff_type_2 == DIFF_TIME)) ? 1
-                                                                         : 0;
-          tab_idx_2D[0][1] = 1;
-
-          FDKwriteBits(strm, lavHuffVal[lav_idx[0]], lavHuffLen[lav_idx[0]]);
-
-          huff_enc_2D(strm, data_type, tab_idx_2D[0], lav_idx[0], pair_vec,
-                      num_val_1_short, 1, p0_data_1);
-
-          break; /* TIME_PAIR */
-      }          /* switch( cdg_scheme & PAIR_MASK ) */
-
-      break; /* HUFF_2D */
-
-    default:
-      break;
-  } /* switch( cdg_scheme >> PAIR_SHIFT ) */
-}
-
-INT fdk_sacenc_ecDataPairEnc(HANDLE_FDK_BITSTREAM strm,
-                             SHORT aaInData[][MAXBANDS],
-                             SHORT aHistory[MAXBANDS],
-                             const DATA_TYPE data_type, const INT setIdx,
-                             const INT startBand, const INT dataBands,
-                             const INT coarse_flag,
-                             const INT independency_flag) {
-  SHORT reset = 0, pb = 0;
-  SHORT quant_levels = 0, quant_offset = 0, num_pcm_val = 0;
-
-  SHORT splitLsb_flag = 0;
-  SHORT pcmCoding_flag = 0;
-
-  SHORT allowDiffTimeBack_flag = !independency_flag || (setIdx > 0);
-
-  SHORT num_lsb_bits = -1;
-  SHORT num_pcm_bits = -1;
-
-  SHORT quant_data_lsb[2][MAXBANDS];
-  SHORT quant_data_msb[2][MAXBANDS];
-
-  SHORT quant_data_hist_lsb[MAXBANDS];
-  SHORT quant_data_hist_msb[MAXBANDS];
-
-  SHORT data_diff_freq[2][MAXBANDS];
-  SHORT data_diff_time[2][MAXBANDS + 2];
-
-  SHORT *p_quant_data_msb[2];
-  SHORT *p_quant_data_hist_msb = NULL;
-
-  SHORT min_bits_all = 0;
-  SHORT min_found = 0;
-
-  SHORT min_bits_df_df = -1;
-  SHORT min_bits_df_dt = -1;
-  SHORT min_bits_dtbw_df = -1;
-  SHORT min_bits_dt_dt = -1;
-
-  SHORT lav_df_df[2] = {-1, -1};
-  SHORT lav_df_dt[2] = {-1, -1};
-  SHORT lav_dtbw_df[2] = {-1, -1};
-  SHORT lav_dt_dt[2] = {-1, -1};
-
-  SHORT coding_scheme_df_df = 0;
-  SHORT coding_scheme_df_dt = 0;
-  SHORT coding_scheme_dtbw_df = 0;
-  SHORT coding_scheme_dt_dt = 0;
-
-  switch (data_type) {
-    case t_CLD:
-      if (coarse_flag) {
-        splitLsb_flag = 0;
-        quant_levels = 15;
-        quant_offset = 7;
-      } else {
-        splitLsb_flag = 0;
-        quant_levels = 31;
-        quant_offset = 15;
-      }
-      break;
-    case t_ICC:
-      if (coarse_flag) {
-        splitLsb_flag = 0;
-        quant_levels = 4;
-        quant_offset = 0;
-      } else {
-        splitLsb_flag = 0;
-        quant_levels = 8;
-        quant_offset = 0;
-      }
-      break;
-  } /* switch( data_type ) */
-
-  /* Split off LSB */
-  if (splitLsb_flag) {
-    split_lsb(aaInData[setIdx] + startBand, quant_offset, dataBands,
-              quant_data_lsb[0], quant_data_msb[0]);
-
-    split_lsb(aaInData[setIdx + 1] + startBand, quant_offset, dataBands,
-              quant_data_lsb[1], quant_data_msb[1]);
-
-    p_quant_data_msb[0] = quant_data_msb[0];
-    p_quant_data_msb[1] = quant_data_msb[1];
-
-    num_lsb_bits = 2 * dataBands;
-  } else if (quant_offset != 0) {
-    for (pb = 0; pb < dataBands; pb++) {
-      quant_data_msb[0][pb] = aaInData[setIdx][startBand + pb] + quant_offset;
-      quant_data_msb[1][pb] =
-          aaInData[setIdx + 1][startBand + pb] + quant_offset;
-    }
-
-    p_quant_data_msb[0] = quant_data_msb[0];
-    p_quant_data_msb[1] = quant_data_msb[1];
-
-    num_lsb_bits = 0;
-  } else {
-    p_quant_data_msb[0] = aaInData[setIdx] + startBand;
-    p_quant_data_msb[1] = aaInData[setIdx + 1] + startBand;
-
-    num_lsb_bits = 0;
-  }
-
-  if (allowDiffTimeBack_flag) {
-    if (splitLsb_flag) {
-      split_lsb(aHistory + startBand, quant_offset, dataBands,
-                quant_data_hist_lsb, quant_data_hist_msb);
-
-      p_quant_data_hist_msb = quant_data_hist_msb;
-    } else if (quant_offset != 0) {
-      for (pb = 0; pb < dataBands; pb++) {
-        quant_data_hist_msb[pb] = aHistory[startBand + pb] + quant_offset;
-      }
-      p_quant_data_hist_msb = quant_data_hist_msb;
-    } else {
-      p_quant_data_hist_msb = aHistory + startBand;
-    }
-  }
-
-  /* Calculate frequency differences */
-  calc_diff_freq(p_quant_data_msb[0], data_diff_freq[0], dataBands);
-
-  calc_diff_freq(p_quant_data_msb[1], data_diff_freq[1], dataBands);
-
-  /* Calculate time differences */
-  if (allowDiffTimeBack_flag) {
-    calc_diff_time(p_quant_data_msb[0], p_quant_data_hist_msb,
-                   data_diff_time[0], dataBands);
-  }
-
-  calc_diff_time(p_quant_data_msb[1], p_quant_data_msb[0], data_diff_time[1],
-                 dataBands);
-
-  /* Calculate coding scheme with minumum bit consumption */
-
-  /**********************************************************/
-  num_pcm_bits = calc_pcm_bits(2 * dataBands, quant_levels);
-  num_pcm_val = 2 * dataBands;
-
-  /**********************************************************/
-
-  min_bits_all = num_pcm_bits;
-
-  /**********************************************************/
-  /**********************************************************/
-
-  /**********************************************************/
-  min_bits_df_df =
-      calc_huff_bits(data_diff_freq[0], data_diff_freq[1], data_type, DIFF_FREQ,
-                     DIFF_FREQ, dataBands, lav_df_df, &coding_scheme_df_df);
-
-  min_bits_df_df += 2;
-
-  min_bits_df_df += num_lsb_bits;
-
-  if (min_bits_df_df < min_bits_all) {
-    min_bits_all = min_bits_df_df;
-  }
-  /**********************************************************/
-
-  /**********************************************************/
-  min_bits_df_dt =
-      calc_huff_bits(data_diff_freq[0], data_diff_time[1], data_type, DIFF_FREQ,
-                     DIFF_TIME, dataBands, lav_df_dt, &coding_scheme_df_dt);
-
-  min_bits_df_dt += 2;
-
-  min_bits_df_dt += num_lsb_bits;
-
-  if (min_bits_df_dt < min_bits_all) {
-    min_bits_all = min_bits_df_dt;
-  }
-  /**********************************************************/
-
-  /**********************************************************/
-  /**********************************************************/
-
-  if (allowDiffTimeBack_flag) {
-    /**********************************************************/
-    min_bits_dtbw_df = calc_huff_bits(
-        data_diff_time[0], data_diff_freq[1], data_type, DIFF_TIME, DIFF_FREQ,
-        dataBands, lav_dtbw_df, &coding_scheme_dtbw_df);
-
-    min_bits_dtbw_df += 2;
-
-    min_bits_dtbw_df += num_lsb_bits;
-
-    if (min_bits_dtbw_df < min_bits_all) {
-      min_bits_all = min_bits_dtbw_df;
-    }
-    /**********************************************************/
-
-    /**********************************************************/
-    min_bits_dt_dt = calc_huff_bits(data_diff_time[0], data_diff_time[1],
-                                    data_type, DIFF_TIME, DIFF_TIME, dataBands,
-                                    lav_dt_dt, &coding_scheme_dt_dt);
-
-    min_bits_dt_dt += 2;
-
-    min_bits_dt_dt += num_lsb_bits;
-
-    if (min_bits_dt_dt < min_bits_all) {
-      min_bits_all = min_bits_dt_dt;
-    }
-    /**********************************************************/
-
-  } /* if( allowDiffTimeBack_flag ) */
-
-  /***************************/
-  /* Start actual coding now */
-  /***************************/
-
-  /* PCM or Diff/Huff Coding? */
-  pcmCoding_flag = (min_bits_all == num_pcm_bits);
-
-  FDKwriteBits(strm, pcmCoding_flag, 1);
-
-  if (pcmCoding_flag) {
-    /* Grouped PCM Coding */
-    apply_pcm_coding(strm, aaInData[setIdx] + startBand,
-                     aaInData[setIdx + 1] + startBand, quant_offset,
-                     num_pcm_val, quant_levels);
-  } else {
-    /* Diff/Huff Coding */
-
-    min_found = 0;
-
-    /*******************************************/
-    if (min_bits_all == min_bits_df_df) {
-      FDKwriteBits(strm, DIFF_FREQ, 1);
-      FDKwriteBits(strm, DIFF_FREQ, 1);
-
-      apply_huff_coding(strm, data_diff_freq[0], data_diff_freq[1], data_type,
-                        DIFF_FREQ, DIFF_FREQ, dataBands, lav_df_df,
-                        coding_scheme_df_df);
-
-      min_found = 1;
-    }
-    /*******************************************/
-
-    /*******************************************/
-    if (!min_found && (min_bits_all == min_bits_df_dt)) {
-      FDKwriteBits(strm, DIFF_FREQ, 1);
-      FDKwriteBits(strm, DIFF_TIME, 1);
-
-      apply_huff_coding(strm, data_diff_freq[0], data_diff_time[1], data_type,
-                        DIFF_FREQ, DIFF_TIME, dataBands, lav_df_dt,
-                        coding_scheme_df_dt);
-
-      min_found = 1;
-    }
-    /*******************************************/
-
-    /*******************************************/
-    /*******************************************/
-
-    if (allowDiffTimeBack_flag) {
-      /*******************************************/
-      if (!min_found && (min_bits_all == min_bits_dtbw_df)) {
-        FDKwriteBits(strm, DIFF_TIME, 1);
-        FDKwriteBits(strm, DIFF_FREQ, 1);
-
-        apply_huff_coding(strm, data_diff_time[0], data_diff_freq[1], data_type,
-                          DIFF_TIME, DIFF_FREQ, dataBands, lav_dtbw_df,
-                          coding_scheme_dtbw_df);
-
-        min_found = 1;
-      }
-      /*******************************************/
-
-      /*******************************************/
-      if (!min_found && (min_bits_all == min_bits_dt_dt)) {
-        FDKwriteBits(strm, DIFF_TIME, 1);
-        FDKwriteBits(strm, DIFF_TIME, 1);
-
-        apply_huff_coding(strm, data_diff_time[0], data_diff_time[1], data_type,
-                          DIFF_TIME, DIFF_TIME, dataBands, lav_dt_dt,
-                          coding_scheme_dt_dt);
-      }
-      /*******************************************/
-
-    } /* if( allowDiffTimeBack_flag ) */
-
-    /* LSB coding */
-    if (splitLsb_flag) {
-      apply_lsb_coding(strm, quant_data_lsb[0], 1, dataBands);
-
-      apply_lsb_coding(strm, quant_data_lsb[1], 1, dataBands);
-    }
-
-  } /* Diff/Huff/LSB coding */
-
-  return reset;
-}
-
-INT fdk_sacenc_ecDataSingleEnc(HANDLE_FDK_BITSTREAM strm,
-                               SHORT aaInData[][MAXBANDS],
-                               SHORT aHistory[MAXBANDS],
-                               const DATA_TYPE data_type, const INT setIdx,
-                               const INT startBand, const INT dataBands,
-                               const INT coarse_flag,
-                               const INT independency_flag) {
-  SHORT reset = 0, pb = 0;
-  SHORT quant_levels = 0, quant_offset = 0, num_pcm_val = 0;
-
-  SHORT splitLsb_flag = 0;
-  SHORT pcmCoding_flag = 0;
-
-  SHORT allowDiffTimeBack_flag = !independency_flag || (setIdx > 0);
-
-  SHORT num_lsb_bits = -1;
-  SHORT num_pcm_bits = -1;
-
-  SHORT quant_data_lsb[MAXBANDS];
-  SHORT quant_data_msb[MAXBANDS];
-
-  SHORT quant_data_hist_lsb[MAXBANDS];
-  SHORT quant_data_hist_msb[MAXBANDS];
-
-  SHORT data_diff_freq[MAXBANDS];
-  SHORT data_diff_time[MAXBANDS + 2];
-
-  SHORT *p_quant_data_msb;
-  SHORT *p_quant_data_hist_msb = NULL;
-
-  SHORT min_bits_all = 0;
-  SHORT min_found = 0;
-
-  SHORT min_bits_df = -1;
-  SHORT min_bits_dt = -1;
-
-  SHORT lav_df[2] = {-1, -1};
-  SHORT lav_dt[2] = {-1, -1};
-
-  SHORT coding_scheme_df = 0;
-  SHORT coding_scheme_dt = 0;
-
-  switch (data_type) {
-    case t_CLD:
-      if (coarse_flag) {
-        splitLsb_flag = 0;
-        quant_levels = 15;
-        quant_offset = 7;
-      } else {
-        splitLsb_flag = 0;
-        quant_levels = 31;
-        quant_offset = 15;
-      }
-      break;
-    case t_ICC:
-      if (coarse_flag) {
-        splitLsb_flag = 0;
-        quant_levels = 4;
-        quant_offset = 0;
-      } else {
-        splitLsb_flag = 0;
-        quant_levels = 8;
-        quant_offset = 0;
-      }
-      break;
-  } /* switch( data_type ) */
-
-  /* Split off LSB */
-  if (splitLsb_flag) {
-    split_lsb(aaInData[setIdx] + startBand, quant_offset, dataBands,
-              quant_data_lsb, quant_data_msb);
-
-    p_quant_data_msb = quant_data_msb;
-    num_lsb_bits = dataBands;
-  } else if (quant_offset != 0) {
-    for (pb = 0; pb < dataBands; pb++) {
-      quant_data_msb[pb] = aaInData[setIdx][startBand + pb] + quant_offset;
-    }
-
-    p_quant_data_msb = quant_data_msb;
-    num_lsb_bits = 0;
-  } else {
-    p_quant_data_msb = aaInData[setIdx] + startBand;
-    num_lsb_bits = 0;
-  }
-
-  if (allowDiffTimeBack_flag) {
-    if (splitLsb_flag) {
-      split_lsb(aHistory + startBand, quant_offset, dataBands,
-                quant_data_hist_lsb, quant_data_hist_msb);
-
-      p_quant_data_hist_msb = quant_data_hist_msb;
-    } else if (quant_offset != 0) {
-      for (pb = 0; pb < dataBands; pb++) {
-        quant_data_hist_msb[pb] = aHistory[startBand + pb] + quant_offset;
-      }
-      p_quant_data_hist_msb = quant_data_hist_msb;
-    } else {
-      p_quant_data_hist_msb = aHistory + startBand;
-    }
-  }
-
-  /* Calculate frequency differences */
-  calc_diff_freq(p_quant_data_msb, data_diff_freq, dataBands);
-
-  /* Calculate time differences */
-  if (allowDiffTimeBack_flag) {
-    calc_diff_time(p_quant_data_msb, p_quant_data_hist_msb, data_diff_time,
-                   dataBands);
-  }
-
-  /* Calculate coding scheme with minumum bit consumption */
-
-  /**********************************************************/
-  num_pcm_bits = calc_pcm_bits(dataBands, quant_levels);
-  num_pcm_val = dataBands;
-
-  /**********************************************************/
-
-  min_bits_all = num_pcm_bits;
-
-  /**********************************************************/
-  /**********************************************************/
-
-  /**********************************************************/
-  min_bits_df = calc_huff_bits(data_diff_freq, NULL, data_type, DIFF_FREQ,
-                               DIFF_FREQ, dataBands, lav_df, &coding_scheme_df);
-
-  if (allowDiffTimeBack_flag) min_bits_df += 1;
-
-  min_bits_df += num_lsb_bits;
-
-  if (min_bits_df < min_bits_all) {
-    min_bits_all = min_bits_df;
-  }
-  /**********************************************************/
-
-  /**********************************************************/
-  if (allowDiffTimeBack_flag) {
-    min_bits_dt =
-        calc_huff_bits(data_diff_time, NULL, data_type, DIFF_TIME, DIFF_TIME,
-                       dataBands, lav_dt, &coding_scheme_dt);
-
-    min_bits_dt += 1;
-    min_bits_dt += num_lsb_bits;
-
-    if (min_bits_dt < min_bits_all) {
-      min_bits_all = min_bits_dt;
-    }
-  } /* if( allowDiffTimeBack_flag ) */
-
-  /***************************/
-  /* Start actual coding now */
-  /***************************/
-
-  /* PCM or Diff/Huff Coding? */
-  pcmCoding_flag = (min_bits_all == num_pcm_bits);
-
-  FDKwriteBits(strm, pcmCoding_flag, 1);
-
-  if (pcmCoding_flag) {
-    /* Grouped PCM Coding */
-    apply_pcm_coding(strm, aaInData[setIdx] + startBand, NULL, quant_offset,
-                     num_pcm_val, quant_levels);
-  } else {
-    /* Diff/Huff Coding */
-
-    min_found = 0;
-
-    /*******************************************/
-    if (min_bits_all == min_bits_df) {
-      if (allowDiffTimeBack_flag) {
-        FDKwriteBits(strm, DIFF_FREQ, 1);
-      }
-
-      apply_huff_coding(strm, data_diff_freq, NULL, data_type, DIFF_FREQ,
-                        DIFF_FREQ, dataBands, lav_df, coding_scheme_df);
-
-      min_found = 1;
-    } /* if( min_bits_all == min_bits_df ) */
-    /*******************************************/
-
-    /*******************************************/
-    if (allowDiffTimeBack_flag) {
-      /*******************************************/
-      if (!min_found && (min_bits_all == min_bits_dt)) {
-        FDKwriteBits(strm, DIFF_TIME, 1);
-
-        apply_huff_coding(strm, data_diff_time, NULL, data_type, DIFF_TIME,
-                          DIFF_TIME, dataBands, lav_dt, coding_scheme_dt);
-      }
-      /*******************************************/
-
-    } /* if( allowDiffTimeBack_flag ) */
-
-    /* LSB coding */
-    if (splitLsb_flag) {
-      apply_lsb_coding(strm, quant_data_lsb, 1, dataBands);
-    }
-
-  } /* Diff/Huff/LSB coding */
-
-  return reset;
-}
--- a/libSACenc/src/sacenc_nlc_enc.h
+++ /dev/null
@@ -1,141 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround encoder library *************************
-
-   Author(s):   Karsten Linzmeier
-
-   Description: Noiseless Coding
-                Huffman encoder
-
-*******************************************************************************/
-
-#ifndef SACENC_NLC_ENC_H
-#define SACENC_NLC_ENC_H
-
-/* Includes ******************************************************************/
-#include "sacenc_const.h"
-#include "FDK_bitstream.h"
-#include "sacenc_bitstream.h"
-
-/* Defines *******************************************************************/
-#define MAXBANDS MAX_NUM_BINS /* maximum number of frequency bands */
-
-/* Data Types ****************************************************************/
-typedef enum {
-  t_CLD,
-  t_ICC
-
-} DATA_TYPE;
-
-/* Constants *****************************************************************/
-
-/* Function / Class Declarations *********************************************/
-INT fdk_sacenc_ecDataPairEnc(HANDLE_FDK_BITSTREAM strm,
-                             SHORT aaInData[][MAXBANDS],
-                             SHORT aHistory[MAXBANDS],
-                             const DATA_TYPE data_type, const INT setIdx,
-                             const INT startBand, const INT dataBands,
-                             const INT coarse_flag,
-                             const INT independency_flag);
-
-INT fdk_sacenc_ecDataSingleEnc(HANDLE_FDK_BITSTREAM strm,
-                               SHORT aaInData[][MAXBANDS],
-                               SHORT aHistory[MAXBANDS],
-                               const DATA_TYPE data_type, const INT setIdx,
-                               const INT startBand, const INT dataBands,
-                               const INT coarse_flag,
-                               const INT independency_flag);
-
-#endif /* SACENC_NLC_ENC_H */
--- a/libSACenc/src/sacenc_onsetdetect.cpp
+++ /dev/null
@@ -1,381 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround encoder library *************************
-
-   Author(s):   Max Neuendorf
-
-   Description: Encoder Library Interface
-                Detect Onset in current frame
-
-*******************************************************************************/
-
-/**************************************************************************/ /**
-   \file
-   Description of file contents
- ******************************************************************************/
-
-/* Includes ******************************************************************/
-#include "sacenc_onsetdetect.h"
-#include "genericStds.h"
-#include "sacenc_vectorfunctions.h"
-
-/* Defines *******************************************************************/
-#define SPACE_ONSET_THRESHOLD (3.0)
-#define SPACE_ONSET_THRESHOLD_SF (3)
-#define SPACE_ONSET_THRESHOLD_SQUARE                                        \
-  (FL2FXCONST_DBL((1.0 / (SPACE_ONSET_THRESHOLD * SPACE_ONSET_THRESHOLD)) * \
-                  (float)(1 << SPACE_ONSET_THRESHOLD_SF)))
-
-/* Data Types ****************************************************************/
-struct ONSET_DETECT {
-  INT maxTimeSlots;
-  INT minTransientDistance;
-  INT avgEnergyDistance;
-  INT lowerBoundOnsetDetection;
-  INT upperBoundOnsetDetection;
-  FIXP_DBL *pEnergyHist__FDK;
-  SCHAR *pEnergyHistScale;
-  SCHAR avgEnergyDistanceScale;
-};
-
-/* Constants *****************************************************************/
-
-/* Function / Class Declarations *********************************************/
-
-/* Function / Class Definition ***********************************************/
-FDK_SACENC_ERROR fdk_sacenc_onsetDetect_Open(HANDLE_ONSET_DETECT *phOnset,
-                                             const UINT maxTimeSlots) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-  HANDLE_ONSET_DETECT hOnset = NULL;
-
-  if (NULL == phOnset) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    /* Memory Allocation */
-    FDK_ALLOCATE_MEMORY_1D(hOnset, 1, struct ONSET_DETECT);
-    FDK_ALLOCATE_MEMORY_1D(hOnset->pEnergyHist__FDK, 16 + maxTimeSlots,
-                           FIXP_DBL);
-    FDK_ALLOCATE_MEMORY_1D(hOnset->pEnergyHistScale, 16 + maxTimeSlots, SCHAR);
-
-    hOnset->maxTimeSlots = maxTimeSlots;
-    hOnset->minTransientDistance =
-        8; /* minimum distance between detected transients */
-    hOnset->avgEnergyDistance = 16; /* average energy distance */
-
-    hOnset->avgEnergyDistanceScale = 4;
-    *phOnset = hOnset;
-  }
-  return error;
-
-bail:
-  fdk_sacenc_onsetDetect_Close(&hOnset);
-  return ((SACENC_OK == error) ? SACENC_MEMORY_ERROR : error);
-}
-
-FDK_SACENC_ERROR fdk_sacenc_onsetDetect_Init(
-    HANDLE_ONSET_DETECT hOnset,
-    const ONSET_DETECT_CONFIG *const pOnsetDetectConfig, const UINT initFlags) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if ((NULL == hOnset) || (pOnsetDetectConfig == NULL)) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    if ((pOnsetDetectConfig->maxTimeSlots > hOnset->maxTimeSlots) ||
-        (pOnsetDetectConfig->upperBoundOnsetDetection <
-         hOnset->lowerBoundOnsetDetection)) {
-      error = SACENC_INVALID_CONFIG;
-      goto bail;
-    }
-
-    hOnset->maxTimeSlots = pOnsetDetectConfig->maxTimeSlots;
-    hOnset->lowerBoundOnsetDetection =
-        pOnsetDetectConfig->lowerBoundOnsetDetection;
-    hOnset->upperBoundOnsetDetection =
-        pOnsetDetectConfig->upperBoundOnsetDetection;
-
-    hOnset->minTransientDistance =
-        8; /* minimum distance between detected transients */
-    hOnset->avgEnergyDistance = 16; /* average energy distance */
-
-    hOnset->avgEnergyDistanceScale = 4;
-
-    /* Init / Reset */
-    if (initFlags) {
-      int i;
-      for (i = 0; i < hOnset->avgEnergyDistance + hOnset->maxTimeSlots; i++)
-        hOnset->pEnergyHistScale[i] = -(DFRACT_BITS - 3);
-
-      FDKmemset_flex(
-          hOnset->pEnergyHist__FDK,
-          FL2FXCONST_DBL(SACENC_FLOAT_EPSILON * (1 << (DFRACT_BITS - 3))),
-          hOnset->avgEnergyDistance + hOnset->maxTimeSlots);
-    }
-  }
-
-bail:
-  return error;
-}
-
-/**************************************************************************/
-
-FDK_SACENC_ERROR fdk_sacenc_onsetDetect_Close(HANDLE_ONSET_DETECT *phOnset) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if ((NULL != phOnset) && (NULL != *phOnset)) {
-    if (NULL != (*phOnset)->pEnergyHist__FDK) {
-      FDKfree((*phOnset)->pEnergyHist__FDK);
-    }
-    (*phOnset)->pEnergyHist__FDK = NULL;
-
-    if (NULL != (*phOnset)->pEnergyHistScale) {
-      FDKfree((*phOnset)->pEnergyHistScale);
-    }
-    (*phOnset)->pEnergyHistScale = NULL;
-    FDKfree(*phOnset);
-    *phOnset = NULL;
-  }
-  return error;
-}
-
-/**************************************************************************/
-
-FDK_SACENC_ERROR fdk_sacenc_onsetDetect_Update(HANDLE_ONSET_DETECT hOnset,
-                                               const INT timeSlots) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if (NULL == hOnset) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    if (timeSlots > hOnset->maxTimeSlots) {
-      error = SACENC_INVALID_CONFIG;
-    } else {
-      int i;
-      /* Shift old data */
-      for (i = 0; i < hOnset->avgEnergyDistance; i++) {
-        hOnset->pEnergyHist__FDK[i] = hOnset->pEnergyHist__FDK[i + timeSlots];
-        hOnset->pEnergyHistScale[i] = hOnset->pEnergyHistScale[i + timeSlots];
-      }
-
-      /* Clear for new data */
-      FDKmemset_flex(&hOnset->pEnergyHist__FDK[hOnset->avgEnergyDistance],
-                     FL2FXCONST_DBL(SACENC_FLOAT_EPSILON), timeSlots);
-    }
-  }
-  return error;
-}
-
-/**************************************************************************/
-
-FDK_SACENC_ERROR fdk_sacenc_onsetDetect_Apply(
-    HANDLE_ONSET_DETECT hOnset, const INT nTimeSlots, const INT nHybridBands,
-    FIXP_DPK *const *const ppHybridData__FDK, const INT hybridDataScale,
-    const INT prevPos, INT pTransientPos[MAX_NUM_TRANS]) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  C_ALLOC_SCRATCH_START(envs, FIXP_DBL, (16 + MAX_TIME_SLOTS))
-  FDKmemclear(envs, (16 + MAX_TIME_SLOTS) * sizeof(FIXP_DBL));
-
-  if ((hOnset == NULL) || (pTransientPos == NULL) ||
-      (ppHybridData__FDK == NULL)) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    int i, ts, trCnt, currPos;
-
-    if ((nTimeSlots < 0) || (nTimeSlots > hOnset->maxTimeSlots) ||
-        (hOnset->lowerBoundOnsetDetection < -1) ||
-        (hOnset->upperBoundOnsetDetection > nHybridBands)) {
-      error = SACENC_INVALID_CONFIG;
-      goto bail;
-    }
-
-    const int lowerBoundOnsetDetection = hOnset->lowerBoundOnsetDetection;
-    const int upperBoundOnsetDetection = hOnset->upperBoundOnsetDetection;
-    const int M = hOnset->avgEnergyDistance;
-
-    {
-      SCHAR *envScale = hOnset->pEnergyHistScale;
-      FIXP_DBL *env = hOnset->pEnergyHist__FDK;
-      const FIXP_DBL threshold_square = SPACE_ONSET_THRESHOLD_SQUARE;
-
-      trCnt = 0;
-
-      /* reset transient array */
-      FDKmemset_flex(pTransientPos, -1, MAX_NUM_TRANS);
-
-      /* minimum transient distance of minTransDist QMF samples */
-      if (prevPos > 0) {
-        currPos = FDKmax(nTimeSlots,
-                         prevPos - nTimeSlots + hOnset->minTransientDistance);
-      } else {
-        currPos = nTimeSlots;
-      }
-
-      /* get energy and scalefactor for each time slot */
-      int outScale;
-      int inScale = 3; /* scale factor determined empirically */
-      for (ts = 0; ts < nTimeSlots; ts++) {
-        env[M + ts] = sumUpCplxPow2(
-            &ppHybridData__FDK[ts][lowerBoundOnsetDetection + 1],
-            SUM_UP_DYNAMIC_SCALE, inScale, &outScale,
-            upperBoundOnsetDetection - lowerBoundOnsetDetection - 1);
-        envScale[M + ts] = outScale + (hybridDataScale << 1);
-      }
-
-      /* calculate common scale for all time slots */
-      SCHAR maxScale = -(DFRACT_BITS - 1);
-      for (i = 0; i < (nTimeSlots + M); i++) {
-        maxScale = fixMax(maxScale, envScale[i]);
-      }
-
-      /* apply common scale and store energy in temporary buffer */
-      for (i = 0; i < (nTimeSlots + M); i++) {
-        envs[i] = env[i] >> fixMin((maxScale - envScale[i]), (DFRACT_BITS - 1));
-      }
-
-      FIXP_DBL maxVal = FL2FXCONST_DBL(0.0f);
-      for (i = 0; i < (nTimeSlots + M); i++) {
-        maxVal |= fAbs(envs[i]);
-      }
-
-      int s = fixMax(0, CntLeadingZeros(maxVal) - 1);
-
-      for (i = 0; i < (nTimeSlots + M); i++) {
-        envs[i] = envs[i] << s;
-      }
-
-      int currPosPrev = currPos;
-      FIXP_DBL p1, p2;
-      p2 = FL2FXCONST_DBL(0.0f);
-      for (; (currPos < (nTimeSlots << 1)) && (trCnt < MAX_NUM_TRANS);
-           currPos++) {
-        p1 = fMultDiv2(envs[currPos - nTimeSlots + M], threshold_square) >>
-             (SPACE_ONSET_THRESHOLD_SF - 1);
-
-        /* Calculate average of past M energy values */
-        if (currPosPrev == (currPos - 1)) {
-          /* remove last and add new element */
-          p2 -= (envs[currPosPrev - nTimeSlots] >>
-                 (int)hOnset->avgEnergyDistanceScale);
-          p2 += (envs[currPos - nTimeSlots + M - 1] >>
-                 (int)hOnset->avgEnergyDistanceScale);
-        } else {
-          /* calculate complete vector */
-          p2 = FL2FXCONST_DBL(0.0f);
-          for (ts = 0; ts < M; ts++) {
-            p2 += (envs[currPos - nTimeSlots + ts] >>
-                   (int)hOnset->avgEnergyDistanceScale);
-          }
-        }
-        currPosPrev = currPos;
-
-        {
-          /* save position if transient found */
-          if (p1 > p2) {
-            pTransientPos[trCnt++] = currPos;
-            currPos += hOnset->minTransientDistance;
-          }
-        }
-      } /* for currPos */
-    }
-
-  } /* valid handle*/
-bail:
-
-  C_ALLOC_SCRATCH_END(envs, FIXP_DBL, (16 + MAX_TIME_SLOTS))
-
-  return error;
-}
-
-/**************************************************************************/
--- a/libSACenc/src/sacenc_onsetdetect.h
+++ /dev/null
@@ -1,154 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround encoder library *************************
-
-   Author(s):   Max Neuendorf
-
-   Description: Encoder Library Interface
-                Determine TES flags
-
-*******************************************************************************/
-
-#ifndef SACENC_ONSETDETECT_H
-#define SACENC_ONSETDETECT_H
-
-/**************************************************************************/ /**
-   \file
-   Description of file contents
- ******************************************************************************/
-
-/* Includes ******************************************************************/
-#include "common_fix.h"
-#include "FDK_matrixCalloc.h"
-#include "sacenc_lib.h"
-#include "sacenc_bitstream.h" /* for def. of MAX_NUM_PARAMS */
-
-/* Defines *******************************************************************/
-#define MAX_NUM_TRANS (MAX_NUM_PARAMS / 2)
-
-/* Data Types ****************************************************************/
-typedef struct T_ONSET_DETECT_CONFIG {
-  INT maxTimeSlots;
-
-  /* calc transien detection in ]lowerBoundOnsetDetection;
-   * upperBoundOnsetDetection[ */
-  INT lowerBoundOnsetDetection;
-  INT upperBoundOnsetDetection;
-
-} ONSET_DETECT_CONFIG;
-
-typedef struct ONSET_DETECT *HANDLE_ONSET_DETECT;
-
-/* Constants *****************************************************************/
-
-/* Function / Class Declarations *********************************************/
-FDK_SACENC_ERROR fdk_sacenc_onsetDetect_Open(HANDLE_ONSET_DETECT *phOnset,
-                                             const UINT maxTimeSlots);
-
-FDK_SACENC_ERROR fdk_sacenc_onsetDetect_Init(
-    HANDLE_ONSET_DETECT hOnset,
-    const ONSET_DETECT_CONFIG *const pOnsetDetectConfig, const UINT initFlags);
-
-FDK_SACENC_ERROR fdk_sacenc_onsetDetect_Close(HANDLE_ONSET_DETECT *phOnset);
-
-FDK_SACENC_ERROR fdk_sacenc_onsetDetect_Update(HANDLE_ONSET_DETECT hOnset,
-                                               const INT timeSlots);
-
-FDK_SACENC_ERROR fdk_sacenc_onsetDetect_Apply(
-    HANDLE_ONSET_DETECT hOnset, const INT nTimeSlots, const INT nHybridBands,
-    FIXP_DPK *const *const ppHybridData__FDK, const INT hybridDataScale,
-    const INT prevPos, INT pTransientPos[MAX_NUM_TRANS]);
-
-#endif /* SACENC_ONSETDETECT_H */
--- a/libSACenc/src/sacenc_paramextract.cpp
+++ /dev/null
@@ -1,725 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround encoder library *************************
-
-   Author(s):   M. Multrus
-
-   Description: Parameter Extraction
-
-*******************************************************************************/
-
-/* Includes ******************************************************************/
-#include "sacenc_paramextract.h"
-#include "sacenc_tree.h"
-#include "sacenc_vectorfunctions.h"
-
-/* Defines *******************************************************************/
-#define LOG10_2_10 (3.01029995664f) /* 10.0f*log10(2.f) */
-#define SCALE_CLDE_SF (7)           /* maxVal in Quant tab is +/-  50 */
-#define SCALE_CLDD_SF (8)           /* maxVal in Quant tab is +/- 150 */
-
-/* Data Types ****************************************************************/
-typedef struct T_TTO_BOX {
-  FIXP_DBL pCld__FDK[MAX_NUM_PARAM_BANDS];
-  FIXP_DBL pIcc__FDK[MAX_NUM_PARAM_BANDS];
-  FIXP_DBL pCldQuant__FDK[MAX_NUM_PARAM_BANDS];
-
-  const FIXP_DBL *pIccQuantTable__FDK;
-  const FIXP_DBL *pCldQuantTableDec__FDK;
-  const FIXP_DBL *pCldQuantTableEnc__FDK;
-
-  SCHAR pCldEbQIdx[MAX_NUM_PARAM_BANDS];
-  SCHAR pIccDownmixIdx[MAX_NUM_PARAM_BANDS];
-
-  UCHAR *pParameterBand2HybridBandOffset;
-  const INT *pSubbandImagSign;
-  UCHAR nHybridBandsMax;
-  UCHAR nParameterBands;
-  UCHAR bFrameKeep;
-
-  UCHAR iccCorrelationCoherenceBorder;
-  BOX_QUANTMODE boxQuantMode;
-
-  UCHAR nIccQuantSteps;
-  UCHAR nIccQuantOffset;
-
-  UCHAR nCldQuantSteps;
-  UCHAR nCldQuantOffset;
-
-  UCHAR bUseCoarseQuantCld;
-  UCHAR bUseCoarseQuantIcc;
-
-} TTO_BOX;
-
-struct BOX_SUBBAND_SETUP {
-  BOX_SUBBAND_CONFIG subbandConfig;
-  UCHAR nParameterBands;
-  const UCHAR *pSubband2ParameterIndexLd;
-  UCHAR iccCorrelationCoherenceBorder;
-};
-
-/* Constants *****************************************************************/
-static const UCHAR subband2Parameter4_Ld[NUM_QMF_BANDS] = {
-    0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-    2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
-    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};
-
-static const UCHAR subband2Parameter5_Ld[NUM_QMF_BANDS] = {
-    0, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
-    3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
-    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4};
-
-static const UCHAR subband2Parameter7_Ld[NUM_QMF_BANDS] = {
-    0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5,
-    5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
-    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6};
-
-static const UCHAR subband2Parameter9_Ld[NUM_QMF_BANDS] = {
-    0, 1, 2, 3, 3, 4, 4, 5, 5, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7,
-    7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
-    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8};
-
-static const UCHAR subband2Parameter12_Ld[NUM_QMF_BANDS] = {
-    0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  7,  7,  7,  8,  8,
-    8,  8,  9,  9,  9,  9,  9,  10, 10, 10, 10, 10, 10, 10, 10, 10,
-    10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
-    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11};
-
-static const UCHAR subband2Parameter15_Ld[NUM_QMF_BANDS] = {
-    0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  9,  10, 10, 10, 11, 11,
-    11, 11, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13,
-    13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
-    14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14};
-
-static const UCHAR subband2Parameter23_Ld[NUM_QMF_BANDS] = {
-    0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 12, 13, 13,
-    14, 14, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 18, 19, 19,
-    19, 19, 19, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21,
-    22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22};
-
-static const INT subbandImagSign_Ld[NUM_QMF_BANDS] = {
-    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-};
-
-#define SCALE_CLDE(a) (FL2FXCONST_DBL(a / (float)(1 << SCALE_CLDE_SF)))
-static const FIXP_DBL cldQuantTableFineEnc__FDK[MAX_CLD_QUANT_FINE] = {
-    SCALE_CLDE(-50.0), SCALE_CLDE(-45.0), SCALE_CLDE(-40.0), SCALE_CLDE(-35.0),
-    SCALE_CLDE(-30.0), SCALE_CLDE(-25.0), SCALE_CLDE(-22.0), SCALE_CLDE(-19.0),
-    SCALE_CLDE(-16.0), SCALE_CLDE(-13.0), SCALE_CLDE(-10.0), SCALE_CLDE(-8.0),
-    SCALE_CLDE(-6.0),  SCALE_CLDE(-4.0),  SCALE_CLDE(-2.0),  SCALE_CLDE(0.0),
-    SCALE_CLDE(2.0),   SCALE_CLDE(4.0),   SCALE_CLDE(6.0),   SCALE_CLDE(8.0),
-    SCALE_CLDE(10.0),  SCALE_CLDE(13.0),  SCALE_CLDE(16.0),  SCALE_CLDE(19.0),
-    SCALE_CLDE(22.0),  SCALE_CLDE(25.0),  SCALE_CLDE(30.0),  SCALE_CLDE(35.0),
-    SCALE_CLDE(40.0),  SCALE_CLDE(45.0),  SCALE_CLDE(50.0)};
-
-static const FIXP_DBL cldQuantTableCoarseEnc__FDK[MAX_CLD_QUANT_COARSE] = {
-    SCALE_CLDE(-50.0), SCALE_CLDE(-35.0), SCALE_CLDE(-25.0), SCALE_CLDE(-19.0),
-    SCALE_CLDE(-13.0), SCALE_CLDE(-8.0),  SCALE_CLDE(-4.0),  SCALE_CLDE(0.0),
-    SCALE_CLDE(4.0),   SCALE_CLDE(8.0),   SCALE_CLDE(13.0),  SCALE_CLDE(19.0),
-    SCALE_CLDE(25.0),  SCALE_CLDE(35.0),  SCALE_CLDE(50.0)};
-
-#define SCALE_CLDD(a) (FL2FXCONST_DBL(a / (float)(1 << SCALE_CLDD_SF)))
-static const FIXP_DBL cldQuantTableFineDec__FDK[MAX_CLD_QUANT_FINE] = {
-    SCALE_CLDD(-150.0), SCALE_CLDD(-45.0), SCALE_CLDD(-40.0), SCALE_CLDD(-35.0),
-    SCALE_CLDD(-30.0),  SCALE_CLDD(-25.0), SCALE_CLDD(-22.0), SCALE_CLDD(-19.0),
-    SCALE_CLDD(-16.0),  SCALE_CLDD(-13.0), SCALE_CLDD(-10.0), SCALE_CLDD(-8.0),
-    SCALE_CLDD(-6.0),   SCALE_CLDD(-4.0),  SCALE_CLDD(-2.0),  SCALE_CLDD(0.0),
-    SCALE_CLDD(2.0),    SCALE_CLDD(4.0),   SCALE_CLDD(6.0),   SCALE_CLDD(8.0),
-    SCALE_CLDD(10.0),   SCALE_CLDD(13.0),  SCALE_CLDD(16.0),  SCALE_CLDD(19.0),
-    SCALE_CLDD(22.0),   SCALE_CLDD(25.0),  SCALE_CLDD(30.0),  SCALE_CLDD(35.0),
-    SCALE_CLDD(40.0),   SCALE_CLDD(45.0),  SCALE_CLDD(150.0)};
-
-static const FIXP_DBL cldQuantTableCoarseDec__FDK[MAX_CLD_QUANT_COARSE] = {
-    SCALE_CLDD(-150.0), SCALE_CLDD(-35.0), SCALE_CLDD(-25.0), SCALE_CLDD(-19.0),
-    SCALE_CLDD(-13.0),  SCALE_CLDD(-8.0),  SCALE_CLDD(-4.0),  SCALE_CLDD(0.0),
-    SCALE_CLDD(4.0),    SCALE_CLDD(8.0),   SCALE_CLDD(13.0),  SCALE_CLDD(19.0),
-    SCALE_CLDD(25.0),   SCALE_CLDD(35.0),  SCALE_CLDD(150.0)};
-
-#define SCALE_ICC(a) (FL2FXCONST_DBL(a))
-static const FIXP_DBL iccQuantTableFine__FDK[MAX_ICC_QUANT_FINE] = {
-    SCALE_ICC(0.99999999953), SCALE_ICC(0.937f),   SCALE_ICC(0.84118f),
-    SCALE_ICC(0.60092f),      SCALE_ICC(0.36764f), SCALE_ICC(0.0f),
-    SCALE_ICC(-0.589f),       SCALE_ICC(-0.99f)};
-
-static const FIXP_DBL iccQuantTableCoarse__FDK[MAX_ICC_QUANT_COARSE] = {
-    SCALE_ICC(0.99999999953), SCALE_ICC(0.84118f), SCALE_ICC(0.36764f),
-    SCALE_ICC(-0.5890f)};
-
-static const BOX_SUBBAND_SETUP boxSubbandSetup[] = {
-    {BOX_SUBBANDS_4, 4, subband2Parameter4_Ld, 1},
-    {BOX_SUBBANDS_5, 5, subband2Parameter5_Ld, 2},
-    {BOX_SUBBANDS_7, 7, subband2Parameter7_Ld, 3},
-    {BOX_SUBBANDS_9, 9, subband2Parameter9_Ld, 4},
-    {BOX_SUBBANDS_12, 12, subband2Parameter12_Ld, 4},
-    {BOX_SUBBANDS_15, 15, subband2Parameter15_Ld, 5},
-    {BOX_SUBBANDS_23, 23, subband2Parameter23_Ld, 8}};
-
-/* Function / Class Declarations *********************************************/
-
-/* Function / Class Definition ***********************************************/
-static const BOX_SUBBAND_SETUP *getBoxSubbandSetup(
-    const BOX_SUBBAND_CONFIG subbandConfig) {
-  int i;
-  const BOX_SUBBAND_SETUP *setup = NULL;
-
-  for (i = 0; i < (int)(sizeof(boxSubbandSetup) / sizeof(BOX_SUBBAND_SETUP));
-       i++) {
-    if (boxSubbandSetup[i].subbandConfig == subbandConfig) {
-      setup = &boxSubbandSetup[i];
-      break;
-    }
-  }
-  return setup;
-}
-
-static inline void ApplyBBCuesFDK(FIXP_DBL *const pData,
-                                  const INT nParamBands) {
-  int i, s;
-  FIXP_DBL tmp, invParamBands;
-
-  invParamBands = fDivNormHighPrec((FIXP_DBL)1, (FIXP_DBL)nParamBands, &s);
-  s = -s;
-
-  tmp = fMult(pData[0], invParamBands) >> s;
-  for (i = 1; i < nParamBands; i++) {
-    tmp += fMult(pData[i], invParamBands) >> s;
-  }
-
-  for (i = 0; i < nParamBands; i++) {
-    pData[i] = tmp;
-  }
-}
-
-static INT getNumberParameterBands(const BOX_SUBBAND_CONFIG subbandConfig) {
-  const BOX_SUBBAND_SETUP *setup = getBoxSubbandSetup(subbandConfig);
-  return ((setup == NULL) ? 0 : setup->nParameterBands);
-}
-
-static const UCHAR *getSubband2ParameterIndex(
-    const BOX_SUBBAND_CONFIG subbandConfig) {
-  const BOX_SUBBAND_SETUP *setup = getBoxSubbandSetup(subbandConfig);
-
-  return ((setup == NULL) ? NULL : (setup->pSubband2ParameterIndexLd));
-}
-
-void fdk_sacenc_calcParameterBand2HybridBandOffset(
-    const BOX_SUBBAND_CONFIG subbandConfig, const INT nHybridBands,
-    UCHAR *pParameterBand2HybridBandOffset) {
-  const BOX_SUBBAND_SETUP *setup = getBoxSubbandSetup(subbandConfig);
-  const UCHAR *pSubband2ParameterIndex;
-
-  int i, pb;
-
-  pSubband2ParameterIndex = setup->pSubband2ParameterIndexLd;
-
-  for (pb = 0, i = 0; i < nHybridBands - 1; i++) {
-    if (pSubband2ParameterIndex[i + 1] - pSubband2ParameterIndex[i]) {
-      pParameterBand2HybridBandOffset[pb++] = (i + 1);
-    }
-  }
-  pParameterBand2HybridBandOffset[pb++] = (i + 1);
-}
-
-const INT *fdk_sacenc_getSubbandImagSign() {
-  const INT *pImagSign = NULL;
-
-  pImagSign = subbandImagSign_Ld;
-
-  return (pImagSign);
-}
-
-static INT getIccCorrelationCoherenceBorder(
-    const BOX_SUBBAND_CONFIG subbandConfig, const INT bUseCoherenceOnly) {
-  const BOX_SUBBAND_SETUP *setup = getBoxSubbandSetup(subbandConfig);
-  return (
-      (setup == NULL)
-          ? 0
-          : ((bUseCoherenceOnly) ? 0 : setup->iccCorrelationCoherenceBorder));
-}
-
-FDK_SACENC_ERROR fdk_sacenc_createTtoBox(HANDLE_TTO_BOX *hTtoBox) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if (NULL == hTtoBox) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    FDK_ALLOCATE_MEMORY_1D(*hTtoBox, 1, TTO_BOX);
-  }
-  return error;
-
-bail:
-  fdk_sacenc_destroyTtoBox(hTtoBox);
-  return ((SACENC_OK == error) ? SACENC_MEMORY_ERROR : error);
-}
-
-FDK_SACENC_ERROR fdk_sacenc_initTtoBox(HANDLE_TTO_BOX hTtoBox,
-                                       const TTO_BOX_CONFIG *const ttoBoxConfig,
-                                       UCHAR *pParameterBand2HybridBandOffset) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if ((hTtoBox == NULL) || (ttoBoxConfig == NULL) ||
-      (pParameterBand2HybridBandOffset == NULL)) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    FDKmemclear(hTtoBox, sizeof(TTO_BOX));
-
-    hTtoBox->bUseCoarseQuantCld = ttoBoxConfig->bUseCoarseQuantCld;
-    hTtoBox->bUseCoarseQuantIcc = ttoBoxConfig->bUseCoarseQuantIcc;
-    hTtoBox->boxQuantMode = ttoBoxConfig->boxQuantMode;
-    hTtoBox->iccCorrelationCoherenceBorder = getIccCorrelationCoherenceBorder(
-        ttoBoxConfig->subbandConfig, ttoBoxConfig->bUseCoherenceIccOnly);
-    hTtoBox->nHybridBandsMax = ttoBoxConfig->nHybridBandsMax;
-    hTtoBox->nParameterBands =
-        getNumberParameterBands(ttoBoxConfig->subbandConfig);
-    hTtoBox->bFrameKeep = ttoBoxConfig->bFrameKeep;
-
-    hTtoBox->nIccQuantSteps =
-        fdk_sacenc_getNumberIccQuantLevels(hTtoBox->bUseCoarseQuantIcc);
-    hTtoBox->nIccQuantOffset =
-        fdk_sacenc_getIccQuantOffset(hTtoBox->bUseCoarseQuantIcc);
-
-    hTtoBox->pIccQuantTable__FDK = hTtoBox->bUseCoarseQuantIcc
-                                       ? iccQuantTableCoarse__FDK
-                                       : iccQuantTableFine__FDK;
-    hTtoBox->pCldQuantTableDec__FDK = hTtoBox->bUseCoarseQuantCld
-                                          ? cldQuantTableCoarseDec__FDK
-                                          : cldQuantTableFineDec__FDK;
-    hTtoBox->pCldQuantTableEnc__FDK = hTtoBox->bUseCoarseQuantCld
-                                          ? cldQuantTableCoarseEnc__FDK
-                                          : cldQuantTableFineEnc__FDK;
-
-    hTtoBox->nCldQuantSteps =
-        fdk_sacenc_getNumberCldQuantLevels(hTtoBox->bUseCoarseQuantCld);
-    hTtoBox->nCldQuantOffset =
-        fdk_sacenc_getCldQuantOffset(hTtoBox->bUseCoarseQuantCld);
-
-    /* sanity */
-    if (NULL == (hTtoBox->pParameterBand2HybridBandOffset =
-                     pParameterBand2HybridBandOffset)) {
-      error = SACENC_INIT_ERROR;
-      goto bail;
-    }
-
-    if (NULL == (hTtoBox->pSubbandImagSign = fdk_sacenc_getSubbandImagSign())) {
-      error = SACENC_INIT_ERROR;
-    }
-
-    if ((hTtoBox->boxQuantMode != BOX_QUANTMODE_FINE) &&
-        (hTtoBox->boxQuantMode != BOX_QUANTMODE_EBQ1) &&
-        (hTtoBox->boxQuantMode != BOX_QUANTMODE_EBQ2)) {
-      error = SACENC_INIT_ERROR;
-      goto bail;
-    }
-  }
-bail:
-  return error;
-}
-
-FDK_SACENC_ERROR fdk_sacenc_destroyTtoBox(HANDLE_TTO_BOX *hTtoBox) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if (*hTtoBox != NULL) {
-    FDKfree(*hTtoBox);
-    *hTtoBox = NULL;
-  }
-
-  return error;
-}
-
-static FDK_SACENC_ERROR calculateIccFDK(const INT nParamBand,
-                                        const INT correlationCoherenceBorder,
-                                        const FIXP_DBL *const pPwr1,
-                                        const FIXP_DBL *const pPwr2,
-                                        const FIXP_DBL *const pProdReal,
-                                        FIXP_DBL const *const pProdImag,
-                                        FIXP_DBL *const pIcc) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if ((pPwr1 == NULL) || (pPwr2 == NULL) || (pProdReal == NULL) ||
-      (pProdImag == NULL) || (pIcc == NULL)) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    /* sanity check border */
-    if (correlationCoherenceBorder > nParamBand) {
-      error = SACENC_INVALID_CONFIG;
-    } else {
-      /* correlation */
-      FDKcalcCorrelationVec(pIcc, pProdReal, pPwr1, pPwr2,
-                            correlationCoherenceBorder);
-
-      /* coherence */
-      calcCoherenceVec(&pIcc[correlationCoherenceBorder],
-                       &pProdReal[correlationCoherenceBorder],
-                       &pProdImag[correlationCoherenceBorder],
-                       &pPwr1[correlationCoherenceBorder],
-                       &pPwr2[correlationCoherenceBorder], 0, 0,
-                       nParamBand - correlationCoherenceBorder);
-
-    } /* valid configuration */
-  }   /* valid handle */
-
-  return error;
-}
-
-static void QuantizeCoefFDK(const FIXP_DBL *const input, const INT nBands,
-                            const FIXP_DBL *const quantTable,
-                            const INT idxOffset, const INT nQuantSteps,
-                            SCHAR *const quantOut) {
-  int band;
-  const int reverse = (quantTable[0] > quantTable[1]);
-
-  for (band = 0; band < nBands; band++) {
-    FIXP_DBL qVal;
-    FIXP_DBL curVal = input[band];
-
-    int lower = 0;
-    int upper = nQuantSteps - 1;
-
-    if (reverse) {
-      while (upper - lower > 1) {
-        int idx = (lower + upper) >> 1;
-        qVal = quantTable[idx];
-        if (curVal >= qVal) {
-          upper = idx;
-        } else {
-          lower = idx;
-        }
-      } /* while */
-
-      if ((curVal - quantTable[lower]) >= (quantTable[upper] - curVal)) {
-        quantOut[band] = lower - idxOffset;
-      } else {
-        quantOut[band] = upper - idxOffset;
-      }
-    } /* if reverse */
-    else {
-      while (upper - lower > 1) {
-        int idx = (lower + upper) >> 1;
-        qVal = quantTable[idx];
-        if (curVal <= qVal) {
-          upper = idx;
-        } else {
-          lower = idx;
-        }
-      } /* while */
-
-      if ((curVal - quantTable[lower]) <= (quantTable[upper] - curVal)) {
-        quantOut[band] = lower - idxOffset;
-      } else {
-        quantOut[band] = upper - idxOffset;
-      }
-    } /* else reverse */
-  }   /* for band */
-}
-
-static void deQuantizeCoefFDK(const SCHAR *const input, const INT nBands,
-                              const FIXP_DBL *const quantTable,
-                              const INT idxOffset, FIXP_DBL *const dequantOut) {
-  int band;
-
-  for (band = 0; band < nBands; band++) {
-    dequantOut[band] = quantTable[input[band] + idxOffset];
-  }
-}
-
-static void CalculateCldFDK(FIXP_DBL *const pCld, const FIXP_DBL *const pPwr1,
-                            const FIXP_DBL *const pPwr2, const INT scaleCh1,
-                            const INT *const pbScaleCh1, const INT scaleCh2,
-                            const INT *const pbScaleCh2, const int nParamBand) {
-  INT i;
-  FIXP_DBL ldPwr1, ldPwr2, cld;
-  FIXP_DBL maxPwr = FL2FXCONST_DBL(
-      30.0f /
-      (1 << (LD_DATA_SHIFT +
-             1))); /* consider SACENC_FLOAT_EPSILON in power calculation */
-
-  for (i = 0; i < nParamBand; i++) {
-    ldPwr1 =
-        (CalcLdData(pPwr1[i]) >> 1) + ((FIXP_DBL)(scaleCh1 + pbScaleCh1[i])
-                                       << (DFRACT_BITS - 1 - LD_DATA_SHIFT));
-    ldPwr2 =
-        (CalcLdData(pPwr2[i]) >> 1) + ((FIXP_DBL)(scaleCh2 + pbScaleCh2[i])
-                                       << (DFRACT_BITS - 1 - LD_DATA_SHIFT));
-
-    ldPwr1 = fixMax(fixMin(ldPwr1, maxPwr), -maxPwr);
-    ldPwr2 = fixMax(fixMin(ldPwr2, maxPwr), -maxPwr);
-
-    /* ldPwr1 and ldPwr2 are scaled by LD_DATA_SHIFT and additional 1 bit; 1 bit
-     * scale by fMultDiv2() */
-    cld = fMultDiv2(FL2FXCONST_DBL(LOG10_2_10 / (1 << SCALE_CLDE_SF)),
-                    ldPwr1 - ldPwr2);
-
-    cld =
-        fixMin(cld, (FIXP_DBL)(((FIXP_DBL)MAXVAL_DBL) >> (LD_DATA_SHIFT + 2)));
-    cld =
-        fixMax(cld, (FIXP_DBL)(((FIXP_DBL)MINVAL_DBL) >> (LD_DATA_SHIFT + 2)));
-    pCld[i] = cld << (LD_DATA_SHIFT + 2);
-  }
-}
-
-FDK_SACENC_ERROR fdk_sacenc_applyTtoBox(
-    HANDLE_TTO_BOX hTtoBox, const INT nTimeSlots, const INT startTimeSlot,
-    const INT nHybridBands, const FIXP_DPK *const *const ppHybridData1__FDK,
-    const FIXP_DPK *const *const ppHybridData2__FDK, SCHAR *const pIccIdx,
-    UCHAR *const pbIccQuantCoarse, SCHAR *const pCldIdx,
-    UCHAR *const pbCldQuantCoarse, const INT bUseBBCues, INT *scaleCh1,
-    INT *scaleCh2) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  C_ALLOC_SCRATCH_START(powerHybridData1__FDK, FIXP_DBL, MAX_NUM_PARAM_BANDS)
-  C_ALLOC_SCRATCH_START(powerHybridData2__FDK, FIXP_DBL, MAX_NUM_PARAM_BANDS)
-  C_ALLOC_SCRATCH_START(prodHybridDataReal__FDK, FIXP_DBL, MAX_NUM_PARAM_BANDS)
-  C_ALLOC_SCRATCH_START(prodHybridDataImag__FDK, FIXP_DBL, MAX_NUM_PARAM_BANDS)
-
-  C_ALLOC_SCRATCH_START(IccDownmix__FDK, FIXP_DBL, MAX_NUM_PARAM_BANDS)
-  C_ALLOC_SCRATCH_START(IccDownmixQuant__FDK, FIXP_DBL, MAX_NUM_PARAM_BANDS)
-  C_ALLOC_SCRATCH_START(pbScaleCh1, INT, MAX_NUM_PARAM_BANDS)
-  C_ALLOC_SCRATCH_START(pbScaleCh2, INT, MAX_NUM_PARAM_BANDS)
-
-  if ((hTtoBox == NULL) || (pCldIdx == NULL) || (pbCldQuantCoarse == NULL) ||
-      (ppHybridData1__FDK == NULL) || (ppHybridData2__FDK == NULL) ||
-      (pIccIdx == NULL) || (pbIccQuantCoarse == NULL)) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    int j, pb;
-    const int nParamBands = hTtoBox->nParameterBands;
-    const int bUseEbQ = (hTtoBox->boxQuantMode == BOX_QUANTMODE_EBQ1) ||
-                        (hTtoBox->boxQuantMode == BOX_QUANTMODE_EBQ2);
-
-    /* sanity check */
-    if ((nHybridBands < 0) || (nHybridBands > hTtoBox->nHybridBandsMax)) {
-      error = SACENC_INVALID_CONFIG;
-      goto bail;
-    }
-
-    int outScale;    /* scalefactor will not be evaluated */
-    int inScale = 5; /* scale factor determined empirically */
-
-    /* calculate the headroom of the hybrid data for each parameter band */
-    FDKcalcPbScaleFactor(ppHybridData1__FDK,
-                         hTtoBox->pParameterBand2HybridBandOffset, pbScaleCh1,
-                         startTimeSlot, nTimeSlots, nParamBands);
-    FDKcalcPbScaleFactor(ppHybridData2__FDK,
-                         hTtoBox->pParameterBand2HybridBandOffset, pbScaleCh2,
-                         startTimeSlot, nTimeSlots, nParamBands);
-
-    for (j = 0, pb = 0; pb < nParamBands; pb++) {
-      FIXP_DBL data1, data2;
-      data1 = data2 = (FIXP_DBL)0;
-      for (; j < hTtoBox->pParameterBand2HybridBandOffset[pb]; j++) {
-        data1 += sumUpCplxPow2Dim2(ppHybridData1__FDK, SUM_UP_STATIC_SCALE,
-                                   inScale + pbScaleCh1[pb], &outScale,
-                                   startTimeSlot, nTimeSlots, j, j + 1);
-        data2 += sumUpCplxPow2Dim2(ppHybridData2__FDK, SUM_UP_STATIC_SCALE,
-                                   inScale + pbScaleCh2[pb], &outScale,
-                                   startTimeSlot, nTimeSlots, j, j + 1);
-      } /* for j */
-      powerHybridData1__FDK[pb] = data1;
-      powerHybridData2__FDK[pb] = data2;
-    } /* pb */
-
-    {
-      for (j = 0, pb = 0; pb < nParamBands; pb++) {
-        FIXP_DBL dataReal, dataImag;
-        dataReal = dataImag = (FIXP_DBL)0;
-        for (; j < hTtoBox->pParameterBand2HybridBandOffset[pb]; j++) {
-          FIXP_DPK scalarProd;
-          cplx_cplxScalarProduct(&scalarProd, ppHybridData1__FDK,
-                                 ppHybridData2__FDK, inScale + pbScaleCh1[pb],
-                                 inScale + pbScaleCh2[pb], &outScale,
-                                 startTimeSlot, nTimeSlots, j, j + 1);
-          dataReal += scalarProd.v.re;
-          if (hTtoBox->pSubbandImagSign[j] < 0) {
-            dataImag -= scalarProd.v.im;
-          } else {
-            dataImag += scalarProd.v.im;
-          }
-        } /* for j */
-        prodHybridDataReal__FDK[pb] = dataReal;
-        prodHybridDataImag__FDK[pb] = dataImag;
-      } /* pb */
-
-      if (SACENC_OK != (error = calculateIccFDK(
-                            nParamBands, hTtoBox->iccCorrelationCoherenceBorder,
-                            powerHybridData1__FDK, powerHybridData2__FDK,
-                            prodHybridDataReal__FDK, prodHybridDataImag__FDK,
-                            hTtoBox->pIcc__FDK))) {
-        goto bail;
-      }
-
-      /* calculate correlation based Icc for downmix */
-      if (SACENC_OK != (error = calculateIccFDK(
-                            nParamBands, nParamBands, powerHybridData1__FDK,
-                            powerHybridData2__FDK, prodHybridDataReal__FDK,
-                            prodHybridDataImag__FDK, IccDownmix__FDK))) {
-        goto bail;
-      }
-    }
-
-    if (!bUseEbQ) {
-      CalculateCldFDK(hTtoBox->pCld__FDK, powerHybridData1__FDK,
-                      powerHybridData2__FDK, *scaleCh1 + inScale + 1,
-                      pbScaleCh1, *scaleCh2 + inScale + 1, pbScaleCh2,
-                      nParamBands);
-    }
-
-    if (bUseBBCues) {
-      ApplyBBCuesFDK(&hTtoBox->pCld__FDK[0], nParamBands);
-
-      { ApplyBBCuesFDK(&hTtoBox->pIcc__FDK[0], nParamBands); }
-
-    } /* bUseBBCues */
-
-    /* quantize/de-quantize icc */
-    {
-      QuantizeCoefFDK(hTtoBox->pIcc__FDK, nParamBands,
-                      hTtoBox->pIccQuantTable__FDK, hTtoBox->nIccQuantOffset,
-                      hTtoBox->nIccQuantSteps, pIccIdx);
-      QuantizeCoefFDK(IccDownmix__FDK, nParamBands,
-                      hTtoBox->pIccQuantTable__FDK, hTtoBox->nIccQuantOffset,
-                      hTtoBox->nIccQuantSteps, hTtoBox->pIccDownmixIdx);
-      deQuantizeCoefFDK(hTtoBox->pIccDownmixIdx, nParamBands,
-                        hTtoBox->pIccQuantTable__FDK, hTtoBox->nIccQuantOffset,
-                        IccDownmixQuant__FDK);
-
-      *pbIccQuantCoarse = hTtoBox->bUseCoarseQuantIcc;
-    }
-
-    /* quantize/de-quantize cld */
-    if (!bUseEbQ) {
-      QuantizeCoefFDK(hTtoBox->pCld__FDK, nParamBands,
-                      hTtoBox->pCldQuantTableEnc__FDK, hTtoBox->nCldQuantOffset,
-                      hTtoBox->nCldQuantSteps, pCldIdx);
-      deQuantizeCoefFDK(pCldIdx, nParamBands, hTtoBox->pCldQuantTableDec__FDK,
-                        hTtoBox->nCldQuantOffset, hTtoBox->pCldQuant__FDK);
-    } else {
-      FDKmemcpy(pCldIdx, hTtoBox->pCldEbQIdx, nParamBands * sizeof(SCHAR));
-    }
-    *pbCldQuantCoarse = hTtoBox->bUseCoarseQuantCld;
-
-  } /* valid handle */
-
-bail:
-  C_ALLOC_SCRATCH_END(pbScaleCh2, INT, MAX_NUM_PARAM_BANDS)
-  C_ALLOC_SCRATCH_END(pbScaleCh1, INT, MAX_NUM_PARAM_BANDS)
-  C_ALLOC_SCRATCH_END(IccDownmixQuant__FDK, FIXP_DBL, MAX_NUM_PARAM_BANDS)
-  C_ALLOC_SCRATCH_END(IccDownmix__FDK, FIXP_DBL, MAX_NUM_PARAM_BANDS)
-
-  C_ALLOC_SCRATCH_END(prodHybridDataImag__FDK, FIXP_DBL, MAX_NUM_PARAM_BANDS)
-  C_ALLOC_SCRATCH_END(prodHybridDataReal__FDK, FIXP_DBL, MAX_NUM_PARAM_BANDS)
-  C_ALLOC_SCRATCH_END(powerHybridData2__FDK, FIXP_DBL, MAX_NUM_PARAM_BANDS)
-  C_ALLOC_SCRATCH_END(powerHybridData1__FDK, FIXP_DBL, MAX_NUM_PARAM_BANDS)
-
-  return error;
-}
-
-INT fdk_sacenc_subband2ParamBand(const BOX_SUBBAND_CONFIG boxSubbandConfig,
-                                 const INT nSubband) {
-  INT nParamBand = -1;
-  const UCHAR *pSubband2ParameterIndex =
-      getSubband2ParameterIndex(boxSubbandConfig);
-
-  if (pSubband2ParameterIndex != NULL) {
-    const int hybrid_resolution = 64;
-
-    if ((nSubband > -1) && (nSubband < hybrid_resolution)) {
-      nParamBand = pSubband2ParameterIndex[nSubband];
-    }
-  }
-
-  return nParamBand;
-}
--- a/libSACenc/src/sacenc_paramextract.h
+++ /dev/null
@@ -1,214 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround encoder library *************************
-
-   Author(s):   M. Multrus
-
-   Description: Parameter Extraction
-
-*******************************************************************************/
-
-#ifndef SACENC_PARAMEXTRACT_H
-#define SACENC_PARAMEXTRACT_H
-
-/* Includes ******************************************************************/
-#include "common_fix.h"
-#include "sacenc_lib.h"
-#include "sacenc_const.h"
-#include "sacenc_bitstream.h"
-
-/* Defines *******************************************************************/
-#define MAX_CLD_QUANT_FINE (31)
-#define MAX_CLD_QUANT_COARSE (15)
-#define OFFSET_CLD_QUANT_COARSE (7)
-#define OFFSET_CLD_QUANT_FINE (15)
-
-#define MAX_ICC_QUANT_COARSE (4)
-#define MAX_ICC_QUANT_FINE (8)
-#define OFFSET_ICC_QUANT_COARSE (0)
-#define OFFSET_ICC_QUANT_FINE (0)
-
-#define MAX_NUM_PARAM_BANDS (28)
-
-#define NUM_MAPPED_HYBRID_BANDS (16)
-
-/* Data Types ****************************************************************/
-typedef struct T_TTO_BOX *HANDLE_TTO_BOX;
-
-typedef enum {
-  BOX_SUBBANDS_INVALID = 0,
-  BOX_SUBBANDS_4 = 4,
-  BOX_SUBBANDS_5 = 5,
-  BOX_SUBBANDS_7 = 7,
-  BOX_SUBBANDS_9 = 9,
-  BOX_SUBBANDS_12 = 12,
-  BOX_SUBBANDS_15 = 15,
-  BOX_SUBBANDS_23 = 23
-
-} BOX_SUBBAND_CONFIG;
-
-typedef enum {
-  BOX_QUANTMODE_INVALID = -1,
-  BOX_QUANTMODE_FINE = 0,
-  BOX_QUANTMODE_EBQ1 = 1,
-  BOX_QUANTMODE_EBQ2 = 2,
-  BOX_QUANTMODE_RESERVED3 = 3,
-  BOX_QUANTMODE_RESERVED4 = 4,
-  BOX_QUANTMODE_RESERVED5 = 5,
-  BOX_QUANTMODE_RESERVED6 = 6,
-  BOX_QUANTMODE_RESERVED7 = 7
-
-} BOX_QUANTMODE;
-
-typedef struct T_TTO_BOX_CONFIG {
-  UCHAR bUseCoarseQuantCld;
-  UCHAR bUseCoarseQuantIcc;
-  UCHAR bUseCoherenceIccOnly;
-
-  BOX_SUBBAND_CONFIG subbandConfig;
-  BOX_QUANTMODE boxQuantMode;
-
-  UCHAR nHybridBandsMax;
-
-  UCHAR bFrameKeep;
-
-} TTO_BOX_CONFIG;
-
-/* Constants *****************************************************************/
-
-/* Function / Class Declarations *********************************************/
-FDK_SACENC_ERROR fdk_sacenc_createTtoBox(HANDLE_TTO_BOX *hTtoBox);
-
-FDK_SACENC_ERROR fdk_sacenc_initTtoBox(HANDLE_TTO_BOX hTtoBox,
-                                       const TTO_BOX_CONFIG *const ttoBoxConfig,
-                                       UCHAR *pParameterBand2HybridBandOffset);
-
-FDK_SACENC_ERROR fdk_sacenc_destroyTtoBox(HANDLE_TTO_BOX *hTtoBox);
-
-FDK_SACENC_ERROR fdk_sacenc_applyTtoBox(
-    HANDLE_TTO_BOX hTtoBox, const INT nTimeSlots, const INT startTimeSlot,
-    const INT nHybridBands, const FIXP_DPK *const *const ppHybridData1__FDK,
-    const FIXP_DPK *const *const ppHybridData2__FDK, SCHAR *const pIccIdx,
-    UCHAR *const pbIccQuantCoarse, SCHAR *const pCldIdx,
-    UCHAR *const pbCldQuantCoarse, const INT bUseBBCues, INT *scaleCh0,
-    INT *scaleCh1);
-
-INT fdk_sacenc_subband2ParamBand(const BOX_SUBBAND_CONFIG boxSubbandConfig,
-                                 const INT nSubband);
-
-const INT *fdk_sacenc_getSubbandImagSign();
-
-void fdk_sacenc_calcParameterBand2HybridBandOffset(
-    const BOX_SUBBAND_CONFIG subbandConfig, const INT nHybridBands,
-    UCHAR *pParameterBand2HybridBandOffset);
-
-/* Function / Class Definition ***********************************************/
-static inline UCHAR fdk_sacenc_getCldQuantOffset(const INT bUseCoarseQuant) {
-  return ((bUseCoarseQuant) ? OFFSET_CLD_QUANT_COARSE : OFFSET_CLD_QUANT_FINE);
-}
-static inline UCHAR fdk_sacenc_getIccQuantOffset(const INT bUseCoarseQuant) {
-  return ((bUseCoarseQuant) ? OFFSET_ICC_QUANT_COARSE : OFFSET_ICC_QUANT_FINE);
-}
-
-static inline UCHAR fdk_sacenc_getNumberCldQuantLevels(
-    const INT bUseCoarseQuant) {
-  return ((bUseCoarseQuant) ? MAX_CLD_QUANT_COARSE : MAX_CLD_QUANT_FINE);
-}
-static inline UCHAR fdk_sacenc_getNumberIccQuantLevels(
-    const INT bUseCoarseQuant) {
-  return ((bUseCoarseQuant) ? MAX_ICC_QUANT_COARSE : MAX_ICC_QUANT_FINE);
-}
-
-#endif /* SACENC_PARAMEXTRACT_H */
--- a/libSACenc/src/sacenc_staticgain.cpp
+++ /dev/null
@@ -1,446 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround encoder library *************************
-
-   Author(s):   Christian Goettlinger
-
-   Description: Encoder Library Interface
-                gain management of the encoder
-
-*******************************************************************************/
-
-/*****************************************************************************
-\file
-This file contains all static gain infrastructure
-******************************************************************************/
-
-/* Includes ******************************************************************/
-#include "sacenc_staticgain.h"
-
-/* Defines *******************************************************************/
-#define MP4SPACEENC_DMX_GAIN_DEFAULT SACENC_DMXGAIN_3_dB
-#define GAINCF_SF (4)
-#define GAINCT1(x) FL2FXCONST_DBL(x)
-#define GAINCF(x) FL2FXCONST_DBL(x)
-
-#define GAINCT2(x) FL2FXCONST_DBL(x)
-#define FX_DBL2FX_GAIN(x) (x)
-
-/* Data Types ****************************************************************/
-struct STATIC_GAIN {
-  /* External Config Values */
-  MP4SPACEENC_MODE encMode;
-  MP4SPACEENC_DMX_GAIN fixedGainDMX;
-  INT preGainFactorDb;
-
-  /* Internal Values */
-  FIXP_GAIN PostGain__FDK;
-  FIXP_GAIN pPreGain__FDK[SACENC_MAX_INPUT_CHANNELS];
-};
-
-/* Constants *****************************************************************/
-/*
-   preGainFactorTable:
-
-   pre calculation: (float)pow(10.f,(((float) x)/20.f))/(float)(1<<GAINCF_SF), x
-   = -20 ... +20
-*/
-static const FIXP_DBL preGainFactorTable__FDK[41] = {
-    GAINCF(6.2500000931e-003), GAINCF(7.0126154460e-003),
-    GAINCF(7.8682834283e-003), GAINCF(8.8283596560e-003),
-    GAINCF(9.9055822939e-003), GAINCF(1.1114246212e-002),
-    GAINCF(1.2470389716e-002), GAINCF(1.3992006890e-002),
-    GAINCF(1.5699289739e-002), GAINCF(1.7614893615e-002),
-    GAINCF(1.9764235243e-002), GAINCF(2.2175837308e-002),
-    GAINCF(2.4881698191e-002), GAINCF(2.7917724103e-002),
-    GAINCF(3.1324200332e-002), GAINCF(3.5146333277e-002),
-    GAINCF(3.9434835315e-002), GAINCF(4.4246610254e-002),
-    GAINCF(4.9645513296e-002), GAINCF(5.5703181773e-002),
-    GAINCF(6.2500000000e-002), GAINCF(7.0126153529e-002),
-    GAINCF(7.8682839870e-002), GAINCF(8.8283598423e-002),
-    GAINCF(9.9055826664e-002), GAINCF(1.1114246398e-001),
-    GAINCF(1.2470389158e-001), GAINCF(1.3992007077e-001),
-    GAINCF(1.5699289739e-001), GAINCF(1.7614893615e-001),
-    GAINCF(1.9764235616e-001), GAINCF(2.2175836563e-001),
-    GAINCF(2.4881698191e-001), GAINCF(2.7917724848e-001),
-    GAINCF(3.1324201822e-001), GAINCF(3.5146331787e-001),
-    GAINCF(3.9434835315e-001), GAINCF(4.4246610999e-001),
-    GAINCF(4.9645513296e-001), GAINCF(5.5703181028e-001),
-    GAINCF(6.2500000000e-001)};
-
-static const FIXP_GAIN dmxGainTable__FDK[] = {
-    /* GAINCT2(1.0), */ GAINCT2(0.84089650f),
-    GAINCT2(0.70710706f),
-    GAINCT2(0.59460385f),
-    GAINCT2(0.50000000f),
-    GAINCT2(0.42044825f),
-    GAINCT2(0.35355341f),
-    GAINCT2(0.25000000f)};
-
-/* Function / Class Declarations *********************************************/
-
-/* Function / Class Definition ***********************************************/
-
-/*-----------------------------------------------------------------------------
-functionname: fdk_sacenc_staticGain_OpenConfig()
-description:  opens and sets ConfigStruct to Default Values
-returns:      noError on success, an apropriate error code else
------------------------------------------------------------------------------*/
-FDK_SACENC_ERROR fdk_sacenc_staticGain_OpenConfig(
-    HANDLE_STATIC_GAIN_CONFIG *phStaticGainConfig) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if (NULL == phStaticGainConfig) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    /* Allocate Instance */
-    FDK_ALLOCATE_MEMORY_1D(*phStaticGainConfig, 1, struct STATIC_GAIN_CONFIG);
-  }
-  return error;
-
-bail:
-  fdk_sacenc_staticGain_CloseConfig(phStaticGainConfig);
-  return ((SACENC_OK == error) ? SACENC_MEMORY_ERROR : error);
-}
-
-FDK_SACENC_ERROR fdk_sacenc_staticGain_InitDefaultConfig(
-    HANDLE_STATIC_GAIN_CONFIG hStaticGainConfig) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if (NULL == hStaticGainConfig) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    /* Necessary Input Variables */
-    hStaticGainConfig->encMode = SACENC_INVALID_MODE;
-
-    /* Optional Configs Set to Default Values */
-    hStaticGainConfig->fixedGainDMX = MP4SPACEENC_DMX_GAIN_DEFAULT;
-    hStaticGainConfig->preGainFactorDb = 0;
-  }
-  return error;
-}
-
-/*-----------------------------------------------------------------------------
-functionname: fdk_sacenc_staticGain_CloseConfig()
-description:  destructs Static Gain Config Structure
-returns:      noError on success, an apropriate error code else
------------------------------------------------------------------------------*/
-FDK_SACENC_ERROR fdk_sacenc_staticGain_CloseConfig(
-    HANDLE_STATIC_GAIN_CONFIG *phStaticGainConfig) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if ((phStaticGainConfig == NULL) || (*phStaticGainConfig == NULL)) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    FDKfree(*phStaticGainConfig);
-    *phStaticGainConfig = NULL;
-  }
-  return error;
-}
-
-/*-----------------------------------------------------------------------------
-functionname: fdk_sacenc_staticGain_Open()
-description:  initializes Static Gains
-returns:      noError on success, an apropriate error code else
------------------------------------------------------------------------------*/
-FDK_SACENC_ERROR fdk_sacenc_staticGain_Open(HANDLE_STATIC_GAIN *phStaticGain) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if (NULL == phStaticGain) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    /* Allocate Instance */
-    FDK_ALLOCATE_MEMORY_1D(*phStaticGain, 1, struct STATIC_GAIN);
-  }
-  return error;
-
-bail:
-  return ((SACENC_OK == error) ? SACENC_MEMORY_ERROR : error);
-}
-
-FDK_SACENC_ERROR fdk_sacenc_staticGain_Init(
-    HANDLE_STATIC_GAIN hStaticGain,
-    const HANDLE_STATIC_GAIN_CONFIG hStaticGainConfig, INT *const scale) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if ((hStaticGain == NULL) || (hStaticGainConfig == NULL)) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    hStaticGain->encMode = hStaticGainConfig->encMode;
-    hStaticGain->fixedGainDMX = hStaticGainConfig->fixedGainDMX;
-    hStaticGain->preGainFactorDb = hStaticGainConfig->preGainFactorDb;
-
-    if ((hStaticGain->preGainFactorDb < -20) ||
-        (hStaticGain->preGainFactorDb > 20)) {
-      error = SACENC_INVALID_CONFIG;
-      goto bail;
-    }
-
-    FIXP_DBL fPreGainFactor__FDK;
-
-    if (hStaticGain->preGainFactorDb == 0) {
-      fPreGainFactor__FDK = (FIXP_DBL)MAXVAL_DBL;
-      *scale = 0;
-    } else {
-      int s;
-      fPreGainFactor__FDK =
-          preGainFactorTable__FDK[hStaticGain->preGainFactorDb + 20];
-      s = fixMax(0, CntLeadingZeros(fPreGainFactor__FDK) - 1);
-      fPreGainFactor__FDK = fPreGainFactor__FDK << (s);
-      *scale = GAINCF_SF - s;
-    }
-
-    if (hStaticGain->fixedGainDMX == 0)
-      hStaticGain->PostGain__FDK = MAXVAL_GAIN;
-    else
-      hStaticGain->PostGain__FDK =
-          dmxGainTable__FDK[hStaticGain->fixedGainDMX - 1];
-
-    FDKmemclear(
-        hStaticGain->pPreGain__FDK,
-        sizeof(hStaticGain->pPreGain__FDK)); /* zero all input channels */
-
-    /* Configure PreGain-Vector */
-    if (hStaticGain->encMode == SACENC_212) {
-      hStaticGain->pPreGain__FDK[0] =
-          FX_DBL2FX_GAIN(fPreGainFactor__FDK); /* L */
-      hStaticGain->pPreGain__FDK[1] =
-          FX_DBL2FX_GAIN(fPreGainFactor__FDK); /* R */
-    } else {
-      error = SACENC_INVALID_CONFIG;
-    }
-
-  } /* valid handle */
-
-bail:
-
-  return error;
-}
-
-/*-----------------------------------------------------------------------------
-functionname: fdk_sacenc_staticGain_Close()
-description:  destructs Static Gains
-returns:      noError on success, an apropriate error code else
------------------------------------------------------------------------------*/
-FDK_SACENC_ERROR fdk_sacenc_staticGain_Close(HANDLE_STATIC_GAIN *phStaticGain) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if ((phStaticGain == NULL) || (*phStaticGain == NULL)) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    FDKfree(*phStaticGain);
-    *phStaticGain = NULL;
-  }
-  return error;
-}
-
-/*-----------------------------------------------------------------------------
-functionname: fdk_sacenc_staticPostGain_Apply
-description:  multiply the Output samples with the PostGain
-returns:      noError on success, an apropriate error code else
------------------------------------------------------------------------------*/
-FDK_SACENC_ERROR fdk_sacenc_staticPostGain_ApplyFDK(
-    const HANDLE_STATIC_GAIN hStaticGain, INT_PCM *const pOutputSamples,
-    const INT nOutputSamples, const INT scale) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if (NULL == hStaticGain) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    int i;
-    FIXP_GAIN postGain = hStaticGain->PostGain__FDK;
-
-    if (scale < 0) {
-      if (postGain == MAXVAL_GAIN) {
-        for (i = 0; i < nOutputSamples; i++) {
-          pOutputSamples[i] = pOutputSamples[i] >> (-scale);
-        }
-      } else {
-        for (i = 0; i < nOutputSamples; i++) {
-          pOutputSamples[i] = FX_DBL2FX_PCM(
-              fMult(postGain, FX_PCM2FX_DBL(pOutputSamples[i])) >> (-scale));
-        }
-      }
-    } else {
-      if (postGain == MAXVAL_GAIN) {
-        for (i = 0; i < nOutputSamples; i++) {
-          pOutputSamples[i] = FX_DBL2FX_PCM(SATURATE_LEFT_SHIFT(
-              FX_PCM2FX_DBL(pOutputSamples[i]), scale, DFRACT_BITS));
-        }
-      } else {
-        for (i = 0; i < nOutputSamples; i++) {
-          pOutputSamples[i] = FX_DBL2FX_PCM(SATURATE_LEFT_SHIFT(
-              fMult(postGain, FX_PCM2FX_DBL(pOutputSamples[i])), scale,
-              DFRACT_BITS));
-        }
-      }
-    }
-  }
-  return error;
-}
-
-/*-----------------------------------------------------------------------------
-functionname: fdk_sacenc_getPreGainPtr()/ fdk_sacenc_getPostGain()
-description:  get Gain-Pointers from struct
-returns:      Pointer to PreGain or postGain
------------------------------------------------------------------------------*/
-FIXP_GAIN *fdk_sacenc_getPreGainPtrFDK(HANDLE_STATIC_GAIN hStaticGain) {
-  return ((hStaticGain == NULL) ? NULL : hStaticGain->pPreGain__FDK);
-}
-
-FIXP_GAIN fdk_sacenc_getPostGainFDK(HANDLE_STATIC_GAIN hStaticGain) {
-  return (hStaticGain->PostGain__FDK);
-}
-
-/* get fixed downmix gain and map it to bitstream enum */
-FIXEDGAINDMXCONFIG fdk_sacenc_staticGain_GetDmxGain(
-    const HANDLE_STATIC_GAIN hStaticGain) {
-  FIXEDGAINDMXCONFIG dmxGain = FIXEDGAINDMX_INVALID;
-
-  switch (hStaticGain->fixedGainDMX) {
-    case 0:
-      dmxGain = FIXEDGAINDMX_0;
-      break;
-    case 1:
-      dmxGain = FIXEDGAINDMX_1;
-      break;
-    case 2:
-      dmxGain = FIXEDGAINDMX_2;
-      break;
-    case 3:
-      dmxGain = FIXEDGAINDMX_3;
-      break;
-    case 4:
-      dmxGain = FIXEDGAINDMX_4;
-      break;
-    case 5:
-      dmxGain = FIXEDGAINDMX_5;
-      break;
-    case 6:
-      dmxGain = FIXEDGAINDMX_6;
-      break;
-    case 7:
-      dmxGain = FIXEDGAINDMX_7;
-      break;
-    default:
-      dmxGain = FIXEDGAINDMX_INVALID;
-  }
-  return dmxGain;
-}
-
-FDK_SACENC_ERROR fdk_sacenc_staticGain_SetDmxGain(
-    HANDLE_STATIC_GAIN_CONFIG hStaticGainCfg,
-    const MP4SPACEENC_DMX_GAIN dmxGain) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if (NULL == hStaticGainCfg) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    hStaticGainCfg->fixedGainDMX = dmxGain;
-  }
-  return error;
-}
-
-FDK_SACENC_ERROR fdk_sacenc_staticGain_SetEncMode(
-    HANDLE_STATIC_GAIN_CONFIG hStaticGainCfg, const MP4SPACEENC_MODE encMode) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if (NULL == hStaticGainCfg) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    hStaticGainCfg->encMode = encMode;
-  }
-  return error;
-}
--- a/libSACenc/src/sacenc_staticgain.h
+++ /dev/null
@@ -1,177 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround encoder library *************************
-
-   Author(s):   Christian Goettlinger
-
-   Description: Encoder Library Interfac
-                gain management of the encoder
-
-*******************************************************************************/
-
-/**************************************************************************/ /**
-   \file
- ******************************************************************************/
-
-#ifndef SACENC_STATICGAIN_H
-#define SACENC_STATICGAIN_H
-
-/* Includes ******************************************************************/
-#include "common_fix.h"
-#include "sacenc_lib.h"
-#include "sacenc_const.h"
-#include "sacenc_bitstream.h"
-
-/* Defines *******************************************************************/
-#define FIXP_GAIN FIXP_DBL
-#define MAXVAL_GAIN ((FIXP_DBL)MAXVAL_DBL)
-
-/* Data Types ****************************************************************/
-struct STATIC_GAIN_CONFIG {
-  MP4SPACEENC_MODE encMode;
-  MP4SPACEENC_DMX_GAIN fixedGainDMX;
-  INT preGainFactorDb;
-};
-
-typedef struct STATIC_GAIN_CONFIG *HANDLE_STATIC_GAIN_CONFIG;
-typedef struct STATIC_GAIN *HANDLE_STATIC_GAIN;
-
-/* Constants *****************************************************************/
-
-/* Function / Class Declarations *********************************************/
-
-/* Initializes Static Gain Computation Config */
-FDK_SACENC_ERROR fdk_sacenc_staticGain_OpenConfig(
-    HANDLE_STATIC_GAIN_CONFIG *phStaticGainConfig);
-
-FDK_SACENC_ERROR fdk_sacenc_staticGain_InitDefaultConfig(
-    HANDLE_STATIC_GAIN_CONFIG hStaticGainConfig);
-
-/* Deletes Static Gain Computation Config ~Destructor */
-FDK_SACENC_ERROR fdk_sacenc_staticGain_CloseConfig(
-    HANDLE_STATIC_GAIN_CONFIG *phStaticGainConfig);
-
-/* Initializes Static Gain Computation ~Constructor */
-FDK_SACENC_ERROR fdk_sacenc_staticGain_Open(HANDLE_STATIC_GAIN *phStaticGain);
-
-FDK_SACENC_ERROR fdk_sacenc_staticGain_Init(
-    HANDLE_STATIC_GAIN hStaticGain,
-    const HANDLE_STATIC_GAIN_CONFIG hStaticGainConfig, INT *const scale);
-
-/* Deletes Static Gain Computation Infrastucture ~Destructor */
-FDK_SACENC_ERROR fdk_sacenc_staticGain_Close(HANDLE_STATIC_GAIN *phStaticGain);
-
-/* Apply PostGain to the output PCM Downmix-Signal */
-FDK_SACENC_ERROR fdk_sacenc_staticPostGain_ApplyFDK(
-    const HANDLE_STATIC_GAIN hStaticGain, INT_PCM *const pOutputSamples,
-    const INT nOutputSamples, const INT scale);
-
-/* Get Pointer to PreGain-vector */
-FIXP_GAIN *fdk_sacenc_getPreGainPtrFDK(HANDLE_STATIC_GAIN hStaticGain);
-
-/* Get Pointer to PostGain-coef */
-FIXP_GAIN fdk_sacenc_getPostGainFDK(HANDLE_STATIC_GAIN hStaticGain);
-
-FIXEDGAINDMXCONFIG fdk_sacenc_staticGain_GetDmxGain(
-    const HANDLE_STATIC_GAIN hStaticGain);
-
-FDK_SACENC_ERROR fdk_sacenc_staticGain_SetDmxGain(
-    HANDLE_STATIC_GAIN_CONFIG hStaticGainCfg,
-    const MP4SPACEENC_DMX_GAIN dmxGain);
-
-FDK_SACENC_ERROR fdk_sacenc_staticGain_SetEncMode(
-    HANDLE_STATIC_GAIN_CONFIG hStaticGainCfg, const MP4SPACEENC_MODE encMode);
-
-#endif /* SACENC_STATICGAIN_H */
--- a/libSACenc/src/sacenc_tree.cpp
+++ /dev/null
@@ -1,488 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround encoder library *************************
-
-   Author(s):   Max Neuendorf
-
-   Description: Encoder Library Interface
-                Tree Structure for Space Encoder
-
-*******************************************************************************/
-
-/* Includes ******************************************************************/
-#include "sacenc_tree.h"
-#include "genericStds.h"
-#include "sacenc_const.h"
-#include "sacenc_paramextract.h"
-#include "sacenc_framewindowing.h"
-#include "FDK_matrixCalloc.h"
-
-/* Defines *******************************************************************/
-enum { BOX_0 = 0, BOX_1 = 1 };
-
-enum { CH_L = 0, CH_R = 1 };
-
-enum { TTO_CH_0 = 0, TTO_CH_1 = 1 };
-
-enum { WIN_INACTIV = 0, WIN_ACTIV = 1 };
-
-enum { MAX_KEEP_FRAMECOUNT = 100 };
-
-/* Data Types ****************************************************************/
-struct SPACE_TREE {
-  SPACETREE_MODE mode;
-  SPACE_TREE_DESCRIPTION descr;
-  HANDLE_TTO_BOX ttoBox[SACENC_MAX_NUM_BOXES];
-  UCHAR nParamBands;
-  UCHAR bUseCoarseQuantTtoIcc;
-  UCHAR bUseCoarseQuantTtoCld;
-  QUANTMODE quantMode;
-  INT frameCount;
-  UCHAR bFrameKeep;
-
-  /* Intermediate buffers */
-  UCHAR pCld_prev[SACENC_MAX_NUM_BOXES][MAX_NUM_PARAM_BANDS];
-  UCHAR pIcc_prev[SACENC_MAX_NUM_BOXES][MAX_NUM_PARAM_BANDS];
-
-  UCHAR nChannelsInMax;
-  UCHAR nHybridBandsMax;
-};
-
-typedef struct {
-  UCHAR boxId;
-  UCHAR inCh1;
-  UCHAR inCh2;
-  UCHAR inCh3;
-  UCHAR inCh4;
-  UCHAR wCh1;
-  UCHAR wCh2;
-
-} TTO_DESCRIPTOR;
-
-typedef struct {
-  SPACETREE_MODE mode;
-  SPACE_TREE_DESCRIPTION treeDescription;
-
-} TREE_CONFIG;
-
-typedef struct {
-  SPACETREE_MODE mode;
-  UCHAR nChannelsIn;
-  UCHAR nChannelsOut;
-  UCHAR nTtoBoxes;
-  TTO_DESCRIPTOR tto_descriptor[1];
-
-} TREE_SETUP;
-
-/* Constants *****************************************************************/
-static const TREE_CONFIG treeConfigTable[] = {
-    {SPACETREE_INVALID_MODE, {0, 0, 0}}, {SPACETREE_212, {1, 1, 2}}};
-
-static const TREE_SETUP treeSetupTable[] = {
-    {SPACETREE_INVALID_MODE, 0, 0, 0, {{0, 0, 0, 0, 0, 0, 0}}},
-    {SPACETREE_212,
-     2,
-     1,
-     1,
-     {{BOX_0, CH_L, CH_R, TTO_CH_0, TTO_CH_1, WIN_ACTIV, WIN_ACTIV}}}};
-
-/* Function / Class Declarations *********************************************/
-
-/* Function / Class Definition ***********************************************/
-static FDK_SACENC_ERROR getTreeConfig(
-    const SPACETREE_MODE mode, SPACE_TREE_DESCRIPTION *pTreeDescription) {
-  FDK_SACENC_ERROR error = SACENC_INIT_ERROR;
-
-  if (pTreeDescription == NULL) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    int i;
-    for (i = 0; i < (int)(sizeof(treeConfigTable) / sizeof(TREE_CONFIG)); i++) {
-      if (treeConfigTable[i].mode == mode) {
-        *pTreeDescription = treeConfigTable[i].treeDescription;
-        error = SACENC_OK;
-        break;
-      }
-    }
-  } /* valid handle */
-  return error;
-}
-
-static const TREE_SETUP *getTreeSetup(const SPACETREE_MODE mode) {
-  int i;
-  const TREE_SETUP *setup = NULL;
-
-  for (i = 0; i < (int)(sizeof(treeSetupTable) / sizeof(TREE_SETUP)); i++) {
-    if (treeSetupTable[i].mode == mode) {
-      setup = &treeSetupTable[i];
-      break;
-    }
-  }
-  return setup;
-}
-
-FDK_SACENC_ERROR fdk_sacenc_spaceTree_Open(HANDLE_SPACE_TREE *phSpaceTree) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-  HANDLE_SPACE_TREE hSpaceTree = NULL;
-
-  if (NULL == phSpaceTree) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    int box;
-
-    FDK_ALLOCATE_MEMORY_1D(hSpaceTree, 1, struct SPACE_TREE);
-
-    for (box = 0; box < SACENC_MAX_NUM_BOXES; box++) {
-      HANDLE_TTO_BOX ttoBox = NULL;
-      if (SACENC_OK != (error = fdk_sacenc_createTtoBox(&ttoBox))) {
-        goto bail;
-      }
-      if (NULL != hSpaceTree) {
-        hSpaceTree->ttoBox[box] = ttoBox;
-      }
-    }
-    *phSpaceTree = hSpaceTree;
-  }
-  return error;
-
-bail:
-  fdk_sacenc_spaceTree_Close(&hSpaceTree);
-  return ((SACENC_OK == error) ? SACENC_MEMORY_ERROR : error);
-}
-
-FDK_SACENC_ERROR fdk_sacenc_spaceTree_Init(
-    HANDLE_SPACE_TREE hST, const SPACE_TREE_SETUP *const hSetup,
-    UCHAR *pParameterBand2HybridBandOffset, const INT bFrameKeep) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if ((hST == NULL) || (hSetup == NULL)) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    int bTtoBoxFrontBackCombin[SACENC_MAX_NUM_BOXES] = {0};
-    int box = 0;
-
-    hST->frameCount = 0;
-    hST->bFrameKeep = bFrameKeep;
-
-    /* Init */
-    hST->mode = hSetup->mode;
-    hST->nParamBands = hSetup->nParamBands;
-    hST->bUseCoarseQuantTtoIcc = hSetup->bUseCoarseQuantTtoIcc;
-    hST->bUseCoarseQuantTtoCld = hSetup->bUseCoarseQuantTtoCld;
-    hST->quantMode = hSetup->quantMode;
-    hST->nChannelsInMax = hSetup->nChannelsInMax;
-    hST->nHybridBandsMax = hSetup->nHybridBandsMax;
-
-    if (SACENC_OK != (error = getTreeConfig(hST->mode, &hST->descr))) {
-      goto bail;
-    }
-
-    switch (hST->mode) {
-      case SPACETREE_212:
-        bTtoBoxFrontBackCombin[BOX_0] = 0;
-        break;
-      case SPACETREE_INVALID_MODE:
-      default:
-        error = SACENC_INIT_ERROR;
-        goto bail;
-    } /* switch (hST->mode) */
-
-    if (hST->descr.nOttBoxes > SACENC_MAX_NUM_BOXES) {
-      error = SACENC_INIT_ERROR;
-      goto bail;
-    }
-
-    for (box = 0; box < hST->descr.nOttBoxes; box++) {
-      TTO_BOX_CONFIG boxConfig;
-      boxConfig.subbandConfig = (BOX_SUBBAND_CONFIG)hST->nParamBands;
-      boxConfig.bUseCoarseQuantCld = hST->bUseCoarseQuantTtoCld;
-      boxConfig.bUseCoarseQuantIcc = hST->bUseCoarseQuantTtoIcc;
-      boxConfig.bUseCoherenceIccOnly = bTtoBoxFrontBackCombin[box];
-      boxConfig.boxQuantMode = (BOX_QUANTMODE)hST->quantMode;
-      boxConfig.nHybridBandsMax = hST->nHybridBandsMax;
-      boxConfig.bFrameKeep = hST->bFrameKeep;
-
-      if (SACENC_OK !=
-          (error = fdk_sacenc_initTtoBox(hST->ttoBox[box], &boxConfig,
-                                         pParameterBand2HybridBandOffset))) {
-        goto bail;
-      }
-    } /* for box */
-
-  } /* valid handle */
-
-bail:
-  return error;
-}
-
-static void SpaceTree_FrameKeep212(const HANDLE_SPACE_TREE hST,
-                                   SPATIALFRAME *const hSTOut,
-                                   const INT avoid_keep) {
-  int pb;
-
-  if (avoid_keep == 0) {
-    if (hST->frameCount % 2 == 0) {
-      for (pb = 0; pb < hST->nParamBands; pb++) {
-        hST->pIcc_prev[BOX_0][pb] = hSTOut->ottData.icc[BOX_0][0][pb];
-        hSTOut->ottData.cld[BOX_0][0][pb] = hST->pCld_prev[BOX_0][pb];
-      }
-    } else {
-      for (pb = 0; pb < hST->nParamBands; pb++) {
-        hSTOut->ottData.icc[BOX_0][0][pb] = hST->pIcc_prev[BOX_0][pb];
-        hST->pCld_prev[BOX_0][pb] = hSTOut->ottData.cld[BOX_0][0][pb];
-      }
-    }
-  } else {
-    for (pb = 0; pb < hST->nParamBands; pb++) {
-      hST->pIcc_prev[BOX_0][pb] = hSTOut->ottData.icc[BOX_0][0][pb];
-      hST->pCld_prev[BOX_0][pb] = hSTOut->ottData.cld[BOX_0][0][pb];
-    }
-  }
-  hST->frameCount++;
-  if (hST->frameCount == MAX_KEEP_FRAMECOUNT) {
-    hST->frameCount = 0;
-  }
-}
-
-static FDK_SACENC_ERROR SpaceTree_FrameKeep(const HANDLE_SPACE_TREE hST,
-                                            SPATIALFRAME *const hSTOut,
-                                            const INT avoid_keep) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  switch (hST->mode) {
-    case SPACETREE_212:
-      SpaceTree_FrameKeep212(hST, hSTOut, avoid_keep);
-      break;
-    case SPACETREE_INVALID_MODE:
-    default:
-      error = SACENC_INVALID_CONFIG;
-      break;
-  }
-  return error;
-}
-
-FDK_SACENC_ERROR fdk_sacenc_spaceTree_Apply(
-    HANDLE_SPACE_TREE hST, const INT paramSet, const INT nChannelsIn,
-    const INT nTimeSlots, const INT startTimeSlot, const INT nHybridBands,
-    FIXP_WIN *pFrameWindowAna__FDK,
-    FIXP_DPK *const *const *const pppHybrid__FDK,
-    FIXP_DPK *const *const *const pppHybridIn__FDK, SPATIALFRAME *const hSTOut,
-    const INT avoid_keep, INT *pEncoderInputChScale) {
-  /** \verbatim
-   =============================================================================================================================
-      TREE_212
-   =============================================================================================================================
-                         _______
-        L -- TTO_CH_0 --|       |
-                        | TTO_0 |-- TTO_CH_0
-        R -- TTO_CH_1 --|_______|
-
-  \endverbatim */
-
-  FDK_SACENC_ERROR error = SACENC_OK;
-  int k;
-  const TREE_SETUP *treeSetup = NULL;
-
-  if ((hST == NULL) || (hSTOut == NULL) || (pppHybrid__FDK == NULL) ||
-      (pppHybridIn__FDK == NULL)) {
-    error = SACENC_INVALID_HANDLE;
-    goto bail;
-  }
-
-  if ((treeSetup = getTreeSetup(hST->mode)) == NULL) {
-    error = SACENC_INVALID_CONFIG;
-    goto bail;
-  }
-
-  /* Sanity Checks */
-  if ((nChannelsIn != treeSetup->nChannelsIn) ||
-      (nChannelsIn > hST->nChannelsInMax) ||
-      (nHybridBands > hST->nHybridBandsMax)) {
-    error = SACENC_INVALID_CONFIG;
-    goto bail;
-  }
-
-  /* Apply all TTO boxes. */
-  for (k = 0; k < treeSetup->nTtoBoxes; k++) {
-    const TTO_DESCRIPTOR *pTTO = &treeSetup->tto_descriptor[k];
-
-    int i, inCh[2], outCh[2], win[2];
-
-    inCh[0] = pTTO->inCh1;
-    outCh[0] = pTTO->inCh3;
-    win[0] = pTTO->wCh1;
-    inCh[1] = pTTO->inCh2;
-    outCh[1] = pTTO->inCh4;
-    win[1] = pTTO->wCh2;
-
-    for (i = 0; i < 2; i++) {
-      if (win[i] == WIN_ACTIV) {
-        fdk_sacenc_analysisWindowing(
-            nTimeSlots, startTimeSlot, pFrameWindowAna__FDK,
-            pppHybrid__FDK[inCh[i]], pppHybridIn__FDK[outCh[i]], nHybridBands,
-            FW_LEAVE_DIM);
-      }
-    }
-
-    /* Calculate output downmix within last TTO box, if no TTT box is applied.
-     */
-    if (SACENC_OK !=
-        (error = fdk_sacenc_applyTtoBox(
-             hST->ttoBox[pTTO->boxId], nTimeSlots, startTimeSlot, nHybridBands,
-             pppHybridIn__FDK[pTTO->inCh3], pppHybridIn__FDK[pTTO->inCh4],
-             hSTOut->ottData.icc[pTTO->boxId][paramSet],
-             &(hSTOut->ICCLosslessData.bsQuantCoarseXXX[pTTO->boxId][paramSet]),
-             hSTOut->ottData.cld[pTTO->boxId][paramSet],
-             &(hSTOut->CLDLosslessData.bsQuantCoarseXXX[pTTO->boxId][paramSet]),
-             hSTOut->bUseBBCues, &pEncoderInputChScale[inCh[0]],
-             &pEncoderInputChScale[inCh[1]]))) {
-      goto bail;
-    }
-  }
-
-  if (hST->bFrameKeep == 1) {
-    if (SACENC_OK != (error = SpaceTree_FrameKeep(hST, hSTOut, avoid_keep))) {
-      goto bail;
-    }
-  }
-
-bail:
-  return error;
-}
-
-FDK_SACENC_ERROR fdk_sacenc_spaceTree_Close(HANDLE_SPACE_TREE *phSpaceTree) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if ((phSpaceTree == NULL) || (*phSpaceTree == NULL)) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    int box;
-    HANDLE_SPACE_TREE const hST = *phSpaceTree;
-
-    /* for (box = 0; box < hST->descr.nOttBoxes; ++box) { */
-    for (box = 0; box < SACENC_MAX_NUM_BOXES; ++box) {
-      if (SACENC_OK != (error = fdk_sacenc_destroyTtoBox(&hST->ttoBox[box]))) {
-        goto bail;
-      }
-    }
-
-    FDKfree(*phSpaceTree);
-    *phSpaceTree = NULL;
-  }
-bail:
-  return error;
-}
-
-FDK_SACENC_ERROR fdk_sacenc_spaceTree_GetDescription(
-    const HANDLE_SPACE_TREE hSpaceTree,
-    SPACE_TREE_DESCRIPTION *pSpaceTreeDescription) {
-  FDK_SACENC_ERROR error = SACENC_OK;
-
-  if ((hSpaceTree == NULL) || (pSpaceTreeDescription == NULL)) {
-    error = SACENC_INVALID_HANDLE;
-  } else {
-    *pSpaceTreeDescription = hSpaceTree->descr;
-  }
-  return error;
-}
-
-INT fdk_sacenc_spaceTree_Hybrid2ParamBand(const INT nParamBands,
-                                          const INT nHybridBand) {
-  return fdk_sacenc_subband2ParamBand((BOX_SUBBAND_CONFIG)nParamBands,
-                                      nHybridBand);
-}
-
-/*****************************************************************************
-******************************************************************************/
--- a/libSACenc/src/sacenc_tree.h
+++ /dev/null
@@ -1,168 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround encoder library *************************
-
-   Author(s):   Max Neuendorf
-
-   Description: Encoder Library Interface
-                Tree Structure for Space Encoder
-
-*******************************************************************************/
-
-#ifndef SACENC_TREE_H
-#define SACENC_TREE_H
-
-/* Includes ******************************************************************/
-#include "sacenc_framewindowing.h"
-#include "sacenc_lib.h"
-#include "sacenc_bitstream.h"
-
-/* Defines *******************************************************************/
-
-/* Data Types ****************************************************************/
-typedef enum {
-  SPACETREE_INVALID_MODE = 0,
-  SPACETREE_212 = 8
-
-} SPACETREE_MODE;
-
-typedef struct SPACE_TREE *HANDLE_SPACE_TREE;
-
-typedef struct {
-  UCHAR nParamBands;
-  UCHAR bUseCoarseQuantTtoCld;
-  UCHAR bUseCoarseQuantTtoIcc;
-  QUANTMODE quantMode;
-  SPACETREE_MODE mode;
-
-  UCHAR nChannelsInMax;
-  UCHAR nHybridBandsMax;
-
-} SPACE_TREE_SETUP;
-
-typedef struct {
-  UCHAR nOttBoxes;
-  UCHAR nInChannels;
-  UCHAR nOutChannels;
-
-} SPACE_TREE_DESCRIPTION;
-
-/* Constants *****************************************************************/
-
-/* Function / Class Declarations *********************************************/
-FDK_SACENC_ERROR fdk_sacenc_spaceTree_Open(HANDLE_SPACE_TREE *phSpaceTree);
-
-FDK_SACENC_ERROR fdk_sacenc_spaceTree_Init(
-    HANDLE_SPACE_TREE hST, const SPACE_TREE_SETUP *const hSetup,
-    UCHAR *pParameterBand2HybridBandOffset, const INT bFrameKeep);
-
-FDK_SACENC_ERROR fdk_sacenc_spaceTree_Apply(
-    HANDLE_SPACE_TREE hST, const INT paramSet, const INT nChannelsIn,
-    const INT nTimeSlots, const INT startTimeSlot, const INT nHybridBands,
-    FIXP_WIN *pFrameWindowAna__FDK,
-    FIXP_DPK *const *const *const pppHybrid__FDK,
-    FIXP_DPK *const *const *const pppHybridIn__FDK, SPATIALFRAME *const hSTOut,
-    const INT avoid_keep, INT *pEncoderInputChScale);
-
-FDK_SACENC_ERROR fdk_sacenc_spaceTree_Close(HANDLE_SPACE_TREE *phSpaceTree);
-
-FDK_SACENC_ERROR fdk_sacenc_spaceTree_GetDescription(
-    const HANDLE_SPACE_TREE hSpaceTree,
-    SPACE_TREE_DESCRIPTION *pSpaceTreeDescription);
-
-INT fdk_sacenc_spaceTree_Hybrid2ParamBand(const INT nParamBands,
-                                          const INT nHybridBand);
-
-#endif /* SACENC_TREE_H */
--- a/libSACenc/src/sacenc_vectorfunctions.cpp
+++ /dev/null
@@ -1,450 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround encoder library *************************
-
-   Author(s):   Josef Hoepfl
-
-   Description: Encoder Library Interface
-                vector functions
-
-*******************************************************************************/
-
-/*****************************************************************************
-\file
-This file contains vector functions
-******************************************************************************/
-
-/* Includes ******************************************************************/
-#include "sacenc_vectorfunctions.h"
-
-/* Defines *******************************************************************/
-
-/* Data Types ****************************************************************/
-
-/* Constants *****************************************************************/
-
-/* Function / Class Declarations *********************************************/
-
-/* Function / Class Definition ***********************************************/
-
-FIXP_DBL sumUpCplxPow2(const FIXP_DPK *const x, const INT scaleMode,
-                       const INT inScaleFactor, INT *const outScaleFactor,
-                       const INT n) {
-  int i, cs;
-
-  if (scaleMode == SUM_UP_DYNAMIC_SCALE) {
-    /* calculate headroom */
-    FIXP_DBL maxVal = FL2FXCONST_DBL(0.0f);
-    for (i = 0; i < n; i++) {
-      maxVal |= fAbs(x[i].v.re);
-      maxVal |= fAbs(x[i].v.im);
-    }
-    cs = inScaleFactor - fixMax(0, CntLeadingZeros(maxVal) - 1);
-  } else {
-    cs = inScaleFactor;
-  }
-
-  /* consider scaling of energy and scaling in fPow2Div2 and addition */
-  *outScaleFactor = 2 * cs + 2;
-
-  /* make sure that the scalefactor is in the range of -(DFRACT_BITS-1), ... ,
-   * (DFRACT_BITS-1) */
-  cs = fixMax(fixMin(cs, DFRACT_BITS - 1), -(DFRACT_BITS - 1));
-
-  /* sum up complex energy samples */
-  FIXP_DBL re, im, sum;
-
-  re = im = sum = FL2FXCONST_DBL(0.0);
-  if (cs < 0) {
-    cs = -cs;
-    for (i = 0; i < n; i++) {
-      re += fPow2Div2(x[i].v.re << cs);
-      im += fPow2Div2(x[i].v.im << cs);
-    }
-  } else {
-    cs = 2 * cs;
-    for (i = 0; i < n; i++) {
-      re += fPow2Div2(x[i].v.re) >> cs;
-      im += fPow2Div2(x[i].v.im) >> cs;
-    }
-  }
-
-  sum = (re >> 1) + (im >> 1);
-
-  return (sum);
-}
-
-FIXP_DBL sumUpCplxPow2Dim2(const FIXP_DPK *const *const x, const INT scaleMode,
-                           const INT inScaleFactor, INT *const outScaleFactor,
-                           const INT sDim1, const INT nDim1, const INT sDim2,
-                           const INT nDim2) {
-  int i, j, cs;
-
-  if (scaleMode == SUM_UP_DYNAMIC_SCALE) {
-    /* calculate headroom */
-    FIXP_DBL maxVal = FL2FXCONST_DBL(0.0f);
-    for (i = sDim1; i < nDim1; i++) {
-      for (j = sDim2; j < nDim2; j++) {
-        maxVal |= fAbs(x[i][j].v.re);
-        maxVal |= fAbs(x[i][j].v.im);
-      }
-    }
-    cs = inScaleFactor - fixMax(0, CntLeadingZeros(maxVal) - 1);
-  } else {
-    cs = inScaleFactor;
-  }
-
-  /* consider scaling of energy and scaling in fPow2Div2 and addition */
-  *outScaleFactor = 2 * cs + 2;
-
-  /* make sure that the scalefactor is in the range of -(DFRACT_BITS-1), ... ,
-   * (DFRACT_BITS-1) */
-  cs = fixMax(fixMin(cs, DFRACT_BITS - 1), -(DFRACT_BITS - 1));
-
-  /* sum up complex energy samples */
-  FIXP_DBL re, im, sum;
-
-  re = im = sum = FL2FXCONST_DBL(0.0);
-  if (cs < 0) {
-    cs = -cs;
-    for (i = sDim1; i < nDim1; i++) {
-      for (j = sDim2; j < nDim2; j++) {
-        re += fPow2Div2(x[i][j].v.re << cs);
-        im += fPow2Div2(x[i][j].v.im << cs);
-      }
-    }
-  } else {
-    cs = 2 * cs;
-    for (i = sDim1; i < nDim1; i++) {
-      for (j = sDim2; j < nDim2; j++) {
-        re += fPow2Div2(x[i][j].v.re) >> cs;
-        im += fPow2Div2(x[i][j].v.im) >> cs;
-      }
-    }
-  }
-
-  sum = (re >> 1) + (im >> 1);
-
-  return (sum);
-}
-
-void copyCplxVec(FIXP_DPK *const Z, const FIXP_DPK *const X, const INT n) {
-  FDKmemmove(Z, X, sizeof(FIXP_DPK) * n);
-}
-
-void setCplxVec(FIXP_DPK *const Z, const FIXP_DBL a, const INT n) {
-  int i;
-
-  for (i = 0; i < n; i++) {
-    Z[i].v.re = a;
-    Z[i].v.im = a;
-  }
-}
-
-void cplx_cplxScalarProduct(FIXP_DPK *const Z, const FIXP_DPK *const *const X,
-                            const FIXP_DPK *const *const Y, const INT scaleX,
-                            const INT scaleY, INT *const scaleZ,
-                            const INT sDim1, const INT nDim1, const INT sDim2,
-                            const INT nDim2) {
-  int i, j, sx, sy;
-  FIXP_DBL xre, yre, xim, yim, re, im;
-
-  /* make sure that the scalefactor is in the range of -(DFRACT_BITS-1), ... ,
-   * (DFRACT_BITS-1) */
-  sx = fixMax(fixMin(scaleX, DFRACT_BITS - 1), -(DFRACT_BITS - 1));
-  sy = fixMax(fixMin(scaleY, DFRACT_BITS - 1), -(DFRACT_BITS - 1));
-
-  /* consider scaling of energy and scaling in fMultDiv2 and shift of result
-   * values */
-  *scaleZ = sx + sy + 2;
-
-  re = (FIXP_DBL)0;
-  im = (FIXP_DBL)0;
-  if ((sx < 0) && (sy < 0)) {
-    sx = -sx;
-    sy = -sy;
-    for (i = sDim1; i < nDim1; i++) {
-      for (j = sDim2; j < nDim2; j++) {
-        xre = X[i][j].v.re << sx;
-        xim = X[i][j].v.im << sx;
-        yre = Y[i][j].v.re << sy;
-        yim = Y[i][j].v.im << sy;
-        re += fMultDiv2(xre, yre) + fMultDiv2(xim, yim);
-        im += fMultDiv2(xim, yre) - fMultDiv2(xre, yim);
-      }
-    }
-  } else if ((sx >= 0) && (sy >= 0)) {
-    for (i = sDim1; i < nDim1; i++) {
-      for (j = sDim2; j < nDim2; j++) {
-        xre = X[i][j].v.re;
-        xim = X[i][j].v.im;
-        yre = Y[i][j].v.re;
-        yim = Y[i][j].v.im;
-        re += (fMultDiv2(xre, yre) + fMultDiv2(xim, yim)) >> (sx + sy);
-        im += (fMultDiv2(xim, yre) - fMultDiv2(xre, yim)) >> (sx + sy);
-      }
-    }
-  } else if ((sx < 0) && (sy >= 0)) {
-    sx = -sx;
-    for (i = sDim1; i < nDim1; i++) {
-      for (j = sDim2; j < nDim2; j++) {
-        xre = X[i][j].v.re << sx;
-        xim = X[i][j].v.im << sx;
-        yre = Y[i][j].v.re;
-        yim = Y[i][j].v.im;
-        re += (fMultDiv2(xre, yre) + fMultDiv2(xim, yim)) >> sy;
-        im += (fMultDiv2(xim, yre) - fMultDiv2(xre, yim)) >> sy;
-      }
-    }
-  } else {
-    sy = -sy;
-    for (i = sDim1; i < nDim1; i++) {
-      for (j = sDim2; j < nDim2; j++) {
-        xre = X[i][j].v.re;
-        xim = X[i][j].v.im;
-        yre = Y[i][j].v.re << sy;
-        yim = Y[i][j].v.im << sy;
-        re += (fMultDiv2(xre, yre) + fMultDiv2(xim, yim)) >> sx;
-        im += (fMultDiv2(xim, yre) - fMultDiv2(xre, yim)) >> sx;
-      }
-    }
-  }
-
-  Z->v.re = re >> 1;
-  Z->v.im = im >> 1;
-}
-
-void FDKcalcCorrelationVec(FIXP_DBL *const z, const FIXP_DBL *const pr12,
-                           const FIXP_DBL *const p1, const FIXP_DBL *const p2,
-                           const INT n) {
-  int i, s;
-  FIXP_DBL p12, cor;
-
-  /* correlation */
-  for (i = 0; i < n; i++) {
-    p12 = fMult(p1[i], p2[i]);
-    if (p12 > FL2FXCONST_DBL(0.0f)) {
-      p12 = invSqrtNorm2(p12, &s);
-      cor = fMult(pr12[i], p12);
-      z[i] = SATURATE_LEFT_SHIFT(cor, s, DFRACT_BITS);
-    } else {
-      z[i] = (FIXP_DBL)MAXVAL_DBL;
-    }
-  }
-}
-
-void calcCoherenceVec(FIXP_DBL *const z, const FIXP_DBL *const p12r,
-                      const FIXP_DBL *const p12i, const FIXP_DBL *const p1,
-                      const FIXP_DBL *const p2, const INT scaleP12,
-                      const INT scaleP, const INT n) {
-  int i, s, s1, s2;
-  FIXP_DBL coh, p12, p12ri;
-
-  for (i = 0; i < n; i++) {
-    s2 = fixMin(fixMax(0, CountLeadingBits(p12r[i]) - 1),
-                fixMax(0, CountLeadingBits(p12i[i]) - 1));
-    p12ri = sqrtFixp(fPow2Div2(p12r[i] << s2) + fPow2Div2(p12i[i] << s2));
-    s1 = fixMin(fixMax(0, CountLeadingBits(p1[i]) - 1),
-                fixMax(0, CountLeadingBits(p2[i]) - 1));
-    p12 = fMultDiv2(p1[i] << s1, p2[i] << s1);
-
-    if (p12 > FL2FXCONST_DBL(0.0f)) {
-      p12 = invSqrtNorm2(p12, &s);
-      coh = fMult(p12ri, p12);
-      s = fixMax(fixMin((scaleP12 - scaleP + s + s1 - s2), DFRACT_BITS - 1),
-                 -(DFRACT_BITS - 1));
-      if (s < 0) {
-        z[i] = coh >> (-s);
-      } else {
-        z[i] = SATURATE_LEFT_SHIFT(coh, s, DFRACT_BITS);
-      }
-    } else {
-      z[i] = (FIXP_DBL)MAXVAL_DBL;
-    }
-  }
-}
-
-void addWeightedCplxVec(FIXP_DPK *const *const Z, const FIXP_DBL *const a,
-                        const FIXP_DPK *const *const X, const FIXP_DBL *const b,
-                        const FIXP_DPK *const *const Y, const INT scale,
-                        INT *const scaleCh1, const INT scaleCh2,
-                        const UCHAR *const pParameterBand2HybridBandOffset,
-                        const INT nParameterBands, const INT nTimeSlots,
-                        const INT startTimeSlot) {
-  int pb, j, i;
-  int cs, s1, s2;
-
-  /* determine maximum scale of both channels */
-  cs = fixMax(*scaleCh1, scaleCh2);
-  s1 = cs - (*scaleCh1);
-  s2 = cs - scaleCh2;
-
-  /* scalefactor 1 is updated with common scale of channel 1 and channel2 */
-  *scaleCh1 = cs;
-
-  /* scale of a and b; additional scale for fMultDiv2() */
-  for (j = 0, pb = 0; pb < nParameterBands; pb++) {
-    FIXP_DBL aPb, bPb;
-    aPb = a[pb], bPb = b[pb];
-    for (; j < pParameterBand2HybridBandOffset[pb]; j++) {
-      for (i = startTimeSlot; i < nTimeSlots; i++) {
-        Z[j][i].v.re = ((fMultDiv2(aPb, X[j][i].v.re) >> s1) +
-                        (fMultDiv2(bPb, Y[j][i].v.re) >> s2))
-                       << (scale + 1);
-        Z[j][i].v.im = ((fMultDiv2(aPb, X[j][i].v.im) >> s1) +
-                        (fMultDiv2(bPb, Y[j][i].v.im) >> s2))
-                       << (scale + 1);
-      }
-    }
-  }
-}
-
-void FDKcalcPbScaleFactor(const FIXP_DPK *const *const x,
-                          const UCHAR *const pParameterBand2HybridBandOffset,
-                          INT *const outScaleFactor, const INT startTimeSlot,
-                          const INT nTimeSlots, const INT nParamBands) {
-  int i, j, pb;
-
-  /* calculate headroom */
-  for (j = 0, pb = 0; pb < nParamBands; pb++) {
-    FIXP_DBL maxVal = FL2FXCONST_DBL(0.0f);
-    for (; j < pParameterBand2HybridBandOffset[pb]; j++) {
-      for (i = startTimeSlot; i < nTimeSlots; i++) {
-        maxVal |= fAbs(x[i][j].v.re);
-        maxVal |= fAbs(x[i][j].v.im);
-      }
-    }
-    outScaleFactor[pb] = -fixMax(0, CntLeadingZeros(maxVal) - 1);
-  }
-}
-
-INT FDKcalcScaleFactor(const FIXP_DBL *const x, const FIXP_DBL *const y,
-                       const INT n) {
-  int i;
-
-  /* calculate headroom */
-  FIXP_DBL maxVal = FL2FXCONST_DBL(0.0f);
-  if (x != NULL) {
-    for (i = 0; i < n; i++) {
-      maxVal |= fAbs(x[i]);
-    }
-  }
-
-  if (y != NULL) {
-    for (i = 0; i < n; i++) {
-      maxVal |= fAbs(y[i]);
-    }
-  }
-
-  if (maxVal == (FIXP_DBL)0)
-    return (-(DFRACT_BITS - 1));
-  else
-    return (-CountLeadingBits(maxVal));
-}
-
-INT FDKcalcScaleFactorDPK(const FIXP_DPK *RESTRICT x, const INT startBand,
-                          const INT bands) {
-  INT qs, clz;
-  FIXP_DBL maxVal = FL2FXCONST_DBL(0.0f);
-
-  for (qs = startBand; qs < bands; qs++) {
-    maxVal |= fAbs(x[qs].v.re);
-    maxVal |= fAbs(x[qs].v.im);
-  }
-
-  clz = -fixMax(0, CntLeadingZeros(maxVal) - 1);
-
-  return (clz);
-}
--- a/libSACenc/src/sacenc_vectorfunctions.h
+++ /dev/null
@@ -1,488 +0,0 @@
-/* -----------------------------------------------------------------------------
-Software License for The Fraunhofer FDK AAC Codec Library for Android
-
-© Copyright  1995 - 2018 Fraunhofer-Gesellschaft zur Förderung der angewandten
-Forschung e.V. All rights reserved.
-
- 1.    INTRODUCTION
-The Fraunhofer FDK AAC Codec Library for Android ("FDK AAC Codec") is software
-that implements the MPEG Advanced Audio Coding ("AAC") encoding and decoding
-scheme for digital audio. This FDK AAC Codec software is intended to be used on
-a wide variety of Android devices.
-
-AAC's HE-AAC and HE-AAC v2 versions are regarded as today's most efficient
-general perceptual audio codecs. AAC-ELD is considered the best-performing
-full-bandwidth communications codec by independent studies and is widely
-deployed. AAC has been standardized by ISO and IEC as part of the MPEG
-specifications.
-
-Patent licenses for necessary patent claims for the FDK AAC Codec (including
-those of Fraunhofer) may be obtained through Via Licensing
-(www.vialicensing.com) or through the respective patent owners individually for
-the purpose of encoding or decoding bit streams in products that are compliant
-with the ISO/IEC MPEG audio standards. Please note that most manufacturers of
-Android devices already license these patent claims through Via Licensing or
-directly from the patent owners, and therefore FDK AAC Codec software may
-already be covered under those patent licenses when it is used for those
-licensed purposes only.
-
-Commercially-licensed AAC software libraries, including floating-point versions
-with enhanced sound quality, are also available from Fraunhofer. Users are
-encouraged to check the Fraunhofer website for additional applications
-information and documentation.
-
-2.    COPYRIGHT LICENSE
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted without payment of copyright license fees provided that you
-satisfy the following conditions:
-
-You must retain the complete text of this software license in redistributions of
-the FDK AAC Codec or your modifications thereto in source code form.
-
-You must retain the complete text of this software license in the documentation
-and/or other materials provided with redistributions of the FDK AAC Codec or
-your modifications thereto in binary form. You must make available free of
-charge copies of the complete source code of the FDK AAC Codec and your
-modifications thereto to recipients of copies in binary form.
-
-The name of Fraunhofer may not be used to endorse or promote products derived
-from this library without prior written permission.
-
-You may not charge copyright license fees for anyone to use, copy or distribute
-the FDK AAC Codec software or your modifications thereto.
-
-Your modified versions of the FDK AAC Codec must carry prominent notices stating
-that you changed the software and the date of any change. For modified versions
-of the FDK AAC Codec, the term "Fraunhofer FDK AAC Codec Library for Android"
-must be replaced by the term "Third-Party Modified Version of the Fraunhofer FDK
-AAC Codec Library for Android."
-
-3.    NO PATENT LICENSE
-
-NO EXPRESS OR IMPLIED LICENSES TO ANY PATENT CLAIMS, including without
-limitation the patents of Fraunhofer, ARE GRANTED BY THIS SOFTWARE LICENSE.
-Fraunhofer provides no warranty of patent non-infringement with respect to this
-software.
-
-You may use this FDK AAC Codec software or modifications thereto only for
-purposes that are authorized by appropriate patent licenses.
-
-4.    DISCLAIMER
-
-This FDK AAC Codec software is provided by Fraunhofer on behalf of the copyright
-holders and contributors "AS IS" and WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
-including but not limited to the implied warranties of merchantability and
-fitness for a particular purpose. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
-CONTRIBUTORS BE LIABLE for any direct, indirect, incidental, special, exemplary,
-or consequential damages, including but not limited to procurement of substitute
-goods or services; loss of use, data, or profits, or business interruption,
-however caused and on any theory of liability, whether in contract, strict
-liability, or tort (including negligence), arising in any way out of the use of
-this software, even if advised of the possibility of such damage.
-
-5.    CONTACT INFORMATION
-
-Fraunhofer Institute for Integrated Circuits IIS
-Attention: Audio and Multimedia Departments - FDK AAC LL
-Am Wolfsmantel 33
-91058 Erlangen, Germany
-
-www.iis.fraunhofer.de/amm
-amm-info@iis.fraunhofer.de
------------------------------------------------------------------------------ */
-
-/*********************** MPEG surround encoder library *************************
-
-   Author(s):   Josef Hoepfl
-
-   Description: Encoder Library Interface
-                vector functions
-
-*******************************************************************************/
-
-/*****************************************************************************
-\file
-This file contains vector functions
-******************************************************************************/
-
-#ifndef SACENC_VECTORFUNCTIONS_H
-#define SACENC_VECTORFUNCTIONS_H
-
-/* Includes ******************************************************************/
-#include "common_fix.h"
-
-/* Defines *******************************************************************/
-#define SUM_UP_STATIC_SCALE 0
-#define SUM_UP_DYNAMIC_SCALE 1
-
-/* Data Types ****************************************************************/
-
-/* Constants *****************************************************************/
-
-/* Function / Class Declarations *********************************************/
-
-/**
- * \brief          Vector function : Sum up complex power
- *
- *                 Description : ret = sum( re{X[i]} * re{X[i]} + im{X[i]} *
- * im{X[i]} ),  i=0,...,n-1 ret is scaled by outScaleFactor
- *
- * \param          const FIXP_DPK x[]
- *                 Input: complex vector of the length n
- *
- * \param          int scaleMode
- *                 Input: choose static or dynamic scaling
- * (SUM_UP_DYNAMIC_SCALE/SUM_UP_STATIC_SCALE)
- *
- * \param          int inScaleFactor
- *                 Input: determine headroom bits for the complex input vector
- *
- * \param          int outScaleFactor
- *                 Output: complete scaling in energy calculation
- *
- * \return         FIXP_DBL ret
- */
-FIXP_DBL sumUpCplxPow2(const FIXP_DPK *const x, const INT scaleMode,
-                       const INT inScaleFactor, INT *const outScaleFactor,
-                       const INT n);
-
-/**
- * \brief          Vector function : Sum up complex power
- *
- *                 Description : ret = sum( re{X[i][j]} * re{X[i][]} +
- * im{X[i][]} * im{X[i][]} ),  i=sDim1,...,nDim1-1 i=sDim2,...,nDim2-1 ret is
- * scaled by outScaleFactor
- *
- * \param          const FIXP_DPK x[]
- *                 Input: complex vector of the length n
- *
- * \param          int scaleMode
- *                 Input: choose static or dynamic scaling
- * (SUM_UP_DYNAMIC_SCALE/SUM_UP_STATIC_SCALE)
- *
- * \param          int inScaleFactor
- *                 Input: determine headroom bits for the complex input vector
- *
- * \param          int outScaleFactor
- *                 Output: complete scaling in energy calculation
- *
- * \param          int sDim1
- *                 Input: start index for loop counter in dimension 1
- *
- * \param          int nDim1
- *                 Input: loop counter in dimension 1
- *
- * \param          int sDim2
- *                 Input: start index for loop counter in dimension 2
- *
- * \param          int nDim2
- *                 Input: loop counter in dimension 2
- *
- * \return         FIXP_DBL ret
- */
-FIXP_DBL sumUpCplxPow2Dim2(const FIXP_DPK *const *const x, const INT scaleMode,
-                           const INT inScaleFactor, INT *const outScaleFactor,
-                           const INT sDim1, const INT nDim1, const INT sDim2,
-                           const INT nDim2);
-
-/**
- * \brief          Vector function : Z[i] = X[i],  i=0,...,n-1
- *
- *                 Description : re{Z[i]} = re{X[i]},  i=0,...,n-1
- *                               im{Z[i]} = im{X[i]},  i=0,...,n-1
- *
- *                 Copy complex vector X[] to complex vector Z[].
- *                 It is allowed to overlay X[] with Z[].
- *
- * \param          FIXP_DPK Z[]
- *                 Output: vector of the length n
- *
- * \param          const FIXP_DPK X[]
- *                 Input: vector of the length n
- *
- * \param          int n
- *                 Input: length of vector Z[] and X[]
- *
- * \return         void
- */
-void copyCplxVec(FIXP_DPK *const Z, const FIXP_DPK *const X, const INT n);
-
-/**
- * \brief          Vector function : Z[i] = a,  i=0,...,n-1
- *
- *                 Description : re{Z[i]} = a,  i=0,...,n-1
- *                               im{Z[i]} = a,  i=0,...,n-1
- *
- *                 Set real and imaginary part of the complex value Z to a.
- *
- * \param          FIPX_DPK Z[]
- *                 Output: vector of the length n
- *
- * \param          const FIXP_DBL a
- *                 Input: constant value
- *
- * \param          int n
- *                 Input: length of vector Z[]
- *
- * \return         void
- */
-void setCplxVec(FIXP_DPK *const Z, const FIXP_DBL a, const INT n);
-
-/**
- * \brief          Vector function : Calculate complex-valued result of complex
- * scalar product
- *
- *                 Description : re{Z} = sum( re{X[i]} * re{Y[i]} + im{X[i]} *
- * im{Y[i]},  i=0,...,n-1 ) im{Z} = sum( im{X[i]} * re{Y[i]} - re{X[i]} *
- * im{Y[i]},  i=0,...,n-1 )
- *
- *                 The function returns the complex-valued result of the complex
- * scalar product at the address of Z. The result is scaled by scaleZ.
- *
- * \param          FIXP_DPK *Z
- *                 Output: pointer to Z
- *
- * \param          const FIXP_DPK *const *const X
- *                 Input: vector of the length n
- *
- * \param          const FIXP_DPK *const *const Y
- *                 Input: vector of the length n
- *
- * \param          int scaleX
- *                 Input: scalefactor of vector X[]
- *
- * \param          int scaleY
- *                 Input: scalefactor of vector Y[]
- *
- * \param          int scaleZ
- *                 Output: scalefactor of vector Z[]
- *
- * \param          int sDim1
- *                 Input: start index for loop counter in dimension 1
- *
- * \param          int nDim1
- *                 Input: loop counter in dimension 1
- *
- * \param          int sDim2
- *                 Input: start index for loop counter in dimension 2
- *
- * \param          int nDim2
- *                 Input: loop counter in dimension 2
- *
- * \return         void
- */
-void cplx_cplxScalarProduct(FIXP_DPK *const Z, const FIXP_DPK *const *const X,
-                            const FIXP_DPK *const *const Y, const INT scaleX,
-                            const INT scaleY, INT *const scaleZ,
-                            const INT sDim1, const INT nDim1, const INT sDim2,
-                            const INT nDim2);
-
-/**
- * \brief          Vector function : Calculate correlation
- *
- *                 Description : z[i] = pr12[i] / sqrt(p1[i]*p2[i]) ,
- * i=0,...,n-1
- *
- * \param          FIXP_DBL z[]
- *                 Output: vector of length n
- *
- * \param          const FIXP_DBL pr12[]
- *                 Input: vector of the length n
- *
- * \param          const FIXP_DBL p1[]
- *                 Input: vector of the length n
- *
- * \param          const FIXP_DBL p2[]
- *                 Input: vector of the length n
- *
- * \param          int n
- *                 Input: length of vector pr12[], p1[] and p2[]
- *
- * \return         void
- */
-void FDKcalcCorrelationVec(FIXP_DBL *const z, const FIXP_DBL *const pr12,
-                           const FIXP_DBL *const p1, const FIXP_DBL *const p2,
-                           const INT n);
-
-/**
- * \brief          Vector function : Calculate coherence
- *
- *                 Description : z[i] = sqrt( (p12r[i]*p12r[i] +
- * p12i[i]*p12i[i]) / (p1[i]*p2[i]) ),  i=0,...,n-1
- *
- * \param          FIXP_DBL z[]
- *                 Output: vector of length n
- *
- * \param          const FIXP_DBL p12r[]
- *                 Input: vector of the length n
- *
- * \param          const FIXP_DBL p12i[]
- *                 Input: vector of the length n
- *
- * \param          const FIXP_DBL p1[]
- *                 Input: vector of the length n
- *
- * \param          const FIXP_DBL p2[]
- *                 Input: vector of the length n
- *
- * \param          int scaleP12[]
- *                 Input: scalefactor of p12r and p12i
- *
- * \param          int scaleP
- *                 Input: scalefactor of p1 and p2
- *
- * \param          int n
- *                 Input: length of vector p12r[], p12i[], p1[] and p2[]
- *
- * \return         void
- */
-void calcCoherenceVec(FIXP_DBL *const z, const FIXP_DBL *const p12r,
-                      const FIXP_DBL *const p12i, const FIXP_DBL *const p1,
-                      const FIXP_DBL *const p2, const INT scaleP12,
-                      const INT scaleP, const INT n);
-
-/**
- * \brief          Vector function : Z[j][i] = a[pb] * X[j][i] + b[pb] *
- * Y[j][i],  j=0,...,nHybridBands-1;  i=startTimeSlot,...,nTimeSlots-1;
- * pb=0,...,nParameterBands-1
- *
- *                 Description : re{Z[j][i]} = a[pb] * re{X[j][i]} + b[pb] *
- * re{Y[j][i]},  j=0,...,nHybridBands-1;  i=startTimeSlot,...,nTimeSlots-1;
- * pb=0,...,nParameterBands-1 im{Z[j][i]} = a[pb] * im{X[j][i]} + b[pb] *
- * im{Y[j][i]},  j=0,...,nHybridBands-1;
- * i=startTimeSlot,...,nTimeSlots-1;  pb=0,...,nParameterBands-1
- *
- *                 It is allowed to overlay X[] or Y[] with Z[]. The scalefactor
- * of channel 1 is updated with the common scalefactor of channel 1 and
- * channel 2.
- *
- * \param          FIXP_DPK **Z
- *                 Output: vector of the length nHybridBands*nTimeSlots
- *
- * \param          const FIXP_DBL *a
- *                 Input: vector of length nParameterBands
- *
- * \param          const FIXP_DPK **X
- *                 Input: vector of the length nHybridBands*nTimeSlots
- *
- * \param          const FIXP_DBL *b
- *                 Input: vector of length nParameterBands
- *
- * \param          const FIXP_DPK **Y
- *                 Input: vector of the length nHybridBands*nTimeSlots
- *
- * \param          int scale
- *                 Input: scale of vector a and b
- *
- * \param          int *scaleCh1
- *                 Input: scale of ch1
- *
- * \param          int scaleCh2
- *                 Input: scale of ch2
- *
- * \param          UCHAR *pParameterBand2HybridBandOffset
- *                 Input: vector of length nParameterBands
- *
- * \param          int nTimeSlots
- *                 Input: number of time slots
- *
- * \param          int startTimeSlot
- *                 Input: start time slot
- *
- * \return         void
- */
-void addWeightedCplxVec(FIXP_DPK *const *const Z, const FIXP_DBL *const a,
-                        const FIXP_DPK *const *const X, const FIXP_DBL *const b,
-                        const FIXP_DPK *const *const Y, const INT scale,
-                        INT *const scaleCh1, const INT scaleCh2,
-                        const UCHAR *const pParameterBand2HybridBandOffset,
-                        const INT nParameterBands, const INT nTimeSlots,
-                        const INT startTimeSlot);
-
-/**
- * \brief          Vector function : Calculate the headroom of a complex vector
- * in a parameter band grid
- *
- * \param          FIXP_DPK **x
- *                 Input: pointer to complex input vector
- *
- * \param          UCHAR *pParameterBand2HybridBandOffset
- *                 Input: pointer to hybrid band offsets
- *
- * \param          int *outScaleFactor
- *                 Input: pointer to ouput scalefactor
- *
- * \param          int startTimeSlot
- *                 Input: start time slot
- *
- * \param          int nTimeSlots
- *                 Input: number of time slot
- *
- * \param          int nParamBands
- *                 Input: number of parameter bands
- *
- * \return         void
- */
-void FDKcalcPbScaleFactor(const FIXP_DPK *const *const x,
-                          const UCHAR *const pParameterBand2HybridBandOffset,
-                          INT *const outScaleFactor, const INT startTimeSlot,
-                          const INT nTimeSlots, const INT nParamBands);
-
-/**
- * \brief          Vector function : Calculate the common headroom of two
- * sparate vectors
- *
- * \param          FIXP_DBL *x
- *                 Input: pointer to first input vector
- *
- * \param          FIXP_DBL *y
- *                 Input: pointer to second input vector
- *
- * \param          int n
- *                 Input: number of samples
- *
- * \return         int headromm in bits
- */
-INT FDKcalcScaleFactor(const FIXP_DBL *const x, const FIXP_DBL *const y,
-                       const INT n);
-
-/**
- * \brief          Vector function : Calculate the headroom of a complex vector
- *
- * \param          FIXP_DPK *x
- *                 Input: pointer to complex input vector
- *
- * \param          INT startBand
- *                 Input: start band
- *
- * \param          INT bands
- *                 Input: number of bands
- *
- * \return         int headromm in bits
- */
-INT FDKcalcScaleFactorDPK(const FIXP_DPK *RESTRICT x, const INT startBand,
-                          const INT bands);
-
-/* Function / Class Definition ***********************************************/
-template <class T>
-inline void FDKmemcpy_flex(T *const dst, const INT dstStride,
-                           const T *const src, const INT srcStride,
-                           const INT nSamples) {
-  int i;
-
-  for (i = 0; i < nSamples; i++) {
-    dst[i * dstStride] = src[i * srcStride];
-  }
-}
-
-template <class T>
-inline void FDKmemset_flex(T *const x, const T c, const INT nSamples) {
-  int i;
-
-  for (i = 0; i < nSamples; i++) {
-    x[i] = c;
-  }
-}
-
-#endif /* SACENC_VECTORFUNCTIONS_H */
